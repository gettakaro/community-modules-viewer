{
    "name": "7dtdStockMarket",
    "versions": [
        {
            "tag": "0.1.14",
            "description": "**Stock Market: A Dynamic Virtual Trading System**\n\nCreate an immersive economic experience with this comprehensive stock market module that lets players invest, trade, and react to market events.\n\n**Market Features:**\n\n![Market Summary](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stocks.png)\n\n* **Multiple Economic Sectors:** Configure various industry sectors (Resource Extraction, Manufacturing, Defense, etc.) each with their own market dynamics.\n* **Realistic Stock Behavior:** Stocks have configurable volatility, sector-based pricing, and react differently to market events.\n* **Dynamic Market Events:** Random or admin-triggered events like \"Horde Night Approaching\" or \"Societal Collapse Setback\" impact different sectors in realistic ways.\n\n![Market Events](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_events.png)\n\n**Trading System:**\n\n* **Buy & Sell Shares:** Players can purchase stocks and sell them later for profit or loss.\n* **Transaction Fees:** Configurable fee percentage on all trades creates a realistic market economy.\n* **VIP Benefits:** Special permissions for designated \"Stock Brokers\" who receive fee discounts.\n\n![Buy Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_buy.png)\n\nPlayers can track price changes and sell at the right moment to maximize profits or minimize losses.\n\n![Sell Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sell.png)\n\n**Player Portfolio:**\n\n* **Portfolio Tracking:** Players can view their holdings, average purchase prices, and current profit/loss.\n* **Transaction History:** System tracks all buy/sell transactions for each player.\n* **Summary Statistics:** See overall portfolio performance and value across all holdings.\n\n![Portfolio View](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockportfolio.png)\n\n**Market Information:**\n\n* **Detailed Stock Info:** Players can research specific stocks, including risk levels and sector trends.\n* **Industry Filters:** View stocks by specific sectors to better understand market segments.\n* **Market Alerts:** Server-wide notifications for significant price changes keep players engaged.\n\n![Market Alerts](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockpricechange.png)\n\n**Configuration Options:**\n\n* **Sectors & Stocks:** Define your own market sectors and individual stocks with customizable starting prices and volatility.\n* **Market Events:** Create unique events with specific sector impacts to drive market dynamics.\n* **Transaction Settings:** Configure fee percentages, VIP discounts, and alert thresholds.\n* **Event Frequency:** Control how often random market events occur and how long they last.\n\n![Configuration](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_config.png)\n![Sectors](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sectors.png)\n\n**Commands:**\n\n* `/markets [industry]` - View all stocks or filter by industry\n* `/stockinfo [ticker]` - Get detailed information about a specific stock\n* `/buystock <ticker> <amount>` - Purchase shares of a stock\n* `/sellstock <ticker> <amount>` - Sell shares from your portfolio\n* `/stockportfolio` - View your current holdings and performance\n* `/triggerevent [event]` - Admin command to trigger specific market events\n\nWho says the apocalypse can't have a thriving economy? Now players can stress about both zombie hordes AND their Duke's Casino Tokens dropping 40% after a market event! As one trader put it: \"I used to check my 401K daily, and now I check my AMMO stock before every Blood Moon. Some habits die harder than zombies.\"",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sectors\":{\"type\":\"array\",\"title\":\"Wasteland Economic Sectors\",\"description\":\"Define economic sectors relevant to survival in Navezgane\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Sector ID (e.g., Very Low Risk)\"},\"name\":{\"type\":\"string\",\"description\":\"Sector name (e.g., Very Low Risk)\"}}},\"default\":[{\"id\":\"Very High Risk\",\"name\":\"Very High Risk\"},{\"id\":\"High Risk\",\"name\":\"High Risk\"},{\"id\":\"Medium Risk\",\"name\":\"Medium Risk\"},{\"id\":\"Low Risk\",\"name\":\"Low Risk\"},{\"id\":\"Very Low Risk\",\"name\":\"Very Low Risk\"}]},\"stocks\":{\"type\":\"array\",\"title\":\"Wasteland Stocks\",\"description\":\"List of stocks representing Navezgane entities and resources\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Stock ticker symbol (e.g., NMC)\"},\"name\":{\"type\":\"string\",\"description\":\"Entity/Resource name\"},\"sector\":{\"type\":\"string\",\"description\":\"Sector ID this stock belongs to\"},\"initialPrice\":{\"type\":\"number\",\"description\":\"Starting price in Dukes\",\"minimum\":1},\"volatility\":{\"type\":\"number\",\"description\":\"Base volatility percentage (5 = 5%)\",\"minimum\":1,\"maximum\":60}}},\"default\":[{\"id\":\"NMC\",\"name\":\"Navezgane Mining Co.\",\"sector\":\"High Risk\",\"initialPrice\":50,\"volatility\":15},{\"id\":\"NIOM\",\"name\":\"Navezgane Iron Ore Mining Co.\",\"sector\":\"High Risk\",\"initialPrice\":55,\"volatility\":16},{\"id\":\"NLMC\",\"name\":\"Navezgane Lead Mining Co.\",\"sector\":\"Medium Risk\",\"initialPrice\":45,\"volatility\":14},{\"id\":\"WOOD\",\"name\":\"Wasteland Lumberjacks\",\"sector\":\"Low Risk\",\"initialPrice\":20,\"volatility\":8},{\"id\":\"SHALE\",\"name\":\"Oil Shale Extractors\",\"sector\":\"Very High Risk\",\"initialPrice\":40,\"volatility\":45},{\"id\":\"FORGE\",\"name\":\"Forge Ahead Metals\",\"sector\":\"Medium Risk\",\"initialPrice\":75,\"volatility\":12},{\"id\":\"TOOLS\",\"name\":\"Working Stiff Tools\",\"sector\":\"Low Risk\",\"initialPrice\":60,\"volatility\":10},{\"id\":\"AIA\",\"name\":\"A1 Auto\",\"sector\":\"Medium Risk\",\"initialPrice\":40,\"volatility\":14},{\"id\":\"AMC\",\"name\":\"Atlas Metal Company\",\"sector\":\"Medium Risk\",\"initialPrice\":65,\"volatility\":13},{\"id\":\"COC\",\"name\":\"COC Chemicals\",\"sector\":\"Very High Risk\",\"initialPrice\":55,\"volatility\":50},{\"id\":\"MECH\",\"name\":\"JunkTech Robotics\",\"sector\":\"High Risk\",\"initialPrice\":110,\"volatility\":25},{\"id\":\"BUILD\",\"name\":\"Barricade Builders\",\"sector\":\"Low Risk\",\"initialPrice\":45,\"volatility\":9},{\"id\":\"ZBI\",\"name\":\"Zombie Bashers Inc.\",\"sector\":\"High Risk\",\"initialPrice\":85,\"volatility\":17},{\"id\":\"TTC\",\"name\":\"Turret Tracker Co.\",\"sector\":\"Very High Risk\",\"initialPrice\":125,\"volatility\":60},{\"id\":\"AMMO\",\"name\":\"AmmoNation Surplus\",\"sector\":\"Very High Risk\",\"initialPrice\":90,\"volatility\":35},{\"id\":\"SHM\",\"name\":\"Shotgun Messiah\",\"sector\":\"Very High Risk\",\"initialPrice\":120,\"volatility\":30},{\"id\":\"SHAM\",\"name\":\"Shamway Foods\",\"sector\":\"Very Low Risk\",\"initialPrice\":30,\"volatility\":5},{\"id\":\"SSHM\",\"name\":\"Super Shamway\",\"sector\":\"Very Low Risk\",\"initialPrice\":32,\"volatility\":4},{\"id\":\"MEDS\",\"name\":\"Pop-N-Pills Medical\",\"sector\":\"Very High Risk\",\"initialPrice\":100,\"volatility\":48},{\"id\":\"SAVG\",\"name\":\"Savage Country\",\"sector\":\"Low Risk\",\"initialPrice\":35,\"volatility\":6},{\"id\":\"CRKB\",\"name\":\"Crack-A-Book\",\"sector\":\"High Risk\",\"initialPrice\":80,\"volatility\":16},{\"id\":\"TRADE\",\"name\":\"Trader Guild Network\",\"sector\":\"Very High Risk\",\"initialPrice\":150,\"volatility\":40},{\"id\":\"PNG\",\"name\":\"Pass-N-Gas\",\"sector\":\"Medium Risk\",\"initialPrice\":50,\"volatility\":11},{\"id\":\"BOB\",\"name\":\"Trader Bob's\",\"sector\":\"Low Risk\",\"initialPrice\":160,\"volatility\":9},{\"id\":\"HUGH\",\"name\":\"Trader Hugh's\",\"sector\":\"Medium Risk\",\"initialPrice\":170,\"volatility\":12},{\"id\":\"JEN\",\"name\":\"Trader Jen's\",\"sector\":\"Low Risk\",\"initialPrice\":180,\"volatility\":10},{\"id\":\"JOEL\",\"name\":\"Trader Joel's\",\"sector\":\"Low Risk\",\"initialPrice\":175,\"volatility\":11},{\"id\":\"REKT\",\"name\":\"Trader Rekt's\",\"sector\":\"Low Risk\",\"initialPrice\":165,\"volatility\":6},{\"id\":\"DUKES\",\"name\":\"Duke's Casino Tokens\",\"sector\":\"Very Low Risk\",\"initialPrice\":1,\"volatility\":3}]},\"marketEvents\":{\"type\":\"array\",\"title\":\"Wasteland Events\",\"description\":\"Events impacting the Navezgane economy\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Unique event ID\"},\"name\":{\"type\":\"string\",\"description\":\"Name of the event\"},\"description\":{\"type\":\"string\",\"description\":\"Description of the event's market effect\"},\"sectorImpacts\":{\"type\":\"array\",\"description\":\"How each sector is affected\",\"items\":{\"type\":\"object\",\"properties\":{\"sectorId\":{\"type\":\"string\",\"description\":\"Sector ID\"},\"impact\":{\"type\":\"number\",\"description\":\"Percentage impact (-99 = -99%)\",\"minimum\":-99,\"maximum\":75}}}}}},\"default\":[{\"id\":\"HORDE_INCOMING\",\"name\":\"Horde Night Approaching\",\"description\":\"Increased Zed activity signals the Blood Moon. Very High and High Risk defense stocks soar, while Very Low Risk stocks see minimal impact.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":50},{\"sectorId\":\"High Risk\",\"impact\":30},{\"sectorId\":\"Medium Risk\",\"impact\":15},{\"sectorId\":\"Low Risk\",\"impact\":5},{\"sectorId\":\"Very Low Risk\",\"impact\":1}]},{\"id\":\"STABLE_ECONOMY\",\"name\":\"Period of Stability\",\"description\":\"A rare period of peace has settled over the wasteland. Very Low and Low Risk assets flourish, with higher risk stocks seeing less significant gains. High risk assets might see slight pull-back.\",\"sectorImpacts\":[{\"sectorId\":\"Very Low Risk\",\"impact\":15},{\"sectorId\":\"Low Risk\",\"impact\":10},{\"sectorId\":\"Medium Risk\",\"impact\":5},{\"sectorId\":\"High Risk\",\"impact\":-5},{\"sectorId\":\"Very High Risk\",\"impact\":-10}]},{\"id\":\"GENERAL_PANIC\",\"name\":\"General Market Panic\",\"description\":\"A major setback reminds everyone how fragile survival is. Fear grips the entire market, causing higher volatility sectors to plummet.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-90},{\"sectorId\":\"High Risk\",\"impact\":-70},{\"sectorId\":\"Medium Risk\",\"impact\":-45},{\"sectorId\":\"Low Risk\",\"impact\":-20},{\"sectorId\":\"Very Low Risk\",\"impact\":-10}]},{\"id\":\"ADVANCED_WEAPONRY_COLLAPSE\",\"name\":\"Turret AI Virus\",\"description\":\"A malicious code is spreading through advanced turret systems, causing them to malfunction violently. Very High Risk weaponry stocks are obliterated.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-99},{\"sectorId\":\"High Risk\",\"impact\":-20}]},{\"id\":\"VOLATILE_CHEMICALS_COLLAPSE\",\"name\":\"Irreversible Contamination\",\"description\":\"A major chemical disaster has occurred. Very High Risk chemical stocks are worthless, impacting related sectors.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-99},{\"sectorId\":\"High Risk\",\"impact\":-25},{\"sectorId\":\"Medium Risk\",\"impact\":-10}]},{\"id\":\"FOSSIL_FUELS_COLLAPSE\",\"name\":\"Clean Energy Breakthrough\",\"description\":\"A new energy source has been discovered. Very High Risk fossil fuel stocks become obsolete, while other sectors see minor adjustments.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-99},{\"sectorId\":\"Medium Risk\",\"impact\":10},{\"sectorId\":\"Low Risk\",\"impact\":5}]},{\"id\":\"PHARMACEUTICALS_COLLAPSE\",\"name\":\"The Cure is Real\",\"description\":\"A cure for the zombie infection has been found! Very High Risk pharmaceutical stocks are wiped out, and even low-risk survival goods see a hit.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-99},{\"sectorId\":\"High Risk\",\"impact\":-30},{\"sectorId\":\"Medium Risk\",\"impact\":-15},{\"sectorId\":\"Low Risk\",\"impact\":-10},{\"sectorId\":\"Very Low Risk\",\"impact\":-5}]},{\"id\":\"GUILD_OPERATIONS_COLLAPSE\",\"name\":\"Trader Guild Dissolved\",\"description\":\"The Trader's Guild has been formally dissolved. Very High Risk trade operation stocks become worthless, affecting overall trade.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-99},{\"sectorId\":\"High Risk\",\"impact\":-40},{\"sectorId\":\"Medium Risk\",\"impact\":-20},{\"sectorId\":\"Low Risk\",\"impact\":-10}]},{\"id\":\"AMMUNITION_DEPLETION\",\"name\":\"Ammunition Shortage\",\"description\":\"A major supply chain disruption has caused ammunition stockpiles to dwindle. Very High Risk ammunition stocks plummet.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-99},{\"sectorId\":\"High Risk\",\"impact\":-30},{\"sectorId\":\"Medium Risk\",\"impact\":-15}]},{\"id\":\"RESOURCE_BOOM\",\"name\":\"Resource Discovery\",\"description\":\"A massive new ore deposit has been found! All resource-related stocks are surging, with higher risk ones seeing the biggest gains.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":60},{\"sectorId\":\"High Risk\",\"impact\":40},{\"sectorId\":\"Medium Risk\",\"impact\":20},{\"sectorId\":\"Low Risk\",\"impact\":10}]},{\"id\":\"MANUFACTURING_SURGE\",\"name\":\"Innovation Breakthrough\",\"description\":\"New manufacturing techniques have greatly increased production efficiency. Manufacturing stocks are up across the board.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":40},{\"sectorId\":\"High Risk\",\"impact\":30},{\"sectorId\":\"Medium Risk\",\"impact\":20},{\"sectorId\":\"Low Risk\",\"impact\":10},{\"sectorId\":\"Very Low Risk\",\"impact\":5}]},{\"id\":\"TRADE_ROUTE_OPENED\",\"name\":\"New Trade Route Established\",\"description\":\"A secure trade route has been opened, boosting commerce. Trade-related stocks are seeing significant gains.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":50},{\"sectorId\":\"High Risk\",\"impact\":30},{\"sectorId\":\"Medium Risk\",\"impact\":20},{\"sectorId\":\"Low Risk\",\"impact\":15},{\"sectorId\":\"Very Low Risk\",\"impact\":10}]},{\"id\":\"MARKET_CORRECTION\",\"name\":\"Market Correction Wave\",\"description\":\"After a period of unusual growth, the market corrects itself. All sectors see a downturn.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-50},{\"sectorId\":\"High Risk\",\"impact\":-35},{\"sectorId\":\"Medium Risk\",\"impact\":-25},{\"sectorId\":\"Low Risk\",\"impact\":-15},{\"sectorId\":\"Very Low Risk\",\"impact\":-10}]},{\"id\":\"GLOBAL_SLOWDOWN\",\"name\":\"Global Economic Slowdown\",\"description\":\"Uncertainty spreads across all sectors, leading to a general market downturn. Less severe than a full panic, but widespread.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-30},{\"sectorId\":\"High Risk\",\"impact\":-20},{\"sectorId\":\"Medium Risk\",\"impact\":-15},{\"sectorId\":\"Low Risk\",\"impact\":-10},{\"sectorId\":\"Very Low Risk\",\"impact\":-5}]}]},\"eventFrequency\":{\"title\":\"Event Frequency\",\"type\":\"number\",\"description\":\"Average number of update cycles between market events (0 to disable). Depends on mod's update frequency (e.g., per in-game hour?).\",\"default\":8,\"minimum\":1},\"defaultEventDuration\":{\"title\":\"Default Event Duration\",\"type\":\"number\",\"description\":\"Default number of update cycles an event lasts.\",\"default\":3,\"minimum\":1,\"maximum\":96},\"transactionFee\":{\"title\":\"Transaction Fee (Dukes Tax)\",\"type\":\"number\",\"description\":\"Percentage fee charged on all buy/sell transactions (5 = 5%)\",\"default\":3,\"minimum\":0,\"maximum\":25},\"vipDiscount\":{\"title\":\"Trader's Favor Discount\",\"type\":\"number\",\"description\":\"Percentage discount on transaction fees for players with 'STOCK_MARKET_BROKER' permission (50 = 50%)\",\"default\":50,\"minimum\":0,\"maximum\":100},\"priceAlertThreshold\":{\"title\":\"Price Alert Threshold\",\"type\":\"number\",\"description\":\"Percentage change that triggers a market alert (15 = 15%)\",\"default\":15,\"minimum\":5,\"maximum\":50},\"marketNewsChannelId\":{\"title\":\"Discord Channel ID (for Market News)\",\"type\":\"string\",\"description\":\"The ID of the Discord channel where market news messages should be posted. Leave empty to disable.\",\"default\":\"\"}},\"additionalProperties\":false}",
            "uiSchema": "{\"sectors\":{\"items\":{\"ui:order\":[\"id\",\"name\"]}},\"stocks\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"sector\",\"initialPrice\",\"volatility\"]}},\"marketEvents\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"description\",\"sectorImpacts\"],\"sectorImpacts\":{\"items\":{\"ui:order\":[\"sectorId\",\"impact\"]}}}},\"transactionFee\":{\"ui:widget\":\"range\"},\"vipDiscount\":{\"ui:widget\":\"range\"},\"eventFrequency\":{\"ui:help\":\"Set to 0 to disable random events\"},\"priceAlertThreshold\":{\"ui:widget\":\"range\"}}",
            "commands": [
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === args.stock.toUpperCase());\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${args.stock} not found. Use /market to see available stocks.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate costs using Math.round to ensure we work with integers\n        const subtotal = Math.round(stock.price) * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const totalCost = subtotal + fee;\n\n        // Check if player has enough currency\n        const playerData = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, player.id);\n        const currentBalance = playerData.data.data.currency;\n\n        if (currentBalance < totalCost) {\n            throw new TakaroUserError(`You don't have enough currency. Cost: $${subtotal} + $${fee} fee = $${totalCost}. Your balance: $${currentBalance}`);\n        }\n\n        // Deduct the currency - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerDeductCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: totalCost\n            }\n        );\n\n        // Get player's portfolio or create new one\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        let portfolio;\n        if (portfolioVar.data.data.length === 0) {\n            portfolio = {};\n        } else {\n            portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        }\n\n        // Update portfolio using rounded values for consistency\n        const stockPrice = Math.round(stock.price);\n        if (!portfolio[stock.id]) {\n            portfolio[stock.id] = {\n                shares: amount,\n                averagePrice: stockPrice\n            };\n        } else {\n            const totalShares = portfolio[stock.id].shares + amount;\n            const totalValue = (portfolio[stock.id].shares * portfolio[stock.id].averagePrice) + (amount * stockPrice);\n            portfolio[stock.id].shares = totalShares;\n            portfolio[stock.id].averagePrice = Math.round(totalValue / totalShares);\n        }\n\n        // Save updated portfolio\n        if (portfolioVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_portfolio',\n                value: JSON.stringify(portfolio),\n                gameServerId,\n                moduleId: mod.moduleId,\n                playerId: player.id\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n                value: JSON.stringify(portfolio)\n            });\n        }\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'BUY',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: totalCost,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully bought ${amount} shares of ${stock.id} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Total cost: $${totalCost}\\n`;\n        message += `Current portfolio: ${portfolio[stock.id].shares} shares of ${stock.id}`;\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in buystock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your purchase. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "buystock",
                    "description": null,
                    "trigger": "buystock",
                    "helpText": "Buy shares of a stock",
                    "arguments": [
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to buy",
                            "position": 1
                        },
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol ",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get player's portfolio\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        if (portfolioVar.data.data.length === 0) {\n            throw new TakaroUserError(\"You don't own any stocks to sell.\");\n        }\n\n        const portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        const stockId = args.stock.toUpperCase();\n\n        if (!portfolio[stockId] || portfolio[stockId].shares < amount) {\n            throw new TakaroUserError(`You don't own ${amount} shares of ${stockId}.`);\n        }\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === stockId);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${stockId} not found in current market data. Please contact an admin.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate sale proceeds using Math.round to ensure we work with integers\n        const stockPrice = Math.round(stock.price);\n        const subtotal = stockPrice * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const netProceeds = subtotal - fee;\n\n        // Add money to player - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerAddCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: netProceeds\n            }\n        );\n\n        // Calculate profit/loss\n        const profitPerShare = stockPrice - portfolio[stockId].averagePrice;\n        const totalProfit = Math.round(profitPerShare * amount);\n        const profitText = totalProfit >= 0\n            ? `profit of $${totalProfit}`\n            : `loss of $${Math.abs(totalProfit)}`;\n\n        // Update portfolio\n        portfolio[stockId].shares -= amount;\n        if (portfolio[stockId].shares === 0) {\n            delete portfolio[stockId];\n        }\n\n        // Save updated portfolio\n        await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n            value: JSON.stringify(portfolio)\n        });\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'SELL',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: netProceeds,\n            profit: totalProfit,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully sold ${amount} shares of ${stockId} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Net proceeds: $${netProceeds} (${profitText})`;\n\n        // Add remaining shares info if player still has some\n        if (portfolio[stockId]) {\n            message += `\\nRemaining shares: ${portfolio[stockId].shares}`;\n        } else {\n            message += `\\nYou've sold all your ${stockId} shares.`;\n        }\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in sellstock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your sale. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "sellstock",
                    "description": null,
                    "trigger": "sellstock",
                    "helpText": "Sell shares of a stock",
                    "arguments": [
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to sell",
                            "position": 1
                        },
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Handle the industry argument - use \"ALL\" as a special value to show all industries\n    const industryFilter = args.Industry ? args.Industry.toUpperCase() : \"ALL\";\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    // If market data doesn't exist, try to initialize it\n    if (marketDataVar.data.data.length === 0) {\n        const initialized = await initializeMarketIfNeeded(gameServerId, mod);\n        if (!initialized) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        // Get the freshly initialized market data\n        const refreshedMarketData = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (refreshedMarketData.data.data.length === 0) {\n            throw new TakaroUserError(\"There was an issue initializing the stock market. Please try again later.\");\n        }\n\n        // Continue with the refreshed data\n        await displayMarketSummary(player, gameServerId, mod, refreshedMarketData.data.data[0], industryFilter);\n    } else {\n        // Market data exists, display it\n        await displayMarketSummary(player, gameServerId, mod, marketDataVar.data.data[0], industryFilter);\n    }\n}\n\n// Display the market summary to the player\nasync function displayMarketSummary(player, gameServerId, mod, marketDataVariable, industryFilter) {\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Handle empty string or empty object\n            if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (e) {\n            // In case of parsing error\n            activeEvent = null;\n        }\n    }\n\n    const stocks = JSON.parse(marketDataVariable.value);\n\n    // Get all available industries for reference\n    const availableIndustries = [...new Set(stocks.map(stock => stock.sector))];\n\n    // If industry filter is provided and not \"ALL\", check if it's valid\n    if (industryFilter !== \"ALL\") {\n        // Check if the industry exists\n        const industryExists = availableIndustries.includes(industryFilter);\n\n        if (!industryExists) {\n            throw new TakaroUserError(`Industry \"${industryFilter}\" not found. Available industries: ${availableIndustries.join(', ')}\\nUse \"ALL\" to view all industries.`);\n        }\n    }\n\n    // Send header message\n    let headerMessage = \"=== STOCK MARKET SUMMARY ===\\n\";\n\n    // If filtering by industry, mention it in the header\n    if (industryFilter !== \"ALL\") {\n        headerMessage = `=== ${industryFilter} INDUSTRY ===\\n`;\n    }\n\n    // If there's an active event, include it in the header\n    if (activeEvent) {\n        headerMessage += `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n`;\n        headerMessage += `${activeEvent.description}\\n\\n`;\n\n        // If filtering by industry, only show relevant impacts\n        if (industryFilter !== \"ALL\") {\n            const relevantImpact = activeEvent.sectorImpacts.find(\n                impact => impact.sectorId === industryFilter\n            );\n\n            if (relevantImpact) {\n                const direction = relevantImpact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `Industry Impact: ${direction} ${Math.abs(relevantImpact.impact)}%\\n`;\n            } else {\n                headerMessage += \"This industry is not directly affected by the current event.\\n\";\n            }\n        } else {\n            // Show all industry impacts\n            headerMessage += \"Industry Impacts:\\n\";\n            for (const impact of activeEvent.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%\\n`;\n            }\n        }\n    }\n\n    // Send header message first\n    await player.pm(headerMessage);\n\n    // Group stocks by industry\n    const stocksByIndustry = {};\n    stocks.forEach(stock => {\n        if (!stocksByIndustry[stock.sector]) {\n            stocksByIndustry[stock.sector] = [];\n        }\n        stocksByIndustry[stock.sector].push(stock);\n    });\n\n    // If industry filter is not \"ALL\", only show that industry\n    if (industryFilter !== \"ALL\") {\n        const filteredStocks = stocksByIndustry[industryFilter] || [];\n\n        if (filteredStocks.length > 0) {\n            let stockMessage = \"\";\n\n            filteredStocks.forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                stockMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(stockMessage);\n        } else {\n            await player.pm(`No stocks found in the ${industryFilter} industry.`);\n        }\n    } else {\n        // Send each industry as a separate message\n        for (const industryId in stocksByIndustry) {\n            let industryMessage = `=== ${industryId} INDUSTRY ===\\n`;\n\n            stocksByIndustry[industryId].forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                industryMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(industryMessage);\n        }\n    }\n\n    // Add a help message for industry filtering if showing all industries\n    if (industryFilter === \"ALL\") {\n        const allIndustries = Object.keys(stocksByIndustry).join(', ');\n        await player.pm(`\\nTip: Use '/markets [industry]' to view only stocks in a specific industry. Available industries: ${allIndustries}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return false;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            const results = await Promise.allSettled(createPromises);\n            // Check if the critical stock_market_data was created successfully\n            const stockDataPromise = results[0];\n            if (stockDataPromise && stockDataPromise.status === 'rejected') {\n                console.log(`Failed to create stock_market_data: ${stockDataPromise.reason}`);\n                return false;\n            }\n        }\n\n        return true;\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n        return false;\n    }\n}\n\nawait main();",
                    "name": "markets",
                    "description": null,
                    "trigger": "markets",
                    "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. \n",
                    "arguments": [
                        {
                            "name": "Industry",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. ",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // Get player's portfolio\n    const portfolioVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_portfolio'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId],\n            playerId: [player.id]\n        }\n    });\n\n    let portfolio = {};\n    if (portfolioVar.data.data.length > 0) {\n        portfolio = JSON.parse(portfolioVar.data.data[0].value);\n    }\n\n    // Send header\n    await player.pm(\"=== YOUR STOCK PORTFOLIO ===\");\n\n    let hasStocks = false;\n    let totalValue = 0;\n    let totalInvestment = 0;\n\n    // If no stocks, send a simple message\n    if (Object.keys(portfolio).length === 0) {\n        await player.pm(\"You don't own any stocks yet.\\n\" +\n            \"Use /markets to see available stocks and prices.\\n\" +\n            \"Use /buy <stock> <amount> to purchase stocks.\");\n        return;\n    }\n\n    // Helper function to format numbers with commas and a dollar sign\n    const formatNumber = (num) => {\n        return `$${Math.round(num).toLocaleString()}`;\n    };\n\n    // Send each stock as a separate message to avoid length issues\n    for (const [stockId, data] of Object.entries(portfolio)) {\n        hasStocks = true;\n        const stock = stocks.find(s => s.id === stockId);\n        if (!stock) continue; // Stock might have been removed from config\n\n        const currentValue = stock.price * data.shares;\n        const investmentValue = data.averagePrice * data.shares;\n        totalValue += currentValue;\n        totalInvestment += investmentValue;\n        const profit = currentValue - investmentValue;\n        const profitPercent = ((profit / investmentValue) * 100).toFixed(1);\n\n        let stockMessage = `--- ${stockId} (${stock.sector}) ---\\n`;\n        stockMessage += `Shares: ${data.shares}\\n`;\n        stockMessage += `Avg buy: ${formatNumber(data.averagePrice)}\\n`;\n        stockMessage += `Current price: ${formatNumber(stock.price)}\\n`;\n        stockMessage += `Total value: ${formatNumber(currentValue)}\\n`;\n\n        if (profit >= 0) {\n            stockMessage += `Profit: +${formatNumber(profit)} (+${profitPercent}%)\\n`;\n        } else {\n            stockMessage += `Loss: -${formatNumber(Math.abs(profit))} (${profitPercent}%)\\n`;\n        }\n\n        await player.pm(stockMessage);\n    }\n\n    if (hasStocks) {\n        const totalProfit = totalValue - totalInvestment;\n        const totalProfitPercent = ((totalProfit / totalInvestment) * 100).toFixed(1);\n\n        let summaryMessage = \"=== PORTFOLIO SUMMARY ===\\n\";\n        summaryMessage += `Total investment: ${formatNumber(totalInvestment)}\\n`;\n        summaryMessage += `Current value: ${formatNumber(totalValue)}\\n`;\n\n        if (totalProfit >= 0) {\n            summaryMessage += `Overall profit: +${formatNumber(totalProfit)} (+${totalProfitPercent}%)\\n`;\n        } else {\n            summaryMessage += `Overall loss: -${formatNumber(Math.abs(totalProfit))} (${totalProfitPercent}%)\\n`;\n        }\n\n        // Get transaction history count\n        try {\n            const historyVar = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: ['stock_transaction_history'],\n                    gameServerId: [gameServerId],\n                    moduleId: [mod.moduleId],\n                    playerId: [player.id]\n                }\n            });\n\n            if (historyVar.data.data.length > 0) {\n                const history = JSON.parse(historyVar.data.data[0].value);\n                const buyCount = history.filter(t => t.type === 'BUY').length;\n                const sellCount = history.filter(t => t.type === 'SELL').length;\n\n                summaryMessage += `\\nTransactions: ${history.length} (${buyCount} buys, ${sellCount} sells)\\n`;\n            }\n        } catch (error) {\n            // Just ignore history errors\n        }\n\n        await player.pm(summaryMessage);\n    }\n}\n\nawait main();",
                    "name": "stockportfolio",
                    "description": null,
                    "trigger": "stockportfolio",
                    "helpText": "No help text available",
                    "arguments": []
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // If a specific stock ticker is provided, show detailed info for that stock\n    const specificTicker = args.ticker ? args.ticker.toUpperCase() : null;\n\n    if (specificTicker && specificTicker !== \"ALL\") {\n        const stock = stocks.find(s => s.id.toUpperCase() === specificTicker);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${specificTicker} not found. Use /stockinfo without parameters to see all available stocks.`);\n        }\n\n        // Get active event to see if this stock's sector is affected\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let activeEvent = null;\n        let sectorImpact = null;\n\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEvent && activeEvent.sectorImpacts) {\n                    sectorImpact = activeEvent.sectorImpacts.find(impact =>\n                        impact.sectorId === stock.sector\n                    );\n                }\n            } catch (e) {\n                // Ignore parsing errors\n            }\n        }\n\n        // Calculate price change indicators\n        let changeText = '';\n        if (stock.lastPrice) {\n            const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n            const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n            changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n        }\n\n        // Add risk assessment based on volatility without showing the raw value\n        let riskLevel;\n        if (stock.volatility <= 0.05) riskLevel = \"Very Low\";\n        else if (stock.volatility <= 0.10) riskLevel = \"Low\";\n        else if (stock.volatility <= 0.15) riskLevel = \"Moderate\";\n        else if (stock.volatility <= 0.20) riskLevel = \"High\";\n        else riskLevel = \"Very High\";\n\n        // Build detailed stock info message\n        let message = `=== ${stock.id}: ${stock.name} ===\\n\\n`;\n        message += `Sector: ${stock.sector}\\n`;\n        message += `Current Price: $${Math.round(stock.price)}${changeText}\\n`;\n        message += `Risk Level: ${riskLevel}\\n`;\n\n        // Add sector trend info if available from event\n        if (activeEvent && sectorImpact) {\n            const direction = sectorImpact.impact >= 0 ? \"Positive\" : \"Negative\";\n            const strength = Math.abs(sectorImpact.impact);\n            let trend;\n\n            if (strength < 10) trend = \"Slight\";\n            else if (strength < 25) trend = \"Moderate\";\n            else trend = \"Strong\";\n\n            message += `\\nCurrent Trend: ${trend} ${direction} (${activeEvent.name})\\n`;\n            message += `Event: ${activeEvent.description}\\n`;\n        }\n\n        // Add trading guidance based on sector and risk, without mentioning volatility\n        message += `\\nTrading Notes:\\n`;\n\n        if (activeEvent && sectorImpact) {\n            if (sectorImpact.impact > 0) {\n                message += `- Currently bullish due to the ${activeEvent.name} event\\n`;\n            } else {\n                message += `- Currently bearish due to the ${activeEvent.name} event\\n`;\n            }\n        }\n\n        if (riskLevel === \"High\" || riskLevel === \"Very High\") {\n            message += `- Expect significant price fluctuations with this stock\\n`;\n        } else if (riskLevel === \"Low\" || riskLevel === \"Very Low\") {\n            message += `- Typically has stable price movement\\n`;\n        }\n\n        message += `\\nUse /buystock ${stock.id} [amount] to purchase shares`;\n\n        await player.pm(message);\n\n    } else {\n        // No specific ticker provided or ALL specified, show summary of all stocks\n        await player.pm(\"=== STOCK MARKET LISTINGS ===\\n\");\n\n        // Group stocks by sector\n        const stocksBySector = {};\n        stocks.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        // MODIFICATION START\n        // Display stocks by sector, chunking them into messages of 3\n        const chunkSize = 3;\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            for (let i = 0; i < sectorStocks.length; i += chunkSize) {\n                const chunk = sectorStocks.slice(i, i + chunkSize);\n\n                // Add the sector header only to the first message for that sector.\n                let sectorMessage = (i === 0) ? `\\n--- ${sector} SECTOR ---\\n` : '';\n\n                chunk.forEach(stock => {\n                    // Add price change indicators\n                    let changeText = '';\n                    if (stock.lastPrice) {\n                        const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                        const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                        changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                    }\n\n                    // Add risk level based on volatility\n                    let riskIndicator;\n                    if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                    else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                    else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                    else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                    else riskIndicator = \"VH\";\n\n                    sectorMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n                });\n\n                await player.pm(sectorMessage);\n            }\n        }\n        // MODIFICATION END\n\n        // Add legend for risk indicators\n        const legend = \"\\n=== LEGEND ===\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\" +\n            \"Use /stockinfo [ticker] for detailed information about a specific stock\";\n\n        await player.pm(legend);\n    }\n}\n\nawait main();",
                    "name": "stockinfo",
                    "description": null,
                    "trigger": "stockinfo",
                    "helpText": "Shows all available stocks in the market. Use with a ticker symbol (e.g., /stockinfo ticker) to see detailed information about a specific stock.",
                    "arguments": [
                        {
                            "name": "ticker",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "stock ticker or ALL to get detailed information about a specific stock",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRIGGER_EVENT')) {\n        throw new TakaroUserError(\"You don't have permission to trigger market events.\");\n    }\n\n    try {\n        // Get current stock data to check market initialization\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Initialize market if needed\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            await player.pm(\"Market was not initialized. Initializing now...\");\n            return;\n        }\n\n        // Get events from module config\n        const marketEvents = mod.userConfig.marketEvents || [];\n\n        if (marketEvents.length === 0) {\n            throw new TakaroUserError(\"No market events configured in this module.\");\n        }\n\n        // Handle case when no event is specified or \"ALL\" is provided\n        if (!args.EventName || args.EventName.toUpperCase() === \"ALL\") {\n            await player.pm(\"=== AVAILABLE MARKET EVENTS ===\\n\");\n\n            // Group events by category or type if possible\n            const eventCategories = {};\n\n            // Create a simple categorization based on positive/negative impact\n            marketEvents.forEach(event => {\n                let category = \"Mixed\";\n                // Calculate net impact across all sectors\n                const netImpact = event.sectorImpacts.reduce((sum, impact) => sum + impact.impact, 0);\n\n                if (netImpact > 0) category = \"Positive\";\n                else if (netImpact < 0) category = \"Negative\";\n\n                if (!eventCategories[category]) {\n                    eventCategories[category] = [];\n                }\n                eventCategories[category].push(event);\n            });\n\n            // Display events by category\n            for (const [category, events] of Object.entries(eventCategories)) {\n                if (events.length > 0) {\n                    await player.pm(`\\n--- ${category.toUpperCase()} EVENTS ---`);\n\n                    let message = \"\";\n                    events.forEach(event => {\n                        // Format primary sectors affected\n                        const primarySectors = event.sectorImpacts\n                            .filter(impact => Math.abs(impact.impact) >= 15)\n                            .map(impact => {\n                                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                                return `${impact.sectorId} ${direction}${Math.abs(impact.impact)}%`;\n                            })\n                            .join(\", \");\n\n                        message += `${event.id}: ${event.name}\\n`;\n                        message += `   ${event.description}\\n`;\n                        if (primarySectors) {\n                            message += `   Major impacts: ${primarySectors}\\n`;\n                        }\n                        message += \"\\n\";\n                    });\n\n                    await player.pm(message);\n                }\n            }\n\n            await player.pm(\"=== HOW TO USE ===\\nUse `/triggerevent <EventName>` to trigger a specific event (e.g., `/triggerevent TECH_BOOM`)\");\n            return;\n        }\n\n        // Find the requested event\n        const eventId = args.EventName.toUpperCase();\n        const event = marketEvents.find(e => e.id === eventId);\n\n        if (!event) {\n            throw new TakaroUserError(`Event \"${eventId}\" not found. Use /triggerevent without parameters to see all available events.`);\n        }\n\n        // Get necessary variables for managing the event\n        const [activeEventVar, eventStartTimeVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_execution_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_cooldown_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['current_event_duration'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Check if there's an active event we need to cancel\n        let activeEventObj = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEventObj = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEventObj && Object.keys(activeEventObj).length > 0) {\n                    await player.pm(`Cancelling active event \"${activeEventObj.name}\" to trigger new event.`);\n                }\n            } catch (e) {\n                // Invalid event data, will be overwritten\n            }\n        }\n\n        // Generate a random duration for the event\n        const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n        // Update or create all event-related variables\n        const updatePromises = [];\n\n        // Save or update the random duration\n        if (eventDurationVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                    value: randomDuration.toString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'current_event_duration',\n                    value: randomDuration.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the event counter to 0\n        if (eventCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the cooldown counter\n        if (cooldownCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update active event\n        if (activeEventVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                    value: JSON.stringify(event)\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: JSON.stringify(event),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update event start time\n        if (eventStartTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update last event time\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (lastEventTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all updates to complete\n        await Promise.all(updatePromises);\n\n        // Check if there are online players to announce the event\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            // Format sector impacts for announcement\n            let impactText = \"\";\n            for (const impact of event.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n            }\n\n            const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${event.name}\\n${event.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /markets to see opportunities!`;\n\n            // Split the message if it's too long\n            const maxLength = 400; // Safe limit for most games\n            for (let i = 0; i < message.length; i += maxLength) {\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message: message.substring(i, i + maxLength)\n                });\n            }\n        }\n\n        await player.pm(`Successfully triggered the \"${event.name}\" market event for ${randomDuration} cycles!`);\n    } catch (error) {\n        // If something goes wrong, log it and let the player know\n        console.log(`Error in triggerEvent: ${error.message}`);\n        throw new TakaroUserError(`Error triggering event: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Store the stocks data\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_data',\n            value: JSON.stringify(stocks),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize last event time to now\n        await takaro.variable.variableControllerCreate({\n            key: 'last_market_event_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize event start time variable\n        await takaro.variable.variableControllerCreate({\n            key: 'event_start_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize active event (empty string means no active event)\n        await takaro.variable.variableControllerCreate({\n            key: 'active_market_event',\n            value: '',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Mark market as initialized\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_initialized',\n            value: 'true',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Announce market initialization to online players\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /markets to see available stocks and /buystock to start investing.\";\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message\n            });\n        }\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "triggerevent",
                    "description": null,
                    "trigger": "triggerevent",
                    "helpText": "Shows all available market events when run without parameters. Use with an event name (e.g., /triggerevent TECH_BOOM) to trigger a specific market event.",
                    "arguments": [
                        {
                            "name": "EventName",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "Event name to trigger a specific market event",
                            "position": 0
                        }
                    ]
                }
            ],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    try {\n        const { gameServerId, module: mod } = data;\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Check if market is initialized\n        if (marketDataVar.data.data.length === 0) {\n            console.log(\"Market data not found, initializing...\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return; // Exit after initialization\n        }\n\n        // Get active market event\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event start time\n        const eventStartTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_start_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event execution counter\n        const eventCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_execution_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event cooldown counter\n        const cooldownCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_cooldown_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let eventCounter = 0;\n        if (eventCounterVar.data.data.length > 0) {\n            eventCounter = parseInt(eventCounterVar.data.data[0].value, 10);\n            console.log(`Event counter: ${eventCounter}`);\n        }\n\n        let cooldownCounter = 0;\n        if (cooldownCounterVar.data.data.length > 0) {\n            cooldownCounter = parseInt(cooldownCounterVar.data.data[0].value, 10);\n            console.log(`Cooldown counter: ${cooldownCounter}`);\n        }\n\n        // Get event duration\n        const eventDurationVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['current_event_duration'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Use stored random duration if available, otherwise use defaultEventDuration\n        let eventDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        if (eventDurationVar.data.data.length > 0) {\n            eventDuration = parseInt(eventDurationVar.data.data[0].value, 10);\n            console.log(`Event duration: ${eventDuration}`);\n        }\n\n        let activeEvent = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                // If it's an empty string, treat as no active event\n                if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                    activeEvent = null;\n                }\n                console.log(`Active event: ${activeEvent ? activeEvent.name : 'None'}`);\n            } catch (e) {\n                // In case of parsing error, consider no active event\n                activeEvent = null;\n                console.log(`Error parsing active event: ${e.message}`);\n            }\n        }\n\n        // Check if the current event should end and increment counter\n        if (activeEvent) {\n            eventCounter++;\n            console.log(`Incremented event counter to: ${eventCounter}`);\n\n            if (eventCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: eventCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: eventCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n\n            if (eventCounter >= eventDuration) {\n                console.log(\"Event duration reached, ending event.\");\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: ''\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_cooldown_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    const message = `ðŸ“ˆ MARKET UPDATE ðŸ“‰\\n\\nThe \"${activeEvent.name}\" event has ended. Markets are returning to normal conditions.`;\n\n                    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                        message: message\n                    });\n                }\n\n                activeEvent = null;\n            }\n        } else {\n            cooldownCounter++;\n            console.log(`Incremented cooldown counter to: ${cooldownCounter}`);\n\n            if (cooldownCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: cooldownCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: cooldownCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n        }\n\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        const eventFrequency = (mod.userConfig && mod.userConfig.eventFrequency) || 10;\n        let shouldTriggerEvent = false;\n\n        if (!activeEvent && cooldownCounter >= eventFrequency) {\n            shouldTriggerEvent = Math.random() < 0.5;\n            if (cooldownCounter >= eventFrequency * 2) {\n                shouldTriggerEvent = true;\n            }\n            console.log(`Should trigger new event: ${shouldTriggerEvent}`);\n        }\n\n        if (shouldTriggerEvent) {\n            const events = (mod.userConfig && mod.userConfig.marketEvents) || [];\n            if (events.length > 0) {\n                const randomEvent = events[Math.floor(Math.random() * events.length)];\n                activeEvent = randomEvent;\n                console.log(`New event triggered: ${activeEvent.name}`);\n\n                const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n                const randomDuration = Math.floor(Math.random() * maxDuration) + 1;\n\n                if (eventDurationVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                        value: randomDuration.toString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'current_event_duration',\n                        value: randomDuration.toString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: JSON.stringify(activeEvent)\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'active_market_event',\n                        value: JSON.stringify(activeEvent),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventStartTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_start_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (lastEventTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'last_market_event_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    let impactText = \"\";\n                    for (const impact of activeEvent.sectorImpacts) {\n                        const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                        impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n                    }\n\n                    const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${activeEvent.name}\\n${activeEvent.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /market to see opportunities!`;\n\n                    const maxLength = 400;\n                    for (let i = 0; i < message.length; i += maxLength) {\n                        await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                            message: message.substring(i, i + maxLength)\n                        });\n                    }\n                }\n            }\n        }\n\n        // Get stocks\n        if (!marketDataVar.data.data[0] || !marketDataVar.data.data[0].value) {\n            console.log(\"Market data is empty or invalid after initial check, re-initializing.\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        let stocks;\n        try {\n            stocks = JSON.parse(marketDataVar.data.data[0].value);\n            if (!Array.isArray(stocks)) {\n                throw new Error(\"Parsed stocks data is not an array\");\n            }\n            // CRITICAL FIX: Ensure each stock has valid numerical price properties\n            stocks = stocks.map(s => {\n                const sanitizedPrice = typeof s.price === 'number' && s.price > 0 ? s.price : 1;\n                const sanitizedLastPrice = typeof s.lastPrice === 'number' && s.lastPrice > 0 ? s.lastPrice : sanitizedPrice;\n                return {\n                    ...s,\n                    price: sanitizedPrice,\n                    lastPrice: sanitizedLastPrice\n                };\n            });\n            console.log(\"Stocks loaded and sanitized successfully.\");\n            console.log(\"Initial stocks for this cycle:\");\n            stocks.forEach(s => console.log(`  ${s.id}: Price ${s.price}, LastPrice ${s.lastPrice}`));\n\n        } catch (e) {\n            console.log(`Error parsing or sanitizing stock data: ${e.message}`);\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        const significantChanges = [];\n\n        // Update each stock price\n        stocks.forEach(stock => {\n            // Always capture oldPrice at the very beginning of the iteration\n            const oldPrice = stock.price;\n            // Set lastPrice to the value before this current update cycle for accurate change tracking\n            stock.lastPrice = oldPrice;\n\n            console.log(`Processing stock: ${stock.id}, Old Price: ${oldPrice}`);\n\n            // Define the threshold for \"penny stock\"\n            const pennyStockThreshold = 1.9; // Stocks at or below this are \"penny stocks\"\n            const guaranteedBreakoutMinPrice = 2.5; // New minimum target for a strong breakout\n            const strongReboundChance = 0.7; // High chance for a significant rebound if very low\n\n            let calculatedNewPrice;\n\n            // New and improved penny stock recovery logic\n            if (oldPrice <= pennyStockThreshold) {\n                if (Math.random() < strongReboundChance) {\n                    // Strong positive breakout: Aim for a price significantly above $1\n                    // The rebound should be influenced by volatility but always ensure a strong jump\n                    const volatilityEffect = stock.volatility * (0.5 + Math.random()); // Scale volatility effect\n                    // A jump to 2.5-5.0 (guaranteedBreakoutMinPrice to guaranteedBreakoutMinPrice * 2)\n                    calculatedNewPrice = guaranteedBreakoutMinPrice + Math.random() * (guaranteedBreakoutMinPrice * 2 - guaranteedBreakoutMinPrice);\n                    calculatedNewPrice = Math.max(calculatedNewPrice, oldPrice * (1 + volatilityEffect)); // Ensure it's higher than current price + volatility\n                    console.log(`${stock.id} (Penny Stock) hit strong rebound! Calculated price: ${calculatedNewPrice.toFixed(2)}`);\n                } else {\n                    // If no strong rebound, still apply normal volatility, but with a slight upward bias\n                    // This is to prevent it from getting stuck even if it misses the strong rebound chance.\n                    const randomFactor = Math.random() * 0.5; // Only allow small fluctuations, mostly positive\n                    calculatedNewPrice = oldPrice * (1 + randomFactor * stock.volatility);\n                    // Ensure it doesn't drop significantly if it misses the strong rebound\n                    calculatedNewPrice = Math.max(calculatedNewPrice, oldPrice * 0.95); // No more than 5% drop if it misses\n                    console.log(`${stock.id} (Penny Stock) minor fluctuation. Calculated price: ${calculatedNewPrice.toFixed(2)}`);\n                }\n            } else {\n                // Original normal price fluctuation logic for non-penny stocks\n                const randomFactor = Math.random() * 2 - 1; // Generates a number between -1 and 1\n                const totalChangePercent = randomFactor * stock.volatility;\n                calculatedNewPrice = oldPrice * (1 + totalChangePercent);\n                console.log(`${stock.id} calculated normal price: ${calculatedNewPrice} (Change: ${totalChangePercent * 100}%)`);\n            }\n\n            let finalPrice = calculatedNewPrice;\n            if (activeEvent) {\n                const sectorImpact = activeEvent.sectorImpacts.find(impact => impact.sectorId === stock.sector);\n                if (sectorImpact) {\n                    const eventImpactPercentage = sectorImpact.impact;\n                    const eventImpactDecimal = eventImpactPercentage / 100;\n                    const randomImpactFactor = 0.5 + Math.random();\n                    const eventImpact = eventImpactDecimal * randomImpactFactor;\n\n                    finalPrice = calculatedNewPrice * (1 + eventImpact);\n                    console.log(`${stock.id} final price after event impact: ${finalPrice} (Event impact: ${eventImpact * 100}%)`);\n                }\n            }\n\n            stock.price = finalPrice;\n\n            // Remove the old hard $1 floor. Replace with minAbsolutePrice at the end.\n            const minAbsolutePrice = 0.01; // Allow price to go very low, but not zero\n            if (stock.price < minAbsolutePrice) {\n                console.log(`${stock.id} price fell below min allowed price (${minAbsolutePrice}), setting to ${minAbsolutePrice}.`);\n                stock.price = minAbsolutePrice;\n            }\n\n            const actualPercentChange = ((stock.price - oldPrice) / oldPrice) * 100;\n            console.log(`${stock.id} - Final Price: ${stock.price.toFixed(2)}, Actual Change: ${actualPercentChange.toFixed(2)}%`);\n\n            const changeThreshold = ((mod.userConfig && mod.userConfig.priceAlertThreshold) || 10) / 100;\n            if (Math.abs(actualPercentChange) > changeThreshold * 100) {\n                significantChanges.push({\n                    ...stock,\n                    changePercent: actualPercentChange\n                });\n            }\n        });\n\n        console.log(\"All stocks processed, saving updated prices...\");\n        await takaro.variable.variableControllerUpdate(marketDataVar.data.data[0].id, {\n            value: JSON.stringify(stocks)\n        });\n        console.log(\"Updated prices saved.\");\n\n        if (significantChanges.length > 0) {\n            console.log(\"Significant changes detected, sending alert.\");\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                significantChanges.sort((a, b) => Math.abs(b.changePercent) - Math.abs(a.changePercent));\n                const topChanges = significantChanges.slice(0, Math.min(3, significantChanges.length));\n\n                let message = \"ðŸ“Š STOCK MARKET ALERT ðŸ“Š\\n\";\n                topChanges.forEach(stock => {\n                    const changeDir = stock.changePercent > 0 ? \"up\" : \"down\";\n                    const displayPrice = stock.price.toFixed(2);\n                    const changePercent = Math.abs(Math.round(stock.changePercent));\n\n                    message += `${stock.id} (${stock.sector}): ${changeDir} ${changePercent}% to $${displayPrice}!\\n`;\n                });\n\n                if (activeEvent) {\n                    message += `\\nCurrent market event: ${activeEvent.name}`;\n                }\n\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            } else {\n                console.log(\"No online players to send alert to.\");\n            }\n        } else {\n            console.log(\"No significant changes to alert players about.\");\n        }\n    } catch (error) {\n        console.log(`FATAL Error in updateStockPrices: ${error.message}`);\n        // Optionally, send an admin message if a fatal error occurs\n        // await takaro.gameserver.gameServerControllerSendMessage(data.gameServerId, {\n        // message: `ðŸš¨ Market Error: An error occurred during stock update: ${error.message}`\n        // });\n    }\n}\n\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        console.log(\"Initializing market if needed...\");\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in module configuration for initialization.\");\n            return;\n        }\n\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_data'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['last_market_event_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_start_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['active_market_event'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_initialized'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_execution_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_cooldown_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['current_event_duration'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } })\n            ]);\n\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n        console.log(\"Mapped initial stocks from config.\");\n\n        const createPromises = [];\n\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_data', value: JSON.stringify(stocks), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'last_market_event_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_start_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'active_market_event', value: '', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_execution_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (cooldownCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_cooldown_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventDurationVar.data.data.length === 0) {\n            const defaultDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'current_event_duration', value: defaultDuration.toString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_initialized', value: 'true', gameServerId, moduleId: mod.moduleId }));\n        }\n\n        if (createPromises.length > 0) {\n            console.log(`Creating ${createPromises.length} initial market variables.`);\n            await Promise.allSettled(createPromises);\n        } else {\n            console.log(\"All market variables already exist, no new initialization needed.\");\n        }\n\n        if (marketDataVar.data.data.length === 0) { // Only announce if we actually created the stock_market_data variable\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /market to see available stocks and /buy to start investing.\";\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, { message });\n            }\n        }\n        console.log(\"Market initialization process complete.\");\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();\n",
                    "name": "updatestockprices",
                    "description": null,
                    "temporalValue": "0 */1 * * *"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n\n    const discordChannelId = mod.userConfig.marketNewsChannelId;\n\n    if (!discordChannelId) {\n        takaro.log.info('Market news Discord channel ID (marketNewsChannelId) not configured in module settings. Skipping Discord messages.');\n    }\n\n    const currentPlayers = (await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    })).data.meta;\n\n    if (currentPlayers.total === 0) {\n        takaro.log.info('Skipping daily market report: No players online.');\n        return;\n    }\n\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        takaro.log.warn('Skipping daily market report: Market data variable not found.');\n        return;\n    }\n\n    let stocks;\n    try {\n        stocks = JSON.parse(marketDataVar.data.data[0].value);\n        if (!Array.isArray(stocks)) {\n            throw new Error('Parsed market data is not an array.');\n        }\n    } catch (error) {\n        takaro.log.error(`Failed to parse stock_market_data: ${error}`);\n        return;\n    }\n\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            if (typeof activeEvent !== 'object' || activeEvent === null || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (error) {\n            takaro.log.warn(`Failed to parse active_market_event: ${error}`);\n            activeEvent = null;\n        }\n    }\n\n    let gameMessage1 = \"==== DAILY MARKET REPORT ====\\n\";\n\n    if (activeEvent && activeEvent.name && activeEvent.description) {\n        const eventText = `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n${activeEvent.description}\\n`;\n        gameMessage1 += eventText;\n    } else {\n        const noEventText = '\\nNo active market events today.\\n';\n        gameMessage1 += noEventText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage1\n    }).catch(err => takaro.log.error(`Failed to send game message 1: ${err}`));\n\n    const stocksWithPerformance = stocks.map(stock => {\n        let change = 0;\n        let percentChange = 0;\n        let changeSymbol = 'â†’';\n\n        if (typeof stock.price === 'number' && typeof stock.lastPrice === 'number' && stock.lastPrice !== 0) {\n            change = stock.price - stock.lastPrice;\n            percentChange = (change / stock.lastPrice) * 100;\n            if (percentChange > 0.05) {\n                changeSymbol = 'â†‘';\n            } else if (percentChange < -0.05) {\n                changeSymbol = 'â†“';\n            }\n        } else if (typeof stock.price === 'number' && stock.lastPrice === undefined) {\n            changeSymbol = 'ðŸ†•';\n            percentChange = 0;\n        }\n        return {\n            ...stock,\n            change,\n            percentChange,\n            changeSymbol\n        };\n    });\n\n    const sectorPerformance = {};\n    // Define the desired display order and mapping for sorting\n    const riskOrder = {\n        \"Very High Risk\": 5,\n        \"High Risk\": 4,\n        \"Medium Risk\": 3,\n        \"Low Risk\": 2,\n        \"Very Low Risk\": 1,\n        \"Uncategorized\": 0 // Fallback for any stock without a defined sector\n    };\n\n    stocksWithPerformance.forEach(stock => {\n        const sectorName = stock.sector || 'Uncategorized'; // Use the sector name directly\n        if (!sectorPerformance[sectorName]) {\n            sectorPerformance[sectorName] = {\n                stocks: [],\n                totalPercentChange: 0,\n                count: 0\n            };\n        }\n        sectorPerformance[sectorName].stocks.push(stock);\n        if (typeof stock.percentChange === 'number' && isFinite(stock.percentChange)) {\n            sectorPerformance[sectorName].totalPercentChange += stock.percentChange;\n            sectorPerformance[sectorName].count++;\n        }\n    });\n\n    for (const sectorName in sectorPerformance) {\n        const sectorData = sectorPerformance[sectorName];\n        if (sectorData.count > 0) {\n            sectorData.avgPerformance = sectorData.totalPercentChange / sectorData.count;\n        } else {\n            sectorData.avgPerformance = 0;\n        }\n    }\n\n    // Sort sector performance by risk order (VH to VL)\n    const sortedSectors = Object.entries(sectorPerformance)\n        .sort(([sectorNameA], [sectorNameB]) => riskOrder[sectorNameB] - riskOrder[sectorNameA]);\n\n    let gameMessage2 = \"\\n=== SECTOR PERFORMANCE ===\\n\";\n\n    if (sortedSectors.length > 0) {\n        sortedSectors.forEach(([sectorName, sectorData]) => { // Use sectorName directly\n            const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n            let line = `${sectorName}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n\n            if (sectorData.avgPerformance > 0.05) {\n                line = `[70FE02]${sectorName}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%[-]\\n`;\n            } else if (sectorData.avgPerformance < -0.05) {\n                line = `[FF0001]${sectorName}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%[-]\\n`;\n            }\n            gameMessage2 += line;\n        });\n    } else {\n        const noDataText = \"No sector performance data available.\\n\";\n        gameMessage2 += noDataText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage2\n    }).catch(err => takaro.log.error(`Failed to send game message 2: ${err}`));\n\n    const validPerformers = stocksWithPerformance.filter(s => typeof s.percentChange === 'number' && isFinite(s.percentChange));\n    validPerformers.sort((a, b) => b.percentChange - a.percentChange);\n\n    let gameMessage3 = \"\";\n\n    const topPerformersTitleGame = \"\\nðŸ”¥ TOP PERFORMERS ðŸ”¥\\n\";\n    gameMessage3 += topPerformersTitleGame;\n\n    if (validPerformers.length > 0) {\n        for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n            const stock = validPerformers[i];\n            gameMessage3 += `[70FE02]${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%[-]\\n`;\n        }\n    } else {\n        gameMessage3 += \"No top performers today.\\n\";\n    }\n\n    const worstPerformersTitleGame = \"\\nðŸ“‰ WORST PERFORMERS ðŸ“‰\\n\";\n    gameMessage3 += worstPerformersTitleGame;\n\n    if (validPerformers.length > 0) {\n        const worstStartIndex = Math.max(0, validPerformers.length - 3);\n        for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n            const stock = validPerformers[i];\n            gameMessage3 += `[FF0001]${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%[-]\\n`;\n        }\n    } else {\n        gameMessage3 += \"No worst performers today.\\n\";\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage3\n    }).catch(err => takaro.log.error(`Failed to send game message 3: ${err}`));\n\n    function hslToRgb(h, s, l) { let a = s * Math.min(l, 1 - l); let f = n => { let k = (n + h / 30) % 12; return l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1)); }; return [Math.round(255 * f(0)), Math.round(255 * f(8)), Math.round(255 * f(4))]; }\n    function rgbToHex(r, g, b) { return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase(); }\n    function stringToHexColor(str) { let hash = 0; for (let i = 0; i < str.length; i++) { hash = str.charCodeAt(i) + ((hash << 5) - hash); } hash = Math.abs(hash); const hue = (hash * 137.508) % 360; const [r, g, b] = hslToRgb(hue, 0.9, 0.7); return rgbToHex(r, g, b); }\n\n    const stockColors = {};\n    stocksWithPerformance.forEach(stock => {\n        stockColors[stock.id] = stringToHexColor(stock.name);\n    });\n\n    const stocksBySectorGame = {};\n    stocksWithPerformance.forEach(stock => {\n        const sector = stock.sector || 'Uncategorized'; // Use the sector name directly\n        if (!stocksBySectorGame[sector]) {\n            stocksBySectorGame[sector] = [];\n        }\n        stocksBySectorGame[sector].push(stock);\n    });\n\n    // Sort the sector names for display in the desired order (VH, H, M, L, VL)\n    const sortedSectorNamesGame = Object.keys(stocksBySectorGame).sort((sectorNameA, sectorNameB) => riskOrder[sectorNameB] - riskOrder[sectorNameA]);\n\n\n    for (const sectorName of sortedSectorNamesGame) { // Iterate through sorted sector names\n        const sectorStocks = stocksBySectorGame[sectorName];\n        const chunkSize = 3;\n        for (let i = 0; i < sectorStocks.length; i += chunkSize) {\n            const chunk = sectorStocks.slice(i, i + chunkSize);\n            // Use sectorName directly for the header\n            let sectorMessage = (i === 0) ? `\\n--- ${sectorName} SECTOR ---\\n` : '';\n\n            chunk.forEach(stock => {\n                let changeText = '';\n                let priceColorPrefix = '', priceColorSuffix = '';\n\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeText = ` ${stock.changeSymbol} ${Math.abs(percentChange).toFixed(1)}%`;\n                    if (percentChange > 0) {\n                        priceColorPrefix = '[70FE02]';\n                        priceColorSuffix = '[-]';\n                    } else if (percentChange < 0) {\n                        priceColorPrefix = '[FF0001]';\n                        priceColorSuffix = '[-]';\n                    }\n                }\n\n                const stockNameColorPrefix = stockColors[stock.id] ? `[${stockColors[stock.id]}]` : '';\n                const stockNameColorSuffix = stockColors[stock.id] ? '[-]' : '';\n\n                let riskIndicator; // This is derived from volatility, not directly from sector ID\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.25) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                sectorMessage += `${stockNameColorPrefix}${stock.name} (${stock.id})${stockNameColorSuffix} (${riskIndicator}): ${priceColorPrefix}$${Math.round(stock.price)}${changeText}${priceColorSuffix}\\n`;\n            });\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message: sectorMessage\n            }).catch(err => takaro.log.error(`Failed to send game message for sector ${sectorName}: ${err}`));\n        }\n    }\n\n    const legendMessage = \"\\n=== LEGEND ===\\n\" +\n        \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\";\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: legendMessage\n    }).catch(err => takaro.log.error(`Failed to send game legend message: ${err}`));\n\n    if (discordChannelId) {\n        // --- MESSAGE 1: The Summary ---\n        let discordMessageSummary = \"**==== DAILY MARKET REPORT ====**\\n\\n\";\n\n        if (activeEvent && activeEvent.name && activeEvent.description) {\n            discordMessageSummary += `ðŸŒ **ACTIVE EVENT: ${activeEvent.name}** ðŸŒ\\n${activeEvent.description}\\n\\n`;\n        } else {\n            discordMessageSummary += 'No active market events today.\\n\\n';\n        }\n\n        discordMessageSummary += \"**=== SECTOR PERFORMANCE ===**\\n\";\n        if (sortedSectors.length > 0) {\n            sortedSectors.forEach(([sectorName, sectorData]) => { // Use sectorName directly\n                const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n                discordMessageSummary += `${sectorName}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n            });\n        } else {\n            discordMessageSummary += \"No sector performance data available.\\n\";\n        }\n        discordMessageSummary += \"\\n\";\n\n        discordMessageSummary += \"**ðŸ”¥ TOP PERFORMERS ðŸ”¥**\\n\";\n        if (validPerformers.length > 0) {\n            for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n                const stock = validPerformers[i];\n                discordMessageSummary += `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            }\n        } else {\n            discordMessageSummary += \"No top performers today.\\n\";\n        }\n        discordMessageSummary += \"\\n\";\n\n        discordMessageSummary += \"**ðŸ“‰ WORST PERFORMERS ðŸ“‰**\\n\";\n        if (validPerformers.length > 0) {\n            const worstStartIndex = Math.max(0, validPerformers.length - 3);\n            for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n                const stock = validPerformers[i];\n                discordMessageSummary += `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            }\n        } else {\n            discordMessageSummary += \"No worst performers today.\\n\";\n        }\n\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessageSummary\n        }).catch(err => takaro.log.error(`Failed to send summary Discord message: ${err.message || err}`));\n\n        // --- MESSAGE 2: All Stock Listings ---\n        let discordMessageDetails = \"**=== ALL STOCK LISTINGS ===**\\n\";\n        const stocksBySector = {};\n        stocksWithPerformance.forEach(stock => {\n            const sector = stock.sector || 'Uncategorized'; // Use the sector name directly\n            if (!stocksBySector[sector]) {\n                stocksBySector[sector] = [];\n            }\n            stocksBySector[sector].push(stock);\n        });\n\n        // Sort the sector names for display in the desired order (VH, H, M, L, VL)\n        const sortedSectorNamesDiscord = Object.keys(stocksBySector).sort((sectorNameA, sectorNameB) => riskOrder[sectorNameB] - riskOrder[sectorNameA]);\n\n\n        for (const sectorName of sortedSectorNamesDiscord) { // Iterate through sorted sector names\n            const sectorStocks = stocksBySector[sectorName];\n            discordMessageDetails += `\\n--- **${sectorName} SECTOR** ---\\n`; // Use sectorName directly\n            sectorStocks.forEach(stock => {\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeText = ` ${stock.changeSymbol} ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.25) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                discordMessageDetails += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n        }\n\n        discordMessageDetails += \"\\n**=== LEGEND ===**\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\";\n\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessageDetails\n        }).catch(err => takaro.log.error(`Failed to send details Discord message: ${err.message || err}`));\n    }\n\n    takaro.log.info('Daily market report sent successfully.');\n}\n\nawait main();",
                    "name": "marketnews",
                    "description": null,
                    "temporalValue": "1 */1 * * *"
                }
            ],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Allows the player to view market prices and their portfolio",
                    "permission": "STOCK_MARKET_USE",
                    "friendlyName": "Use Stock Market"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows the player to buy and sell stocks",
                    "permission": "STOCK_MARKET_TRADE",
                    "friendlyName": "Trade Stocks"
                },
                {
                    "canHaveCount": false,
                    "description": "VIP status that reduces transaction fees",
                    "permission": "STOCK_MARKET_BROKER",
                    "friendlyName": "Stock Broker"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows admins to manually trigger market events",
                    "permission": "STOCK_MARKET_TRIGGER_EVENT",
                    "friendlyName": "Trigger Market Events"
                }
            ]
        },
        {
            "tag": "0.1.4",
            "description": "**Stock Market: A Dynamic Virtual Trading System**\n\nCreate an immersive economic experience with this comprehensive stock market module that lets players invest, trade, and react to market events.\n\n**Market Features:**\n\n![Market Summary](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stocks.png)\n\n* **Multiple Economic Sectors:** Configure various industry sectors (Resource Extraction, Manufacturing, Defense, etc.) each with their own market dynamics.\n* **Realistic Stock Behavior:** Stocks have configurable volatility, sector-based pricing, and react differently to market events.\n* **Dynamic Market Events:** Random or admin-triggered events like \"Horde Night Approaching\" or \"Societal Collapse Setback\" impact different sectors in realistic ways.\n\n![Market Events](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_events.png)\n\n**Trading System:**\n\n* **Buy & Sell Shares:** Players can purchase stocks and sell them later for profit or loss.\n* **Transaction Fees:** Configurable fee percentage on all trades creates a realistic market economy.\n* **VIP Benefits:** Special permissions for designated \"Stock Brokers\" who receive fee discounts.\n\n![Buy Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_buy.png)\n\nPlayers can track price changes and sell at the right moment to maximize profits or minimize losses.\n\n![Sell Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sell.png)\n\n**Player Portfolio:**\n\n* **Portfolio Tracking:** Players can view their holdings, average purchase prices, and current profit/loss.\n* **Transaction History:** System tracks all buy/sell transactions for each player.\n* **Summary Statistics:** See overall portfolio performance and value across all holdings.\n\n![Portfolio View](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockportfolio.png)\n\n**Market Information:**\n\n* **Detailed Stock Info:** Players can research specific stocks, including risk levels and sector trends.\n* **Industry Filters:** View stocks by specific sectors to better understand market segments.\n* **Market Alerts:** Server-wide notifications for significant price changes keep players engaged.\n\n![Market Alerts](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockpricechange.png)\n\n**Configuration Options:**\n\n* **Sectors & Stocks:** Define your own market sectors and individual stocks with customizable starting prices and volatility.\n* **Market Events:** Create unique events with specific sector impacts to drive market dynamics.\n* **Transaction Settings:** Configure fee percentages, VIP discounts, and alert thresholds.\n* **Event Frequency:** Control how often random market events occur and how long they last.\n\n![Configuration](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_config.png)\n![Sectors](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sectors.png)\n\n**Commands:**\n\n* `/markets [industry]` - View all stocks or filter by industry\n* `/stockinfo [ticker]` - Get detailed information about a specific stock\n* `/buystock <ticker> <amount>` - Purchase shares of a stock\n* `/sellstock <ticker> <amount>` - Sell shares from your portfolio\n* `/stockportfolio` - View your current holdings and performance\n* `/triggerevent [event]` - Admin command to trigger specific market events\n\nWho says the apocalypse can't have a thriving economy? Now players can stress about both zombie hordes AND their Duke's Casino Tokens dropping 40% after a market event! As one trader put it: \"I used to check my 401K daily, and now I check my AMMO stock before every Blood Moon. Some habits die harder than zombies.\"",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sectors\":{\"type\":\"array\",\"title\":\"Wasteland Economic Sectors\",\"description\":\"Define economic sectors relevant to survival in Navezgane\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Sector ID (e.g., RESOURCES)\"},\"name\":{\"type\":\"string\",\"description\":\"Sector name (e.g., Resource Extraction)\"}}},\"default\":[{\"id\":\"RESOURCES\",\"name\":\"Resource Extraction\"},{\"id\":\"MANUFACTURING\",\"name\":\"Manufacturing & Crafting\"},{\"id\":\"DEFENSE\",\"name\":\"Defense & Fortifications\"},{\"id\":\"SURVIVAL\",\"name\":\"Survival Goods\"},{\"id\":\"TRADE\",\"name\":\"Trade & Currency\"}]},\"stocks\":{\"type\":\"array\",\"title\":\"Wasteland Stocks\",\"description\":\"List of stocks representing Navezgane entities and resources\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Stock ticker symbol (e.g., NMC)\"},\"name\":{\"type\":\"string\",\"description\":\"Entity/Resource name\"},\"sector\":{\"type\":\"string\",\"description\":\"Sector ID this stock belongs to\"},\"initialPrice\":{\"type\":\"number\",\"description\":\"Starting price in Dukes\",\"minimum\":1},\"volatility\":{\"type\":\"number\",\"description\":\"Base volatility percentage (5 = 5%)\",\"minimum\":1,\"maximum\":35}}},\"default\":[{\"id\":\"NMC\",\"name\":\"Navezgane Mining Co.\",\"sector\":\"RESOURCES\",\"initialPrice\":50,\"volatility\":15},{\"id\":\"WOOD\",\"name\":\"Wasteland Lumberjacks\",\"sector\":\"RESOURCES\",\"initialPrice\":20,\"volatility\":8},{\"id\":\"SHALE\",\"name\":\"Oil Shale Extractors\",\"sector\":\"RESOURCES\",\"initialPrice\":40,\"volatility\":18},{\"id\":\"FORGE\",\"name\":\"Forge Ahead Metals\",\"sector\":\"MANUFACTURING\",\"initialPrice\":75,\"volatility\":12},{\"id\":\"TOOLS\",\"name\":\"Working Stiff Tools\",\"sector\":\"MANUFACTURING\",\"initialPrice\":60,\"volatility\":10},{\"id\":\"MECH\",\"name\":\"JunkTech Robotics\",\"sector\":\"MANUFACTURING\",\"initialPrice\":110,\"volatility\":20},{\"id\":\"BUILD\",\"name\":\"Barricade Builders\",\"sector\":\"DEFENSE\",\"initialPrice\":45,\"volatility\":9},{\"id\":\"AMMO\",\"name\":\"AmmoNation Surplus\",\"sector\":\"DEFENSE\",\"initialPrice\":90,\"volatility\":18},{\"id\":\"SHAM\",\"name\":\"Shamway Foods\",\"sector\":\"SURVIVAL\",\"initialPrice\":30,\"volatility\":5},{\"id\":\"MEDS\",\"name\":\"Pop-N-Pills Medical\",\"sector\":\"SURVIVAL\",\"initialPrice\":100,\"volatility\":18},{\"id\":\"TRADE\",\"name\":\"Trader Guild Network\",\"sector\":\"TRADE\",\"initialPrice\":150,\"volatility\":10},{\"id\":\"DUKES\",\"name\":\"Duke's Casino Tokens\",\"sector\":\"TRADE\",\"initialPrice\":1,\"volatility\":3}]},\"marketEvents\":{\"type\":\"array\",\"title\":\"Wasteland Events\",\"description\":\"Events impacting the Navezgane economy\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Unique event ID\"},\"name\":{\"type\":\"string\",\"description\":\"Name of the event\"},\"description\":{\"type\":\"string\",\"description\":\"Description of the event's market effect\"},\"sectorImpacts\":{\"type\":\"array\",\"description\":\"How each sector is affected\",\"items\":{\"type\":\"object\",\"properties\":{\"sectorId\":{\"type\":\"string\",\"description\":\"Sector ID\"},\"impact\":{\"type\":\"number\",\"description\":\"Percentage impact (-30 = -30%)\",\"minimum\":-75,\"maximum\":75}}}}}},\"default\":[{\"id\":\"HORDE_INCOMING\",\"name\":\"Horde Night Approaching\",\"description\":\"Increased Zed activity signals the Blood Moon. Survivors prepare defenses.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-5},{\"sectorId\":\"MANUFACTURING\",\"impact\":15},{\"sectorId\":\"DEFENSE\",\"impact\":25},{\"sectorId\":\"SURVIVAL\",\"impact\":10},{\"sectorId\":\"TRADE\",\"impact\":-10}]},{\"id\":\"RESOURCE_SHOCK\",\"name\":\"Resource Shock\",\"description\":\"Key resource veins are depleted, making raw materials expensive and driving up the price of finished goods.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-30},{\"sectorId\":\"MANUFACTURING\",\"impact\":15},{\"sectorId\":\"DEFENSE\",\"impact\":10},{\"sectorId\":\"SURVIVAL\",\"impact\":5},{\"sectorId\":\"TRADE\",\"impact\":5}]},{\"id\":\"ZED_OUTBREAK\",\"name\":\"Severe Zed Outbreak\",\"description\":\"An unusual concentration of Zed activity makes scavenging dangerous. Demand for medical supplies and defenses skyrockets.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-20},{\"sectorId\":\"MANUFACTURING\",\"impact\":-5},{\"sectorId\":\"DEFENSE\",\"impact\":25},{\"sectorId\":\"SURVIVAL\",\"impact\":25},{\"sectorId\":\"TRADE\",\"impact\":-15}]},{\"id\":\"TECH_BREAKTHROUGH\",\"name\":\"Technological Breakthrough\",\"description\":\"A discovery of pre-collapse schematics has revolutionized crafting and manufacturing.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":10},{\"sectorId\":\"MANUFACTURING\",\"impact\":30},{\"sectorId\":\"DEFENSE\",\"impact\":15},{\"sectorId\":\"SURVIVAL\",\"impact\":5},{\"sectorId\":\"TRADE\",\"impact\":15}]},{\"id\":\"TRADE_ROUTE_SECURED\",\"name\":\"Trade Route Secured\",\"description\":\"Traders have established a safer passage, improving the flow of all goods and services.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":20},{\"sectorId\":\"MANUFACTURING\",\"impact\":10},{\"sectorId\":\"DEFENSE\",\"impact\":5},{\"sectorId\":\"SURVIVAL\",\"impact\":15},{\"sectorId\":\"TRADE\",\"impact\":30}]},{\"id\":\"GENERAL_COLLAPSE\",\"name\":\"Societal Collapse Setback\",\"description\":\"A major setback reminds everyone how fragile survival is. Fear grips the market.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-15},{\"sectorId\":\"MANUFACTURING\",\"impact\":-20},{\"sectorId\":\"DEFENSE\",\"impact\":-15},{\"sectorId\":\"SURVIVAL\",\"impact\":0},{\"sectorId\":\"TRADE\",\"impact\":-25}]}]},\"eventFrequency\":{\"title\":\"Event Frequency\",\"type\":\"number\",\"description\":\"Average number of update cycles between market events (0 to disable). Depends on mod's update frequency (e.g., per in-game hour?).\",\"default\":8,\"minimum\":1},\"defaultEventDuration\":{\"title\":\"Default Event Duration\",\"type\":\"number\",\"description\":\"Default number of update cycles an event lasts.\",\"default\":3,\"minimum\":1,\"maximum\":96},\"transactionFee\":{\"title\":\"Transaction Fee (Dukes Tax)\",\"type\":\"number\",\"description\":\"Percentage fee charged on all buy/sell transactions (5 = 5%)\",\"default\":3,\"minimum\":0,\"maximum\":25},\"vipDiscount\":{\"title\":\"Trader's Favor Discount\",\"type\":\"number\",\"description\":\"Percentage discount on transaction fees for players with 'STOCK_MARKET_BROKER' permission (50 = 50%)\",\"default\":50,\"minimum\":0,\"maximum\":100},\"priceAlertThreshold\":{\"title\":\"Price Alert Threshold\",\"type\":\"number\",\"description\":\"Percentage change that triggers a market alert (15 = 15%)\",\"default\":15,\"minimum\":5,\"maximum\":50},\"marketNewsChannelId\":{\"title\":\"Discord Channel ID (for Market News)\",\"type\":\"string\",\"description\":\"The ID of the Discord channel where market news messages should be posted. Leave empty to disable.\",\"default\":\"\"}},\"additionalProperties\":false}",
            "uiSchema": "{\"sectors\":{\"items\":{\"ui:order\":[\"id\",\"name\"]}},\"stocks\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"sector\",\"initialPrice\",\"volatility\"]}},\"marketEvents\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"description\",\"sectorImpacts\"],\"sectorImpacts\":{\"items\":{\"ui:order\":[\"sectorId\",\"impact\"]}}}},\"transactionFee\":{\"ui:widget\":\"range\"},\"vipDiscount\":{\"ui:widget\":\"range\"},\"eventFrequency\":{\"ui:help\":\"Set to 0 to disable random events\"},\"priceAlertThreshold\":{\"ui:widget\":\"range\"}}",
            "commands": [
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // Get player's portfolio\n    const portfolioVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_portfolio'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId],\n            playerId: [player.id]\n        }\n    });\n\n    let portfolio = {};\n    if (portfolioVar.data.data.length > 0) {\n        portfolio = JSON.parse(portfolioVar.data.data[0].value);\n    }\n\n    // Send header\n    await player.pm(\"=== YOUR STOCK PORTFOLIO ===\");\n\n    let hasStocks = false;\n    let totalValue = 0;\n    let totalInvestment = 0;\n\n    // If no stocks, send a simple message\n    if (Object.keys(portfolio).length === 0) {\n        await player.pm(\"You don't own any stocks yet.\\n\" +\n            \"Use /markets to see available stocks and prices.\\n\" +\n            \"Use /buy <stock> <amount> to purchase stocks.\");\n        return;\n    }\n\n    // Send each stock as a separate message to avoid length issues\n    for (const [stockId, data] of Object.entries(portfolio)) {\n        hasStocks = true;\n        const stock = stocks.find(s => s.id === stockId);\n        if (!stock) continue; // Stock might have been removed from config\n\n        const currentValue = stock.price * data.shares;\n        const investmentValue = data.averagePrice * data.shares;\n        totalValue += currentValue;\n        totalInvestment += investmentValue;\n        const profit = currentValue - investmentValue;\n        const profitPercent = ((profit / investmentValue) * 100).toFixed(1);\n\n        let stockMessage = `--- ${stockId} (${stock.sector}) ---\\n`;\n        stockMessage += `Shares: ${data.shares}\\n`;\n        stockMessage += `Avg buy: $${Math.round(data.averagePrice)}\\n`;\n        stockMessage += `Current price: $${Math.round(stock.price)}\\n`;\n        stockMessage += `Total value: $${Math.round(currentValue)}\\n`;\n\n        if (profit >= 0) {\n            stockMessage += `Profit: +$${Math.round(profit)} (+${profitPercent}%)\\n`;\n        } else {\n            stockMessage += `Loss: -$${Math.abs(Math.round(profit))} (${profitPercent}%)\\n`;\n        }\n\n        await player.pm(stockMessage);\n    }\n\n    if (hasStocks) {\n        const totalProfit = totalValue - totalInvestment;\n        const totalProfitPercent = ((totalProfit / totalInvestment) * 100).toFixed(1);\n\n        let summaryMessage = \"=== PORTFOLIO SUMMARY ===\\n\";\n        summaryMessage += `Total investment: $${Math.round(totalInvestment)}\\n`;\n        summaryMessage += `Current value: $${Math.round(totalValue)}\\n`;\n\n        if (totalProfit >= 0) {\n            summaryMessage += `Overall profit: +$${Math.round(totalProfit)} (+${totalProfitPercent}%)\\n`;\n        } else {\n            summaryMessage += `Overall loss: -$${Math.abs(Math.round(totalProfit))} (${totalProfitPercent}%)\\n`;\n        }\n\n        // Get transaction history count\n        try {\n            const historyVar = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: ['stock_transaction_history'],\n                    gameServerId: [gameServerId],\n                    moduleId: [mod.moduleId],\n                    playerId: [player.id]\n                }\n            });\n\n            if (historyVar.data.data.length > 0) {\n                const history = JSON.parse(historyVar.data.data[0].value);\n                const buyCount = history.filter(t => t.type === 'BUY').length;\n                const sellCount = history.filter(t => t.type === 'SELL').length;\n\n                summaryMessage += `\\nTransactions: ${history.length} (${buyCount} buys, ${sellCount} sells)\\n`;\n            }\n        } catch (error) {\n            // Just ignore history errors\n        }\n\n        await player.pm(summaryMessage);\n\n    }\n}\n\nawait main();",
                    "name": "stockportfolio",
                    "description": null,
                    "trigger": "stockportfolio",
                    "helpText": "No help text available",
                    "arguments": []
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // If a specific stock ticker is provided, show detailed info for that stock\n    const specificTicker = args.ticker ? args.ticker.toUpperCase() : null;\n\n    if (specificTicker && specificTicker !== \"ALL\") {\n        const stock = stocks.find(s => s.id.toUpperCase() === specificTicker);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${specificTicker} not found. Use /stockinfo without parameters to see all available stocks.`);\n        }\n\n        // Get active event to see if this stock's sector is affected\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let activeEvent = null;\n        let sectorImpact = null;\n\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEvent && activeEvent.sectorImpacts) {\n                    sectorImpact = activeEvent.sectorImpacts.find(impact =>\n                        impact.sectorId === stock.sector\n                    );\n                }\n            } catch (e) {\n                // Ignore parsing errors\n            }\n        }\n\n        // Calculate price change indicators\n        let changeText = '';\n        if (stock.lastPrice) {\n            const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n            const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n            changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n        }\n\n        // Add risk assessment based on volatility without showing the raw value\n        let riskLevel;\n        if (stock.volatility <= 0.05) riskLevel = \"Very Low\";\n        else if (stock.volatility <= 0.10) riskLevel = \"Low\";\n        else if (stock.volatility <= 0.15) riskLevel = \"Moderate\";\n        else if (stock.volatility <= 0.20) riskLevel = \"High\";\n        else riskLevel = \"Very High\";\n\n        // Build detailed stock info message\n        let message = `=== ${stock.id}: ${stock.name} ===\\n\\n`;\n        message += `Sector: ${stock.sector}\\n`;\n        message += `Current Price: $${Math.round(stock.price)}${changeText}\\n`;\n        message += `Risk Level: ${riskLevel}\\n`;\n\n        // Add sector trend info if available from event\n        if (activeEvent && sectorImpact) {\n            const direction = sectorImpact.impact >= 0 ? \"Positive\" : \"Negative\";\n            const strength = Math.abs(sectorImpact.impact);\n            let trend;\n\n            if (strength < 10) trend = \"Slight\";\n            else if (strength < 25) trend = \"Moderate\";\n            else trend = \"Strong\";\n\n            message += `\\nCurrent Trend: ${trend} ${direction} (${activeEvent.name})\\n`;\n            message += `Event: ${activeEvent.description}\\n`;\n        }\n\n        // Add trading guidance based on sector and risk, without mentioning volatility\n        message += `\\nTrading Notes:\\n`;\n\n        if (activeEvent && sectorImpact) {\n            if (sectorImpact.impact > 0) {\n                message += `- Currently bullish due to the ${activeEvent.name} event\\n`;\n            } else {\n                message += `- Currently bearish due to the ${activeEvent.name} event\\n`;\n            }\n        }\n\n        if (riskLevel === \"High\" || riskLevel === \"Very High\") {\n            message += `- Expect significant price fluctuations with this stock\\n`;\n        } else if (riskLevel === \"Low\" || riskLevel === \"Very Low\") {\n            message += `- Typically has stable price movement\\n`;\n        }\n\n        message += `\\nUse /buystock ${stock.id} [amount] to purchase shares`;\n\n        await player.pm(message);\n\n    } else {\n        // No specific ticker provided or ALL specified, show summary of all stocks\n        await player.pm(\"=== STOCK MARKET LISTINGS ===\\n\");\n\n        // Group stocks by sector\n        const stocksBySector = {};\n        stocks.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        // Display stocks by sector\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            let sectorMessage = `\\n--- ${sector} SECTOR ---\\n`;\n\n            sectorStocks.forEach(stock => {\n                // Add price change indicators\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                    changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                // Add risk level based on volatility\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                sectorMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n\n            await player.pm(sectorMessage);\n        }\n\n        // Add legend for risk indicators\n        const legend = \"\\n=== LEGEND ===\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\" +\n            \"Use /stockinfo [ticker] for detailed information about a specific stock\";\n\n        await player.pm(legend);\n    }\n}\n\nawait main();",
                    "name": "stockinfo",
                    "description": null,
                    "trigger": "stockinfo",
                    "helpText": "Shows all available stocks in the market. Use with a ticker symbol (e.g., /stockinfo ticker) to see detailed information about a specific stock.",
                    "arguments": [
                        {
                            "name": "ticker",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "stock ticker or ALL to get detailed information about a specific stock",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get player's portfolio\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        if (portfolioVar.data.data.length === 0) {\n            throw new TakaroUserError(\"You don't own any stocks to sell.\");\n        }\n\n        const portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        const stockId = args.stock.toUpperCase();\n\n        if (!portfolio[stockId] || portfolio[stockId].shares < amount) {\n            throw new TakaroUserError(`You don't own ${amount} shares of ${stockId}.`);\n        }\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === stockId);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${stockId} not found in current market data. Please contact an admin.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate sale proceeds using Math.round to ensure we work with integers\n        const stockPrice = Math.round(stock.price);\n        const subtotal = stockPrice * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const netProceeds = subtotal - fee;\n\n        // Add money to player - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerAddCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: netProceeds\n            }\n        );\n\n        // Calculate profit/loss\n        const profitPerShare = stockPrice - portfolio[stockId].averagePrice;\n        const totalProfit = Math.round(profitPerShare * amount);\n        const profitText = totalProfit >= 0\n            ? `profit of $${totalProfit}`\n            : `loss of $${Math.abs(totalProfit)}`;\n\n        // Update portfolio\n        portfolio[stockId].shares -= amount;\n        if (portfolio[stockId].shares === 0) {\n            delete portfolio[stockId];\n        }\n\n        // Save updated portfolio\n        await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n            value: JSON.stringify(portfolio)\n        });\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'SELL',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: netProceeds,\n            profit: totalProfit,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully sold ${amount} shares of ${stockId} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Net proceeds: $${netProceeds} (${profitText})`;\n\n        // Add remaining shares info if player still has some\n        if (portfolio[stockId]) {\n            message += `\\nRemaining shares: ${portfolio[stockId].shares}`;\n        } else {\n            message += `\\nYou've sold all your ${stockId} shares.`;\n        }\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in sellstock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your sale. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "sellstock",
                    "description": null,
                    "trigger": "sellstock",
                    "helpText": "Sell shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to sell",
                            "position": 1
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === args.stock.toUpperCase());\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${args.stock} not found. Use /market to see available stocks.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate costs using Math.round to ensure we work with integers\n        const subtotal = Math.round(stock.price) * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const totalCost = subtotal + fee;\n\n        // Check if player has enough currency\n        const playerData = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, player.id);\n        const currentBalance = playerData.data.data.currency;\n\n        if (currentBalance < totalCost) {\n            throw new TakaroUserError(`You don't have enough currency. Cost: $${subtotal} + $${fee} fee = $${totalCost}. Your balance: $${currentBalance}`);\n        }\n\n        // Deduct the currency - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerDeductCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: totalCost\n            }\n        );\n\n        // Get player's portfolio or create new one\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        let portfolio;\n        if (portfolioVar.data.data.length === 0) {\n            portfolio = {};\n        } else {\n            portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        }\n\n        // Update portfolio using rounded values for consistency\n        const stockPrice = Math.round(stock.price);\n        if (!portfolio[stock.id]) {\n            portfolio[stock.id] = {\n                shares: amount,\n                averagePrice: stockPrice\n            };\n        } else {\n            const totalShares = portfolio[stock.id].shares + amount;\n            const totalValue = (portfolio[stock.id].shares * portfolio[stock.id].averagePrice) + (amount * stockPrice);\n            portfolio[stock.id].shares = totalShares;\n            portfolio[stock.id].averagePrice = Math.round(totalValue / totalShares);\n        }\n\n        // Save updated portfolio\n        if (portfolioVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_portfolio',\n                value: JSON.stringify(portfolio),\n                gameServerId,\n                moduleId: mod.moduleId,\n                playerId: player.id\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n                value: JSON.stringify(portfolio)\n            });\n        }\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'BUY',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: totalCost,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully bought ${amount} shares of ${stock.id} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Total cost: $${totalCost}\\n`;\n        message += `Current portfolio: ${portfolio[stock.id].shares} shares of ${stock.id}`;\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in buystock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your purchase. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "buystock",
                    "description": null,
                    "trigger": "buystock",
                    "helpText": "Buy shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol ",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to buy",
                            "position": 1
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Handle the industry argument - use \"ALL\" as a special value to show all industries\n    const industryFilter = args.Industry ? args.Industry.toUpperCase() : \"ALL\";\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    // If market data doesn't exist, try to initialize it\n    if (marketDataVar.data.data.length === 0) {\n        const initialized = await initializeMarketIfNeeded(gameServerId, mod);\n        if (!initialized) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        // Get the freshly initialized market data\n        const refreshedMarketData = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (refreshedMarketData.data.data.length === 0) {\n            throw new TakaroUserError(\"There was an issue initializing the stock market. Please try again later.\");\n        }\n\n        // Continue with the refreshed data\n        await displayMarketSummary(player, gameServerId, mod, refreshedMarketData.data.data[0], industryFilter);\n    } else {\n        // Market data exists, display it\n        await displayMarketSummary(player, gameServerId, mod, marketDataVar.data.data[0], industryFilter);\n    }\n}\n\n// Display the market summary to the player\nasync function displayMarketSummary(player, gameServerId, mod, marketDataVariable, industryFilter) {\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Handle empty string or empty object\n            if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (e) {\n            // In case of parsing error\n            activeEvent = null;\n        }\n    }\n\n    const stocks = JSON.parse(marketDataVariable.value);\n\n    // Get all available industries for reference\n    const availableIndustries = [...new Set(stocks.map(stock => stock.sector))];\n\n    // If industry filter is provided and not \"ALL\", check if it's valid\n    if (industryFilter !== \"ALL\") {\n        // Check if the industry exists\n        const industryExists = availableIndustries.includes(industryFilter);\n\n        if (!industryExists) {\n            throw new TakaroUserError(`Industry \"${industryFilter}\" not found. Available industries: ${availableIndustries.join(', ')}\\nUse \"ALL\" to view all industries.`);\n        }\n    }\n\n    // Send header message\n    let headerMessage = \"=== STOCK MARKET SUMMARY ===\\n\";\n\n    // If filtering by industry, mention it in the header\n    if (industryFilter !== \"ALL\") {\n        headerMessage = `=== ${industryFilter} INDUSTRY ===\\n`;\n    }\n\n    // If there's an active event, include it in the header\n    if (activeEvent) {\n        headerMessage += `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n`;\n        headerMessage += `${activeEvent.description}\\n\\n`;\n\n        // If filtering by industry, only show relevant impacts\n        if (industryFilter !== \"ALL\") {\n            const relevantImpact = activeEvent.sectorImpacts.find(\n                impact => impact.sectorId === industryFilter\n            );\n\n            if (relevantImpact) {\n                const direction = relevantImpact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `Industry Impact: ${direction} ${Math.abs(relevantImpact.impact)}%\\n`;\n            } else {\n                headerMessage += \"This industry is not directly affected by the current event.\\n\";\n            }\n        } else {\n            // Show all industry impacts\n            headerMessage += \"Industry Impacts:\\n\";\n            for (const impact of activeEvent.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%\\n`;\n            }\n        }\n    }\n\n    // Send header message first\n    await player.pm(headerMessage);\n\n    // Group stocks by industry\n    const stocksByIndustry = {};\n    stocks.forEach(stock => {\n        if (!stocksByIndustry[stock.sector]) {\n            stocksByIndustry[stock.sector] = [];\n        }\n        stocksByIndustry[stock.sector].push(stock);\n    });\n\n    // If industry filter is not \"ALL\", only show that industry\n    if (industryFilter !== \"ALL\") {\n        const filteredStocks = stocksByIndustry[industryFilter] || [];\n\n        if (filteredStocks.length > 0) {\n            let stockMessage = \"\";\n\n            filteredStocks.forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                stockMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(stockMessage);\n        } else {\n            await player.pm(`No stocks found in the ${industryFilter} industry.`);\n        }\n    } else {\n        // Send each industry as a separate message\n        for (const industryId in stocksByIndustry) {\n            let industryMessage = `=== ${industryId} INDUSTRY ===\\n`;\n\n            stocksByIndustry[industryId].forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                industryMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(industryMessage);\n        }\n    }\n\n    // Add a help message for industry filtering if showing all industries\n    if (industryFilter === \"ALL\") {\n        const allIndustries = Object.keys(stocksByIndustry).join(', ');\n        await player.pm(`\\nTip: Use '/markets [industry]' to view only stocks in a specific industry. Available industries: ${allIndustries}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return false;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            const results = await Promise.allSettled(createPromises);\n            // Check if the critical stock_market_data was created successfully\n            const stockDataPromise = results[0];\n            if (stockDataPromise && stockDataPromise.status === 'rejected') {\n                console.log(`Failed to create stock_market_data: ${stockDataPromise.reason}`);\n                return false;\n            }\n        }\n\n        return true;\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n        return false;\n    }\n}\n\nawait main();",
                    "name": "markets",
                    "description": null,
                    "trigger": "markets",
                    "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. \n",
                    "arguments": [
                        {
                            "name": "Industry",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. ",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRIGGER_EVENT')) {\n        throw new TakaroUserError(\"You don't have permission to trigger market events.\");\n    }\n\n    try {\n        // Get current stock data to check market initialization\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Initialize market if needed\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            await player.pm(\"Market was not initialized. Initializing now...\");\n            return;\n        }\n\n        // Get events from module config\n        const marketEvents = mod.userConfig.marketEvents || [];\n\n        if (marketEvents.length === 0) {\n            throw new TakaroUserError(\"No market events configured in this module.\");\n        }\n\n        // Handle case when no event is specified or \"ALL\" is provided\n        if (!args.EventName || args.EventName.toUpperCase() === \"ALL\") {\n            await player.pm(\"=== AVAILABLE MARKET EVENTS ===\\n\");\n\n            // Group events by category or type if possible\n            const eventCategories = {};\n\n            // Create a simple categorization based on positive/negative impact\n            marketEvents.forEach(event => {\n                let category = \"Mixed\";\n                // Calculate net impact across all sectors\n                const netImpact = event.sectorImpacts.reduce((sum, impact) => sum + impact.impact, 0);\n\n                if (netImpact > 0) category = \"Positive\";\n                else if (netImpact < 0) category = \"Negative\";\n\n                if (!eventCategories[category]) {\n                    eventCategories[category] = [];\n                }\n                eventCategories[category].push(event);\n            });\n\n            // Display events by category\n            for (const [category, events] of Object.entries(eventCategories)) {\n                if (events.length > 0) {\n                    await player.pm(`\\n--- ${category.toUpperCase()} EVENTS ---`);\n\n                    let message = \"\";\n                    events.forEach(event => {\n                        // Format primary sectors affected\n                        const primarySectors = event.sectorImpacts\n                            .filter(impact => Math.abs(impact.impact) >= 15)\n                            .map(impact => {\n                                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                                return `${impact.sectorId} ${direction}${Math.abs(impact.impact)}%`;\n                            })\n                            .join(\", \");\n\n                        message += `${event.id}: ${event.name}\\n`;\n                        message += `   ${event.description}\\n`;\n                        if (primarySectors) {\n                            message += `   Major impacts: ${primarySectors}\\n`;\n                        }\n                        message += \"\\n\";\n                    });\n\n                    await player.pm(message);\n                }\n            }\n\n            await player.pm(\"=== HOW TO USE ===\\nUse `/triggerevent <EventName>` to trigger a specific event (e.g., `/triggerevent TECH_BOOM`)\");\n            return;\n        }\n\n        // Find the requested event\n        const eventId = args.EventName.toUpperCase();\n        const event = marketEvents.find(e => e.id === eventId);\n\n        if (!event) {\n            throw new TakaroUserError(`Event \"${eventId}\" not found. Use /triggerevent without parameters to see all available events.`);\n        }\n\n        // Get necessary variables for managing the event\n        const [activeEventVar, eventStartTimeVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_execution_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_cooldown_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['current_event_duration'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Check if there's an active event we need to cancel\n        let activeEventObj = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEventObj = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEventObj && Object.keys(activeEventObj).length > 0) {\n                    await player.pm(`Cancelling active event \"${activeEventObj.name}\" to trigger new event.`);\n                }\n            } catch (e) {\n                // Invalid event data, will be overwritten\n            }\n        }\n\n        // Generate a random duration for the event\n        const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n        // Update or create all event-related variables\n        const updatePromises = [];\n\n        // Save or update the random duration\n        if (eventDurationVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                    value: randomDuration.toString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'current_event_duration',\n                    value: randomDuration.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the event counter to 0\n        if (eventCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the cooldown counter\n        if (cooldownCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update active event\n        if (activeEventVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                    value: JSON.stringify(event)\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: JSON.stringify(event),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update event start time\n        if (eventStartTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update last event time\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (lastEventTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all updates to complete\n        await Promise.all(updatePromises);\n\n        // Check if there are online players to announce the event\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            // Format sector impacts for announcement\n            let impactText = \"\";\n            for (const impact of event.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n            }\n\n            const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${event.name}\\n${event.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /markets to see opportunities!`;\n\n            // Split the message if it's too long\n            const maxLength = 400; // Safe limit for most games\n            for (let i = 0; i < message.length; i += maxLength) {\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message: message.substring(i, i + maxLength)\n                });\n            }\n        }\n\n        await player.pm(`Successfully triggered the \"${event.name}\" market event for ${randomDuration} cycles!`);\n    } catch (error) {\n        // If something goes wrong, log it and let the player know\n        console.log(`Error in triggerEvent: ${error.message}`);\n        throw new TakaroUserError(`Error triggering event: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Store the stocks data\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_data',\n            value: JSON.stringify(stocks),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize last event time to now\n        await takaro.variable.variableControllerCreate({\n            key: 'last_market_event_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize event start time variable\n        await takaro.variable.variableControllerCreate({\n            key: 'event_start_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize active event (empty string means no active event)\n        await takaro.variable.variableControllerCreate({\n            key: 'active_market_event',\n            value: '',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Mark market as initialized\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_initialized',\n            value: 'true',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Announce market initialization to online players\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /markets to see available stocks and /buystock to start investing.\";\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message\n            });\n        }\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "triggerevent",
                    "description": null,
                    "trigger": "triggerevent",
                    "helpText": "Shows all available market events when run without parameters. Use with an event name (e.g., /triggerevent TECH_BOOM) to trigger a specific market event.",
                    "arguments": [
                        {
                            "name": "EventName",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "Event name to trigger a specific market event",
                            "position": 0
                        }
                    ]
                }
            ],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n\n    // Get the Discord channel ID from module configuration\n    // IMPORTANT: You need to add 'marketNewsChannelId' to your module's configSchema and set its value.\n    const discordChannelId = mod.userConfig.marketNewsChannelId;\n\n    if (!discordChannelId) {\n        takaro.log.info('Market news Discord channel ID (marketNewsChannelId) not configured in module settings. Skipping Discord messages.');\n    }\n\n    // Check for online players\n    const currentPlayers = (await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    })).data.meta;\n\n    if (currentPlayers.total === 0) {\n        takaro.log.info('Skipping daily market report: No players online.');\n        return; // No players online, skip the market news\n    }\n\n    // Get current stock data (which should include lastPrice)\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        takaro.log.warn('Skipping daily market report: Market data variable not found.');\n        return; // Market not initialized yet\n    }\n\n    let stocks;\n    try {\n        stocks = JSON.parse(marketDataVar.data.data[0].value);\n        if (!Array.isArray(stocks)) {\n            throw new Error('Parsed market data is not an array.');\n        }\n    } catch (error) {\n        takaro.log.error(`Failed to parse stock_market_data: ${error}`);\n        return; // Invalid market data\n    }\n\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Ensure activeEvent is an object with data, not an empty string or empty object\n            if (typeof activeEvent !== 'object' || activeEvent === null || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (error) {\n            takaro.log.warn(`Failed to parse active_market_event: ${error}`);\n            activeEvent = null; // Continue without event info if parsing fails\n        }\n    }\n\n    // --- Message 1: Header and active event ---\n    let gameMessage1 = \"==== DAILY MARKET REPORT ====\\n\";\n    let discordMessage1 = \"**==== DAILY MARKET REPORT ====**\\n\"; // Discord version with Markdown\n\n    if (activeEvent && activeEvent.name && activeEvent.description) {\n        const eventText = `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n${activeEvent.description}\\n`;\n        gameMessage1 += eventText;\n        discordMessage1 += eventText;\n    } else {\n        const noEventText = '\\nNo active market events today.\\n';\n        gameMessage1 += noEventText;\n        discordMessage1 += noEventText;\n    }\n\n    // Send first part of the report to game server\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage1\n    }).catch(err => takaro.log.error(`Failed to send game message 1: ${err}`));\n\n    // Send first part of the report to Discord\n    if (discordChannelId) {\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessage1\n        }).catch(err => takaro.log.error(`Failed to send Discord message 1: ${err.message || err}`));\n    }\n\n    // --- Calculate stock performance using stock.price and stock.lastPrice ---\n    const stocksWithPerformance = stocks.map(stock => {\n        let change = 0;\n        let percentChange = 0;\n        let changeSymbol = 'â†’'; // Default: No change or insufficient data\n\n        if (typeof stock.price === 'number' && typeof stock.lastPrice === 'number' && stock.lastPrice !== 0) {\n            change = stock.price - stock.lastPrice;\n            percentChange = (change / stock.lastPrice) * 100;\n            if (percentChange > 0.05) {\n                changeSymbol = 'â†‘';\n            } else if (percentChange < -0.05) {\n                changeSymbol = 'â†“';\n            }\n        } else if (typeof stock.price === 'number' && stock.lastPrice === undefined) {\n            changeSymbol = 'ðŸ†•';\n            percentChange = 0;\n        }\n        return {\n            ...stock,\n            change,\n            percentChange,\n            changeSymbol\n        };\n    });\n\n    // --- Group by sector ---\n    const sectorPerformance = {};\n    stocksWithPerformance.forEach(stock => {\n        const sectorId = stock.sector || 'Uncategorized';\n        if (!sectorPerformance[sectorId]) {\n            sectorPerformance[sectorId] = {\n                stocks: [],\n                totalPercentChange: 0,\n                count: 0\n            };\n        }\n        sectorPerformance[sectorId].stocks.push(stock);\n        if (typeof stock.percentChange === 'number' && isFinite(stock.percentChange)) {\n            sectorPerformance[sectorId].totalPercentChange += stock.percentChange;\n            sectorPerformance[sectorId].count++;\n        }\n    });\n\n    // --- Calculate average sector performance ---\n    for (const sectorId in sectorPerformance) {\n        const sectorData = sectorPerformance[sectorId];\n        if (sectorData.count > 0) {\n            sectorData.avgPerformance = sectorData.totalPercentChange / sectorData.count;\n        } else {\n            sectorData.avgPerformance = 0;\n        }\n    }\n\n    const sortedSectors = Object.entries(sectorPerformance)\n        .sort(([, a], [, b]) => b.avgPerformance - a.avgPerformance);\n\n    // --- Message 2: Sector performance ---\n    let gameMessage2 = \"\\n=== SECTOR PERFORMANCE ===\\n\";\n    let discordMessage2 = \"\\n**=== SECTOR PERFORMANCE ===**\\n\"; // Discord version\n\n    if (sortedSectors.length > 0) {\n        sortedSectors.forEach(([sectorId, sectorData]) => {\n            const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n            const line = `${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n            gameMessage2 += line;\n            discordMessage2 += line;\n        });\n    } else {\n        const noDataText = \"No sector performance data available.\\n\";\n        gameMessage2 += noDataText;\n        discordMessage2 += noDataText;\n    }\n\n    // Send sector performance report to game server\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage2\n    }).catch(err => takaro.log.error(`Failed to send game message 2: ${err}`));\n\n    // Send sector performance report to Discord\n    if (discordChannelId) {\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessage2\n        }).catch(err => takaro.log.error(`Failed to send Discord message 2: ${err.message || err}`));\n    }\n\n    // --- Message 3: Top and Worst performers ---\n    const validPerformers = stocksWithPerformance.filter(s => typeof s.percentChange === 'number' && isFinite(s.percentChange));\n    validPerformers.sort((a, b) => b.percentChange - a.percentChange);\n\n    let gameMessage3 = \"\";\n    let discordMessage3 = \"\";\n\n    const topPerformersTitleGame = \"\\nðŸ”¥ TOP PERFORMERS ðŸ”¥\\n\";\n    const topPerformersTitleDiscord = \"\\n**ðŸ”¥ TOP PERFORMERS ðŸ”¥**\\n\";\n    gameMessage3 += topPerformersTitleGame;\n    discordMessage3 += topPerformersTitleDiscord;\n\n    if (validPerformers.length > 0) {\n        for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n            const stock = validPerformers[i];\n            const line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            gameMessage3 += line;\n            discordMessage3 += line;\n        }\n    } else {\n        const noTopText = \"No top performers today.\\n\";\n        gameMessage3 += noTopText;\n        discordMessage3 += noTopText;\n    }\n\n    const worstPerformersTitleGame = \"\\nðŸ“‰ WORST PERFORMERS ðŸ“‰\\n\";\n    const worstPerformersTitleDiscord = \"\\n**ðŸ“‰ WORST PERFORMERS ðŸ“‰**\\n\";\n    gameMessage3 += worstPerformersTitleGame;\n    discordMessage3 += worstPerformersTitleDiscord;\n\n    if (validPerformers.length > 0) {\n        const worstStartIndex = Math.max(0, validPerformers.length - 3);\n        for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n            const stock = validPerformers[i];\n            const line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            gameMessage3 += line;\n            discordMessage3 += line;\n        }\n    } else {\n        const noWorstText = \"No worst performers today.\\n\";\n        gameMessage3 += noWorstText;\n        discordMessage3 += noWorstText;\n    }\n\n    // Send top/worst performers report to game server\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage3\n    }).catch(err => takaro.log.error(`Failed to send game message 3: ${err}`));\n\n    // Send top/worst performers report to Discord\n    if (discordChannelId) {\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessage3\n        }).catch(err => takaro.log.error(`Failed to send Discord message 3: ${err.message || err}`));\n    }\n\n    takaro.log.info('Daily market report sent successfully (game server and potentially Discord).');\n}\n\nawait main();",
                    "name": "marketnews",
                    "description": null,
                    "temporalValue": "1 */1 * * *"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    try {\n        const { gameServerId, module: mod } = data;\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Check if market is initialized\n        if (marketDataVar.data.data.length === 0) {\n            console.log(\"Market data not found, initializing...\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return; // Exit after initialization\n        }\n\n        // Get active market event\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event start time\n        const eventStartTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_start_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event execution counter\n        const eventCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_execution_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event cooldown counter\n        const cooldownCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_cooldown_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let eventCounter = 0;\n        if (eventCounterVar.data.data.length > 0) {\n            eventCounter = parseInt(eventCounterVar.data.data[0].value, 10);\n            console.log(`Event counter: ${eventCounter}`);\n        }\n\n        let cooldownCounter = 0;\n        if (cooldownCounterVar.data.data.length > 0) {\n            cooldownCounter = parseInt(cooldownCounterVar.data.data[0].value, 10);\n            console.log(`Cooldown counter: ${cooldownCounter}`);\n        }\n\n        // Get event duration\n        const eventDurationVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['current_event_duration'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Use stored random duration if available, otherwise use defaultEventDuration\n        let eventDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        if (eventDurationVar.data.data.length > 0) {\n            eventDuration = parseInt(eventDurationVar.data.data[0].value, 10);\n            console.log(`Event duration: ${eventDuration}`);\n        }\n\n        let activeEvent = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                // If it's an empty string, treat as no active event\n                if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                    activeEvent = null;\n                }\n                console.log(`Active event: ${activeEvent ? activeEvent.name : 'None'}`);\n            } catch (e) {\n                // In case of parsing error, consider no active event\n                activeEvent = null;\n                console.log(`Error parsing active event: ${e.message}`);\n            }\n        }\n\n        // Check if the current event should end and increment counter\n        if (activeEvent) {\n            eventCounter++;\n            console.log(`Incremented event counter to: ${eventCounter}`);\n\n            if (eventCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: eventCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: eventCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n\n            if (eventCounter >= eventDuration) {\n                console.log(\"Event duration reached, ending event.\");\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: ''\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_cooldown_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    const message = `ðŸ“ˆ MARKET UPDATE ðŸ“‰\\n\\nThe \"${activeEvent.name}\" event has ended. Markets are returning to normal conditions.`;\n\n                    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                        message: message\n                    });\n                }\n\n                activeEvent = null;\n            }\n        } else {\n            cooldownCounter++;\n            console.log(`Incremented cooldown counter to: ${cooldownCounter}`);\n\n            if (cooldownCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: cooldownCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: cooldownCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n        }\n\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        const eventFrequency = (mod.userConfig && mod.userConfig.eventFrequency) || 10;\n        let shouldTriggerEvent = false;\n\n        if (!activeEvent && cooldownCounter >= eventFrequency) {\n            shouldTriggerEvent = Math.random() < 0.5;\n            if (cooldownCounter >= eventFrequency * 2) {\n                shouldTriggerEvent = true;\n            }\n            console.log(`Should trigger new event: ${shouldTriggerEvent}`);\n        }\n\n        if (shouldTriggerEvent) {\n            const events = (mod.userConfig && mod.userConfig.marketEvents) || [];\n            if (events.length > 0) {\n                const randomEvent = events[Math.floor(Math.random() * events.length)];\n                activeEvent = randomEvent;\n                console.log(`New event triggered: ${activeEvent.name}`);\n\n                const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n                const randomDuration = Math.floor(Math.random() * maxDuration) + 1;\n\n                if (eventDurationVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                        value: randomDuration.toString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'current_event_duration',\n                        value: randomDuration.toString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: JSON.stringify(activeEvent)\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'active_market_event',\n                        value: JSON.stringify(activeEvent),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventStartTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_start_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (lastEventTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'last_market_event_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    let impactText = \"\";\n                    for (const impact of activeEvent.sectorImpacts) {\n                        const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                        impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n                    }\n\n                    const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${activeEvent.name}\\n${activeEvent.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /market to see opportunities!`;\n\n                    const maxLength = 400;\n                    for (let i = 0; i < message.length; i += maxLength) {\n                        await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                            message: message.substring(i, i + maxLength)\n                        });\n                    }\n                }\n            }\n        }\n\n        // Get stocks\n        if (!marketDataVar.data.data[0] || !marketDataVar.data.data[0].value) {\n            console.log(\"Market data is empty or invalid after initial check, re-initializing.\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        let stocks;\n        try {\n            stocks = JSON.parse(marketDataVar.data.data[0].value);\n            if (!Array.isArray(stocks)) {\n                throw new Error(\"Parsed stocks data is not an array\");\n            }\n            // CRITICAL FIX: Ensure each stock has valid numerical price properties\n            stocks = stocks.map(s => {\n                const sanitizedPrice = typeof s.price === 'number' && s.price > 0 ? s.price : 1;\n                const sanitizedLastPrice = typeof s.lastPrice === 'number' && s.lastPrice > 0 ? s.lastPrice : sanitizedPrice;\n                return {\n                    ...s,\n                    price: sanitizedPrice,\n                    lastPrice: sanitizedLastPrice\n                };\n            });\n            console.log(\"Stocks loaded and sanitized successfully.\");\n            console.log(\"Initial stocks for this cycle:\");\n            stocks.forEach(s => console.log(`  ${s.id}: Price ${s.price}, LastPrice ${s.lastPrice}`));\n\n        } catch (e) {\n            console.log(`Error parsing or sanitizing stock data: ${e.message}`);\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        const significantChanges = [];\n\n        // Update each stock price\n        stocks.forEach(stock => {\n            // Always capture oldPrice at the very beginning of the iteration\n            const oldPrice = stock.price;\n            // Set lastPrice to the value before this current update cycle for accurate change tracking\n            stock.lastPrice = oldPrice;\n\n            console.log(`Processing stock: ${stock.id}, Old Price: ${oldPrice}`);\n\n            // Define the threshold for \"penny stock\" and the chance/magnitude of a breakout\n            const pennyStockThreshold = 1.9;\n            const breakoutChance = 0.6;\n\n            const targetMinPrice = 2.0;\n            const targetMaxPrice = 10.0;\n\n            let calculatedNewPrice;\n\n            // Check if it's a penny stock and qualifies for a breakout\n            if (oldPrice <= pennyStockThreshold && Math.random() < breakoutChance) {\n                console.log(`${stock.id} is a penny stock (${oldPrice}) and hit breakout chance!`);\n                calculatedNewPrice = targetMinPrice + Math.random() * (targetMaxPrice - targetMinPrice);\n                calculatedNewPrice = Math.max(calculatedNewPrice, oldPrice + 0.01); // Ensure at least a penny increase\n                console.log(`${stock.id} calculated breakout price: ${calculatedNewPrice}`);\n            } else {\n                const randomFactor = Math.random() * 2 - 1;\n                const totalChangePercent = randomFactor * stock.volatility;\n                calculatedNewPrice = oldPrice * (1 + totalChangePercent);\n                console.log(`${stock.id} calculated normal price: ${calculatedNewPrice} (Change: ${totalChangePercent * 100}%)`);\n            }\n\n            let finalPrice = calculatedNewPrice;\n            if (activeEvent) {\n                const sectorImpact = activeEvent.sectorImpacts.find(impact => impact.sectorId === stock.sector);\n                if (sectorImpact) {\n                    const eventImpactPercentage = sectorImpact.impact;\n                    const eventImpactDecimal = eventImpactPercentage / 100;\n                    const randomImpactFactor = 0.5 + Math.random();\n                    const eventImpact = eventImpactDecimal * randomImpactFactor;\n\n                    finalPrice = calculatedNewPrice * (1 + eventImpact);\n                    console.log(`${stock.id} final price after event impact: ${finalPrice} (Event impact: ${eventImpact * 100}%)`);\n                }\n            }\n\n            stock.price = finalPrice;\n\n            if (stock.price < 1) {\n                console.log(`${stock.id} price fell below 1, setting to 1.`);\n                stock.price = 1;\n            }\n\n            const actualPercentChange = ((stock.price - oldPrice) / oldPrice) * 100;\n            console.log(`${stock.id} - Final Price: ${stock.price.toFixed(2)}, Actual Change: ${actualPercentChange.toFixed(2)}%`);\n\n            const changeThreshold = ((mod.userConfig && mod.userConfig.priceAlertThreshold) || 10) / 100;\n            if (Math.abs(actualPercentChange) > changeThreshold * 100) {\n                significantChanges.push({\n                    ...stock,\n                    changePercent: actualPercentChange\n                });\n            }\n        });\n\n        console.log(\"All stocks processed, saving updated prices...\");\n        await takaro.variable.variableControllerUpdate(marketDataVar.data.data[0].id, {\n            value: JSON.stringify(stocks)\n        });\n        console.log(\"Updated prices saved.\");\n\n        if (significantChanges.length > 0) {\n            console.log(\"Significant changes detected, sending alert.\");\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                significantChanges.sort((a, b) => Math.abs(b.changePercent) - Math.abs(a.changePercent));\n                const topChanges = significantChanges.slice(0, Math.min(3, significantChanges.length));\n\n                let message = \"ðŸ“Š STOCK MARKET ALERT ðŸ“Š\\n\";\n                topChanges.forEach(stock => {\n                    const changeDir = stock.changePercent > 0 ? \"up\" : \"down\";\n                    const displayPrice = stock.price.toFixed(2);\n                    const changePercent = Math.abs(Math.round(stock.changePercent));\n\n                    message += `${stock.id} (${stock.sector}): ${changeDir} ${changePercent}% to $${displayPrice}!\\n`;\n                });\n\n                if (activeEvent) {\n                    message += `\\nCurrent market event: ${activeEvent.name}`;\n                }\n\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            } else {\n                console.log(\"No online players to send alert to.\");\n            }\n        } else {\n            console.log(\"No significant changes to alert players about.\");\n        }\n    } catch (error) {\n        console.log(`FATAL Error in updateStockPrices: ${error.message}`);\n        // Optionally, send an admin message if a fatal error occurs\n        // await takaro.gameserver.gameServerControllerSendMessage(data.gameServerId, {\n        //     message: `ðŸš¨ Market Error: An error occurred during stock update: ${error.message}`\n        // });\n    }\n}\n\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        console.log(\"Initializing market if needed...\");\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in module configuration for initialization.\");\n            return;\n        }\n\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_data'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['last_market_event_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_start_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['active_market_event'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_initialized'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_execution_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_cooldown_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['current_event_duration'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } })\n            ]);\n\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n        console.log(\"Mapped initial stocks from config.\");\n\n        const createPromises = [];\n\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_data', value: JSON.stringify(stocks), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'last_market_event_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_start_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'active_market_event', value: '', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_execution_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (cooldownCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_cooldown_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventDurationVar.data.data.length === 0) {\n            const defaultDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'current_event_duration', value: defaultDuration.toString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_initialized', value: 'true', gameServerId, moduleId: mod.moduleId }));\n        }\n\n        if (createPromises.length > 0) {\n            console.log(`Creating ${createPromises.length} initial market variables.`);\n            await Promise.allSettled(createPromises);\n        } else {\n            console.log(\"All market variables already exist, no new initialization needed.\");\n        }\n\n        if (marketDataVar.data.data.length === 0) { // Only announce if we actually created the stock_market_data variable\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /market to see available stocks and /buy to start investing.\";\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, { message });\n            }\n        }\n        console.log(\"Market initialization process complete.\");\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "updatestockprices",
                    "description": null,
                    "temporalValue": "0 */1 * * *"
                }
            ],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Allows the player to view market prices and their portfolio",
                    "permission": "STOCK_MARKET_USE",
                    "friendlyName": "Use Stock Market"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows the player to buy and sell stocks",
                    "permission": "STOCK_MARKET_TRADE",
                    "friendlyName": "Trade Stocks"
                },
                {
                    "canHaveCount": false,
                    "description": "VIP status that reduces transaction fees",
                    "permission": "STOCK_MARKET_BROKER",
                    "friendlyName": "Stock Broker"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows admins to manually trigger market events",
                    "permission": "STOCK_MARKET_TRIGGER_EVENT",
                    "friendlyName": "Trigger Market Events"
                }
            ]
        },
        {
            "tag": "latest",
            "description": "**Stock Market: A Dynamic Virtual Trading System**\n\nCreate an immersive economic experience with this comprehensive stock market module that lets players invest, trade, and react to market events.\n\n**Market Features:**\n\n![Market Summary](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stocks.png)\n\n* **Multiple Economic Sectors:** Configure various industry sectors (Resource Extraction, Manufacturing, Defense, etc.) each with their own market dynamics.\n* **Realistic Stock Behavior:** Stocks have configurable volatility, sector-based pricing, and react differently to market events.\n* **Dynamic Market Events:** Random or admin-triggered events like \"Horde Night Approaching\" or \"Societal Collapse Setback\" impact different sectors in realistic ways.\n\n![Market Events](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_events.png)\n\n**Trading System:**\n\n* **Buy & Sell Shares:** Players can purchase stocks and sell them later for profit or loss.\n* **Transaction Fees:** Configurable fee percentage on all trades creates a realistic market economy.\n* **VIP Benefits:** Special permissions for designated \"Stock Brokers\" who receive fee discounts.\n\n![Buy Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_buy.png)\n\nPlayers can track price changes and sell at the right moment to maximize profits or minimize losses.\n\n![Sell Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sell.png)\n\n**Player Portfolio:**\n\n* **Portfolio Tracking:** Players can view their holdings, average purchase prices, and current profit/loss.\n* **Transaction History:** System tracks all buy/sell transactions for each player.\n* **Summary Statistics:** See overall portfolio performance and value across all holdings.\n\n![Portfolio View](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockportfolio.png)\n\n**Market Information:**\n\n* **Detailed Stock Info:** Players can research specific stocks, including risk levels and sector trends.\n* **Industry Filters:** View stocks by specific sectors to better understand market segments.\n* **Market Alerts:** Server-wide notifications for significant price changes keep players engaged.\n\n![Market Alerts](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockpricechange.png)\n\n**Configuration Options:**\n\n* **Sectors & Stocks:** Define your own market sectors and individual stocks with customizable starting prices and volatility.\n* **Market Events:** Create unique events with specific sector impacts to drive market dynamics.\n* **Transaction Settings:** Configure fee percentages, VIP discounts, and alert thresholds.\n* **Event Frequency:** Control how often random market events occur and how long they last.\n\n![Configuration](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_config.png)\n![Sectors](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sectors.png)\n\n**Commands:**\n\n* `/markets [industry]` - View all stocks or filter by industry\n* `/stockinfo [ticker]` - Get detailed information about a specific stock\n* `/buystock <ticker> <amount>` - Purchase shares of a stock\n* `/sellstock <ticker> <amount>` - Sell shares from your portfolio\n* `/stockportfolio` - View your current holdings and performance\n* `/triggerevent [event]` - Admin command to trigger specific market events\n\nWho says the apocalypse can't have a thriving economy? Now players can stress about both zombie hordes AND their Duke's Casino Tokens dropping 40% after a market event! As one trader put it: \"I used to check my 401K daily, and now I check my AMMO stock before every Blood Moon. Some habits die harder than zombies.\"",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sectors\":{\"type\":\"array\",\"title\":\"Wasteland Economic Sectors\",\"description\":\"Define economic sectors relevant to survival in Navezgane.\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Sector ID (e.g., RESOURCES)\"},\"name\":{\"type\":\"string\",\"description\":\"Sector name (e.g., Resources)\"}}},\"default\":[{\"id\":\"RESOURCES\",\"name\":\"Resources\"},{\"id\":\"MANUFACTURING\",\"name\":\"Manufacturing\"},{\"id\":\"DEFENSE\",\"name\":\"Defense & Weaponry\"},{\"id\":\"FOOD\",\"name\":\"Food & Consumables\"},{\"id\":\"MEDICAL\",\"name\":\"Medical Supplies\"},{\"id\":\"RETAIL\",\"name\":\"General Retail\"},{\"id\":\"TRADE\",\"name\":\"Trade & Commerce\"},{\"id\":\"FINANCIAL\",\"name\":\"Financial\"}]},\"stocks\":{\"type\":\"array\",\"title\":\"Wasteland Stocks\",\"description\":\"List of stocks representing Navezgane entities and resources.\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Stock ticker symbol (e.g., NMC)\"},\"name\":{\"type\":\"string\",\"description\":\"Entity/Resource name\"},\"sector\":{\"type\":\"string\",\"description\":\"Sector ID this stock belongs to\"},\"initialPrice\":{\"type\":\"number\",\"description\":\"Starting price in Dukes\",\"minimum\":1}}},\"default\":[{\"id\":\"NMC\",\"name\":\"Navezgane Mining Co.\",\"sector\":\"RESOURCES\",\"initialPrice\":50},{\"id\":\"NIOM\",\"name\":\"Navezgane Iron Ore Mining Co.\",\"sector\":\"RESOURCES\",\"initialPrice\":55},{\"id\":\"NLMC\",\"name\":\"Navezgane Lead Mining Co.\",\"sector\":\"RESOURCES\",\"initialPrice\":45},{\"id\":\"WOOD\",\"name\":\"Wasteland Lumberjacks\",\"sector\":\"RESOURCES\",\"initialPrice\":20},{\"id\":\"SHALE\",\"name\":\"Oil Shale Extractors\",\"sector\":\"RESOURCES\",\"initialPrice\":40},{\"id\":\"FORGE\",\"name\":\"Forge Ahead Metals\",\"sector\":\"MANUFACTURING\",\"initialPrice\":75},{\"id\":\"TOOLS\",\"name\":\"Working Stiff Tools\",\"sector\":\"MANUFACTURING\",\"initialPrice\":60},{\"id\":\"AIA\",\"name\":\"A1 Auto\",\"sector\":\"MANUFACTURING\",\"initialPrice\":40},{\"id\":\"AMC\",\"name\":\"Atlas Metal Company\",\"sector\":\"MANUFACTURING\",\"initialPrice\":65},{\"id\":\"COC\",\"name\":\"COC Chemicals\",\"sector\":\"MANUFACTURING\",\"initialPrice\":55},{\"id\":\"MECH\",\"name\":\"JunkTech Robotics\",\"sector\":\"MANUFACTURING\",\"initialPrice\":110},{\"id\":\"BUILD\",\"name\":\"Barricade Builders\",\"sector\":\"MANUFACTURING\",\"initialPrice\":45},{\"id\":\"ZBI\",\"name\":\"Zombie Bashers Inc.\",\"sector\":\"DEFENSE\",\"initialPrice\":85},{\"id\":\"TTC\",\"name\":\"Turret Tracker Co.\",\"sector\":\"DEFENSE\",\"initialPrice\":125},{\"id\":\"AMMO\",\"name\":\"AmmoNation Surplus\",\"sector\":\"DEFENSE\",\"initialPrice\":90},{\"id\":\"SHM\",\"name\":\"Shotgun Messiah\",\"sector\":\"DEFENSE\",\"initialPrice\":120},{\"id\":\"SHAM\",\"name\":\"Shamway Foods\",\"sector\":\"FOOD\",\"initialPrice\":30},{\"id\":\"SSHM\",\"name\":\"Super Shamway\",\"sector\":\"FOOD\",\"initialPrice\":32},{\"id\":\"MEDS\",\"name\":\"Pop-N-Pills Medical\",\"sector\":\"MEDICAL\",\"initialPrice\":100},{\"id\":\"SAVG\",\"name\":\"Savage Country\",\"sector\":\"RETAIL\",\"initialPrice\":35},{\"id\":\"CRKB\",\"name\":\"Crack-A-Book\",\"sector\":\"RETAIL\",\"initialPrice\":80},{\"id\":\"TRADE\",\"name\":\"Trader Guild Network\",\"sector\":\"TRADE\",\"initialPrice\":150},{\"id\":\"PNG\",\"name\":\"Pass-N-Gas\",\"sector\":\"TRADE\",\"initialPrice\":50},{\"id\":\"BOB\",\"name\":\"Trader Bob's\",\"sector\":\"TRADE\",\"initialPrice\":160},{\"id\":\"HUGH\",\"name\":\"Trader Hugh's\",\"sector\":\"TRADE\",\"initialPrice\":170},{\"id\":\"JEN\",\"name\":\"Trader Jen's\",\"sector\":\"TRADE\",\"initialPrice\":180},{\"id\":\"JOEL\",\"name\":\"Trader Joel's\",\"sector\":\"TRADE\",\"initialPrice\":175},{\"id\":\"REKT\",\"name\":\"Trader Rekt's\",\"sector\":\"TRADE\",\"initialPrice\":165},{\"id\":\"DUKES\",\"name\":\"Duke's Casino Tokens\",\"sector\":\"FINANCIAL\",\"initialPrice\":1}]},\"transactionFee\":{\"title\":\"Transaction Fee (Dukes Tax)\",\"type\":\"number\",\"description\":\"Percentage fee charged on all buy/sell transactions (5 = 5%)\",\"default\":3,\"minimum\":0,\"maximum\":25},\"vipDiscount\":{\"title\":\"Trader's Favor Discount\",\"type\":\"number\",\"description\":\"Percentage discount on transaction fees for players with 'STOCK_MARKET_BROKER' permission (50 = 50%)\",\"default\":50,\"minimum\":0,\"maximum\":100},\"priceAlertThreshold\":{\"title\":\"Price Alert Threshold\",\"type\":\"number\",\"description\":\"Percentage change that triggers a market alert (15 = 15%)\",\"default\":15,\"minimum\":5,\"maximum\":50},\"marketNewsChannelId\":{\"title\":\"Discord Channel ID (for Market News)\",\"type\":\"string\",\"description\":\"The ID of the Discord channel where market news messages should be posted. Leave empty to disable.\",\"default\":\"\"}},\"additionalProperties\":false}",
            "uiSchema": "{\"sectors\":{\"items\":{\"ui:order\":[\"id\",\"name\"]}},\"stocks\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"sector\",\"initialPrice\"]}},\"transactionFee\":{\"ui:widget\":\"range\"},\"vipDiscount\":{\"ui:widget\":\"range\"},\"priceAlertThreshold\":{\"ui:widget\":\"range\"}}",
            "commands": [
                {
                    "function": "import { takaro, data, TakaroUserError } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    if (!args.stock || !args.amount) {\n        throw new TakaroUserError(\"Usage: /buystock <TICKER> <AMOUNT>\");\n    }\n\n    const amount = parseInt(args.amount, 10);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number.\");\n    }\n\n    // Correctly fetches the global market data variable by removing the gameServerId filter.\n    const marketDataVar = await takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_data'], moduleId: [mod.moduleId] } });\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n    const stock = stocks.find(s => s.id.toUpperCase() === args.stock.toUpperCase());\n\n    if (!stock) {\n        throw new TakaroUserError(`Stock ${args.stock} not found.`);\n    }\n\n    if (stock.delisted) {\n        throw new TakaroUserError(`Stock ${stock.id} is currently delisted and cannot be purchased.`);\n    }\n\n    let feePercentage = mod.userConfig.transactionFee || 3;\n\n    const price = parseFloat(stock.price);\n    const subtotal = price * amount;\n    const fee = subtotal * (feePercentage / 100);\n    const totalCost = subtotal + fee;\n    const roundedTotalCost = Math.round(totalCost);\n\n    const playerData = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, player.id);\n    if (playerData.data.data.currency < roundedTotalCost) {\n        throw new TakaroUserError(`You don't have enough currency. Cost: $${totalCost.toFixed(2)} (rounded to $${roundedTotalCost}). Your balance: $${playerData.data.data.currency}`);\n    }\n\n    await takaro.playerOnGameserver.playerOnGameServerControllerDeductCurrency(gameServerId, player.id, { currency: roundedTotalCost });\n\n    const portfolioVar = await takaro.variable.variableControllerSearch({ filters: { key: ['stock_portfolio'], gameServerId: [gameServerId], moduleId: [mod.moduleId], playerId: [player.id] } });\n\n    let portfolio = portfolioVar.data.data.length > 0 ? JSON.parse(portfolioVar.data.data[0].value) : {};\n\n    if (!portfolio[stock.id]) {\n        portfolio[stock.id] = { shares: 0, totalCost: 0 };\n    }\n    portfolio[stock.id].shares += amount;\n    portfolio[stock.id].totalCost += subtotal;\n\n    if (portfolioVar.data.data.length === 0) {\n        await takaro.variable.variableControllerCreate({ key: 'stock_portfolio', value: JSON.stringify(portfolio), gameServerId, moduleId: mod.moduleId, playerId: player.id });\n    } else {\n        await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, { value: JSON.stringify(portfolio) });\n    }\n\n    await player.pm(`Bought ${amount} shares of ${stock.id} for $${totalCost.toFixed(2)} (includes $${fee.toFixed(2)} fee). Total cost rounded to $${roundedTotalCost}.`);\n}\n\nawait main();",
                    "name": "buystock",
                    "description": null,
                    "trigger": "buystock",
                    "helpText": "Buy shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol ",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to buy",
                            "position": 1
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    if (!args.stock || !args.amount) {\n        throw new TakaroUserError(\"Usage: /sellstock <TICKER> <AMOUNT>\");\n    }\n\n    const amount = parseInt(args.amount, 10);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number.\");\n    }\n\n    const portfolioVar = await takaro.variable.variableControllerSearch({ filters: { key: ['stock_portfolio'], gameServerId: [gameServerId], moduleId: [mod.moduleId], playerId: [player.id] } });\n    if (portfolioVar.data.data.length === 0) {\n        throw new TakaroUserError(\"You don't own any stocks.\");\n    }\n\n    let portfolio = JSON.parse(portfolioVar.data.data[0].value);\n    const stockId = args.stock.toUpperCase();\n\n    if (!portfolio[stockId] || portfolio[stockId].shares < amount) {\n        throw new TakaroUserError(`You don't own ${amount} shares of ${stockId}. You have ${portfolio[stockId] ? portfolio[stockId].shares : 0}.`);\n    }\n\n    // Correctly fetches the global market data variable by removing the gameServerId filter.\n    const marketDataVar = await takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_data'], moduleId: [mod.moduleId] } });\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n    const stock = stocks.find(s => s.id.toUpperCase() === stockId);\n    if (!stock) {\n        throw new TakaroUserError(`Stock ${stockId} no longer exists.`);\n    }\n\n    let feePercentage = mod.userConfig.transactionFee || 3;\n\n    const price = parseFloat(stock.price);\n    const subtotal = price * amount;\n    const fee = subtotal * (feePercentage / 100);\n    const netProceeds = subtotal - fee;\n    const roundedPayout = Math.round(netProceeds);\n\n    const costBasisPerShare = portfolio[stockId].totalCost / portfolio[stockId].shares;\n    const costOfSharesSold = costBasisPerShare * amount;\n    const profit = netProceeds - costOfSharesSold;\n\n    await takaro.playerOnGameserver.playerOnGameServerControllerAddCurrency(gameServerId, player.id, { currency: roundedPayout });\n\n    portfolio[stockId].shares -= amount;\n    portfolio[stockId].totalCost -= costOfSharesSold;\n    if (portfolio[stockId].shares <= 0) {\n        delete portfolio[stockId];\n    }\n\n    await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, { value: JSON.stringify(portfolio) });\n\n    const profitLossText = profit >= 0 ? `profit of $${profit.toFixed(2)}` : `loss of $${Math.abs(profit).toFixed(2)}`;\n    await player.pm(`Sold ${amount} shares of ${stockId}. Net proceeds: $${netProceeds.toFixed(2)} (rounded to $${roundedPayout} for payout), for a ${profitLossText}.`);\n}\n\nawait main();",
                    "name": "sellstock",
                    "description": null,
                    "trigger": "sellstock",
                    "helpText": "Sell shares of a stock",
                    "arguments": [
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to sell",
                            "position": 1
                        },
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError } from '@takaro/helpers';\n\n// Helper function to format numbers with commas for readability\nfunction formatCurrency(num) {\n    return num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });\n}\n\nasync function main() {\n    const { player, module: mod, arguments: args } = data;\n\n    const ticker = args.ticker ? args.ticker.toUpperCase() : \"ALL\";\n\n    // Correctly fetches the global market data variable by removing the gameServerId filter.\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n    const sectorConfig = mod.userConfig.sectors || [];\n    const sectorMap = new Map(sectorConfig.map(s => [s.id, s.name]));\n\n    const sectorColorMap = {\n        \"RESOURCES\": \"[FFA500]\",\n        \"MANUFACTURING\": \"[B0C4DE]\",\n        \"DEFENSE\": \"[FF6347]\",\n        \"FOOD\": \"[32CD32]\",\n        \"MEDICAL\": \"[00FFFF]\",\n        \"RETAIL\": \"[6495ED]\",\n        \"TRADE\": \"[FFD700]\",\n        \"FINANCIAL\": \"[FFFFE0]\",\n    };\n\n    const headerColor = '[00FFFF]';\n    const textColor = '[ADD8E6]';\n    const neutralColor = '[ADD8E6]';\n    const delistedColor = '[FFD700]';\n\n    if (ticker === \"ALL\") {\n        await player.pm(`=== ${headerColor}Stock Market Info[-] ===`);\n\n        const sectorOrder = sectorConfig.map(s => s.id);\n        const stocksBySector = {};\n        stocks.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        for (const sectorId of sectorOrder) {\n            if (!stocksBySector[sectorId]) continue;\n\n            const sectorName = sectorMap.get(sectorId) || sectorId;\n            const sectorColor = sectorColorMap[sectorId] || headerColor;\n\n            await player.pm(' ');\n            await player.pm(`--- ${sectorColor}${sectorName}[-] ---`);\n\n            for (const stock of stocksBySector[sectorId]) {\n                const price = parseFloat(stock.price);\n                const lastPrice = parseFloat(stock.lastPrice);\n                let changeString = `${neutralColor}â†’[-]`;\n                let priceString = `${neutralColor}$${formatCurrency(price)}[-]`;\n\n                if (lastPrice && price !== lastPrice) {\n                    const percentChange = ((price - lastPrice) / lastPrice) * 100;\n                    if (percentChange > 0.01) {\n                        priceString = `[00FF00]$${formatCurrency(price)}[-]`;\n                        changeString = `[00FF00]â†‘ ${percentChange.toFixed(2)}%[-]`;\n                    } else if (percentChange < -0.01) {\n                        priceString = `[FF0000]$${formatCurrency(price)}[-]`;\n                        changeString = `[FF0000]â†“ ${Math.abs(percentChange).toFixed(2)}%[-]`;\n                    }\n                }\n                const delistedTag = stock.delisted ? ` ${delistedColor}(DELISTED)[-]` : '';\n                const stockMessage = `${sectorColor}${stock.id}[-]: ${priceString}${delistedTag} ${textColor}(${changeString}${textColor})[-]`;\n                await player.pm(stockMessage);\n            }\n        }\n        return;\n    }\n\n    const stock = stocks.find(s => s.id.toUpperCase() === ticker);\n\n    if (!stock) {\n        throw new TakaroUserError(`Stock ${ticker} not found.`);\n    }\n\n    const friendlySectorName = sectorMap.get(stock.sector) || stock.sector;\n    const sectorColor = sectorColorMap[stock.sector] || headerColor;\n    const price = parseFloat(stock.price);\n    const lastPrice = parseFloat(stock.lastPrice);\n    let changeText = `${neutralColor}â†’[-]`;\n    let priceString = `${neutralColor}$${formatCurrency(price)}[-]`;\n\n    if (lastPrice) {\n        const percentChange = ((price - lastPrice) / lastPrice) * 100;\n        if (percentChange > 0.01) {\n            priceString = `[00FF00]$${formatCurrency(price)}[-]`;\n            changeText = ` [00FF00]â†‘ ${percentChange.toFixed(2)}%[-]`;\n        } else if (percentChange < -0.01) {\n            priceString = `[FF0000]$${formatCurrency(price)}[-]`;\n            changeText = ` [FF0000]â†“ ${Math.abs(percentChange).toFixed(2)}%[-]`;\n        }\n    }\n\n    await player.pm(`=== ${sectorColor}${stock.id}[-]: ${textColor}${stock.name}[-] ===`);\n    await player.pm(`${textColor}Sector: ${sectorColor}${friendlySectorName}[-]`);\n    await player.pm(`${textColor}Current Price: ${priceString}${changeText}`);\n    if (stock.delisted) {\n        await player.pm(`${textColor}Status: ${delistedColor}DELISTED (Cannot be purchased)[-]`);\n    }\n}\n\nawait main();",
                    "name": "stockinfo",
                    "description": null,
                    "trigger": "stockinfo",
                    "helpText": "Shows all available stocks in the market. Use with a ticker symbol (e.g., /stockinfo ticker) to see detailed information about a specific stock.",
                    "arguments": [
                        {
                            "name": "ticker",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "stock ticker or ALL to get detailed information about a specific stock",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError } from '@takaro/helpers';\n\n// Helper function to format numbers with commas for readability\nfunction formatCurrency(num) {\n    return num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });\n}\n\nasync function main() {\n    const { player, gameServerId, module: mod } = data;\n\n    const portfolioVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_portfolio'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId],\n            playerId: [player.id]\n        }\n    });\n\n    if (portfolioVar.data.data.length === 0 || Object.keys(JSON.parse(portfolioVar.data.data[0].value)).length === 0) {\n        throw new TakaroUserError(\"You don't own any stocks. Use /markets to see options.\");\n    }\n\n    const portfolio = JSON.parse(portfolioVar.data.data[0].value);\n\n    // Correctly fetches the global market data variable by removing the gameServerId filter.\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now.\");\n    }\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    const sectorColorMap = {\n        \"RESOURCES\": \"[FFA500]\",\n        \"MANUFACTURING\": \"[B0C4DE]\",\n        \"DEFENSE\": \"[FF6347]\",\n        \"FOOD\": \"[32CD32]\",\n        \"MEDICAL\": \"[00FFFF]\",\n        \"RETAIL\": \"[6495ED]\",\n        \"TRADE\": \"[FFD700]\",\n        \"FINANCIAL\": \"[FFFFE0]\",\n    };\n\n    const headerColor = '[00FFFF]';\n    const textColor = '[ADD8E6]';\n    const valueColor = '[FFFF00]';\n    const delistedColor = '[FFD700]';\n\n    await player.pm(`=== ${headerColor}YOUR STOCK PORTFOLIO[-] ===`);\n\n    let totalValue = 0;\n    let totalInvestment = 0;\n\n    for (const stockId in portfolio) {\n        const stockData = portfolio[stockId];\n        const marketInfo = stocks.find(s => s.id === stockId);\n        if (!marketInfo) continue;\n\n        const sectorColor = sectorColorMap[marketInfo.sector] || headerColor;\n        const currentValue = parseFloat(marketInfo.price) * stockData.shares;\n        const investmentValue = parseFloat(stockData.totalCost);\n        const profit = currentValue - investmentValue;\n        const profitPercent = investmentValue > 0 ? (profit / investmentValue) * 100 : 0;\n\n        let profitColor = textColor;\n        let sign = '';\n        if (profit > 0.01) {\n            profitColor = '[00FF00]';\n            sign = '+';\n        } else if (profit < -0.01) {\n            profitColor = '[FF0000]';\n        }\n\n        const delistedTag = marketInfo.delisted ? ` ${delistedColor}(DELISTED)[-]` : '';\n\n        let stockMessage =\n            `${sectorColor}${stockId}[-]${textColor}: ${stockData.shares} shares [-]` +\n            `${textColor} | Val: ${valueColor}$${formatCurrency(currentValue)}[-] ` +\n            `${textColor}| P/L: ${profitColor}${sign}$${formatCurrency(profit)} (${sign}${profitPercent.toFixed(1)}%)[-]` +\n            `${delistedTag}`;\n\n        await player.pm(stockMessage);\n\n        totalValue += currentValue;\n        totalInvestment += investmentValue;\n    }\n\n    const totalProfit = totalValue - totalInvestment;\n    const totalProfitPercent = totalInvestment > 0 ? (totalProfit / totalInvestment) * 100 : 0;\n\n    let totalProfitColor = textColor;\n    let totalSign = '';\n    if (totalProfit > 0.01) {\n        totalProfitColor = '[00FF00]';\n        totalSign = '+';\n    } else if (totalProfit < -0.01) {\n        totalProfitColor = '[FF0000]';\n    }\n\n    await player.pm(`\\\\n=== ${headerColor}SUMMARY[-] ===`);\n    await player.pm(`${textColor}Total Value: ${valueColor}$${formatCurrency(totalValue)}[-]`);\n    await player.pm(`${textColor}Overall P/L: ${totalProfitColor}${totalSign}$${formatCurrency(totalProfit)} (${totalSign}${totalProfitPercent.toFixed(1)}%)[-]`);\n}\n\nawait main();",
                    "name": "portfolio",
                    "description": "portfolio",
                    "trigger": "portfolio",
                    "helpText": "Portfolio",
                    "arguments": []
                }
            ],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    try {\n        const { module: mod } = data;\n\n        // --- 1. GET OR INITIALIZE MARKET DATA (GLOBAL) ---\n        // The gameServerId has been removed to make the variable global.\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: { key: ['stock_market_data'], moduleId: [mod.moduleId] }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            console.log(\"Stock Market: Initializing global market data...\");\n            // Pass only the module context, as gameServerId is no longer needed for initialization.\n            await initializeMarket(mod);\n            return;\n        }\n\n        let stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const configStocks = mod.userConfig.stocks || [];\n\n        // --- SYNC WITH CONFIG ---\n        const configStockMap = new Map(configStocks.map(s => [s.id, s]));\n        stocks.forEach(stock => {\n            const configData = configStockMap.get(stock.id);\n            if (configData) {\n                stock.name = configData.name;\n                stock.sector = configData.sector;\n            }\n        });\n        configStocks.forEach(configStock => {\n            if (!stocks.some(s => s.id === configStock.id)) {\n                stocks.push({\n                    id: configStock.id,\n                    name: configStock.name,\n                    sector: configStock.sector,\n                    price: parseFloat(configStock.initialPrice) || 1.0,\n                    lastPrice: parseFloat(configStock.initialPrice) || 1.0,\n                    delisted: (parseFloat(configStock.initialPrice) || 1.0) < 1.0\n                });\n            }\n        });\n        stocks = stocks.filter(stock => configStockMap.has(stock.id));\n\n        const delistAnnouncements = [];\n\n        // --- 2. CALCULATE NEW PRICES ---\n        stocks.forEach(stock => stock.lastPrice = stock.price);\n\n        const listedStocks = stocks.filter(s => !s.delisted);\n        const specialTreatmentIds = new Set();\n\n        if (listedStocks.length >= 2) {\n            let increaseIndex = Math.floor(Math.random() * listedStocks.length);\n            listedStocks[increaseIndex].price *= 1.05;\n            specialTreatmentIds.add(listedStocks[increaseIndex].id);\n\n            let decreaseIndex;\n            do {\n                decreaseIndex = Math.floor(Math.random() * listedStocks.length);\n            } while (decreaseIndex === increaseIndex);\n            listedStocks[decreaseIndex].price *= 0.95;\n            specialTreatmentIds.add(listedStocks[decreaseIndex].id);\n        }\n\n        stocks.forEach(stock => {\n            if (!specialTreatmentIds.has(stock.id)) {\n                const pennyChange = (Math.random() * 0.02 - 0.01);\n                stock.price += pennyChange;\n            }\n            if (stock.price < 0.01) stock.price = 0.01;\n            const wasDelisted = stock.delisted;\n            if (stock.price < 1.00 && !wasDelisted) {\n                stock.delisted = true;\n                delistAnnouncements.push(`- **${stock.name} - ${stock.id}** has been delisted!`);\n            } else if (stock.price >= 1.00 && wasDelisted) {\n                stock.delisted = false;\n                delistAnnouncements.push(`- **${stock.name} - ${stock.id}** has been relisted!`);\n            }\n        });\n\n        // --- 3. SAVE UPDATED DATA ---\n        await takaro.variable.variableControllerUpdate(marketDataVar.data.data[0].id, { value: JSON.stringify(stocks) });\n\n        // --- 4. BUILD AND SEND DISCORD REPORT ---\n        const discordChannelId = mod.userConfig.marketNewsChannelId;\n        if (discordChannelId) {\n            const now = new Date();\n            const dateString = now.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });\n            const sectorConfig = mod.userConfig.sectors || [];\n            const sectorMap = new Map(sectorConfig.map(s => [s.id, s.name]));\n            const emojiMap = { \"RESOURCES\": \"â›ï¸\", \"MANUFACTURING\": \"ðŸ­\", \"DEFENSE\": \"ðŸ›¡ï¸\", \"FOOD\": \"ðŸŒ½\", \"MEDICAL\": \"âš•ï¸\", \"RETAIL\": \"ðŸ›’\", \"TRADE\": \"ðŸ¤\", \"FINANCIAL\": \"ðŸ’°\" };\n\n            let discordReport = `## â”€â•Ú¿Ú°Û£Ú¿â•â”€ **Stock Market Update - ${dateString}** â”€â•Ú¿Ú°Û£Ú¿â•â”€\\n\\n`;\n\n            if (delistAnnouncements.length > 0) {\n                discordReport += `### Market Alerts\\n${delistAnnouncements.join('\\n')}\\n\\n`;\n            }\n\n            const stocksBySector = {};\n            stocks.forEach(stock => {\n                const sectorId = stock.sector;\n                if (!stocksBySector[sectorId]) stocksBySector[sectorId] = [];\n                stocksBySector[sectorId].push(stock);\n            });\n\n            const sectorOrder = sectorConfig.map(s => s.id);\n            for (const sectorId of sectorOrder) {\n                if (!stocksBySector[sectorId]) continue;\n\n                const sectorName = sectorMap.get(sectorId) || sectorId;\n                const sectorEmoji = emojiMap[sectorId] || 'ðŸ“Š';\n                discordReport += `### ${sectorEmoji} ${sectorName}\\n`;\n\n                stocksBySector[sectorId].forEach(stock => {\n                    const price = parseFloat(stock.price);\n                    const lastPrice = parseFloat(stock.lastPrice);\n                    let changeText = 'â†’';\n                    if (lastPrice && price !== lastPrice) {\n                        const percentChange = ((price - lastPrice) / lastPrice) * 100;\n                        changeText = percentChange > 0 ? `â†‘ ${percentChange.toFixed(2)}%` : `â†“ ${Math.abs(percentChange).toFixed(2)}%`;\n                    }\n                    const delistedTag = stock.delisted ? ' `(DELISTED)`' : '';\n                    discordReport += `- **${stock.name} - ${stock.id}:** \\`$${price.toFixed(2)}\\` \\`(${changeText})\\`${delistedTag}\\n`;\n                });\n                discordReport += '\\n';\n            }\n\n            const messages = discordReport.match(/(.|[\\r\\n]){1,1990}([\\r\\n]|$)/g) || [];\n            for (const message of messages) {\n                await takaro.discord.discordControllerSendMessage(discordChannelId, { message: message });\n            }\n        }\n    } catch (error) {\n        console.error(`Cron job updatestockprices failed: ${error.stack}`);\n    }\n}\n\nasync function initializeMarket(mod) {\n    const configStocks = mod.userConfig.stocks || [];\n    if (configStocks.length === 0) {\n        console.log(\"Stock Market: No stocks defined in configuration to initialize.\");\n        return;\n    }\n    const stocks = configStocks.map(stock => ({\n        id: stock.id,\n        name: stock.name,\n        sector: stock.sector,\n        price: parseFloat(stock.initialPrice) || 1.0,\n        lastPrice: parseFloat(stock.initialPrice) || 1.0,\n        delisted: (parseFloat(stock.initialPrice) || 1.0) < 1.0\n    }));\n\n    // Create the variable without a gameServerId to make it global.\n    await takaro.variable.variableControllerCreate({\n        key: 'stock_market_data',\n        value: JSON.stringify(stocks),\n        moduleId: mod.moduleId\n    });\n}\n\nawait main();",
                    "name": "updatestockprices",
                    "description": "When he cronjob runs",
                    "temporalValue": "0 */1 * * *"
                }
            ],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Allows the player to view market prices and their portfolio",
                    "permission": "STOCK_MARKET_USE",
                    "friendlyName": "Use Stock Market"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows the player to buy and sell stocks",
                    "permission": "STOCK_MARKET_TRADE",
                    "friendlyName": "Trade Stocks"
                },
                {
                    "canHaveCount": false,
                    "description": "VIP status that reduces transaction fees",
                    "permission": "STOCK_MARKET_BROKER",
                    "friendlyName": "Stock Broker"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows admins to manually trigger market events",
                    "permission": "STOCK_MARKET_TRIGGER_EVENT",
                    "friendlyName": "Trigger Market Events"
                }
            ]
        },
        {
            "tag": "0.1.8",
            "description": "**Stock Market: A Dynamic Virtual Trading System**\n\nCreate an immersive economic experience with this comprehensive stock market module that lets players invest, trade, and react to market events.\n\n**Market Features:**\n\n![Market Summary](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stocks.png)\n\n* **Multiple Economic Sectors:** Configure various industry sectors (Resource Extraction, Manufacturing, Defense, etc.) each with their own market dynamics.\n* **Realistic Stock Behavior:** Stocks have configurable volatility, sector-based pricing, and react differently to market events.\n* **Dynamic Market Events:** Random or admin-triggered events like \"Horde Night Approaching\" or \"Societal Collapse Setback\" impact different sectors in realistic ways.\n\n![Market Events](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_events.png)\n\n**Trading System:**\n\n* **Buy & Sell Shares:** Players can purchase stocks and sell them later for profit or loss.\n* **Transaction Fees:** Configurable fee percentage on all trades creates a realistic market economy.\n* **VIP Benefits:** Special permissions for designated \"Stock Brokers\" who receive fee discounts.\n\n![Buy Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_buy.png)\n\nPlayers can track price changes and sell at the right moment to maximize profits or minimize losses.\n\n![Sell Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sell.png)\n\n**Player Portfolio:**\n\n* **Portfolio Tracking:** Players can view their holdings, average purchase prices, and current profit/loss.\n* **Transaction History:** System tracks all buy/sell transactions for each player.\n* **Summary Statistics:** See overall portfolio performance and value across all holdings.\n\n![Portfolio View](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockportfolio.png)\n\n**Market Information:**\n\n* **Detailed Stock Info:** Players can research specific stocks, including risk levels and sector trends.\n* **Industry Filters:** View stocks by specific sectors to better understand market segments.\n* **Market Alerts:** Server-wide notifications for significant price changes keep players engaged.\n\n![Market Alerts](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockpricechange.png)\n\n**Configuration Options:**\n\n* **Sectors & Stocks:** Define your own market sectors and individual stocks with customizable starting prices and volatility.\n* **Market Events:** Create unique events with specific sector impacts to drive market dynamics.\n* **Transaction Settings:** Configure fee percentages, VIP discounts, and alert thresholds.\n* **Event Frequency:** Control how often random market events occur and how long they last.\n\n![Configuration](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_config.png)\n![Sectors](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sectors.png)\n\n**Commands:**\n\n* `/markets [industry]` - View all stocks or filter by industry\n* `/stockinfo [ticker]` - Get detailed information about a specific stock\n* `/buystock <ticker> <amount>` - Purchase shares of a stock\n* `/sellstock <ticker> <amount>` - Sell shares from your portfolio\n* `/stockportfolio` - View your current holdings and performance\n* `/triggerevent [event]` - Admin command to trigger specific market events\n\nWho says the apocalypse can't have a thriving economy? Now players can stress about both zombie hordes AND their Duke's Casino Tokens dropping 40% after a market event! As one trader put it: \"I used to check my 401K daily, and now I check my AMMO stock before every Blood Moon. Some habits die harder than zombies.\"",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sectors\":{\"type\":\"array\",\"title\":\"Wasteland Economic Sectors\",\"description\":\"Define economic sectors relevant to survival in Navezgane\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Sector ID (e.g., RESOURCES)\"},\"name\":{\"type\":\"string\",\"description\":\"Sector name (e.g., Resource Extraction)\"}}},\"default\":[{\"id\":\"RESOURCES\",\"name\":\"Resource Extraction\"},{\"id\":\"MANUFACTURING\",\"name\":\"Manufacturing & Crafting\"},{\"id\":\"DEFENSE\",\"name\":\"Defense & Fortifications\"},{\"id\":\"SURVIVAL\",\"name\":\"Survival Goods\"},{\"id\":\"TRADE\",\"name\":\"Trade & Currency\"}]},\"stocks\":{\"type\":\"array\",\"title\":\"Wasteland Stocks\",\"description\":\"List of stocks representing Navezgane entities and resources\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Stock ticker symbol (e.g., NMC)\"},\"name\":{\"type\":\"string\",\"description\":\"Entity/Resource name\"},\"sector\":{\"type\":\"string\",\"description\":\"Sector ID this stock belongs to\"},\"initialPrice\":{\"type\":\"number\",\"description\":\"Starting price in Dukes\",\"minimum\":1},\"volatility\":{\"type\":\"number\",\"description\":\"Base volatility percentage (5 = 5%)\",\"minimum\":1,\"maximum\":35}}},\"default\":[{\"id\":\"NMC\",\"name\":\"Navezgane Mining Co.\",\"sector\":\"RESOURCES\",\"initialPrice\":50,\"volatility\":15},{\"id\":\"WOOD\",\"name\":\"Wasteland Lumberjacks\",\"sector\":\"RESOURCES\",\"initialPrice\":20,\"volatility\":8},{\"id\":\"SHALE\",\"name\":\"Oil Shale Extractors\",\"sector\":\"RESOURCES\",\"initialPrice\":40,\"volatility\":18},{\"id\":\"FORGE\",\"name\":\"Forge Ahead Metals\",\"sector\":\"MANUFACTURING\",\"initialPrice\":75,\"volatility\":12},{\"id\":\"TOOLS\",\"name\":\"Working Stiff Tools\",\"sector\":\"MANUFACTURING\",\"initialPrice\":60,\"volatility\":10},{\"id\":\"MECH\",\"name\":\"JunkTech Robotics\",\"sector\":\"MANUFACTURING\",\"initialPrice\":110,\"volatility\":20},{\"id\":\"BUILD\",\"name\":\"Barricade Builders\",\"sector\":\"DEFENSE\",\"initialPrice\":45,\"volatility\":9},{\"id\":\"AMMO\",\"name\":\"AmmoNation Surplus\",\"sector\":\"DEFENSE\",\"initialPrice\":90,\"volatility\":18},{\"id\":\"SHAM\",\"name\":\"Shamway Foods\",\"sector\":\"SURVIVAL\",\"initialPrice\":30,\"volatility\":5},{\"id\":\"MEDS\",\"name\":\"Pop-N-Pills Medical\",\"sector\":\"SURVIVAL\",\"initialPrice\":100,\"volatility\":18},{\"id\":\"TRADE\",\"name\":\"Trader Guild Network\",\"sector\":\"TRADE\",\"initialPrice\":150,\"volatility\":10},{\"id\":\"DUKES\",\"name\":\"Duke's Casino Tokens\",\"sector\":\"TRADE\",\"initialPrice\":1,\"volatility\":3}]},\"marketEvents\":{\"type\":\"array\",\"title\":\"Wasteland Events\",\"description\":\"Events impacting the Navezgane economy\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Unique event ID\"},\"name\":{\"type\":\"string\",\"description\":\"Name of the event\"},\"description\":{\"type\":\"string\",\"description\":\"Description of the event's market effect\"},\"sectorImpacts\":{\"type\":\"array\",\"description\":\"How each sector is affected\",\"items\":{\"type\":\"object\",\"properties\":{\"sectorId\":{\"type\":\"string\",\"description\":\"Sector ID\"},\"impact\":{\"type\":\"number\",\"description\":\"Percentage impact (-30 = -30%)\",\"minimum\":-75,\"maximum\":75}}}}}},\"default\":[{\"id\":\"HORDE_INCOMING\",\"name\":\"Horde Night Approaching\",\"description\":\"Increased Zed activity signals the Blood Moon. Survivors prepare defenses.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-5},{\"sectorId\":\"MANUFACTURING\",\"impact\":15},{\"sectorId\":\"DEFENSE\",\"impact\":25},{\"sectorId\":\"SURVIVAL\",\"impact\":10},{\"sectorId\":\"TRADE\",\"impact\":-10}]},{\"id\":\"RESOURCE_SHOCK\",\"name\":\"Resource Shock\",\"description\":\"Key resource veins are depleted, making raw materials expensive and driving up the price of finished goods.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-30},{\"sectorId\":\"MANUFACTURING\",\"impact\":15},{\"sectorId\":\"DEFENSE\",\"impact\":10},{\"sectorId\":\"SURVIVAL\",\"impact\":5},{\"sectorId\":\"TRADE\",\"impact\":5}]},{\"id\":\"ZED_OUTBREAK\",\"name\":\"Severe Zed Outbreak\",\"description\":\"An unusual concentration of Zed activity makes scavenging dangerous. Demand for medical supplies and defenses skyrockets.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-20},{\"sectorId\":\"MANUFACTURING\",\"impact\":-5},{\"sectorId\":\"DEFENSE\",\"impact\":25},{\"sectorId\":\"SURVIVAL\",\"impact\":25},{\"sectorId\":\"TRADE\",\"impact\":-15}]},{\"id\":\"TECH_BREAKTHROUGH\",\"name\":\"Technological Breakthrough\",\"description\":\"A discovery of pre-collapse schematics has revolutionized crafting and manufacturing.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":10},{\"sectorId\":\"MANUFACTURING\",\"impact\":30},{\"sectorId\":\"DEFENSE\",\"impact\":15},{\"sectorId\":\"SURVIVAL\",\"impact\":5},{\"sectorId\":\"TRADE\",\"impact\":15}]},{\"id\":\"TRADE_ROUTE_SECURED\",\"name\":\"Trade Route Secured\",\"description\":\"Traders have established a safer passage, improving the flow of all goods and services.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":20},{\"sectorId\":\"MANUFACTURING\",\"impact\":10},{\"sectorId\":\"DEFENSE\",\"impact\":5},{\"sectorId\":\"SURVIVAL\",\"impact\":15},{\"sectorId\":\"TRADE\",\"impact\":30}]},{\"id\":\"GENERAL_COLLAPSE\",\"name\":\"Societal Collapse Setback\",\"description\":\"A major setback reminds everyone how fragile survival is. Fear grips the market.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-15},{\"sectorId\":\"MANUFACTURING\",\"impact\":-20},{\"sectorId\":\"DEFENSE\",\"impact\":-15},{\"sectorId\":\"SURVIVAL\",\"impact\":0},{\"sectorId\":\"TRADE\",\"impact\":-25}]}]},\"eventFrequency\":{\"title\":\"Event Frequency\",\"type\":\"number\",\"description\":\"Average number of update cycles between market events (0 to disable). Depends on mod's update frequency (e.g., per in-game hour?).\",\"default\":8,\"minimum\":1},\"defaultEventDuration\":{\"title\":\"Default Event Duration\",\"type\":\"number\",\"description\":\"Default number of update cycles an event lasts.\",\"default\":3,\"minimum\":1,\"maximum\":96},\"transactionFee\":{\"title\":\"Transaction Fee (Dukes Tax)\",\"type\":\"number\",\"description\":\"Percentage fee charged on all buy/sell transactions (5 = 5%)\",\"default\":3,\"minimum\":0,\"maximum\":25},\"vipDiscount\":{\"title\":\"Trader's Favor Discount\",\"type\":\"number\",\"description\":\"Percentage discount on transaction fees for players with 'STOCK_MARKET_BROKER' permission (50 = 50%)\",\"default\":50,\"minimum\":0,\"maximum\":100},\"priceAlertThreshold\":{\"title\":\"Price Alert Threshold\",\"type\":\"number\",\"description\":\"Percentage change that triggers a market alert (15 = 15%)\",\"default\":15,\"minimum\":5,\"maximum\":50},\"marketNewsChannelId\":{\"title\":\"Discord Channel ID (for Market News)\",\"type\":\"string\",\"description\":\"The ID of the Discord channel where market news messages should be posted. Leave empty to disable.\",\"default\":\"\"}},\"additionalProperties\":false}",
            "uiSchema": "{\"sectors\":{\"items\":{\"ui:order\":[\"id\",\"name\"]}},\"stocks\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"sector\",\"initialPrice\",\"volatility\"]}},\"marketEvents\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"description\",\"sectorImpacts\"],\"sectorImpacts\":{\"items\":{\"ui:order\":[\"sectorId\",\"impact\"]}}}},\"transactionFee\":{\"ui:widget\":\"range\"},\"vipDiscount\":{\"ui:widget\":\"range\"},\"eventFrequency\":{\"ui:help\":\"Set to 0 to disable random events\"},\"priceAlertThreshold\":{\"ui:widget\":\"range\"}}",
            "commands": [
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === args.stock.toUpperCase());\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${args.stock} not found. Use /market to see available stocks.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate costs using Math.round to ensure we work with integers\n        const subtotal = Math.round(stock.price) * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const totalCost = subtotal + fee;\n\n        // Check if player has enough currency\n        const playerData = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, player.id);\n        const currentBalance = playerData.data.data.currency;\n\n        if (currentBalance < totalCost) {\n            throw new TakaroUserError(`You don't have enough currency. Cost: $${subtotal} + $${fee} fee = $${totalCost}. Your balance: $${currentBalance}`);\n        }\n\n        // Deduct the currency - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerDeductCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: totalCost\n            }\n        );\n\n        // Get player's portfolio or create new one\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        let portfolio;\n        if (portfolioVar.data.data.length === 0) {\n            portfolio = {};\n        } else {\n            portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        }\n\n        // Update portfolio using rounded values for consistency\n        const stockPrice = Math.round(stock.price);\n        if (!portfolio[stock.id]) {\n            portfolio[stock.id] = {\n                shares: amount,\n                averagePrice: stockPrice\n            };\n        } else {\n            const totalShares = portfolio[stock.id].shares + amount;\n            const totalValue = (portfolio[stock.id].shares * portfolio[stock.id].averagePrice) + (amount * stockPrice);\n            portfolio[stock.id].shares = totalShares;\n            portfolio[stock.id].averagePrice = Math.round(totalValue / totalShares);\n        }\n\n        // Save updated portfolio\n        if (portfolioVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_portfolio',\n                value: JSON.stringify(portfolio),\n                gameServerId,\n                moduleId: mod.moduleId,\n                playerId: player.id\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n                value: JSON.stringify(portfolio)\n            });\n        }\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'BUY',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: totalCost,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully bought ${amount} shares of ${stock.id} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Total cost: $${totalCost}\\n`;\n        message += `Current portfolio: ${portfolio[stock.id].shares} shares of ${stock.id}`;\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in buystock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your purchase. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "buystock",
                    "description": null,
                    "trigger": "buystock",
                    "helpText": "Buy shares of a stock",
                    "arguments": [
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to buy",
                            "position": 1
                        },
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol ",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // If a specific stock ticker is provided, show detailed info for that stock\n    const specificTicker = args.ticker ? args.ticker.toUpperCase() : null;\n\n    if (specificTicker && specificTicker !== \"ALL\") {\n        const stock = stocks.find(s => s.id.toUpperCase() === specificTicker);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${specificTicker} not found. Use /stockinfo without parameters to see all available stocks.`);\n        }\n\n        // Get active event to see if this stock's sector is affected\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let activeEvent = null;\n        let sectorImpact = null;\n\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEvent && activeEvent.sectorImpacts) {\n                    sectorImpact = activeEvent.sectorImpacts.find(impact =>\n                        impact.sectorId === stock.sector\n                    );\n                }\n            } catch (e) {\n                // Ignore parsing errors\n            }\n        }\n\n        // Calculate price change indicators\n        let changeText = '';\n        if (stock.lastPrice) {\n            const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n            const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n            changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n        }\n\n        // Add risk assessment based on volatility without showing the raw value\n        let riskLevel;\n        if (stock.volatility <= 0.05) riskLevel = \"Very Low\";\n        else if (stock.volatility <= 0.10) riskLevel = \"Low\";\n        else if (stock.volatility <= 0.15) riskLevel = \"Moderate\";\n        else if (stock.volatility <= 0.20) riskLevel = \"High\";\n        else riskLevel = \"Very High\";\n\n        // Build detailed stock info message\n        let message = `=== ${stock.id}: ${stock.name} ===\\n\\n`;\n        message += `Sector: ${stock.sector}\\n`;\n        message += `Current Price: $${Math.round(stock.price)}${changeText}\\n`;\n        message += `Risk Level: ${riskLevel}\\n`;\n\n        // Add sector trend info if available from event\n        if (activeEvent && sectorImpact) {\n            const direction = sectorImpact.impact >= 0 ? \"Positive\" : \"Negative\";\n            const strength = Math.abs(sectorImpact.impact);\n            let trend;\n\n            if (strength < 10) trend = \"Slight\";\n            else if (strength < 25) trend = \"Moderate\";\n            else trend = \"Strong\";\n\n            message += `\\nCurrent Trend: ${trend} ${direction} (${activeEvent.name})\\n`;\n            message += `Event: ${activeEvent.description}\\n`;\n        }\n\n        // Add trading guidance based on sector and risk, without mentioning volatility\n        message += `\\nTrading Notes:\\n`;\n\n        if (activeEvent && sectorImpact) {\n            if (sectorImpact.impact > 0) {\n                message += `- Currently bullish due to the ${activeEvent.name} event\\n`;\n            } else {\n                message += `- Currently bearish due to the ${activeEvent.name} event\\n`;\n            }\n        }\n\n        if (riskLevel === \"High\" || riskLevel === \"Very High\") {\n            message += `- Expect significant price fluctuations with this stock\\n`;\n        } else if (riskLevel === \"Low\" || riskLevel === \"Very Low\") {\n            message += `- Typically has stable price movement\\n`;\n        }\n\n        message += `\\nUse /buystock ${stock.id} [amount] to purchase shares`;\n\n        await player.pm(message);\n\n    } else {\n        // No specific ticker provided or ALL specified, show summary of all stocks\n        await player.pm(\"=== STOCK MARKET LISTINGS ===\\n\");\n\n        // Group stocks by sector\n        const stocksBySector = {};\n        stocks.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        // Display stocks by sector\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            let sectorMessage = `\\n--- ${sector} SECTOR ---\\n`;\n\n            sectorStocks.forEach(stock => {\n                // Add price change indicators\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                    changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                // Add risk level based on volatility\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                sectorMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n\n            await player.pm(sectorMessage);\n        }\n\n        // Add legend for risk indicators\n        const legend = \"\\n=== LEGEND ===\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\" +\n            \"Use /stockinfo [ticker] for detailed information about a specific stock\";\n\n        await player.pm(legend);\n    }\n}\n\nawait main();",
                    "name": "stockinfo",
                    "description": null,
                    "trigger": "stockinfo",
                    "helpText": "Shows all available stocks in the market. Use with a ticker symbol (e.g., /stockinfo ticker) to see detailed information about a specific stock.",
                    "arguments": [
                        {
                            "name": "ticker",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "stock ticker or ALL to get detailed information about a specific stock",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get player's portfolio\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        if (portfolioVar.data.data.length === 0) {\n            throw new TakaroUserError(\"You don't own any stocks to sell.\");\n        }\n\n        const portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        const stockId = args.stock.toUpperCase();\n\n        if (!portfolio[stockId] || portfolio[stockId].shares < amount) {\n            throw new TakaroUserError(`You don't own ${amount} shares of ${stockId}.`);\n        }\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === stockId);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${stockId} not found in current market data. Please contact an admin.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate sale proceeds using Math.round to ensure we work with integers\n        const stockPrice = Math.round(stock.price);\n        const subtotal = stockPrice * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const netProceeds = subtotal - fee;\n\n        // Add money to player - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerAddCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: netProceeds\n            }\n        );\n\n        // Calculate profit/loss\n        const profitPerShare = stockPrice - portfolio[stockId].averagePrice;\n        const totalProfit = Math.round(profitPerShare * amount);\n        const profitText = totalProfit >= 0\n            ? `profit of $${totalProfit}`\n            : `loss of $${Math.abs(totalProfit)}`;\n\n        // Update portfolio\n        portfolio[stockId].shares -= amount;\n        if (portfolio[stockId].shares === 0) {\n            delete portfolio[stockId];\n        }\n\n        // Save updated portfolio\n        await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n            value: JSON.stringify(portfolio)\n        });\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'SELL',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: netProceeds,\n            profit: totalProfit,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully sold ${amount} shares of ${stockId} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Net proceeds: $${netProceeds} (${profitText})`;\n\n        // Add remaining shares info if player still has some\n        if (portfolio[stockId]) {\n            message += `\\nRemaining shares: ${portfolio[stockId].shares}`;\n        } else {\n            message += `\\nYou've sold all your ${stockId} shares.`;\n        }\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in sellstock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your sale. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "sellstock",
                    "description": null,
                    "trigger": "sellstock",
                    "helpText": "Sell shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to sell",
                            "position": 1
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // Get player's portfolio\n    const portfolioVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_portfolio'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId],\n            playerId: [player.id]\n        }\n    });\n\n    let portfolio = {};\n    if (portfolioVar.data.data.length > 0) {\n        portfolio = JSON.parse(portfolioVar.data.data[0].value);\n    }\n\n    // Send header\n    await player.pm(\"=== YOUR STOCK PORTFOLIO ===\");\n\n    let hasStocks = false;\n    let totalValue = 0;\n    let totalInvestment = 0;\n\n    // If no stocks, send a simple message\n    if (Object.keys(portfolio).length === 0) {\n        await player.pm(\"You don't own any stocks yet.\\n\" +\n            \"Use /markets to see available stocks and prices.\\n\" +\n            \"Use /buy <stock> <amount> to purchase stocks.\");\n        return;\n    }\n\n    // Helper function to format numbers with commas\n    const formatNumber = (num) => {\n        return Math.round(num).toLocaleString();\n    };\n\n    // Send each stock as a separate message to avoid length issues\n    for (const [stockId, data] of Object.entries(portfolio)) {\n        hasStocks = true;\n        const stock = stocks.find(s => s.id === stockId);\n        if (!stock) continue; // Stock might have been removed from config\n\n        const currentValue = stock.price * data.shares;\n        const investmentValue = data.averagePrice * data.shares;\n        totalValue += currentValue;\n        totalInvestment += investmentValue;\n        const profit = currentValue - investmentValue;\n        const profitPercent = ((profit / investmentValue) * 100).toFixed(1);\n\n        let stockMessage = `--- ${stockId} (${stock.sector}) ---\\n`;\n        stockMessage += `Shares: ${data.shares}\\n`;\n        stockMessage += `Avg buy: $${formatNumber(data.averagePrice)}\\n`;\n        stockMessage += `Current price: $${formatNumber(stock.price)}\\n`;\n        stockMessage += `Total value: $${formatNumber(currentValue)}\\n`;\n\n        if (profit >= 0) {\n            stockMessage += `Profit: +$${formatNumber(profit)} (+${profitPercent}%)\\n`;\n        } else {\n            stockMessage += `Loss: -$${formatNumber(Math.abs(profit))} (${profitPercent}%)\\n`;\n        }\n\n        await player.pm(stockMessage);\n    }\n\n    if (hasStocks) {\n        const totalProfit = totalValue - totalInvestment;\n        const totalProfitPercent = ((totalProfit / totalInvestment) * 100).toFixed(1);\n\n        let summaryMessage = \"=== PORTFOLIO SUMMARY ===\\n\";\n        summaryMessage += `Total investment: $${formatNumber(totalInvestment)}\\n`;\n        summaryMessage += `Current value: $${formatNumber(totalValue)}\\n`;\n\n        if (totalProfit >= 0) {\n            summaryMessage += `Overall profit: +$${formatNumber(totalProfit)} (+${totalProfitPercent}%)\\n`;\n        } else {\n            summaryMessage += `Overall loss: -$${formatNumber(Math.abs(totalProfit))} (${totalProfitPercent}%)\\n`;\n        }\n\n        // Get transaction history count\n        try {\n            const historyVar = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: ['stock_transaction_history'],\n                    gameServerId: [gameServerId],\n                    moduleId: [mod.moduleId],\n                    playerId: [player.id]\n                }\n            });\n\n            if (historyVar.data.data.length > 0) {\n                const history = JSON.parse(historyVar.data.data[0].value);\n                const buyCount = history.filter(t => t.type === 'BUY').length;\n                const sellCount = history.filter(t => t.type === 'SELL').length;\n\n                summaryMessage += `\\nTransactions: ${history.length} (${buyCount} buys, ${sellCount} sells)\\n`;\n            }\n        } catch (error) {\n            // Just ignore history errors\n        }\n\n        await player.pm(summaryMessage);\n    }\n}\n\nawait main();",
                    "name": "stockportfolio",
                    "description": null,
                    "trigger": "stockportfolio",
                    "helpText": "No help text available",
                    "arguments": []
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Handle the industry argument - use \"ALL\" as a special value to show all industries\n    const industryFilter = args.Industry ? args.Industry.toUpperCase() : \"ALL\";\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    // If market data doesn't exist, try to initialize it\n    if (marketDataVar.data.data.length === 0) {\n        const initialized = await initializeMarketIfNeeded(gameServerId, mod);\n        if (!initialized) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        // Get the freshly initialized market data\n        const refreshedMarketData = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (refreshedMarketData.data.data.length === 0) {\n            throw new TakaroUserError(\"There was an issue initializing the stock market. Please try again later.\");\n        }\n\n        // Continue with the refreshed data\n        await displayMarketSummary(player, gameServerId, mod, refreshedMarketData.data.data[0], industryFilter);\n    } else {\n        // Market data exists, display it\n        await displayMarketSummary(player, gameServerId, mod, marketDataVar.data.data[0], industryFilter);\n    }\n}\n\n// Display the market summary to the player\nasync function displayMarketSummary(player, gameServerId, mod, marketDataVariable, industryFilter) {\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Handle empty string or empty object\n            if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (e) {\n            // In case of parsing error\n            activeEvent = null;\n        }\n    }\n\n    const stocks = JSON.parse(marketDataVariable.value);\n\n    // Get all available industries for reference\n    const availableIndustries = [...new Set(stocks.map(stock => stock.sector))];\n\n    // If industry filter is provided and not \"ALL\", check if it's valid\n    if (industryFilter !== \"ALL\") {\n        // Check if the industry exists\n        const industryExists = availableIndustries.includes(industryFilter);\n\n        if (!industryExists) {\n            throw new TakaroUserError(`Industry \"${industryFilter}\" not found. Available industries: ${availableIndustries.join(', ')}\\nUse \"ALL\" to view all industries.`);\n        }\n    }\n\n    // Send header message\n    let headerMessage = \"=== STOCK MARKET SUMMARY ===\\n\";\n\n    // If filtering by industry, mention it in the header\n    if (industryFilter !== \"ALL\") {\n        headerMessage = `=== ${industryFilter} INDUSTRY ===\\n`;\n    }\n\n    // If there's an active event, include it in the header\n    if (activeEvent) {\n        headerMessage += `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n`;\n        headerMessage += `${activeEvent.description}\\n\\n`;\n\n        // If filtering by industry, only show relevant impacts\n        if (industryFilter !== \"ALL\") {\n            const relevantImpact = activeEvent.sectorImpacts.find(\n                impact => impact.sectorId === industryFilter\n            );\n\n            if (relevantImpact) {\n                const direction = relevantImpact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `Industry Impact: ${direction} ${Math.abs(relevantImpact.impact)}%\\n`;\n            } else {\n                headerMessage += \"This industry is not directly affected by the current event.\\n\";\n            }\n        } else {\n            // Show all industry impacts\n            headerMessage += \"Industry Impacts:\\n\";\n            for (const impact of activeEvent.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%\\n`;\n            }\n        }\n    }\n\n    // Send header message first\n    await player.pm(headerMessage);\n\n    // Group stocks by industry\n    const stocksByIndustry = {};\n    stocks.forEach(stock => {\n        if (!stocksByIndustry[stock.sector]) {\n            stocksByIndustry[stock.sector] = [];\n        }\n        stocksByIndustry[stock.sector].push(stock);\n    });\n\n    // If industry filter is not \"ALL\", only show that industry\n    if (industryFilter !== \"ALL\") {\n        const filteredStocks = stocksByIndustry[industryFilter] || [];\n\n        if (filteredStocks.length > 0) {\n            let stockMessage = \"\";\n\n            filteredStocks.forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                stockMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(stockMessage);\n        } else {\n            await player.pm(`No stocks found in the ${industryFilter} industry.`);\n        }\n    } else {\n        // Send each industry as a separate message\n        for (const industryId in stocksByIndustry) {\n            let industryMessage = `=== ${industryId} INDUSTRY ===\\n`;\n\n            stocksByIndustry[industryId].forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                industryMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(industryMessage);\n        }\n    }\n\n    // Add a help message for industry filtering if showing all industries\n    if (industryFilter === \"ALL\") {\n        const allIndustries = Object.keys(stocksByIndustry).join(', ');\n        await player.pm(`\\nTip: Use '/markets [industry]' to view only stocks in a specific industry. Available industries: ${allIndustries}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return false;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            const results = await Promise.allSettled(createPromises);\n            // Check if the critical stock_market_data was created successfully\n            const stockDataPromise = results[0];\n            if (stockDataPromise && stockDataPromise.status === 'rejected') {\n                console.log(`Failed to create stock_market_data: ${stockDataPromise.reason}`);\n                return false;\n            }\n        }\n\n        return true;\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n        return false;\n    }\n}\n\nawait main();",
                    "name": "markets",
                    "description": null,
                    "trigger": "markets",
                    "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. \n",
                    "arguments": [
                        {
                            "name": "Industry",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. ",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRIGGER_EVENT')) {\n        throw new TakaroUserError(\"You don't have permission to trigger market events.\");\n    }\n\n    try {\n        // Get current stock data to check market initialization\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Initialize market if needed\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            await player.pm(\"Market was not initialized. Initializing now...\");\n            return;\n        }\n\n        // Get events from module config\n        const marketEvents = mod.userConfig.marketEvents || [];\n\n        if (marketEvents.length === 0) {\n            throw new TakaroUserError(\"No market events configured in this module.\");\n        }\n\n        // Handle case when no event is specified or \"ALL\" is provided\n        if (!args.EventName || args.EventName.toUpperCase() === \"ALL\") {\n            await player.pm(\"=== AVAILABLE MARKET EVENTS ===\\n\");\n\n            // Group events by category or type if possible\n            const eventCategories = {};\n\n            // Create a simple categorization based on positive/negative impact\n            marketEvents.forEach(event => {\n                let category = \"Mixed\";\n                // Calculate net impact across all sectors\n                const netImpact = event.sectorImpacts.reduce((sum, impact) => sum + impact.impact, 0);\n\n                if (netImpact > 0) category = \"Positive\";\n                else if (netImpact < 0) category = \"Negative\";\n\n                if (!eventCategories[category]) {\n                    eventCategories[category] = [];\n                }\n                eventCategories[category].push(event);\n            });\n\n            // Display events by category\n            for (const [category, events] of Object.entries(eventCategories)) {\n                if (events.length > 0) {\n                    await player.pm(`\\n--- ${category.toUpperCase()} EVENTS ---`);\n\n                    let message = \"\";\n                    events.forEach(event => {\n                        // Format primary sectors affected\n                        const primarySectors = event.sectorImpacts\n                            .filter(impact => Math.abs(impact.impact) >= 15)\n                            .map(impact => {\n                                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                                return `${impact.sectorId} ${direction}${Math.abs(impact.impact)}%`;\n                            })\n                            .join(\", \");\n\n                        message += `${event.id}: ${event.name}\\n`;\n                        message += `   ${event.description}\\n`;\n                        if (primarySectors) {\n                            message += `   Major impacts: ${primarySectors}\\n`;\n                        }\n                        message += \"\\n\";\n                    });\n\n                    await player.pm(message);\n                }\n            }\n\n            await player.pm(\"=== HOW TO USE ===\\nUse `/triggerevent <EventName>` to trigger a specific event (e.g., `/triggerevent TECH_BOOM`)\");\n            return;\n        }\n\n        // Find the requested event\n        const eventId = args.EventName.toUpperCase();\n        const event = marketEvents.find(e => e.id === eventId);\n\n        if (!event) {\n            throw new TakaroUserError(`Event \"${eventId}\" not found. Use /triggerevent without parameters to see all available events.`);\n        }\n\n        // Get necessary variables for managing the event\n        const [activeEventVar, eventStartTimeVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_execution_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_cooldown_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['current_event_duration'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Check if there's an active event we need to cancel\n        let activeEventObj = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEventObj = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEventObj && Object.keys(activeEventObj).length > 0) {\n                    await player.pm(`Cancelling active event \"${activeEventObj.name}\" to trigger new event.`);\n                }\n            } catch (e) {\n                // Invalid event data, will be overwritten\n            }\n        }\n\n        // Generate a random duration for the event\n        const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n        // Update or create all event-related variables\n        const updatePromises = [];\n\n        // Save or update the random duration\n        if (eventDurationVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                    value: randomDuration.toString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'current_event_duration',\n                    value: randomDuration.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the event counter to 0\n        if (eventCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the cooldown counter\n        if (cooldownCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update active event\n        if (activeEventVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                    value: JSON.stringify(event)\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: JSON.stringify(event),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update event start time\n        if (eventStartTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update last event time\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (lastEventTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all updates to complete\n        await Promise.all(updatePromises);\n\n        // Check if there are online players to announce the event\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            // Format sector impacts for announcement\n            let impactText = \"\";\n            for (const impact of event.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n            }\n\n            const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${event.name}\\n${event.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /markets to see opportunities!`;\n\n            // Split the message if it's too long\n            const maxLength = 400; // Safe limit for most games\n            for (let i = 0; i < message.length; i += maxLength) {\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message: message.substring(i, i + maxLength)\n                });\n            }\n        }\n\n        await player.pm(`Successfully triggered the \"${event.name}\" market event for ${randomDuration} cycles!`);\n    } catch (error) {\n        // If something goes wrong, log it and let the player know\n        console.log(`Error in triggerEvent: ${error.message}`);\n        throw new TakaroUserError(`Error triggering event: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Store the stocks data\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_data',\n            value: JSON.stringify(stocks),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize last event time to now\n        await takaro.variable.variableControllerCreate({\n            key: 'last_market_event_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize event start time variable\n        await takaro.variable.variableControllerCreate({\n            key: 'event_start_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize active event (empty string means no active event)\n        await takaro.variable.variableControllerCreate({\n            key: 'active_market_event',\n            value: '',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Mark market as initialized\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_initialized',\n            value: 'true',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Announce market initialization to online players\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /markets to see available stocks and /buystock to start investing.\";\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message\n            });\n        }\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "triggerevent",
                    "description": null,
                    "trigger": "triggerevent",
                    "helpText": "Shows all available market events when run without parameters. Use with an event name (e.g., /triggerevent TECH_BOOM) to trigger a specific market event.",
                    "arguments": [
                        {
                            "name": "EventName",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "Event name to trigger a specific market event",
                            "position": 0
                        }
                    ]
                }
            ],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n\n    const discordChannelId = mod.userConfig.marketNewsChannelId;\n\n    if (!discordChannelId) {\n        takaro.log.info('Market news Discord channel ID (marketNewsChannelId) not configured in module settings. Skipping Discord messages.');\n    }\n\n    const currentPlayers = (await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    })).data.meta;\n\n    if (currentPlayers.total === 0) {\n        takaro.log.info('Skipping daily market report: No players online.');\n        return;\n    }\n\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        takaro.log.warn('Skipping daily market report: Market data variable not found.');\n        return;\n    }\n\n    let stocks;\n    try {\n        stocks = JSON.parse(marketDataVar.data.data[0].value);\n        if (!Array.isArray(stocks)) {\n            throw new Error('Parsed market data is not an array.');\n        }\n    } catch (error) {\n        takaro.log.error(`Failed to parse stock_market_data: ${error}`);\n        return;\n    }\n\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            if (typeof activeEvent !== 'object' || activeEvent === null || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (error) {\n            takaro.log.warn(`Failed to parse active_market_event: ${error}`);\n            activeEvent = null;\n        }\n    }\n\n    let gameMessage1 = \"==== DAILY MARKET REPORT ====\\n\";\n\n    if (activeEvent && activeEvent.name && activeEvent.description) {\n        const eventText = `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n${activeEvent.description}\\n`;\n        gameMessage1 += eventText;\n    } else {\n        const noEventText = '\\nNo active market events today.\\n';\n        gameMessage1 += noEventText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage1\n    }).catch(err => takaro.log.error(`Failed to send game message 1: ${err}`));\n\n    const stocksWithPerformance = stocks.map(stock => {\n        let change = 0;\n        let percentChange = 0;\n        let changeSymbol = 'â†’';\n\n        if (typeof stock.price === 'number' && typeof stock.lastPrice === 'number' && stock.lastPrice !== 0) {\n            change = stock.price - stock.lastPrice;\n            percentChange = (change / stock.lastPrice) * 100;\n            if (percentChange > 0.05) {\n                changeSymbol = 'â†‘';\n            } else if (percentChange < -0.05) {\n                changeSymbol = 'â†“';\n            }\n        } else if (typeof stock.price === 'number' && stock.lastPrice === undefined) {\n            changeSymbol = 'ðŸ†•';\n            percentChange = 0;\n        }\n        return {\n            ...stock,\n            change,\n            percentChange,\n            changeSymbol\n        };\n    });\n\n    const sectorPerformance = {};\n    stocksWithPerformance.forEach(stock => {\n        const sectorId = stock.sector || 'Uncategorized';\n        if (!sectorPerformance[sectorId]) {\n            sectorPerformance[sectorId] = {\n                stocks: [],\n                totalPercentChange: 0,\n                count: 0\n            };\n        }\n        sectorPerformance[sectorId].stocks.push(stock);\n        if (typeof stock.percentChange === 'number' && isFinite(stock.percentChange)) {\n            sectorPerformance[sectorId].totalPercentChange += stock.percentChange;\n            sectorPerformance[sectorId].count++;\n        }\n    });\n\n    for (const sectorId in sectorPerformance) {\n        const sectorData = sectorPerformance[sectorId];\n        if (sectorData.count > 0) {\n            sectorData.avgPerformance = sectorData.totalPercentChange / sectorData.count;\n        } else {\n            sectorData.avgPerformance = 0;\n        }\n    }\n\n    const sortedSectors = Object.entries(sectorPerformance)\n        .sort(([, a], [, b]) => b.avgPerformance - a.avgPerformance);\n\n    let gameMessage2 = \"\\n=== SECTOR PERFORMANCE ===\\n\";\n\n    if (sortedSectors.length > 0) {\n        sortedSectors.forEach(([sectorId, sectorData]) => {\n            const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n            let line = `${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n\n            if (sectorData.avgPerformance > 0.05) {\n                line = `[70FE02]${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%[-]\\n`;\n            } else if (sectorData.avgPerformance < -0.05) {\n                line = `[FF0001]${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%[-]\\n`;\n            }\n            gameMessage2 += line;\n        });\n    } else {\n        const noDataText = \"No sector performance data available.\\n\";\n        gameMessage2 += noDataText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage2\n    }).catch(err => takaro.log.error(`Failed to send game message 2: ${err}`));\n\n    const validPerformers = stocksWithPerformance.filter(s => typeof s.percentChange === 'number' && isFinite(s.percentChange));\n    validPerformers.sort((a, b) => b.percentChange - a.percentChange);\n\n    let gameMessage3 = \"\";\n\n    const topPerformersTitleGame = \"\\nðŸ”¥ TOP PERFORMERS ðŸ”¥\\n\";\n    gameMessage3 += topPerformersTitleGame;\n\n    if (validPerformers.length > 0) {\n        for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n            const stock = validPerformers[i];\n            let linePrefix = '';\n            let lineSuffix = '';\n\n            if (stock.percentChange > 0) {\n                linePrefix = '[70FE02]';\n                lineSuffix = '[-]';\n            } else if (stock.percentChange < 0) {\n                linePrefix = '[FF0001]';\n                lineSuffix = '[-]';\n            }\n            // Applying color to the entire line for top/worst performers as before\n            gameMessage3 += `${linePrefix}${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%${lineSuffix}\\n`;\n        }\n    } else {\n        const noTopText = \"No top performers today.\\n\";\n        gameMessage3 += noTopText;\n    }\n\n    const worstPerformersTitleGame = \"\\nðŸ“‰ WORST PERFORMERS ðŸ“‰\\n\";\n    gameMessage3 += worstPerformersTitleGame;\n\n    if (validPerformers.length > 0) {\n        const worstStartIndex = Math.max(0, validPerformers.length - 3);\n        for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n            const stock = validPerformers[i];\n            let linePrefix = '';\n            let lineSuffix = '';\n\n            if (stock.percentChange > 0) {\n                linePrefix = '[70FE02]';\n                lineSuffix = '[-]';\n            } else if (stock.percentChange < 0) {\n                linePrefix = '[FF0001]';\n                lineSuffix = '[-]';\n            }\n            // Applying color to the entire line for top/worst performers as before\n            gameMessage3 += `${linePrefix}${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%${lineSuffix}\\n`;\n        }\n    } else {\n        const noWorstText = \"No worst performers today.\\n\";\n        gameMessage3 += noWorstText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage3\n    }).catch(err => takaro.log.error(`Failed to send game message 3: ${err}`));\n\n    // Helper function to convert HSL to RGB\n    function hslToRgb(h, s, l) {\n        let c = (1 - Math.abs(2 * l - 1)) * s;\n        let x = c * (1 - Math.abs((h / 60) % 2 - 1));\n        let m = l - c / 2;\n        let r = 0, g = 0, b = 0;\n\n        if (0 <= h && h < 60) {\n            r = c; g = x; b = 0;\n        } else if (60 <= h && h < 120) {\n            r = x; g = c; b = 0;\n        } else if (120 <= h && h < 180) {\n            r = 0; g = c; b = x;\n        } else if (180 <= h && h < 240) {\n            r = 0; g = x; b = c;\n        } else if (240 <= h && h < 300) {\n            r = x; g = 0; b = c;\n        } else if (300 <= h && h < 360) {\n            r = c; g = 0; b = x;\n        }\n        r = Math.round((r + m) * 255);\n        g = Math.round((g + m) * 255);\n        b = Math.round((b + m) * 255);\n\n        return [r, g, b];\n    }\n\n    // Helper function to convert RGB to Hex\n    function rgbToHex(r, g, b) {\n        return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();\n    }\n\n    // Function to generate a consistent BRIGHT and DISTINCT hex color from a string\n    function stringToHexColor(str) {\n        let hash = 0;\n        for (let i = 0; i < str.length; i++) {\n            hash = str.charCodeAt(i) + ((hash << 5) - hash);\n        }\n        // Ensure hash is non-negative\n        hash = Math.abs(hash);\n\n        // Use a \"golden angle\" to distribute hues more evenly across the spectrum\n        // This helps in generating visually distinct colors.\n        const goldenAngle = 137.508; // Degrees\n        let hue = (hash * goldenAngle) % 360;\n\n        // Set high saturation and lightness for bright colors\n        const saturation = 0.9; // 90%\n        const lightness = 0.7;  // 70%\n\n        const [r, g, b] = hslToRgb(hue, saturation, lightness);\n        return rgbToHex(r, g, b);\n    }\n\n    const stockColors = {};\n    stocksWithPerformance.forEach(stock => {\n        // Use stock.name for color generation to ensure consistent unique colors for full names\n        stockColors[stock.id] = stringToHexColor(stock.name);\n    });\n\n    // --- Send each sector's stock listings in separate messages (Game Server Only) ---\n    const stocksBySectorGame = {};\n    stocksWithPerformance.forEach(stock => {\n        if (!stocksBySectorGame[stock.sector]) {\n            stocksBySectorGame[stock.sector] = [];\n        }\n        stocksBySectorGame[stock.sector].push(stock);\n    });\n\n    for (const [sector, sectorStocks] of Object.entries(stocksBySectorGame)) {\n        let sectorMessage = `\\n--- ${sector} SECTOR ---\\n`;\n        sectorStocks.forEach(stock => {\n            let changeText = '';\n            let priceColorPrefix = '';\n            let priceColorSuffix = '';\n\n            if (stock.lastPrice) {\n                const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                if (percentChange > 0) {\n                    priceColorPrefix = '[70FE02]';\n                    priceColorSuffix = '[-]';\n                } else if (percentChange < 0) {\n                    priceColorPrefix = '[FF0001]';\n                    priceColorSuffix = '[-]';\n                }\n            }\n\n            // Apply distinct hex color for stock name\n            // The unique color is for the *full stock name* like \"AmmoNation Surplus\"\n            const stockNameColorPrefix = stockColors[stock.id] ? `[${stockColors[stock.id]}]` : '';\n            const stockNameColorSuffix = stockColors[stock.id] ? '[-]' : '';\n\n            let riskIndicator;\n            if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n            else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n            else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n            else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n            else riskIndicator = \"VH\";\n\n            // Corrected concatenation for nested colors:\n            // Stock name color opens, then risk indicator, then price color opens, then price/change, then close all.\n            // Ensure the stock name is wrapped by its unique color.\n            // Ensure the price/change is wrapped by its red/green color.\n            sectorMessage += `${stockNameColorPrefix}${stock.name}${stockNameColorSuffix} (${riskIndicator}): ${priceColorPrefix}$${Math.round(stock.price)}${changeText}${priceColorSuffix}\\n`;\n        });\n\n        await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n            message: sectorMessage\n        }).catch(err => takaro.log.error(`Failed to send game message for sector ${sector}: ${err}`));\n    }\n\n    // Send the legend for risk indicators as a separate message\n    const legendMessage = \"\\n=== LEGEND ===\\n\" +\n        \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\";\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: legendMessage\n    }).catch(err => takaro.log.error(`Failed to send game legend message: ${err}`));\n\n\n    // --- Discord Message: Consolidated Market Report ---\n    if (discordChannelId) {\n        let discordMessage = \"**==== DAILY MARKET REPORT ====**\\n\\n\";\n\n        if (activeEvent && activeEvent.name && activeEvent.description) {\n            discordMessage += `ðŸŒ **ACTIVE EVENT: ${activeEvent.name}** ðŸŒ\\n${activeEvent.description}\\n\\n`;\n        } else {\n            discordMessage += 'No active market events today.\\n\\n';\n        }\n\n        discordMessage += \"**=== SECTOR PERFORMANCE ===**\\n\";\n        if (sortedSectors.length > 0) {\n            sortedSectors.forEach(([sectorId, sectorData]) => {\n                const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n                discordMessage += `${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n            });\n        } else {\n            discordMessage += \"No sector performance data available.\\n\";\n        }\n        discordMessage += \"\\n\";\n\n        discordMessage += \"**ðŸ”¥ TOP PERFORMERS ðŸ”¥**\\n\";\n        if (validPerformers.length > 0) {\n            for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n                const stock = validPerformers[i];\n                const line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n                discordMessage += line;\n            }\n        } else {\n            discordMessage += \"No top performers today.\\n\";\n        }\n        discordMessage += \"\\n\";\n\n        discordMessage += \"**ðŸ“‰ WORST PERFORMERS ðŸ“‰**\\n\";\n        if (validPerformers.length > 0) {\n            const worstStartIndex = Math.max(0, validPerformers.length - 3);\n            for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n                const stock = validPerformers[i];\n                const line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n                discordMessage += line;\n            }\n        } else {\n            discordMessage += \"No worst performers today.\\n\";\n        }\n        discordMessage += \"\\n\";\n\n        discordMessage += \"**=== ALL STOCK LISTINGS ===**\\n\";\n        const stocksBySector = {};\n        stocksWithPerformance.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            discordMessage += `\\n--- **${sector} SECTOR** ---\\n`;\n            sectorStocks.forEach(stock => {\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                    changeText = ` ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                discordMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n        }\n\n        discordMessage += \"\\n**=== LEGEND ===**\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\";\n\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessage\n        }).catch(err => takaro.log.error(`Failed to send consolidated Discord message: ${err.message || err}`));\n    }\n\n    takaro.log.info('Daily market report sent successfully (game server and potentially Discord).');\n}\n\nawait main();",
                    "name": "marketnews",
                    "description": null,
                    "temporalValue": "1 */1 * * *"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    try {\n        const { gameServerId, module: mod } = data;\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Check if market is initialized\n        if (marketDataVar.data.data.length === 0) {\n            console.log(\"Market data not found, initializing...\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return; // Exit after initialization\n        }\n\n        // Get active market event\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event start time\n        const eventStartTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_start_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event execution counter\n        const eventCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_execution_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event cooldown counter\n        const cooldownCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_cooldown_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let eventCounter = 0;\n        if (eventCounterVar.data.data.length > 0) {\n            eventCounter = parseInt(eventCounterVar.data.data[0].value, 10);\n            console.log(`Event counter: ${eventCounter}`);\n        }\n\n        let cooldownCounter = 0;\n        if (cooldownCounterVar.data.data.length > 0) {\n            cooldownCounter = parseInt(cooldownCounterVar.data.data[0].value, 10);\n            console.log(`Cooldown counter: ${cooldownCounter}`);\n        }\n\n        // Get event duration\n        const eventDurationVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['current_event_duration'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Use stored random duration if available, otherwise use defaultEventDuration\n        let eventDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        if (eventDurationVar.data.data.length > 0) {\n            eventDuration = parseInt(eventDurationVar.data.data[0].value, 10);\n            console.log(`Event duration: ${eventDuration}`);\n        }\n\n        let activeEvent = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                // If it's an empty string, treat as no active event\n                if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                    activeEvent = null;\n                }\n                console.log(`Active event: ${activeEvent ? activeEvent.name : 'None'}`);\n            } catch (e) {\n                // In case of parsing error, consider no active event\n                activeEvent = null;\n                console.log(`Error parsing active event: ${e.message}`);\n            }\n        }\n\n        // Check if the current event should end and increment counter\n        if (activeEvent) {\n            eventCounter++;\n            console.log(`Incremented event counter to: ${eventCounter}`);\n\n            if (eventCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: eventCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: eventCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n\n            if (eventCounter >= eventDuration) {\n                console.log(\"Event duration reached, ending event.\");\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: ''\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_cooldown_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    const message = `ðŸ“ˆ MARKET UPDATE ðŸ“‰\\n\\nThe \"${activeEvent.name}\" event has ended. Markets are returning to normal conditions.`;\n\n                    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                        message: message\n                    });\n                }\n\n                activeEvent = null;\n            }\n        } else {\n            cooldownCounter++;\n            console.log(`Incremented cooldown counter to: ${cooldownCounter}`);\n\n            if (cooldownCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: cooldownCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: cooldownCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n        }\n\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        const eventFrequency = (mod.userConfig && mod.userConfig.eventFrequency) || 10;\n        let shouldTriggerEvent = false;\n\n        if (!activeEvent && cooldownCounter >= eventFrequency) {\n            shouldTriggerEvent = Math.random() < 0.5;\n            if (cooldownCounter >= eventFrequency * 2) {\n                shouldTriggerEvent = true;\n            }\n            console.log(`Should trigger new event: ${shouldTriggerEvent}`);\n        }\n\n        if (shouldTriggerEvent) {\n            const events = (mod.userConfig && mod.userConfig.marketEvents) || [];\n            if (events.length > 0) {\n                const randomEvent = events[Math.floor(Math.random() * events.length)];\n                activeEvent = randomEvent;\n                console.log(`New event triggered: ${activeEvent.name}`);\n\n                const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n                const randomDuration = Math.floor(Math.random() * maxDuration) + 1;\n\n                if (eventDurationVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                        value: randomDuration.toString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'current_event_duration',\n                        value: randomDuration.toString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: JSON.stringify(activeEvent)\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'active_market_event',\n                        value: JSON.stringify(activeEvent),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventStartTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_start_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (lastEventTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'last_market_event_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    let impactText = \"\";\n                    for (const impact of activeEvent.sectorImpacts) {\n                        const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                        impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n                    }\n\n                    const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${activeEvent.name}\\n${activeEvent.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /market to see opportunities!`;\n\n                    const maxLength = 400;\n                    for (let i = 0; i < message.length; i += maxLength) {\n                        await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                            message: message.substring(i, i + maxLength)\n                        });\n                    }\n                }\n            }\n        }\n\n        // Get stocks\n        if (!marketDataVar.data.data[0] || !marketDataVar.data.data[0].value) {\n            console.log(\"Market data is empty or invalid after initial check, re-initializing.\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        let stocks;\n        try {\n            stocks = JSON.parse(marketDataVar.data.data[0].value);\n            if (!Array.isArray(stocks)) {\n                throw new Error(\"Parsed stocks data is not an array\");\n            }\n            // CRITICAL FIX: Ensure each stock has valid numerical price properties\n            stocks = stocks.map(s => {\n                const sanitizedPrice = typeof s.price === 'number' && s.price > 0 ? s.price : 1;\n                const sanitizedLastPrice = typeof s.lastPrice === 'number' && s.lastPrice > 0 ? s.lastPrice : sanitizedPrice;\n                return {\n                    ...s,\n                    price: sanitizedPrice,\n                    lastPrice: sanitizedLastPrice\n                };\n            });\n            console.log(\"Stocks loaded and sanitized successfully.\");\n            console.log(\"Initial stocks for this cycle:\");\n            stocks.forEach(s => console.log(`  ${s.id}: Price ${s.price}, LastPrice ${s.lastPrice}`));\n\n        } catch (e) {\n            console.log(`Error parsing or sanitizing stock data: ${e.message}`);\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        const significantChanges = [];\n\n        // Update each stock price\n        stocks.forEach(stock => {\n            // Always capture oldPrice at the very beginning of the iteration\n            const oldPrice = stock.price;\n            // Set lastPrice to the value before this current update cycle for accurate change tracking\n            stock.lastPrice = oldPrice;\n\n            console.log(`Processing stock: ${stock.id}, Old Price: ${oldPrice}`);\n\n            // Define the threshold for \"penny stock\" and the chance/magnitude of a breakout\n            const pennyStockThreshold = 1.9;\n            const breakoutChance = 0.6;\n\n            const targetMinPrice = 2.0;\n            const targetMaxPrice = 10.0;\n\n            let calculatedNewPrice;\n\n            // Check if it's a penny stock and qualifies for a breakout\n            if (oldPrice <= pennyStockThreshold && Math.random() < breakoutChance) {\n                console.log(`${stock.id} is a penny stock (${oldPrice}) and hit breakout chance!`);\n                calculatedNewPrice = targetMinPrice + Math.random() * (targetMaxPrice - targetMinPrice);\n                calculatedNewPrice = Math.max(calculatedNewPrice, oldPrice + 0.01); // Ensure at least a penny increase\n                console.log(`${stock.id} calculated breakout price: ${calculatedNewPrice}`);\n            } else {\n                const randomFactor = Math.random() * 2 - 1;\n                const totalChangePercent = randomFactor * stock.volatility;\n                calculatedNewPrice = oldPrice * (1 + totalChangePercent);\n                console.log(`${stock.id} calculated normal price: ${calculatedNewPrice} (Change: ${totalChangePercent * 100}%)`);\n            }\n\n            let finalPrice = calculatedNewPrice;\n            if (activeEvent) {\n                const sectorImpact = activeEvent.sectorImpacts.find(impact => impact.sectorId === stock.sector);\n                if (sectorImpact) {\n                    const eventImpactPercentage = sectorImpact.impact;\n                    const eventImpactDecimal = eventImpactPercentage / 100;\n                    const randomImpactFactor = 0.5 + Math.random();\n                    const eventImpact = eventImpactDecimal * randomImpactFactor;\n\n                    finalPrice = calculatedNewPrice * (1 + eventImpact);\n                    console.log(`${stock.id} final price after event impact: ${finalPrice} (Event impact: ${eventImpact * 100}%)`);\n                }\n            }\n\n            stock.price = finalPrice;\n\n            if (stock.price < 1) {\n                console.log(`${stock.id} price fell below 1, setting to 1.`);\n                stock.price = 1;\n            }\n\n            const actualPercentChange = ((stock.price - oldPrice) / oldPrice) * 100;\n            console.log(`${stock.id} - Final Price: ${stock.price.toFixed(2)}, Actual Change: ${actualPercentChange.toFixed(2)}%`);\n\n            const changeThreshold = ((mod.userConfig && mod.userConfig.priceAlertThreshold) || 10) / 100;\n            if (Math.abs(actualPercentChange) > changeThreshold * 100) {\n                significantChanges.push({\n                    ...stock,\n                    changePercent: actualPercentChange\n                });\n            }\n        });\n\n        console.log(\"All stocks processed, saving updated prices...\");\n        await takaro.variable.variableControllerUpdate(marketDataVar.data.data[0].id, {\n            value: JSON.stringify(stocks)\n        });\n        console.log(\"Updated prices saved.\");\n\n        if (significantChanges.length > 0) {\n            console.log(\"Significant changes detected, sending alert.\");\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                significantChanges.sort((a, b) => Math.abs(b.changePercent) - Math.abs(a.changePercent));\n                const topChanges = significantChanges.slice(0, Math.min(3, significantChanges.length));\n\n                let message = \"ðŸ“Š STOCK MARKET ALERT ðŸ“Š\\n\";\n                topChanges.forEach(stock => {\n                    const changeDir = stock.changePercent > 0 ? \"up\" : \"down\";\n                    const displayPrice = stock.price.toFixed(2);\n                    const changePercent = Math.abs(Math.round(stock.changePercent));\n\n                    message += `${stock.id} (${stock.sector}): ${changeDir} ${changePercent}% to $${displayPrice}!\\n`;\n                });\n\n                if (activeEvent) {\n                    message += `\\nCurrent market event: ${activeEvent.name}`;\n                }\n\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            } else {\n                console.log(\"No online players to send alert to.\");\n            }\n        } else {\n            console.log(\"No significant changes to alert players about.\");\n        }\n    } catch (error) {\n        console.log(`FATAL Error in updateStockPrices: ${error.message}`);\n        // Optionally, send an admin message if a fatal error occurs\n        // await takaro.gameserver.gameServerControllerSendMessage(data.gameServerId, {\n        //     message: `ðŸš¨ Market Error: An error occurred during stock update: ${error.message}`\n        // });\n    }\n}\n\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        console.log(\"Initializing market if needed...\");\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in module configuration for initialization.\");\n            return;\n        }\n\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_data'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['last_market_event_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_start_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['active_market_event'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_initialized'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_execution_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_cooldown_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['current_event_duration'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } })\n            ]);\n\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n        console.log(\"Mapped initial stocks from config.\");\n\n        const createPromises = [];\n\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_data', value: JSON.stringify(stocks), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'last_market_event_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_start_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'active_market_event', value: '', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_execution_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (cooldownCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_cooldown_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventDurationVar.data.data.length === 0) {\n            const defaultDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'current_event_duration', value: defaultDuration.toString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_initialized', value: 'true', gameServerId, moduleId: mod.moduleId }));\n        }\n\n        if (createPromises.length > 0) {\n            console.log(`Creating ${createPromises.length} initial market variables.`);\n            await Promise.allSettled(createPromises);\n        } else {\n            console.log(\"All market variables already exist, no new initialization needed.\");\n        }\n\n        if (marketDataVar.data.data.length === 0) { // Only announce if we actually created the stock_market_data variable\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /market to see available stocks and /buy to start investing.\";\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, { message });\n            }\n        }\n        console.log(\"Market initialization process complete.\");\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "updatestockprices",
                    "description": null,
                    "temporalValue": "0 */1 * * *"
                }
            ],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Allows the player to view market prices and their portfolio",
                    "permission": "STOCK_MARKET_USE",
                    "friendlyName": "Use Stock Market"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows the player to buy and sell stocks",
                    "permission": "STOCK_MARKET_TRADE",
                    "friendlyName": "Trade Stocks"
                },
                {
                    "canHaveCount": false,
                    "description": "VIP status that reduces transaction fees",
                    "permission": "STOCK_MARKET_BROKER",
                    "friendlyName": "Stock Broker"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows admins to manually trigger market events",
                    "permission": "STOCK_MARKET_TRIGGER_EVENT",
                    "friendlyName": "Trigger Market Events"
                }
            ]
        },
        {
            "tag": "0.1.15",
            "description": "**Stock Market: A Dynamic Virtual Trading System**\n\nCreate an immersive economic experience with this comprehensive stock market module that lets players invest, trade, and react to market events.\n\n**Market Features:**\n\n![Market Summary](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stocks.png)\n\n* **Multiple Economic Sectors:** Configure various industry sectors (Resource Extraction, Manufacturing, Defense, etc.) each with their own market dynamics.\n* **Realistic Stock Behavior:** Stocks have configurable volatility, sector-based pricing, and react differently to market events.\n* **Dynamic Market Events:** Random or admin-triggered events like \"Horde Night Approaching\" or \"Societal Collapse Setback\" impact different sectors in realistic ways.\n\n![Market Events](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_events.png)\n\n**Trading System:**\n\n* **Buy & Sell Shares:** Players can purchase stocks and sell them later for profit or loss.\n* **Transaction Fees:** Configurable fee percentage on all trades creates a realistic market economy.\n* **VIP Benefits:** Special permissions for designated \"Stock Brokers\" who receive fee discounts.\n\n![Buy Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_buy.png)\n\nPlayers can track price changes and sell at the right moment to maximize profits or minimize losses.\n\n![Sell Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sell.png)\n\n**Player Portfolio:**\n\n* **Portfolio Tracking:** Players can view their holdings, average purchase prices, and current profit/loss.\n* **Transaction History:** System tracks all buy/sell transactions for each player.\n* **Summary Statistics:** See overall portfolio performance and value across all holdings.\n\n![Portfolio View](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockportfolio.png)\n\n**Market Information:**\n\n* **Detailed Stock Info:** Players can research specific stocks, including risk levels and sector trends.\n* **Industry Filters:** View stocks by specific sectors to better understand market segments.\n* **Market Alerts:** Server-wide notifications for significant price changes keep players engaged.\n\n![Market Alerts](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockpricechange.png)\n\n**Configuration Options:**\n\n* **Sectors & Stocks:** Define your own market sectors and individual stocks with customizable starting prices and volatility.\n* **Market Events:** Create unique events with specific sector impacts to drive market dynamics.\n* **Transaction Settings:** Configure fee percentages, VIP discounts, and alert thresholds.\n* **Event Frequency:** Control how often random market events occur and how long they last.\n\n![Configuration](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_config.png)\n![Sectors](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sectors.png)\n\n**Commands:**\n\n* `/markets [industry]` - View all stocks or filter by industry\n* `/stockinfo [ticker]` - Get detailed information about a specific stock\n* `/buystock <ticker> <amount>` - Purchase shares of a stock\n* `/sellstock <ticker> <amount>` - Sell shares from your portfolio\n* `/stockportfolio` - View your current holdings and performance\n* `/triggerevent [event]` - Admin command to trigger specific market events\n\nWho says the apocalypse can't have a thriving economy? Now players can stress about both zombie hordes AND their Duke's Casino Tokens dropping 40% after a market event! As one trader put it: \"I used to check my 401K daily, and now I check my AMMO stock before every Blood Moon. Some habits die harder than zombies.\"",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sectors\":{\"type\":\"array\",\"title\":\"Wasteland Economic Sectors\",\"description\":\"Define economic sectors relevant to survival in Navezgane\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Sector ID (e.g., Very Low Risk)\"},\"name\":{\"type\":\"string\",\"description\":\"Sector name (e.g., Very Low Risk)\"}}},\"default\":[{\"id\":\"Very High Risk\",\"name\":\"Very High Risk\"},{\"id\":\"High Risk\",\"name\":\"High Risk\"},{\"id\":\"Medium Risk\",\"name\":\"Medium Risk\"},{\"id\":\"Low Risk\",\"name\":\"Low Risk\"},{\"id\":\"Very Low Risk\",\"name\":\"Very Low Risk\"}]},\"stocks\":{\"type\":\"array\",\"title\":\"Wasteland Stocks\",\"description\":\"List of stocks representing Navezgane entities and resources\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Stock ticker symbol (e.g., NMC)\"},\"name\":{\"type\":\"string\",\"description\":\"Entity/Resource name\"},\"sector\":{\"type\":\"string\",\"description\":\"Sector ID this stock belongs to\"},\"initialPrice\":{\"type\":\"number\",\"description\":\"Starting price in Dukes\",\"minimum\":1},\"volatility\":{\"type\":\"number\",\"description\":\"Base volatility percentage (5 = 5%)\",\"minimum\":1,\"maximum\":60}}},\"default\":[{\"id\":\"NMC\",\"name\":\"Navezgane Mining Co.\",\"sector\":\"High Risk\",\"initialPrice\":50,\"volatility\":15},{\"id\":\"NIOM\",\"name\":\"Navezgane Iron Ore Mining Co.\",\"sector\":\"High Risk\",\"initialPrice\":55,\"volatility\":16},{\"id\":\"NLMC\",\"name\":\"Navezgane Lead Mining Co.\",\"sector\":\"Medium Risk\",\"initialPrice\":45,\"volatility\":14},{\"id\":\"WOOD\",\"name\":\"Wasteland Lumberjacks\",\"sector\":\"Low Risk\",\"initialPrice\":20,\"volatility\":8},{\"id\":\"SHALE\",\"name\":\"Oil Shale Extractors\",\"sector\":\"Very High Risk\",\"initialPrice\":40,\"volatility\":45},{\"id\":\"FORGE\",\"name\":\"Forge Ahead Metals\",\"sector\":\"Medium Risk\",\"initialPrice\":75,\"volatility\":12},{\"id\":\"TOOLS\",\"name\":\"Working Stiff Tools\",\"sector\":\"Low Risk\",\"initialPrice\":60,\"volatility\":10},{\"id\":\"AIA\",\"name\":\"A1 Auto\",\"sector\":\"Medium Risk\",\"initialPrice\":40,\"volatility\":14},{\"id\":\"AMC\",\"name\":\"Atlas Metal Company\",\"sector\":\"Medium Risk\",\"initialPrice\":65,\"volatility\":13},{\"id\":\"COC\",\"name\":\"COC Chemicals\",\"sector\":\"Very High Risk\",\"initialPrice\":55,\"volatility\":50},{\"id\":\"MECH\",\"name\":\"JunkTech Robotics\",\"sector\":\"High Risk\",\"initialPrice\":110,\"volatility\":25},{\"id\":\"BUILD\",\"name\":\"Barricade Builders\",\"sector\":\"Low Risk\",\"initialPrice\":45,\"volatility\":9},{\"id\":\"ZBI\",\"name\":\"Zombie Bashers Inc.\",\"sector\":\"High Risk\",\"initialPrice\":85,\"volatility\":17},{\"id\":\"TTC\",\"name\":\"Turret Tracker Co.\",\"sector\":\"Very High Risk\",\"initialPrice\":125,\"volatility\":60},{\"id\":\"AMMO\",\"name\":\"AmmoNation Surplus\",\"sector\":\"Very High Risk\",\"initialPrice\":90,\"volatility\":35},{\"id\":\"SHM\",\"name\":\"Shotgun Messiah\",\"sector\":\"Very High Risk\",\"initialPrice\":120,\"volatility\":30},{\"id\":\"SHAM\",\"name\":\"Shamway Foods\",\"sector\":\"Very Low Risk\",\"initialPrice\":30,\"volatility\":5},{\"id\":\"SSHM\",\"name\":\"Super Shamway\",\"sector\":\"Very Low Risk\",\"initialPrice\":32,\"volatility\":4},{\"id\":\"MEDS\",\"name\":\"Pop-N-Pills Medical\",\"sector\":\"Very High Risk\",\"initialPrice\":100,\"volatility\":48},{\"id\":\"SAVG\",\"name\":\"Savage Country\",\"sector\":\"Low Risk\",\"initialPrice\":35,\"volatility\":6},{\"id\":\"CRKB\",\"name\":\"Crack-A-Book\",\"sector\":\"High Risk\",\"initialPrice\":80,\"volatility\":16},{\"id\":\"TRADE\",\"name\":\"Trader Guild Network\",\"sector\":\"Very High Risk\",\"initialPrice\":150,\"volatility\":40},{\"id\":\"PNG\",\"name\":\"Pass-N-Gas\",\"sector\":\"Medium Risk\",\"initialPrice\":50,\"volatility\":11},{\"id\":\"BOB\",\"name\":\"Trader Bob's\",\"sector\":\"Low Risk\",\"initialPrice\":160,\"volatility\":9},{\"id\":\"HUGH\",\"name\":\"Trader Hugh's\",\"sector\":\"Medium Risk\",\"initialPrice\":170,\"volatility\":12},{\"id\":\"JEN\",\"name\":\"Trader Jen's\",\"sector\":\"Low Risk\",\"initialPrice\":180,\"volatility\":10},{\"id\":\"JOEL\",\"name\":\"Trader Joel's\",\"sector\":\"Low Risk\",\"initialPrice\":175,\"volatility\":11},{\"id\":\"REKT\",\"name\":\"Trader Rekt's\",\"sector\":\"Low Risk\",\"initialPrice\":165,\"volatility\":6},{\"id\":\"DUKES\",\"name\":\"Duke's Casino Tokens\",\"sector\":\"Very Low Risk\",\"initialPrice\":1,\"volatility\":3}]},\"marketEvents\":{\"type\":\"array\",\"title\":\"Wasteland Events\",\"description\":\"Events impacting the Navezgane economy\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Unique event ID\"},\"name\":{\"type\":\"string\",\"description\":\"Name of the event\"},\"description\":{\"type\":\"string\",\"description\":\"Description of the event's market effect\"},\"sectorImpacts\":{\"type\":\"array\",\"description\":\"How each sector is affected\",\"items\":{\"type\":\"object\",\"properties\":{\"sectorId\":{\"type\":\"string\",\"description\":\"Sector ID\"},\"impact\":{\"type\":\"number\",\"description\":\"Percentage impact (-99 = -99%)\",\"minimum\":-99,\"maximum\":75}}}}}},\"default\":[{\"id\":\"HORDE_INCOMING\",\"name\":\"Horde Night Approaching\",\"description\":\"Increased Zed activity signals the Blood Moon. Very High and High Risk defense stocks soar, while Very Low Risk stocks see minimal impact.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":50},{\"sectorId\":\"High Risk\",\"impact\":30},{\"sectorId\":\"Medium Risk\",\"impact\":15},{\"sectorId\":\"Low Risk\",\"impact\":5},{\"sectorId\":\"Very Low Risk\",\"impact\":1}]},{\"id\":\"STABLE_ECONOMY\",\"name\":\"Period of Stability\",\"description\":\"A rare period of peace has settled over the wasteland. Very Low and Low Risk assets flourish, with higher risk stocks seeing less significant gains. High risk assets might see slight pull-back.\",\"sectorImpacts\":[{\"sectorId\":\"Very Low Risk\",\"impact\":15},{\"sectorId\":\"Low Risk\",\"impact\":10},{\"sectorId\":\"Medium Risk\",\"impact\":5},{\"sectorId\":\"High Risk\",\"impact\":-5},{\"sectorId\":\"Very High Risk\",\"impact\":-10}]},{\"id\":\"GENERAL_PANIC\",\"name\":\"General Market Panic\",\"description\":\"A major setback reminds everyone how fragile survival is. Fear grips the entire market, causing higher volatility sectors to plummet.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-90},{\"sectorId\":\"High Risk\",\"impact\":-70},{\"sectorId\":\"Medium Risk\",\"impact\":-45},{\"sectorId\":\"Low Risk\",\"impact\":-20},{\"sectorId\":\"Very Low Risk\",\"impact\":-10}]},{\"id\":\"ADVANCED_WEAPONRY_COLLAPSE\",\"name\":\"Turret AI Virus\",\"description\":\"A malicious code is spreading through advanced turret systems, causing them to malfunction violently. Very High Risk weaponry stocks are obliterated.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-99},{\"sectorId\":\"High Risk\",\"impact\":-20}]},{\"id\":\"VOLATILE_CHEMICALS_COLLAPSE\",\"name\":\"Irreversible Contamination\",\"description\":\"A major chemical disaster has occurred. Very High Risk chemical stocks are worthless, impacting related sectors.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-99},{\"sectorId\":\"High Risk\",\"impact\":-25},{\"sectorId\":\"Medium Risk\",\"impact\":-10}]},{\"id\":\"FOSSIL_FUELS_COLLAPSE\",\"name\":\"Clean Energy Breakthrough\",\"description\":\"A new energy source has been discovered. Very High Risk fossil fuel stocks become obsolete, while other sectors see minor adjustments.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-99},{\"sectorId\":\"Medium Risk\",\"impact\":10},{\"sectorId\":\"Low Risk\",\"impact\":5}]},{\"id\":\"PHARMACEUTICALS_COLLAPSE\",\"name\":\"The Cure is Real\",\"description\":\"A cure for the zombie infection has been found! Very High Risk pharmaceutical stocks are wiped out, and even low-risk survival goods see a hit.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-99},{\"sectorId\":\"High Risk\",\"impact\":-30},{\"sectorId\":\"Medium Risk\",\"impact\":-15},{\"sectorId\":\"Low Risk\",\"impact\":-10},{\"sectorId\":\"Very Low Risk\",\"impact\":-5}]},{\"id\":\"GUILD_OPERATIONS_COLLAPSE\",\"name\":\"Trader Guild Dissolved\",\"description\":\"The Trader's Guild has been formally dissolved. Very High Risk trade operation stocks become worthless, affecting overall trade.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-99},{\"sectorId\":\"High Risk\",\"impact\":-40},{\"sectorId\":\"Medium Risk\",\"impact\":-20},{\"sectorId\":\"Low Risk\",\"impact\":-10}]},{\"id\":\"AMMUNITION_DEPLETION\",\"name\":\"Ammunition Shortage\",\"description\":\"A major supply chain disruption has caused ammunition stockpiles to dwindle. Very High Risk ammunition stocks plummet.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-99},{\"sectorId\":\"High Risk\",\"impact\":-30},{\"sectorId\":\"Medium Risk\",\"impact\":-15}]},{\"id\":\"RESOURCE_BOOM\",\"name\":\"Resource Discovery\",\"description\":\"A massive new ore deposit has been found! All resource-related stocks are surging, with higher risk ones seeing the biggest gains.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":60},{\"sectorId\":\"High Risk\",\"impact\":40},{\"sectorId\":\"Medium Risk\",\"impact\":20},{\"sectorId\":\"Low Risk\",\"impact\":10}]},{\"id\":\"MANUFACTURING_SURGE\",\"name\":\"Innovation Breakthrough\",\"description\":\"New manufacturing techniques have greatly increased production efficiency. Manufacturing stocks are up across the board.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":40},{\"sectorId\":\"High Risk\",\"impact\":30},{\"sectorId\":\"Medium Risk\",\"impact\":20},{\"sectorId\":\"Low Risk\",\"impact\":10},{\"sectorId\":\"Very Low Risk\",\"impact\":5}]},{\"id\":\"TRADE_ROUTE_OPENED\",\"name\":\"New Trade Route Established\",\"description\":\"A secure trade route has been opened, boosting commerce. Trade-related stocks are seeing significant gains.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":50},{\"sectorId\":\"High Risk\",\"impact\":30},{\"sectorId\":\"Medium Risk\",\"impact\":20},{\"sectorId\":\"Low Risk\",\"impact\":15},{\"sectorId\":\"Very Low Risk\",\"impact\":10}]},{\"id\":\"MARKET_CORRECTION\",\"name\":\"Market Correction Wave\",\"description\":\"After a period of unusual growth, the market corrects itself. All sectors see a downturn.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-50},{\"sectorId\":\"High Risk\",\"impact\":-35},{\"sectorId\":\"Medium Risk\",\"impact\":-25},{\"sectorId\":\"Low Risk\",\"impact\":-15},{\"sectorId\":\"Very Low Risk\",\"impact\":-10}]},{\"id\":\"GLOBAL_SLOWDOWN\",\"name\":\"Global Economic Slowdown\",\"description\":\"Uncertainty spreads across all sectors, leading to a general market downturn. Less severe than a full panic, but widespread.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-30},{\"sectorId\":\"High Risk\",\"impact\":-20},{\"sectorId\":\"Medium Risk\",\"impact\":-15},{\"sectorId\":\"Low Risk\",\"impact\":-10},{\"sectorId\":\"Very Low Risk\",\"impact\":-5}]}]},\"eventFrequency\":{\"title\":\"Event Frequency\",\"type\":\"number\",\"description\":\"Average number of update cycles between market events (0 to disable). Depends on mod's update frequency (e.g., per in-game hour?).\",\"default\":8,\"minimum\":1},\"defaultEventDuration\":{\"title\":\"Default Event Duration\",\"type\":\"number\",\"description\":\"Default number of update cycles an event lasts.\",\"default\":3,\"minimum\":1,\"maximum\":96},\"transactionFee\":{\"title\":\"Transaction Fee (Dukes Tax)\",\"type\":\"number\",\"description\":\"Percentage fee charged on all buy/sell transactions (5 = 5%)\",\"default\":3,\"minimum\":0,\"maximum\":25},\"vipDiscount\":{\"title\":\"Trader's Favor Discount\",\"type\":\"number\",\"description\":\"Percentage discount on transaction fees for players with 'STOCK_MARKET_BROKER' permission (50 = 50%)\",\"default\":50,\"minimum\":0,\"maximum\":100},\"priceAlertThreshold\":{\"title\":\"Price Alert Threshold\",\"type\":\"number\",\"description\":\"Percentage change that triggers a market alert (15 = 15%)\",\"default\":15,\"minimum\":5,\"maximum\":50},\"marketNewsChannelId\":{\"title\":\"Discord Channel ID (for Market News)\",\"type\":\"string\",\"description\":\"The ID of the Discord channel where market news messages should be posted. Leave empty to disable.\",\"default\":\"\"}},\"additionalProperties\":false}",
            "uiSchema": "{\"sectors\":{\"items\":{\"ui:order\":[\"id\",\"name\"]}},\"stocks\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"sector\",\"initialPrice\",\"volatility\"]}},\"marketEvents\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"description\",\"sectorImpacts\"],\"sectorImpacts\":{\"items\":{\"ui:order\":[\"sectorId\",\"impact\"]}}}},\"transactionFee\":{\"ui:widget\":\"range\"},\"vipDiscount\":{\"ui:widget\":\"range\"},\"eventFrequency\":{\"ui:help\":\"Set to 0 to disable random events\"},\"priceAlertThreshold\":{\"ui:widget\":\"range\"}}",
            "commands": [
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // Get player's portfolio\n    const portfolioVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_portfolio'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId],\n            playerId: [player.id]\n        }\n    });\n\n    let portfolio = {};\n    if (portfolioVar.data.data.length > 0) {\n        portfolio = JSON.parse(portfolioVar.data.data[0].value);\n    }\n\n    // Send header\n    await player.pm(\"=== YOUR STOCK PORTFOLIO ===\");\n\n    let hasStocks = false;\n    let totalValue = 0;\n    let totalInvestment = 0;\n\n    // If no stocks, send a simple message\n    if (Object.keys(portfolio).length === 0) {\n        await player.pm(\"You don't own any stocks yet.\\n\" +\n            \"Use /markets to see available stocks and prices.\\n\" +\n            \"Use /buy <stock> <amount> to purchase stocks.\");\n        return;\n    }\n\n    // Helper function to format numbers with commas and a dollar sign\n    const formatNumber = (num) => {\n        return `$${Math.round(num).toLocaleString()}`;\n    };\n\n    // Send each stock as a separate message to avoid length issues\n    for (const [stockId, data] of Object.entries(portfolio)) {\n        hasStocks = true;\n        const stock = stocks.find(s => s.id === stockId);\n        if (!stock) continue; // Stock might have been removed from config\n\n        const currentValue = stock.price * data.shares;\n        const investmentValue = data.averagePrice * data.shares;\n        totalValue += currentValue;\n        totalInvestment += investmentValue;\n        const profit = currentValue - investmentValue;\n        const profitPercent = ((profit / investmentValue) * 100).toFixed(1);\n\n        let stockMessage = `--- ${stockId} (${stock.sector}) ---\\n`;\n        stockMessage += `Shares: ${data.shares}\\n`;\n        stockMessage += `Avg buy: ${formatNumber(data.averagePrice)}\\n`;\n        stockMessage += `Current price: ${formatNumber(stock.price)}\\n`;\n        stockMessage += `Total value: ${formatNumber(currentValue)}\\n`;\n\n        if (profit >= 0) {\n            stockMessage += `Profit: +${formatNumber(profit)} (+${profitPercent}%)\\n`;\n        } else {\n            stockMessage += `Loss: -${formatNumber(Math.abs(profit))} (${profitPercent}%)\\n`;\n        }\n\n        await player.pm(stockMessage);\n    }\n\n    if (hasStocks) {\n        const totalProfit = totalValue - totalInvestment;\n        const totalProfitPercent = ((totalProfit / totalInvestment) * 100).toFixed(1);\n\n        let summaryMessage = \"=== PORTFOLIO SUMMARY ===\\n\";\n        summaryMessage += `Total investment: ${formatNumber(totalInvestment)}\\n`;\n        summaryMessage += `Current value: ${formatNumber(totalValue)}\\n`;\n\n        if (totalProfit >= 0) {\n            summaryMessage += `Overall profit: +${formatNumber(totalProfit)} (+${totalProfitPercent}%)\\n`;\n        } else {\n            summaryMessage += `Overall loss: -${formatNumber(Math.abs(totalProfit))} (${totalProfitPercent}%)\\n`;\n        }\n\n        // Get transaction history count\n        try {\n            const historyVar = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: ['stock_transaction_history'],\n                    gameServerId: [gameServerId],\n                    moduleId: [mod.moduleId],\n                    playerId: [player.id]\n                }\n            });\n\n            if (historyVar.data.data.length > 0) {\n                const history = JSON.parse(historyVar.data.data[0].value);\n                const buyCount = history.filter(t => t.type === 'BUY').length;\n                const sellCount = history.filter(t => t.type === 'SELL').length;\n\n                summaryMessage += `\\nTransactions: ${history.length} (${buyCount} buys, ${sellCount} sells)\\n`;\n            }\n        } catch (error) {\n            // Just ignore history errors\n        }\n\n        await player.pm(summaryMessage);\n    }\n}\n\nawait main();",
                    "name": "stockportfolio",
                    "description": null,
                    "trigger": "stockportfolio",
                    "helpText": "No help text available",
                    "arguments": []
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get player's portfolio\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        if (portfolioVar.data.data.length === 0) {\n            throw new TakaroUserError(\"You don't own any stocks to sell.\");\n        }\n\n        const portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        const stockId = args.stock.toUpperCase();\n\n        if (!portfolio[stockId] || portfolio[stockId].shares < amount) {\n            throw new TakaroUserError(`You don't own ${amount} shares of ${stockId}.`);\n        }\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === stockId);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${stockId} not found in current market data. Please contact an admin.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate sale proceeds using Math.round to ensure we work with integers\n        const stockPrice = Math.round(stock.price);\n        const subtotal = stockPrice * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const netProceeds = subtotal - fee;\n\n        // Add money to player - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerAddCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: netProceeds\n            }\n        );\n\n        // Calculate profit/loss\n        const profitPerShare = stockPrice - portfolio[stockId].averagePrice;\n        const totalProfit = Math.round(profitPerShare * amount);\n        const profitText = totalProfit >= 0\n            ? `profit of $${totalProfit}`\n            : `loss of $${Math.abs(totalProfit)}`;\n\n        // Update portfolio\n        portfolio[stockId].shares -= amount;\n        if (portfolio[stockId].shares === 0) {\n            delete portfolio[stockId];\n        }\n\n        // Save updated portfolio\n        await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n            value: JSON.stringify(portfolio)\n        });\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'SELL',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: netProceeds,\n            profit: totalProfit,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully sold ${amount} shares of ${stockId} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Net proceeds: $${netProceeds} (${profitText})`;\n\n        // Add remaining shares info if player still has some\n        if (portfolio[stockId]) {\n            message += `\\nRemaining shares: ${portfolio[stockId].shares}`;\n        } else {\n            message += `\\nYou've sold all your ${stockId} shares.`;\n        }\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in sellstock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your sale. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "sellstock",
                    "description": null,
                    "trigger": "sellstock",
                    "helpText": "Sell shares of a stock",
                    "arguments": [
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to sell",
                            "position": 1
                        },
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Handle the industry argument - use \"ALL\" as a special value to show all industries\n    const industryFilter = args.Industry ? args.Industry.toUpperCase() : \"ALL\";\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    // If market data doesn't exist, try to initialize it\n    if (marketDataVar.data.data.length === 0) {\n        const initialized = await initializeMarketIfNeeded(gameServerId, mod);\n        if (!initialized) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        // Get the freshly initialized market data\n        const refreshedMarketData = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (refreshedMarketData.data.data.length === 0) {\n            throw new TakaroUserError(\"There was an issue initializing the stock market. Please try again later.\");\n        }\n\n        // Continue with the refreshed data\n        await displayMarketSummary(player, gameServerId, mod, refreshedMarketData.data.data[0], industryFilter);\n    } else {\n        // Market data exists, display it\n        await displayMarketSummary(player, gameServerId, mod, marketDataVar.data.data[0], industryFilter);\n    }\n}\n\n// Display the market summary to the player\nasync function displayMarketSummary(player, gameServerId, mod, marketDataVariable, industryFilter) {\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Handle empty string or empty object\n            if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (e) {\n            // In case of parsing error\n            activeEvent = null;\n        }\n    }\n\n    const stocks = JSON.parse(marketDataVariable.value);\n\n    // Get all available industries for reference\n    const availableIndustries = [...new Set(stocks.map(stock => stock.sector))];\n\n    // If industry filter is provided and not \"ALL\", check if it's valid\n    if (industryFilter !== \"ALL\") {\n        // Check if the industry exists\n        const industryExists = availableIndustries.includes(industryFilter);\n\n        if (!industryExists) {\n            throw new TakaroUserError(`Industry \"${industryFilter}\" not found. Available industries: ${availableIndustries.join(', ')}\\nUse \"ALL\" to view all industries.`);\n        }\n    }\n\n    // Send header message\n    let headerMessage = \"=== STOCK MARKET SUMMARY ===\\n\";\n\n    // If filtering by industry, mention it in the header\n    if (industryFilter !== \"ALL\") {\n        headerMessage = `=== ${industryFilter} INDUSTRY ===\\n`;\n    }\n\n    // If there's an active event, include it in the header\n    if (activeEvent) {\n        headerMessage += `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n`;\n        headerMessage += `${activeEvent.description}\\n\\n`;\n\n        // If filtering by industry, only show relevant impacts\n        if (industryFilter !== \"ALL\") {\n            const relevantImpact = activeEvent.sectorImpacts.find(\n                impact => impact.sectorId === industryFilter\n            );\n\n            if (relevantImpact) {\n                const direction = relevantImpact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `Industry Impact: ${direction} ${Math.abs(relevantImpact.impact)}%\\n`;\n            } else {\n                headerMessage += \"This industry is not directly affected by the current event.\\n\";\n            }\n        } else {\n            // Show all industry impacts\n            headerMessage += \"Industry Impacts:\\n\";\n            for (const impact of activeEvent.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%\\n`;\n            }\n        }\n    }\n\n    // Send header message first\n    await player.pm(headerMessage);\n\n    // Group stocks by industry\n    const stocksByIndustry = {};\n    stocks.forEach(stock => {\n        if (!stocksByIndustry[stock.sector]) {\n            stocksByIndustry[stock.sector] = [];\n        }\n        stocksByIndustry[stock.sector].push(stock);\n    });\n\n    // If industry filter is not \"ALL\", only show that industry\n    if (industryFilter !== \"ALL\") {\n        const filteredStocks = stocksByIndustry[industryFilter] || [];\n\n        if (filteredStocks.length > 0) {\n            let stockMessage = \"\";\n\n            filteredStocks.forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                stockMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(stockMessage);\n        } else {\n            await player.pm(`No stocks found in the ${industryFilter} industry.`);\n        }\n    } else {\n        // Send each industry as a separate message\n        for (const industryId in stocksByIndustry) {\n            let industryMessage = `=== ${industryId} INDUSTRY ===\\n`;\n\n            stocksByIndustry[industryId].forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                industryMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(industryMessage);\n        }\n    }\n\n    // Add a help message for industry filtering if showing all industries\n    if (industryFilter === \"ALL\") {\n        const allIndustries = Object.keys(stocksByIndustry).join(', ');\n        await player.pm(`\\nTip: Use '/markets [industry]' to view only stocks in a specific industry. Available industries: ${allIndustries}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return false;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            const results = await Promise.allSettled(createPromises);\n            // Check if the critical stock_market_data was created successfully\n            const stockDataPromise = results[0];\n            if (stockDataPromise && stockDataPromise.status === 'rejected') {\n                console.log(`Failed to create stock_market_data: ${stockDataPromise.reason}`);\n                return false;\n            }\n        }\n\n        return true;\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n        return false;\n    }\n}\n\nawait main();",
                    "name": "markets",
                    "description": null,
                    "trigger": "markets",
                    "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. \n",
                    "arguments": [
                        {
                            "name": "Industry",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. ",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // If a specific stock ticker is provided, show detailed info for that stock\n    const specificTicker = args.ticker ? args.ticker.toUpperCase() : null;\n\n    if (specificTicker && specificTicker !== \"ALL\") {\n        const stock = stocks.find(s => s.id.toUpperCase() === specificTicker);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${specificTicker} not found. Use /stockinfo without parameters to see all available stocks.`);\n        }\n\n        // Get active event to see if this stock's sector is affected\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let activeEvent = null;\n        let sectorImpact = null;\n\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEvent && activeEvent.sectorImpacts) {\n                    sectorImpact = activeEvent.sectorImpacts.find(impact =>\n                        impact.sectorId === stock.sector\n                    );\n                }\n            } catch (e) {\n                // Ignore parsing errors\n            }\n        }\n\n        // Calculate price change indicators\n        let changeText = '';\n        if (stock.lastPrice) {\n            const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n            const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n            changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n        }\n\n        // Add risk assessment based on volatility without showing the raw value\n        let riskLevel;\n        if (stock.volatility <= 0.05) riskLevel = \"Very Low\";\n        else if (stock.volatility <= 0.10) riskLevel = \"Low\";\n        else if (stock.volatility <= 0.15) riskLevel = \"Moderate\";\n        else if (stock.volatility <= 0.20) riskLevel = \"High\";\n        else riskLevel = \"Very High\";\n\n        // Build detailed stock info message\n        let message = `=== ${stock.id}: ${stock.name} ===\\n\\n`;\n        message += `Sector: ${stock.sector}\\n`;\n        message += `Current Price: $${Math.round(stock.price)}${changeText}\\n`;\n        message += `Risk Level: ${riskLevel}\\n`;\n\n        // Add sector trend info if available from event\n        if (activeEvent && sectorImpact) {\n            const direction = sectorImpact.impact >= 0 ? \"Positive\" : \"Negative\";\n            const strength = Math.abs(sectorImpact.impact);\n            let trend;\n\n            if (strength < 10) trend = \"Slight\";\n            else if (strength < 25) trend = \"Moderate\";\n            else trend = \"Strong\";\n\n            message += `\\nCurrent Trend: ${trend} ${direction} (${activeEvent.name})\\n`;\n            message += `Event: ${activeEvent.description}\\n`;\n        }\n\n        // Add trading guidance based on sector and risk, without mentioning volatility\n        message += `\\nTrading Notes:\\n`;\n\n        if (activeEvent && sectorImpact) {\n            if (sectorImpact.impact > 0) {\n                message += `- Currently bullish due to the ${activeEvent.name} event\\n`;\n            } else {\n                message += `- Currently bearish due to the ${activeEvent.name} event\\n`;\n            }\n        }\n\n        if (riskLevel === \"High\" || riskLevel === \"Very High\") {\n            message += `- Expect significant price fluctuations with this stock\\n`;\n        } else if (riskLevel === \"Low\" || riskLevel === \"Very Low\") {\n            message += `- Typically has stable price movement\\n`;\n        }\n\n        message += `\\nUse /buystock ${stock.id} [amount] to purchase shares`;\n\n        await player.pm(message);\n\n    } else {\n        // No specific ticker provided or ALL specified, show summary of all stocks\n        await player.pm(\"=== STOCK MARKET LISTINGS ===\\n\");\n\n        // Group stocks by sector\n        const stocksBySector = {};\n        stocks.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        // MODIFICATION START\n        // Display stocks by sector, chunking them into messages of 3\n        const chunkSize = 3;\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            for (let i = 0; i < sectorStocks.length; i += chunkSize) {\n                const chunk = sectorStocks.slice(i, i + chunkSize);\n\n                // Add the sector header only to the first message for that sector.\n                let sectorMessage = (i === 0) ? `\\n--- ${sector} SECTOR ---\\n` : '';\n\n                chunk.forEach(stock => {\n                    // Add price change indicators\n                    let changeText = '';\n                    if (stock.lastPrice) {\n                        const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                        const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                        changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                    }\n\n                    // Add risk level based on volatility\n                    let riskIndicator;\n                    if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                    else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                    else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                    else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                    else riskIndicator = \"VH\";\n\n                    sectorMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n                });\n\n                await player.pm(sectorMessage);\n            }\n        }\n        // MODIFICATION END\n\n        // Add legend for risk indicators\n        const legend = \"\\n=== LEGEND ===\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\" +\n            \"Use /stockinfo [ticker] for detailed information about a specific stock\";\n\n        await player.pm(legend);\n    }\n}\n\nawait main();",
                    "name": "stockinfo",
                    "description": null,
                    "trigger": "stockinfo",
                    "helpText": "Shows all available stocks in the market. Use with a ticker symbol (e.g., /stockinfo ticker) to see detailed information about a specific stock.",
                    "arguments": [
                        {
                            "name": "ticker",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "stock ticker or ALL to get detailed information about a specific stock",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRIGGER_EVENT')) {\n        throw new TakaroUserError(\"You don't have permission to trigger market events.\");\n    }\n\n    try {\n        // Get current stock data to check market initialization\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Initialize market if needed\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            await player.pm(\"Market was not initialized. Initializing now...\");\n            return;\n        }\n\n        // Get events from module config\n        const marketEvents = mod.userConfig.marketEvents || [];\n\n        if (marketEvents.length === 0) {\n            throw new TakaroUserError(\"No market events configured in this module.\");\n        }\n\n        // Handle case when no event is specified or \"ALL\" is provided\n        if (!args.EventName || args.EventName.toUpperCase() === \"ALL\") {\n            await player.pm(\"=== AVAILABLE MARKET EVENTS ===\\n\");\n\n            // Group events by category or type if possible\n            const eventCategories = {};\n\n            // Create a simple categorization based on positive/negative impact\n            marketEvents.forEach(event => {\n                let category = \"Mixed\";\n                // Calculate net impact across all sectors\n                const netImpact = event.sectorImpacts.reduce((sum, impact) => sum + impact.impact, 0);\n\n                if (netImpact > 0) category = \"Positive\";\n                else if (netImpact < 0) category = \"Negative\";\n\n                if (!eventCategories[category]) {\n                    eventCategories[category] = [];\n                }\n                eventCategories[category].push(event);\n            });\n\n            // Display events by category\n            for (const [category, events] of Object.entries(eventCategories)) {\n                if (events.length > 0) {\n                    await player.pm(`\\n--- ${category.toUpperCase()} EVENTS ---`);\n\n                    let message = \"\";\n                    events.forEach(event => {\n                        // Format primary sectors affected\n                        const primarySectors = event.sectorImpacts\n                            .filter(impact => Math.abs(impact.impact) >= 15)\n                            .map(impact => {\n                                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                                return `${impact.sectorId} ${direction}${Math.abs(impact.impact)}%`;\n                            })\n                            .join(\", \");\n\n                        message += `${event.id}: ${event.name}\\n`;\n                        message += `   ${event.description}\\n`;\n                        if (primarySectors) {\n                            message += `   Major impacts: ${primarySectors}\\n`;\n                        }\n                        message += \"\\n\";\n                    });\n\n                    await player.pm(message);\n                }\n            }\n\n            await player.pm(\"=== HOW TO USE ===\\nUse `/triggerevent <EventName>` to trigger a specific event (e.g., `/triggerevent TECH_BOOM`)\");\n            return;\n        }\n\n        // Find the requested event\n        const eventId = args.EventName.toUpperCase();\n        const event = marketEvents.find(e => e.id === eventId);\n\n        if (!event) {\n            throw new TakaroUserError(`Event \"${eventId}\" not found. Use /triggerevent without parameters to see all available events.`);\n        }\n\n        // Get necessary variables for managing the event\n        const [activeEventVar, eventStartTimeVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_execution_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_cooldown_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['current_event_duration'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Check if there's an active event we need to cancel\n        let activeEventObj = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEventObj = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEventObj && Object.keys(activeEventObj).length > 0) {\n                    await player.pm(`Cancelling active event \"${activeEventObj.name}\" to trigger new event.`);\n                }\n            } catch (e) {\n                // Invalid event data, will be overwritten\n            }\n        }\n\n        // Generate a random duration for the event\n        const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n        // Update or create all event-related variables\n        const updatePromises = [];\n\n        // Save or update the random duration\n        if (eventDurationVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                    value: randomDuration.toString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'current_event_duration',\n                    value: randomDuration.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the event counter to 0\n        if (eventCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the cooldown counter\n        if (cooldownCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update active event\n        if (activeEventVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                    value: JSON.stringify(event)\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: JSON.stringify(event),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update event start time\n        if (eventStartTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update last event time\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (lastEventTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all updates to complete\n        await Promise.all(updatePromises);\n\n        // Check if there are online players to announce the event\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            // Format sector impacts for announcement\n            let impactText = \"\";\n            for (const impact of event.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n            }\n\n            const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${event.name}\\n${event.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /markets to see opportunities!`;\n\n            // Split the message if it's too long\n            const maxLength = 400; // Safe limit for most games\n            for (let i = 0; i < message.length; i += maxLength) {\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message: message.substring(i, i + maxLength)\n                });\n            }\n        }\n\n        await player.pm(`Successfully triggered the \"${event.name}\" market event for ${randomDuration} cycles!`);\n    } catch (error) {\n        // If something goes wrong, log it and let the player know\n        console.log(`Error in triggerEvent: ${error.message}`);\n        throw new TakaroUserError(`Error triggering event: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Store the stocks data\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_data',\n            value: JSON.stringify(stocks),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize last event time to now\n        await takaro.variable.variableControllerCreate({\n            key: 'last_market_event_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize event start time variable\n        await takaro.variable.variableControllerCreate({\n            key: 'event_start_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize active event (empty string means no active event)\n        await takaro.variable.variableControllerCreate({\n            key: 'active_market_event',\n            value: '',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Mark market as initialized\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_initialized',\n            value: 'true',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Announce market initialization to online players\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /markets to see available stocks and /buystock to start investing.\";\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message\n            });\n        }\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "triggerevent",
                    "description": null,
                    "trigger": "triggerevent",
                    "helpText": "Shows all available market events when run without parameters. Use with an event name (e.g., /triggerevent TECH_BOOM) to trigger a specific market event.",
                    "arguments": [
                        {
                            "name": "EventName",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "Event name to trigger a specific market event",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === args.stock.toUpperCase());\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${args.stock} not found. Use /market to see available stocks.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate costs using Math.round to ensure we work with integers\n        const subtotal = Math.round(stock.price) * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const totalCost = subtotal + fee;\n\n        // Check if player has enough currency\n        const playerData = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, player.id);\n        const currentBalance = playerData.data.data.currency;\n\n        if (currentBalance < totalCost) {\n            throw new TakaroUserError(`You don't have enough currency. Cost: $${subtotal} + $${fee} fee = $${totalCost}. Your balance: $${currentBalance}`);\n        }\n\n        // Deduct the currency - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerDeductCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: totalCost\n            }\n        );\n\n        // Get player's portfolio or create new one\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        let portfolio;\n        if (portfolioVar.data.data.length === 0) {\n            portfolio = {};\n        } else {\n            portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        }\n\n        // Update portfolio using rounded values for consistency\n        const stockPrice = Math.round(stock.price);\n        if (!portfolio[stock.id]) {\n            portfolio[stock.id] = {\n                shares: amount,\n                averagePrice: stockPrice\n            };\n        } else {\n            const totalShares = portfolio[stock.id].shares + amount;\n            const totalValue = (portfolio[stock.id].shares * portfolio[stock.id].averagePrice) + (amount * stockPrice);\n            portfolio[stock.id].shares = totalShares;\n            portfolio[stock.id].averagePrice = Math.round(totalValue / totalShares);\n        }\n\n        // Save updated portfolio\n        if (portfolioVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_portfolio',\n                value: JSON.stringify(portfolio),\n                gameServerId,\n                moduleId: mod.moduleId,\n                playerId: player.id\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n                value: JSON.stringify(portfolio)\n            });\n        }\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'BUY',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: totalCost,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully bought ${amount} shares of ${stock.id} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Total cost: $${totalCost}\\n`;\n        message += `Current portfolio: ${portfolio[stock.id].shares} shares of ${stock.id}`;\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in buystock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your purchase. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "buystock",
                    "description": null,
                    "trigger": "buystock",
                    "helpText": "Buy shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol ",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to buy",
                            "position": 1
                        }
                    ]
                }
            ],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    try {\n        const { gameServerId, module: mod } = data;\n\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            console.log(\"Market data not found, initializing...\");\n            return;\n        }\n\n        const [activeEventVar, eventStartTimeVar, eventCounterVar, cooldownCounterVar, eventDurationVar] = await Promise.all([\n            takaro.variable.variableControllerSearch({ filters: { key: ['active_market_event'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n            takaro.variable.variableControllerSearch({ filters: { key: ['event_start_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n            takaro.variable.variableControllerSearch({ filters: { key: ['event_execution_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n            takaro.variable.variableControllerSearch({ filters: { key: ['event_cooldown_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n            takaro.variable.variableControllerSearch({ filters: { key: ['current_event_duration'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } })\n        ]);\n\n        let stocks;\n        try {\n            stocks = JSON.parse(marketDataVar.data.data[0].value);\n            if (!Array.isArray(stocks)) {\n                throw new Error(\"Parsed stocks data is not an array\");\n            }\n            stocks = stocks.map(s => ({\n                ...s,\n                price: typeof s.price === 'number' && s.price > 0 ? s.price : 1,\n                lastPrice: typeof s.lastPrice === 'number' && s.lastPrice > 0 ? s.lastPrice : (s.price || 1)\n            }));\n        } catch (e) {\n            console.log(`Error parsing or sanitizing stock data: ${e.message}`);\n            return;\n        }\n\n        const significantChanges = [];\n\n        stocks.forEach(stock => {\n            const oldPrice = stock.price;\n            stock.lastPrice = oldPrice;\n\n            let calculatedNewPrice;\n\n            const randomFactor = (Math.random() * 2 - 1) * 0.005;\n            const totalChangePercent = randomFactor * stock.volatility;\n            calculatedNewPrice = oldPrice * (1 + totalChangePercent);\n\n            let finalPrice = calculatedNewPrice;\n\n            stock.price = finalPrice;\n\n            const minAbsolutePrice = 1.00;\n            if (stock.price < minAbsolutePrice) {\n                stock.price = minAbsolutePrice;\n            }\n\n            const actualPercentChange = ((stock.price - oldPrice) / oldPrice) * 100;\n            const changeThreshold = ((mod.userConfig && mod.userConfig.priceAlertThreshold) || 10) / 100;\n\n            if (Math.abs(actualPercentChange) > changeThreshold * 100) {\n                significantChanges.push({\n                    ...stock,\n                    changePercent: actualPercentChange\n                });\n            }\n        });\n\n        await takaro.variable.variableControllerUpdate(marketDataVar.data.data[0].id, {\n            value: JSON.stringify(stocks)\n        });\n\n    } catch (error) {\n        console.log(`FATAL Error in updateStockPrices: ${error.message}`);\n    }\n}\n\nawait main();\n",
                    "name": "updatestockprices",
                    "description": null,
                    "temporalValue": "0 */1 * * *"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n\n    const discordChannelId = mod.userConfig.marketNewsChannelId;\n\n    if (!discordChannelId) {\n        takaro.log.info('Market news Discord channel ID (marketNewsChannelId) not configured in module settings. Skipping Discord messages.');\n    }\n\n    const currentPlayers = (await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    })).data.meta;\n\n    if (currentPlayers.total === 0) {\n        takaro.log.info('Skipping daily market report: No players online.');\n        return;\n    }\n\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        takaro.log.warn('Skipping daily market report: Market data variable not found.');\n        return;\n    }\n\n    let stocks;\n    try {\n        stocks = JSON.parse(marketDataVar.data.data[0].value);\n        if (!Array.isArray(stocks)) {\n            throw new Error('Parsed market data is not an array.');\n        }\n    } catch (error) {\n        takaro.log.error(`Failed to parse stock_market_data: ${error}`);\n        return;\n    }\n\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            if (typeof activeEvent !== 'object' || activeEvent === null || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (error) {\n            takaro.log.warn(`Failed to parse active_market_event: ${error}`);\n            activeEvent = null;\n        }\n    }\n\n    let gameMessage1 = \"==== DAILY MARKET REPORT ====\\n\";\n\n    if (activeEvent && activeEvent.name && activeEvent.description) {\n        const eventText = `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n${activeEvent.description}\\n`;\n        gameMessage1 += eventText;\n    } else {\n        const noEventText = '\\nNo active market events today.\\n';\n        gameMessage1 += noEventText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage1\n    }).catch(err => takaro.log.error(`Failed to send game message 1: ${err}`));\n\n    const stocksWithPerformance = stocks.map(stock => {\n        let change = 0;\n        let percentChange = 0;\n        let changeSymbol = 'â†’';\n\n        if (typeof stock.price === 'number' && typeof stock.lastPrice === 'number' && stock.lastPrice !== 0) {\n            change = stock.price - stock.lastPrice;\n            percentChange = (change / stock.lastPrice) * 100;\n            if (percentChange > 0.05) {\n                changeSymbol = 'â†‘';\n            } else if (percentChange < -0.05) {\n                changeSymbol = 'â†“';\n            }\n        } else if (typeof stock.price === 'number' && stock.lastPrice === undefined) {\n            changeSymbol = 'ðŸ†•';\n            percentChange = 0;\n        }\n        return {\n            ...stock,\n            change,\n            percentChange,\n            changeSymbol\n        };\n    });\n\n    const sectorPerformance = {};\n    // Define the desired display order and mapping for sorting\n    const riskOrder = {\n        \"Very High Risk\": 5,\n        \"High Risk\": 4,\n        \"Medium Risk\": 3,\n        \"Low Risk\": 2,\n        \"Very Low Risk\": 1,\n        \"Uncategorized\": 0 // Fallback for any stock without a defined sector\n    };\n\n    stocksWithPerformance.forEach(stock => {\n        const sectorName = stock.sector || 'Uncategorized'; // Use the sector name directly\n        if (!sectorPerformance[sectorName]) {\n            sectorPerformance[sectorName] = {\n                stocks: [],\n                totalPercentChange: 0,\n                count: 0\n            };\n        }\n        sectorPerformance[sectorName].stocks.push(stock);\n        if (typeof stock.percentChange === 'number' && isFinite(stock.percentChange)) {\n            sectorPerformance[sectorName].totalPercentChange += stock.percentChange;\n            sectorPerformance[sectorName].count++;\n        }\n    });\n\n    for (const sectorName in sectorPerformance) {\n        const sectorData = sectorPerformance[sectorName];\n        if (sectorData.count > 0) {\n            sectorData.avgPerformance = sectorData.totalPercentChange / sectorData.count;\n        } else {\n            sectorData.avgPerformance = 0;\n        }\n    }\n\n    // Sort sector performance by risk order (VH to VL)\n    const sortedSectors = Object.entries(sectorPerformance)\n        .sort(([sectorNameA], [sectorNameB]) => riskOrder[sectorNameB] - riskOrder[sectorNameA]);\n\n    let gameMessage2 = \"\\n=== SECTOR PERFORMANCE ===\\n\";\n\n    if (sortedSectors.length > 0) {\n        sortedSectors.forEach(([sectorName, sectorData]) => { // Use sectorName directly\n            const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n            let line = `${sectorName}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n\n            if (sectorData.avgPerformance > 0.05) {\n                line = `[70FE02]${sectorName}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%[-]\\n`;\n            } else if (sectorData.avgPerformance < -0.05) {\n                line = `[FF0001]${sectorName}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%[-]\\n`;\n            }\n            gameMessage2 += line;\n        });\n    } else {\n        const noDataText = \"No sector performance data available.\\n\";\n        gameMessage2 += noDataText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage2\n    }).catch(err => takaro.log.error(`Failed to send game message 2: ${err}`));\n\n    const validPerformers = stocksWithPerformance.filter(s => typeof s.percentChange === 'number' && isFinite(s.percentChange));\n    validPerformers.sort((a, b) => b.percentChange - a.percentChange);\n\n    let gameMessage3 = \"\";\n\n    const topPerformersTitleGame = \"\\nðŸ”¥ TOP PERFORMERS ðŸ”¥\\n\";\n    gameMessage3 += topPerformersTitleGame;\n\n    if (validPerformers.length > 0) {\n        for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n            const stock = validPerformers[i];\n            gameMessage3 += `[70FE02]${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%[-]\\n`;\n        }\n    } else {\n        gameMessage3 += \"No top performers today.\\n\";\n    }\n\n    const worstPerformersTitleGame = \"\\nðŸ“‰ WORST PERFORMERS ðŸ“‰\\n\";\n    gameMessage3 += worstPerformersTitleGame;\n\n    if (validPerformers.length > 0) {\n        const worstStartIndex = Math.max(0, validPerformers.length - 3);\n        for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n            const stock = validPerformers[i];\n            gameMessage3 += `[FF0001]${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%[-]\\n`;\n        }\n    } else {\n        gameMessage3 += \"No worst performers today.\\n\";\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage3\n    }).catch(err => takaro.log.error(`Failed to send game message 3: ${err}`));\n\n    function hslToRgb(h, s, l) { let a = s * Math.min(l, 1 - l); let f = n => { let k = (n + h / 30) % 12; return l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1)); }; return [Math.round(255 * f(0)), Math.round(255 * f(8)), Math.round(255 * f(4))]; }\n    function rgbToHex(r, g, b) { return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase(); }\n    function stringToHexColor(str) { let hash = 0; for (let i = 0; i < str.length; i++) { hash = str.charCodeAt(i) + ((hash << 5) - hash); } hash = Math.abs(hash); const hue = (hash * 137.508) % 360; const [r, g, b] = hslToRgb(hue, 0.9, 0.7); return rgbToHex(r, g, b); }\n\n    const stockColors = {};\n    stocksWithPerformance.forEach(stock => {\n        stockColors[stock.id] = stringToHexColor(stock.name);\n    });\n\n    const stocksBySectorGame = {};\n    stocksWithPerformance.forEach(stock => {\n        const sector = stock.sector || 'Uncategorized'; // Use the sector name directly\n        if (!stocksBySectorGame[sector]) {\n            stocksBySectorGame[sector] = [];\n        }\n        stocksBySectorGame[sector].push(stock);\n    });\n\n    // Sort the sector names for display in the desired order (VH, H, M, L, VL)\n    const sortedSectorNamesGame = Object.keys(stocksBySectorGame).sort((sectorNameA, sectorNameB) => riskOrder[sectorNameB] - riskOrder[sectorNameA]);\n\n\n    for (const sectorName of sortedSectorNamesGame) { // Iterate through sorted sector names\n        const sectorStocks = stocksBySectorGame[sectorName];\n        const chunkSize = 3;\n        for (let i = 0; i < sectorStocks.length; i += chunkSize) {\n            const chunk = sectorStocks.slice(i, i + chunkSize);\n            // Use sectorName directly for the header\n            let sectorMessage = (i === 0) ? `\\n--- ${sectorName} SECTOR ---\\n` : '';\n\n            chunk.forEach(stock => {\n                let changeText = '';\n                let priceColorPrefix = '', priceColorSuffix = '';\n\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeText = ` ${stock.changeSymbol} ${Math.abs(percentChange).toFixed(1)}%`;\n                    if (percentChange > 0) {\n                        priceColorPrefix = '[70FE02]';\n                        priceColorSuffix = '[-]';\n                    } else if (percentChange < 0) {\n                        priceColorPrefix = '[FF0001]';\n                        priceColorSuffix = '[-]';\n                    }\n                }\n\n                const stockNameColorPrefix = stockColors[stock.id] ? `[${stockColors[stock.id]}]` : '';\n                const stockNameColorSuffix = stockColors[stock.id] ? '[-]' : '';\n\n                let riskIndicator; // This is derived from volatility, not directly from sector ID\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.25) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                sectorMessage += `${stockNameColorPrefix}${stock.name} (${stock.id})${stockNameColorSuffix} (${riskIndicator}): ${priceColorPrefix}$${Math.round(stock.price)}${changeText}${priceColorSuffix}\\n`;\n            });\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message: sectorMessage\n            }).catch(err => takaro.log.error(`Failed to send game message for sector ${sectorName}: ${err}`));\n        }\n    }\n\n    const legendMessage = \"\\n=== LEGEND ===\\n\" +\n        \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\";\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: legendMessage\n    }).catch(err => takaro.log.error(`Failed to send game legend message: ${err}`));\n\n    if (discordChannelId) {\n        // --- MESSAGE 1: The Summary ---\n        let discordMessageSummary = \"**==== DAILY MARKET REPORT ====**\\n\\n\";\n\n        if (activeEvent && activeEvent.name && activeEvent.description) {\n            discordMessageSummary += `ðŸŒ **ACTIVE EVENT: ${activeEvent.name}** ðŸŒ\\n${activeEvent.description}\\n\\n`;\n        } else {\n            discordMessageSummary += 'No active market events today.\\n\\n';\n        }\n\n        discordMessageSummary += \"**=== SECTOR PERFORMANCE ===**\\n\";\n        if (sortedSectors.length > 0) {\n            sortedSectors.forEach(([sectorName, sectorData]) => { // Use sectorName directly\n                const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n                discordMessageSummary += `${sectorName}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n            });\n        } else {\n            discordMessageSummary += \"No sector performance data available.\\n\";\n        }\n        discordMessageSummary += \"\\n\";\n\n        discordMessageSummary += \"**ðŸ”¥ TOP PERFORMERS ðŸ”¥**\\n\";\n        if (validPerformers.length > 0) {\n            for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n                const stock = validPerformers[i];\n                discordMessageSummary += `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            }\n        } else {\n            discordMessageSummary += \"No top performers today.\\n\";\n        }\n        discordMessageSummary += \"\\n\";\n\n        discordMessageSummary += \"**ðŸ“‰ WORST PERFORMERS ðŸ“‰**\\n\";\n        if (validPerformers.length > 0) {\n            const worstStartIndex = Math.max(0, validPerformers.length - 3);\n            for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n                const stock = validPerformers[i];\n                discordMessageSummary += `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            }\n        } else {\n            discordMessageSummary += \"No worst performers today.\\n\";\n        }\n\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessageSummary\n        }).catch(err => takaro.log.error(`Failed to send summary Discord message: ${err.message || err}`));\n\n        // --- MESSAGE 2: All Stock Listings ---\n        let discordMessageDetails = \"**=== ALL STOCK LISTINGS ===**\\n\";\n        const stocksBySector = {};\n        stocksWithPerformance.forEach(stock => {\n            const sector = stock.sector || 'Uncategorized'; // Use the sector name directly\n            if (!stocksBySector[sector]) {\n                stocksBySector[sector] = [];\n            }\n            stocksBySector[sector].push(stock);\n        });\n\n        // Sort the sector names for display in the desired order (VH, H, M, L, VL)\n        const sortedSectorNamesDiscord = Object.keys(stocksBySector).sort((sectorNameA, sectorNameB) => riskOrder[sectorNameB] - riskOrder[sectorNameA]);\n\n\n        for (const sectorName of sortedSectorNamesDiscord) { // Iterate through sorted sector names\n            const sectorStocks = stocksBySector[sectorName];\n            discordMessageDetails += `\\n--- **${sectorName} SECTOR** ---\\n`; // Use sectorName directly\n            sectorStocks.forEach(stock => {\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeText = ` ${stock.changeSymbol} ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.25) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                discordMessageDetails += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n        }\n\n        discordMessageDetails += \"\\n**=== LEGEND ===**\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\";\n\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessageDetails\n        }).catch(err => takaro.log.error(`Failed to send details Discord message: ${err.message || err}`));\n    }\n\n    takaro.log.info('Daily market report sent successfully.');\n}\n\nawait main();",
                    "name": "marketnews",
                    "description": null,
                    "temporalValue": "1 */1 * * *"
                }
            ],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Allows the player to view market prices and their portfolio",
                    "permission": "STOCK_MARKET_USE",
                    "friendlyName": "Use Stock Market"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows the player to buy and sell stocks",
                    "permission": "STOCK_MARKET_TRADE",
                    "friendlyName": "Trade Stocks"
                },
                {
                    "canHaveCount": false,
                    "description": "VIP status that reduces transaction fees",
                    "permission": "STOCK_MARKET_BROKER",
                    "friendlyName": "Stock Broker"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows admins to manually trigger market events",
                    "permission": "STOCK_MARKET_TRIGGER_EVENT",
                    "friendlyName": "Trigger Market Events"
                }
            ]
        },
        {
            "tag": "0.1.2",
            "description": "**Stock Market: A Dynamic Virtual Trading System**\n\nCreate an immersive economic experience with this comprehensive stock market module that lets players invest, trade, and react to market events.\n\n**Market Features:**\n\n![Market Summary](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stocks.png)\n\n* **Multiple Economic Sectors:** Configure various industry sectors (Resource Extraction, Manufacturing, Defense, etc.) each with their own market dynamics.\n* **Realistic Stock Behavior:** Stocks have configurable volatility, sector-based pricing, and react differently to market events.\n* **Dynamic Market Events:** Random or admin-triggered events like \"Horde Night Approaching\" or \"Societal Collapse Setback\" impact different sectors in realistic ways.\n\n![Market Events](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_events.png)\n\n**Trading System:**\n\n* **Buy & Sell Shares:** Players can purchase stocks and sell them later for profit or loss.\n* **Transaction Fees:** Configurable fee percentage on all trades creates a realistic market economy.\n* **VIP Benefits:** Special permissions for designated \"Stock Brokers\" who receive fee discounts.\n\n![Buy Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_buy.png)\n\nPlayers can track price changes and sell at the right moment to maximize profits or minimize losses.\n\n![Sell Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sell.png)\n\n**Player Portfolio:**\n\n* **Portfolio Tracking:** Players can view their holdings, average purchase prices, and current profit/loss.\n* **Transaction History:** System tracks all buy/sell transactions for each player.\n* **Summary Statistics:** See overall portfolio performance and value across all holdings.\n\n![Portfolio View](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockportfolio.png)\n\n**Market Information:**\n\n* **Detailed Stock Info:** Players can research specific stocks, including risk levels and sector trends.\n* **Industry Filters:** View stocks by specific sectors to better understand market segments.\n* **Market Alerts:** Server-wide notifications for significant price changes keep players engaged.\n\n![Market Alerts](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockpricechange.png)\n\n**Configuration Options:**\n\n* **Sectors & Stocks:** Define your own market sectors and individual stocks with customizable starting prices and volatility.\n* **Market Events:** Create unique events with specific sector impacts to drive market dynamics.\n* **Transaction Settings:** Configure fee percentages, VIP discounts, and alert thresholds.\n* **Event Frequency:** Control how often random market events occur and how long they last.\n\n![Configuration](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_config.png)\n![Sectors](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sectors.png)\n\n**Commands:**\n\n* `/markets [industry]` - View all stocks or filter by industry\n* `/stockinfo [ticker]` - Get detailed information about a specific stock\n* `/buystock <ticker> <amount>` - Purchase shares of a stock\n* `/sellstock <ticker> <amount>` - Sell shares from your portfolio\n* `/stockportfolio` - View your current holdings and performance\n* `/triggerevent [event]` - Admin command to trigger specific market events\n\nWho says the apocalypse can't have a thriving economy? Now players can stress about both zombie hordes AND their Duke's Casino Tokens dropping 40% after a market event! As one trader put it: \"I used to check my 401K daily, and now I check my AMMO stock before every Blood Moon. Some habits die harder than zombies.\"",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sectors\":{\"type\":\"array\",\"title\":\"Wasteland Economic Sectors\",\"description\":\"Define economic sectors relevant to survival in Navezgane\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Sector ID (e.g., RESOURCES)\"},\"name\":{\"type\":\"string\",\"description\":\"Sector name (e.g., Resource Extraction)\"}}},\"default\":[{\"id\":\"RESOURCES\",\"name\":\"Resource Extraction\"},{\"id\":\"MANUFACTURING\",\"name\":\"Manufacturing & Crafting\"},{\"id\":\"DEFENSE\",\"name\":\"Defense & Fortifications\"},{\"id\":\"SURVIVAL\",\"name\":\"Survival Goods\"},{\"id\":\"TRADE\",\"name\":\"Trade & Currency\"}]},\"stocks\":{\"type\":\"array\",\"title\":\"Wasteland Stocks\",\"description\":\"List of stocks representing Navezgane entities and resources\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Stock ticker symbol (e.g., NMC)\"},\"name\":{\"type\":\"string\",\"description\":\"Entity/Resource name\"},\"sector\":{\"type\":\"string\",\"description\":\"Sector ID this stock belongs to\"},\"initialPrice\":{\"type\":\"number\",\"description\":\"Starting price in Dukes\",\"minimum\":1},\"volatility\":{\"type\":\"number\",\"description\":\"Base volatility percentage (5 = 5%)\",\"minimum\":1,\"maximum\":35}}},\"default\":[{\"id\":\"NMC\",\"name\":\"Navezgane Mining Co.\",\"sector\":\"RESOURCES\",\"initialPrice\":50,\"volatility\":15},{\"id\":\"WOOD\",\"name\":\"Wasteland Lumberjacks\",\"sector\":\"RESOURCES\",\"initialPrice\":20,\"volatility\":8},{\"id\":\"SHALE\",\"name\":\"Oil Shale Extractors\",\"sector\":\"RESOURCES\",\"initialPrice\":40,\"volatility\":18},{\"id\":\"FORGE\",\"name\":\"Forge Ahead Metals\",\"sector\":\"MANUFACTURING\",\"initialPrice\":75,\"volatility\":12},{\"id\":\"TOOLS\",\"name\":\"Working Stiff Tools\",\"sector\":\"MANUFACTURING\",\"initialPrice\":60,\"volatility\":10},{\"id\":\"MECH\",\"name\":\"JunkTech Robotics\",\"sector\":\"MANUFACTURING\",\"initialPrice\":110,\"volatility\":20},{\"id\":\"BUILD\",\"name\":\"Barricade Builders\",\"sector\":\"DEFENSE\",\"initialPrice\":45,\"volatility\":9},{\"id\":\"AMMO\",\"name\":\"AmmoNation Surplus\",\"sector\":\"DEFENSE\",\"initialPrice\":90,\"volatility\":25},{\"id\":\"SHAM\",\"name\":\"Shamway Foods\",\"sector\":\"SURVIVAL\",\"initialPrice\":30,\"volatility\":5},{\"id\":\"MEDS\",\"name\":\"Pop-N-Pills Medical\",\"sector\":\"SURVIVAL\",\"initialPrice\":100,\"volatility\":18},{\"id\":\"TRADE\",\"name\":\"Trader Guild Network\",\"sector\":\"TRADE\",\"initialPrice\":150,\"volatility\":10},{\"id\":\"DUKES\",\"name\":\"Duke's Casino Tokens\",\"sector\":\"TRADE\",\"initialPrice\":1,\"volatility\":3}]},\"marketEvents\":{\"type\":\"array\",\"title\":\"Wasteland Events\",\"description\":\"Events impacting the Navezgane economy\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Unique event ID\"},\"name\":{\"type\":\"string\",\"description\":\"Name of the event\"},\"description\":{\"type\":\"string\",\"description\":\"Description of the event's market effect\"},\"sectorImpacts\":{\"type\":\"array\",\"description\":\"How each sector is affected\",\"items\":{\"type\":\"object\",\"properties\":{\"sectorId\":{\"type\":\"string\",\"description\":\"Sector ID\"},\"impact\":{\"type\":\"number\",\"description\":\"Percentage impact (-30 = -30%)\",\"minimum\":-75,\"maximum\":75}}}}}},\"default\":[{\"id\":\"HORDE_INCOMING\",\"name\":\"Horde Night Approaching\",\"description\":\"Increased Zed activity signals the Blood Moon. Survivors prepare defenses.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-15},{\"sectorId\":\"MANUFACTURING\",\"impact\":20},{\"sectorId\":\"DEFENSE\",\"impact\":35},{\"sectorId\":\"SURVIVAL\",\"impact\":5},{\"sectorId\":\"TRADE\",\"impact\":-10}]},{\"id\":\"RESOURCE_SCARCITY\",\"name\":\"Resource Scarcity\",\"description\":\"Key resource veins are depleted, making raw materials harder to find.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-40},{\"sectorId\":\"MANUFACTURING\",\"impact\":-25},{\"sectorId\":\"DEFENSE\",\"impact\":-10},{\"sectorId\":\"SURVIVAL\",\"impact\":0},{\"sectorId\":\"TRADE\",\"impact\":5}]},{\"id\":\"ZED_OUTBREAK\",\"name\":\"Severe Zed Outbreak\",\"description\":\"An unusual concentration of Zed activity makes scavenging and travel extremely dangerous.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-30},{\"sectorId\":\"MANUFACTURING\",\"impact\":-10},{\"sectorId\":\"DEFENSE\",\"impact\":15},{\"sectorId\":\"SURVIVAL\",\"impact\":25},{\"sectorId\":\"TRADE\",\"impact\":-20}]},{\"id\":\"TRADE_ROUTE_SECURED\",\"name\":\"Trade Route Secured\",\"description\":\"Traders have established a safer passage, improving the flow of goods.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":5},{\"sectorId\":\"MANUFACTURING\",\"impact\":10},{\"sectorId\":\"DEFENSE\",\"impact\":0},{\"sectorId\":\"SURVIVAL\",\"impact\":15},{\"sectorId\":\"TRADE\",\"impact\":30}]},{\"id\":\"GENERAL_COLLAPSE\",\"name\":\"Societal Collapse Setback\",\"description\":\"A major setback reminds everyone how fragile survival is. Fear grips the market.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-25},{\"sectorId\":\"MANUFACTURING\",\"impact\":-30},{\"sectorId\":\"DEFENSE\",\"impact\":-15},{\"sectorId\":\"SURVIVAL\",\"impact\":-10},{\"sectorId\":\"TRADE\",\"impact\":-40}]}]},\"eventFrequency\":{\"title\":\"Event Frequency\",\"type\":\"number\",\"description\":\"Average number of update cycles between market events (0 to disable). Depends on mod's update frequency (e.g., per in-game hour?).\",\"default\":8,\"minimum\":1},\"defaultEventDuration\":{\"title\":\"Default Event Duration\",\"type\":\"number\",\"description\":\"Default number of update cycles an event lasts.\",\"default\":3,\"minimum\":1,\"maximum\":96},\"transactionFee\":{\"title\":\"Transaction Fee (Dukes Tax)\",\"type\":\"number\",\"description\":\"Percentage fee charged on all buy/sell transactions (5 = 5%)\",\"default\":3,\"minimum\":0,\"maximum\":25},\"vipDiscount\":{\"title\":\"Trader's Favor Discount\",\"type\":\"number\",\"description\":\"Percentage discount on transaction fees for players with 'STOCK_MARKET_BROKER' permission (50 = 50%)\",\"default\":50,\"minimum\":0,\"maximum\":100},\"priceAlertThreshold\":{\"title\":\"Price Alert Threshold\",\"type\":\"number\",\"description\":\"Percentage change that triggers a market alert (15 = 15%)\",\"default\":15,\"minimum\":5,\"maximum\":50},\"marketNewsChannelId\":{\"title\":\"Discord Channel ID (for Market News)\",\"type\":\"string\",\"description\":\"The ID of the Discord channel where market news messages should be posted. Leave empty to disable.\",\"default\":\"\"}},\"additionalProperties\":false}",
            "uiSchema": "{\"sectors\":{\"items\":{\"ui:order\":[\"id\",\"name\"]}},\"stocks\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"sector\",\"initialPrice\",\"volatility\"]}},\"marketEvents\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"description\",\"sectorImpacts\"],\"sectorImpacts\":{\"items\":{\"ui:order\":[\"sectorId\",\"impact\"]}}}},\"transactionFee\":{\"ui:widget\":\"range\"},\"vipDiscount\":{\"ui:widget\":\"range\"},\"eventFrequency\":{\"ui:help\":\"Set to 0 to disable random events\"},\"priceAlertThreshold\":{\"ui:widget\":\"range\"}}",
            "commands": [
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // Get player's portfolio\n    const portfolioVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_portfolio'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId],\n            playerId: [player.id]\n        }\n    });\n\n    let portfolio = {};\n    if (portfolioVar.data.data.length > 0) {\n        portfolio = JSON.parse(portfolioVar.data.data[0].value);\n    }\n\n    // Send header\n    await player.pm(\"=== YOUR STOCK PORTFOLIO ===\");\n\n    let hasStocks = false;\n    let totalValue = 0;\n    let totalInvestment = 0;\n\n    // If no stocks, send a simple message\n    if (Object.keys(portfolio).length === 0) {\n        await player.pm(\"You don't own any stocks yet.\\n\" +\n            \"Use /markets to see available stocks and prices.\\n\" +\n            \"Use /buy <stock> <amount> to purchase stocks.\");\n        return;\n    }\n\n    // Send each stock as a separate message to avoid length issues\n    for (const [stockId, data] of Object.entries(portfolio)) {\n        hasStocks = true;\n        const stock = stocks.find(s => s.id === stockId);\n        if (!stock) continue; // Stock might have been removed from config\n\n        const currentValue = stock.price * data.shares;\n        const investmentValue = data.averagePrice * data.shares;\n        totalValue += currentValue;\n        totalInvestment += investmentValue;\n        const profit = currentValue - investmentValue;\n        const profitPercent = ((profit / investmentValue) * 100).toFixed(1);\n\n        let stockMessage = `--- ${stockId} (${stock.sector}) ---\\n`;\n        stockMessage += `Shares: ${data.shares}\\n`;\n        stockMessage += `Avg buy: $${Math.round(data.averagePrice)}\\n`;\n        stockMessage += `Current price: $${Math.round(stock.price)}\\n`;\n        stockMessage += `Total value: $${Math.round(currentValue)}\\n`;\n\n        if (profit >= 0) {\n            stockMessage += `Profit: +$${Math.round(profit)} (+${profitPercent}%)\\n`;\n        } else {\n            stockMessage += `Loss: -$${Math.abs(Math.round(profit))} (${profitPercent}%)\\n`;\n        }\n\n        await player.pm(stockMessage);\n    }\n\n    if (hasStocks) {\n        const totalProfit = totalValue - totalInvestment;\n        const totalProfitPercent = ((totalProfit / totalInvestment) * 100).toFixed(1);\n\n        let summaryMessage = \"=== PORTFOLIO SUMMARY ===\\n\";\n        summaryMessage += `Total investment: $${Math.round(totalInvestment)}\\n`;\n        summaryMessage += `Current value: $${Math.round(totalValue)}\\n`;\n\n        if (totalProfit >= 0) {\n            summaryMessage += `Overall profit: +$${Math.round(totalProfit)} (+${totalProfitPercent}%)\\n`;\n        } else {\n            summaryMessage += `Overall loss: -$${Math.abs(Math.round(totalProfit))} (${totalProfitPercent}%)\\n`;\n        }\n\n        // Get transaction history count\n        try {\n            const historyVar = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: ['stock_transaction_history'],\n                    gameServerId: [gameServerId],\n                    moduleId: [mod.moduleId],\n                    playerId: [player.id]\n                }\n            });\n\n            if (historyVar.data.data.length > 0) {\n                const history = JSON.parse(historyVar.data.data[0].value);\n                const buyCount = history.filter(t => t.type === 'BUY').length;\n                const sellCount = history.filter(t => t.type === 'SELL').length;\n\n                summaryMessage += `\\nTransactions: ${history.length} (${buyCount} buys, ${sellCount} sells)\\n`;\n            }\n        } catch (error) {\n            // Just ignore history errors\n        }\n\n        await player.pm(summaryMessage);\n\n    }\n}\n\nawait main();",
                    "name": "stockportfolio",
                    "description": null,
                    "trigger": "stockportfolio",
                    "helpText": "No help text available",
                    "arguments": []
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === args.stock.toUpperCase());\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${args.stock} not found. Use /market to see available stocks.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate costs using Math.round to ensure we work with integers\n        const subtotal = Math.round(stock.price) * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const totalCost = subtotal + fee;\n\n        // Check if player has enough currency\n        const playerData = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, player.id);\n        const currentBalance = playerData.data.data.currency;\n\n        if (currentBalance < totalCost) {\n            throw new TakaroUserError(`You don't have enough currency. Cost: $${subtotal} + $${fee} fee = $${totalCost}. Your balance: $${currentBalance}`);\n        }\n\n        // Deduct the currency - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerDeductCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: totalCost\n            }\n        );\n\n        // Get player's portfolio or create new one\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        let portfolio;\n        if (portfolioVar.data.data.length === 0) {\n            portfolio = {};\n        } else {\n            portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        }\n\n        // Update portfolio using rounded values for consistency\n        const stockPrice = Math.round(stock.price);\n        if (!portfolio[stock.id]) {\n            portfolio[stock.id] = {\n                shares: amount,\n                averagePrice: stockPrice\n            };\n        } else {\n            const totalShares = portfolio[stock.id].shares + amount;\n            const totalValue = (portfolio[stock.id].shares * portfolio[stock.id].averagePrice) + (amount * stockPrice);\n            portfolio[stock.id].shares = totalShares;\n            portfolio[stock.id].averagePrice = Math.round(totalValue / totalShares);\n        }\n\n        // Save updated portfolio\n        if (portfolioVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_portfolio',\n                value: JSON.stringify(portfolio),\n                gameServerId,\n                moduleId: mod.moduleId,\n                playerId: player.id\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n                value: JSON.stringify(portfolio)\n            });\n        }\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'BUY',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: totalCost,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully bought ${amount} shares of ${stock.id} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Total cost: $${totalCost}\\n`;\n        message += `Current portfolio: ${portfolio[stock.id].shares} shares of ${stock.id}`;\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in buystock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your purchase. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "buystock",
                    "description": null,
                    "trigger": "buystock",
                    "helpText": "Buy shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol ",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to buy",
                            "position": 1
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // If a specific stock ticker is provided, show detailed info for that stock\n    const specificTicker = args.ticker ? args.ticker.toUpperCase() : null;\n\n    if (specificTicker && specificTicker !== \"ALL\") {\n        const stock = stocks.find(s => s.id.toUpperCase() === specificTicker);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${specificTicker} not found. Use /stockinfo without parameters to see all available stocks.`);\n        }\n\n        // Get active event to see if this stock's sector is affected\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let activeEvent = null;\n        let sectorImpact = null;\n\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEvent && activeEvent.sectorImpacts) {\n                    sectorImpact = activeEvent.sectorImpacts.find(impact =>\n                        impact.sectorId === stock.sector\n                    );\n                }\n            } catch (e) {\n                // Ignore parsing errors\n            }\n        }\n\n        // Calculate price change indicators\n        let changeText = '';\n        if (stock.lastPrice) {\n            const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n            const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n            changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n        }\n\n        // Add risk assessment based on volatility without showing the raw value\n        let riskLevel;\n        if (stock.volatility <= 0.05) riskLevel = \"Very Low\";\n        else if (stock.volatility <= 0.10) riskLevel = \"Low\";\n        else if (stock.volatility <= 0.15) riskLevel = \"Moderate\";\n        else if (stock.volatility <= 0.20) riskLevel = \"High\";\n        else riskLevel = \"Very High\";\n\n        // Build detailed stock info message\n        let message = `=== ${stock.id}: ${stock.name} ===\\n\\n`;\n        message += `Sector: ${stock.sector}\\n`;\n        message += `Current Price: $${Math.round(stock.price)}${changeText}\\n`;\n        message += `Risk Level: ${riskLevel}\\n`;\n\n        // Add sector trend info if available from event\n        if (activeEvent && sectorImpact) {\n            const direction = sectorImpact.impact >= 0 ? \"Positive\" : \"Negative\";\n            const strength = Math.abs(sectorImpact.impact);\n            let trend;\n\n            if (strength < 10) trend = \"Slight\";\n            else if (strength < 25) trend = \"Moderate\";\n            else trend = \"Strong\";\n\n            message += `\\nCurrent Trend: ${trend} ${direction} (${activeEvent.name})\\n`;\n            message += `Event: ${activeEvent.description}\\n`;\n        }\n\n        // Add trading guidance based on sector and risk, without mentioning volatility\n        message += `\\nTrading Notes:\\n`;\n\n        if (activeEvent && sectorImpact) {\n            if (sectorImpact.impact > 0) {\n                message += `- Currently bullish due to the ${activeEvent.name} event\\n`;\n            } else {\n                message += `- Currently bearish due to the ${activeEvent.name} event\\n`;\n            }\n        }\n\n        if (riskLevel === \"High\" || riskLevel === \"Very High\") {\n            message += `- Expect significant price fluctuations with this stock\\n`;\n        } else if (riskLevel === \"Low\" || riskLevel === \"Very Low\") {\n            message += `- Typically has stable price movement\\n`;\n        }\n\n        message += `\\nUse /buystock ${stock.id} [amount] to purchase shares`;\n\n        await player.pm(message);\n\n    } else {\n        // No specific ticker provided or ALL specified, show summary of all stocks\n        await player.pm(\"=== STOCK MARKET LISTINGS ===\\n\");\n\n        // Group stocks by sector\n        const stocksBySector = {};\n        stocks.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        // Display stocks by sector\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            let sectorMessage = `\\n--- ${sector} SECTOR ---\\n`;\n\n            sectorStocks.forEach(stock => {\n                // Add price change indicators\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                    changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                // Add risk level based on volatility\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                sectorMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n\n            await player.pm(sectorMessage);\n        }\n\n        // Add legend for risk indicators\n        const legend = \"\\n=== LEGEND ===\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\" +\n            \"Use /stockinfo [ticker] for detailed information about a specific stock\";\n\n        await player.pm(legend);\n    }\n}\n\nawait main();",
                    "name": "stockinfo",
                    "description": null,
                    "trigger": "stockinfo",
                    "helpText": "Shows all available stocks in the market. Use with a ticker symbol (e.g., /stockinfo ticker) to see detailed information about a specific stock.",
                    "arguments": [
                        {
                            "name": "ticker",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "stock ticker or ALL to get detailed information about a specific stock",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRIGGER_EVENT')) {\n        throw new TakaroUserError(\"You don't have permission to trigger market events.\");\n    }\n\n    try {\n        // Get current stock data to check market initialization\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Initialize market if needed\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            await player.pm(\"Market was not initialized. Initializing now...\");\n            return;\n        }\n\n        // Get events from module config\n        const marketEvents = mod.userConfig.marketEvents || [];\n\n        if (marketEvents.length === 0) {\n            throw new TakaroUserError(\"No market events configured in this module.\");\n        }\n\n        // Handle case when no event is specified or \"ALL\" is provided\n        if (!args.EventName || args.EventName.toUpperCase() === \"ALL\") {\n            await player.pm(\"=== AVAILABLE MARKET EVENTS ===\\n\");\n\n            // Group events by category or type if possible\n            const eventCategories = {};\n\n            // Create a simple categorization based on positive/negative impact\n            marketEvents.forEach(event => {\n                let category = \"Mixed\";\n                // Calculate net impact across all sectors\n                const netImpact = event.sectorImpacts.reduce((sum, impact) => sum + impact.impact, 0);\n\n                if (netImpact > 0) category = \"Positive\";\n                else if (netImpact < 0) category = \"Negative\";\n\n                if (!eventCategories[category]) {\n                    eventCategories[category] = [];\n                }\n                eventCategories[category].push(event);\n            });\n\n            // Display events by category\n            for (const [category, events] of Object.entries(eventCategories)) {\n                if (events.length > 0) {\n                    await player.pm(`\\n--- ${category.toUpperCase()} EVENTS ---`);\n\n                    let message = \"\";\n                    events.forEach(event => {\n                        // Format primary sectors affected\n                        const primarySectors = event.sectorImpacts\n                            .filter(impact => Math.abs(impact.impact) >= 15)\n                            .map(impact => {\n                                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                                return `${impact.sectorId} ${direction}${Math.abs(impact.impact)}%`;\n                            })\n                            .join(\", \");\n\n                        message += `${event.id}: ${event.name}\\n`;\n                        message += `   ${event.description}\\n`;\n                        if (primarySectors) {\n                            message += `   Major impacts: ${primarySectors}\\n`;\n                        }\n                        message += \"\\n\";\n                    });\n\n                    await player.pm(message);\n                }\n            }\n\n            await player.pm(\"=== HOW TO USE ===\\nUse `/triggerevent <EventName>` to trigger a specific event (e.g., `/triggerevent TECH_BOOM`)\");\n            return;\n        }\n\n        // Find the requested event\n        const eventId = args.EventName.toUpperCase();\n        const event = marketEvents.find(e => e.id === eventId);\n\n        if (!event) {\n            throw new TakaroUserError(`Event \"${eventId}\" not found. Use /triggerevent without parameters to see all available events.`);\n        }\n\n        // Get necessary variables for managing the event\n        const [activeEventVar, eventStartTimeVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_execution_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_cooldown_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['current_event_duration'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Check if there's an active event we need to cancel\n        let activeEventObj = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEventObj = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEventObj && Object.keys(activeEventObj).length > 0) {\n                    await player.pm(`Cancelling active event \"${activeEventObj.name}\" to trigger new event.`);\n                }\n            } catch (e) {\n                // Invalid event data, will be overwritten\n            }\n        }\n\n        // Generate a random duration for the event\n        const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n        // Update or create all event-related variables\n        const updatePromises = [];\n\n        // Save or update the random duration\n        if (eventDurationVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                    value: randomDuration.toString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'current_event_duration',\n                    value: randomDuration.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the event counter to 0\n        if (eventCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the cooldown counter\n        if (cooldownCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update active event\n        if (activeEventVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                    value: JSON.stringify(event)\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: JSON.stringify(event),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update event start time\n        if (eventStartTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update last event time\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (lastEventTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all updates to complete\n        await Promise.all(updatePromises);\n\n        // Check if there are online players to announce the event\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            // Format sector impacts for announcement\n            let impactText = \"\";\n            for (const impact of event.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n            }\n\n            const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${event.name}\\n${event.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /markets to see opportunities!`;\n\n            // Split the message if it's too long\n            const maxLength = 400; // Safe limit for most games\n            for (let i = 0; i < message.length; i += maxLength) {\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message: message.substring(i, i + maxLength)\n                });\n            }\n        }\n\n        await player.pm(`Successfully triggered the \"${event.name}\" market event for ${randomDuration} cycles!`);\n    } catch (error) {\n        // If something goes wrong, log it and let the player know\n        console.log(`Error in triggerEvent: ${error.message}`);\n        throw new TakaroUserError(`Error triggering event: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Store the stocks data\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_data',\n            value: JSON.stringify(stocks),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize last event time to now\n        await takaro.variable.variableControllerCreate({\n            key: 'last_market_event_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize event start time variable\n        await takaro.variable.variableControllerCreate({\n            key: 'event_start_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize active event (empty string means no active event)\n        await takaro.variable.variableControllerCreate({\n            key: 'active_market_event',\n            value: '',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Mark market as initialized\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_initialized',\n            value: 'true',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Announce market initialization to online players\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /markets to see available stocks and /buystock to start investing.\";\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message\n            });\n        }\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "triggerevent",
                    "description": null,
                    "trigger": "triggerevent",
                    "helpText": "Shows all available market events when run without parameters. Use with an event name (e.g., /triggerevent TECH_BOOM) to trigger a specific market event.",
                    "arguments": [
                        {
                            "name": "EventName",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "Event name to trigger a specific market event",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get player's portfolio\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        if (portfolioVar.data.data.length === 0) {\n            throw new TakaroUserError(\"You don't own any stocks to sell.\");\n        }\n\n        const portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        const stockId = args.stock.toUpperCase();\n\n        if (!portfolio[stockId] || portfolio[stockId].shares < amount) {\n            throw new TakaroUserError(`You don't own ${amount} shares of ${stockId}.`);\n        }\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === stockId);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${stockId} not found in current market data. Please contact an admin.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate sale proceeds using Math.round to ensure we work with integers\n        const stockPrice = Math.round(stock.price);\n        const subtotal = stockPrice * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const netProceeds = subtotal - fee;\n\n        // Add money to player - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerAddCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: netProceeds\n            }\n        );\n\n        // Calculate profit/loss\n        const profitPerShare = stockPrice - portfolio[stockId].averagePrice;\n        const totalProfit = Math.round(profitPerShare * amount);\n        const profitText = totalProfit >= 0\n            ? `profit of $${totalProfit}`\n            : `loss of $${Math.abs(totalProfit)}`;\n\n        // Update portfolio\n        portfolio[stockId].shares -= amount;\n        if (portfolio[stockId].shares === 0) {\n            delete portfolio[stockId];\n        }\n\n        // Save updated portfolio\n        await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n            value: JSON.stringify(portfolio)\n        });\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'SELL',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: netProceeds,\n            profit: totalProfit,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully sold ${amount} shares of ${stockId} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Net proceeds: $${netProceeds} (${profitText})`;\n\n        // Add remaining shares info if player still has some\n        if (portfolio[stockId]) {\n            message += `\\nRemaining shares: ${portfolio[stockId].shares}`;\n        } else {\n            message += `\\nYou've sold all your ${stockId} shares.`;\n        }\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in sellstock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your sale. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "sellstock",
                    "description": null,
                    "trigger": "sellstock",
                    "helpText": "Sell shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to sell",
                            "position": 1
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Handle the industry argument - use \"ALL\" as a special value to show all industries\n    const industryFilter = args.Industry ? args.Industry.toUpperCase() : \"ALL\";\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    // If market data doesn't exist, try to initialize it\n    if (marketDataVar.data.data.length === 0) {\n        const initialized = await initializeMarketIfNeeded(gameServerId, mod);\n        if (!initialized) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        // Get the freshly initialized market data\n        const refreshedMarketData = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (refreshedMarketData.data.data.length === 0) {\n            throw new TakaroUserError(\"There was an issue initializing the stock market. Please try again later.\");\n        }\n\n        // Continue with the refreshed data\n        await displayMarketSummary(player, gameServerId, mod, refreshedMarketData.data.data[0], industryFilter);\n    } else {\n        // Market data exists, display it\n        await displayMarketSummary(player, gameServerId, mod, marketDataVar.data.data[0], industryFilter);\n    }\n}\n\n// Display the market summary to the player\nasync function displayMarketSummary(player, gameServerId, mod, marketDataVariable, industryFilter) {\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Handle empty string or empty object\n            if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (e) {\n            // In case of parsing error\n            activeEvent = null;\n        }\n    }\n\n    const stocks = JSON.parse(marketDataVariable.value);\n\n    // Get all available industries for reference\n    const availableIndustries = [...new Set(stocks.map(stock => stock.sector))];\n\n    // If industry filter is provided and not \"ALL\", check if it's valid\n    if (industryFilter !== \"ALL\") {\n        // Check if the industry exists\n        const industryExists = availableIndustries.includes(industryFilter);\n\n        if (!industryExists) {\n            throw new TakaroUserError(`Industry \"${industryFilter}\" not found. Available industries: ${availableIndustries.join(', ')}\\nUse \"ALL\" to view all industries.`);\n        }\n    }\n\n    // Send header message\n    let headerMessage = \"=== STOCK MARKET SUMMARY ===\\n\";\n\n    // If filtering by industry, mention it in the header\n    if (industryFilter !== \"ALL\") {\n        headerMessage = `=== ${industryFilter} INDUSTRY ===\\n`;\n    }\n\n    // If there's an active event, include it in the header\n    if (activeEvent) {\n        headerMessage += `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n`;\n        headerMessage += `${activeEvent.description}\\n\\n`;\n\n        // If filtering by industry, only show relevant impacts\n        if (industryFilter !== \"ALL\") {\n            const relevantImpact = activeEvent.sectorImpacts.find(\n                impact => impact.sectorId === industryFilter\n            );\n\n            if (relevantImpact) {\n                const direction = relevantImpact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `Industry Impact: ${direction} ${Math.abs(relevantImpact.impact)}%\\n`;\n            } else {\n                headerMessage += \"This industry is not directly affected by the current event.\\n\";\n            }\n        } else {\n            // Show all industry impacts\n            headerMessage += \"Industry Impacts:\\n\";\n            for (const impact of activeEvent.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%\\n`;\n            }\n        }\n    }\n\n    // Send header message first\n    await player.pm(headerMessage);\n\n    // Group stocks by industry\n    const stocksByIndustry = {};\n    stocks.forEach(stock => {\n        if (!stocksByIndustry[stock.sector]) {\n            stocksByIndustry[stock.sector] = [];\n        }\n        stocksByIndustry[stock.sector].push(stock);\n    });\n\n    // If industry filter is not \"ALL\", only show that industry\n    if (industryFilter !== \"ALL\") {\n        const filteredStocks = stocksByIndustry[industryFilter] || [];\n\n        if (filteredStocks.length > 0) {\n            let stockMessage = \"\";\n\n            filteredStocks.forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                stockMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(stockMessage);\n        } else {\n            await player.pm(`No stocks found in the ${industryFilter} industry.`);\n        }\n    } else {\n        // Send each industry as a separate message\n        for (const industryId in stocksByIndustry) {\n            let industryMessage = `=== ${industryId} INDUSTRY ===\\n`;\n\n            stocksByIndustry[industryId].forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                industryMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(industryMessage);\n        }\n    }\n\n    // Add a help message for industry filtering if showing all industries\n    if (industryFilter === \"ALL\") {\n        const allIndustries = Object.keys(stocksByIndustry).join(', ');\n        await player.pm(`\\nTip: Use '/markets [industry]' to view only stocks in a specific industry. Available industries: ${allIndustries}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return false;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            const results = await Promise.allSettled(createPromises);\n            // Check if the critical stock_market_data was created successfully\n            const stockDataPromise = results[0];\n            if (stockDataPromise && stockDataPromise.status === 'rejected') {\n                console.log(`Failed to create stock_market_data: ${stockDataPromise.reason}`);\n                return false;\n            }\n        }\n\n        return true;\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n        return false;\n    }\n}\n\nawait main();",
                    "name": "markets",
                    "description": null,
                    "trigger": "markets",
                    "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. \n",
                    "arguments": [
                        {
                            "name": "Industry",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. ",
                            "position": 0
                        }
                    ]
                }
            ],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n\n    // Get the Discord channel ID from module configuration\n    // IMPORTANT: You need to add 'marketNewsChannelId' to your module's configSchema and set its value.\n    const discordChannelId = mod.userConfig.marketNewsChannelId;\n\n    if (!discordChannelId) {\n        takaro.log.info('Market news Discord channel ID (marketNewsChannelId) not configured in module settings. Skipping Discord messages.');\n    }\n\n    // Check for online players\n    const currentPlayers = (await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    })).data.meta;\n\n    if (currentPlayers.total === 0) {\n        takaro.log.info('Skipping daily market report: No players online.');\n        return; // No players online, skip the market news\n    }\n\n    // Get current stock data (which should include lastPrice)\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        takaro.log.warn('Skipping daily market report: Market data variable not found.');\n        return; // Market not initialized yet\n    }\n\n    let stocks;\n    try {\n        stocks = JSON.parse(marketDataVar.data.data[0].value);\n        if (!Array.isArray(stocks)) {\n            throw new Error('Parsed market data is not an array.');\n        }\n    } catch (error) {\n        takaro.log.error(`Failed to parse stock_market_data: ${error}`);\n        return; // Invalid market data\n    }\n\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Ensure activeEvent is an object with data, not an empty string or empty object\n            if (typeof activeEvent !== 'object' || activeEvent === null || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (error) {\n            takaro.log.warn(`Failed to parse active_market_event: ${error}`);\n            activeEvent = null; // Continue without event info if parsing fails\n        }\n    }\n\n    // --- Message 1: Header and active event ---\n    let gameMessage1 = \"==== DAILY MARKET REPORT ====\\n\";\n    let discordMessage1 = \"**==== DAILY MARKET REPORT ====**\\n\"; // Discord version with Markdown\n\n    if (activeEvent && activeEvent.name && activeEvent.description) {\n        const eventText = `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n${activeEvent.description}\\n`;\n        gameMessage1 += eventText;\n        discordMessage1 += eventText;\n    } else {\n        const noEventText = '\\nNo active market events today.\\n';\n        gameMessage1 += noEventText;\n        discordMessage1 += noEventText;\n    }\n\n    // Send first part of the report to game server\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage1\n    }).catch(err => takaro.log.error(`Failed to send game message 1: ${err}`));\n\n    // Send first part of the report to Discord\n    if (discordChannelId) {\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessage1\n        }).catch(err => takaro.log.error(`Failed to send Discord message 1: ${err.message || err}`));\n    }\n\n    // --- Calculate stock performance using stock.price and stock.lastPrice ---\n    const stocksWithPerformance = stocks.map(stock => {\n        let change = 0;\n        let percentChange = 0;\n        let changeSymbol = 'â†’'; // Default: No change or insufficient data\n\n        if (typeof stock.price === 'number' && typeof stock.lastPrice === 'number' && stock.lastPrice !== 0) {\n            change = stock.price - stock.lastPrice;\n            percentChange = (change / stock.lastPrice) * 100;\n            if (percentChange > 0.05) {\n                changeSymbol = 'â†‘';\n            } else if (percentChange < -0.05) {\n                changeSymbol = 'â†“';\n            }\n        } else if (typeof stock.price === 'number' && stock.lastPrice === undefined) {\n            changeSymbol = 'ðŸ†•';\n            percentChange = 0;\n        }\n        return {\n            ...stock,\n            change,\n            percentChange,\n            changeSymbol\n        };\n    });\n\n    // --- Group by sector ---\n    const sectorPerformance = {};\n    stocksWithPerformance.forEach(stock => {\n        const sectorId = stock.sector || 'Uncategorized';\n        if (!sectorPerformance[sectorId]) {\n            sectorPerformance[sectorId] = {\n                stocks: [],\n                totalPercentChange: 0,\n                count: 0\n            };\n        }\n        sectorPerformance[sectorId].stocks.push(stock);\n        if (typeof stock.percentChange === 'number' && isFinite(stock.percentChange)) {\n            sectorPerformance[sectorId].totalPercentChange += stock.percentChange;\n            sectorPerformance[sectorId].count++;\n        }\n    });\n\n    // --- Calculate average sector performance ---\n    for (const sectorId in sectorPerformance) {\n        const sectorData = sectorPerformance[sectorId];\n        if (sectorData.count > 0) {\n            sectorData.avgPerformance = sectorData.totalPercentChange / sectorData.count;\n        } else {\n            sectorData.avgPerformance = 0;\n        }\n    }\n\n    const sortedSectors = Object.entries(sectorPerformance)\n        .sort(([, a], [, b]) => b.avgPerformance - a.avgPerformance);\n\n    // --- Message 2: Sector performance ---\n    let gameMessage2 = \"\\n=== SECTOR PERFORMANCE ===\\n\";\n    let discordMessage2 = \"\\n**=== SECTOR PERFORMANCE ===**\\n\"; // Discord version\n\n    if (sortedSectors.length > 0) {\n        sortedSectors.forEach(([sectorId, sectorData]) => {\n            const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n            const line = `${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n            gameMessage2 += line;\n            discordMessage2 += line;\n        });\n    } else {\n        const noDataText = \"No sector performance data available.\\n\";\n        gameMessage2 += noDataText;\n        discordMessage2 += noDataText;\n    }\n\n    // Send sector performance report to game server\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage2\n    }).catch(err => takaro.log.error(`Failed to send game message 2: ${err}`));\n\n    // Send sector performance report to Discord\n    if (discordChannelId) {\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessage2\n        }).catch(err => takaro.log.error(`Failed to send Discord message 2: ${err.message || err}`));\n    }\n\n    // --- Message 3: Top and Worst performers ---\n    const validPerformers = stocksWithPerformance.filter(s => typeof s.percentChange === 'number' && isFinite(s.percentChange));\n    validPerformers.sort((a, b) => b.percentChange - a.percentChange);\n\n    let gameMessage3 = \"\";\n    let discordMessage3 = \"\";\n\n    const topPerformersTitleGame = \"\\nðŸ”¥ TOP PERFORMERS ðŸ”¥\\n\";\n    const topPerformersTitleDiscord = \"\\n**ðŸ”¥ TOP PERFORMERS ðŸ”¥**\\n\";\n    gameMessage3 += topPerformersTitleGame;\n    discordMessage3 += topPerformersTitleDiscord;\n\n    if (validPerformers.length > 0) {\n        for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n            const stock = validPerformers[i];\n            const line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            gameMessage3 += line;\n            discordMessage3 += line;\n        }\n    } else {\n        const noTopText = \"No top performers today.\\n\";\n        gameMessage3 += noTopText;\n        discordMessage3 += noTopText;\n    }\n\n    const worstPerformersTitleGame = \"\\nðŸ“‰ WORST PERFORMERS ðŸ“‰\\n\";\n    const worstPerformersTitleDiscord = \"\\n**ðŸ“‰ WORST PERFORMERS ðŸ“‰**\\n\";\n    gameMessage3 += worstPerformersTitleGame;\n    discordMessage3 += worstPerformersTitleDiscord;\n\n    if (validPerformers.length > 0) {\n        const worstStartIndex = Math.max(0, validPerformers.length - 3);\n        for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n            const stock = validPerformers[i];\n            const line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            gameMessage3 += line;\n            discordMessage3 += line;\n        }\n    } else {\n        const noWorstText = \"No worst performers today.\\n\";\n        gameMessage3 += noWorstText;\n        discordMessage3 += noWorstText;\n    }\n\n    // Send top/worst performers report to game server\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage3\n    }).catch(err => takaro.log.error(`Failed to send game message 3: ${err}`));\n\n    // Send top/worst performers report to Discord\n    if (discordChannelId) {\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessage3\n        }).catch(err => takaro.log.error(`Failed to send Discord message 3: ${err.message || err}`));\n    }\n\n    takaro.log.info('Daily market report sent successfully (game server and potentially Discord).');\n}\n\nawait main();",
                    "name": "marketnews",
                    "description": null,
                    "temporalValue": "0 */1 * * *"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    try {\n        const { gameServerId, module: mod } = data;\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Check if market is initialized\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return; // Exit after initialization\n        }\n\n        // Get active market event\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event start time\n        const eventStartTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_start_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event execution counter\n        const eventCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_execution_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event cooldown counter\n        const cooldownCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_cooldown_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let eventCounter = 0;\n        if (eventCounterVar.data.data.length > 0) {\n            eventCounter = parseInt(eventCounterVar.data.data[0].value, 10);\n        }\n\n        let cooldownCounter = 0;\n        if (cooldownCounterVar.data.data.length > 0) {\n            cooldownCounter = parseInt(cooldownCounterVar.data.data[0].value, 10);\n        }\n\n        // Get event duration\n        const eventDurationVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['current_event_duration'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Use stored random duration if available, otherwise use defaultEventDuration\n        let eventDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        if (eventDurationVar.data.data.length > 0) {\n            eventDuration = parseInt(eventDurationVar.data.data[0].value, 10);\n        }\n\n        let activeEvent = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                // If it's an empty string, treat as no active event\n                if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                    activeEvent = null;\n                }\n            } catch (e) {\n                // In case of parsing error, consider no active event\n                activeEvent = null;\n            }\n        }\n\n        // Check if the current event should end and increment counter\n        if (activeEvent) {\n            // Increment the event execution counter\n            eventCounter++;\n\n            // Update or create the counter\n            if (eventCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: eventCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: eventCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n\n            // End the event if counter reached duration\n            if (eventCounter >= eventDuration) {\n                // Clear the active event\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: ''\n                    });\n                }\n\n                // Reset counter to 0\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                // Reset cooldown counter to 0 to begin cooldown period\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_cooldown_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Announce the end of the event to all online players\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    const message = `ðŸ“ˆ MARKET UPDATE ðŸ“‰\\n\\nThe \"${activeEvent.name}\" event has ended. Markets are returning to normal conditions.`;\n\n                    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                        message: message\n                    });\n                }\n\n                // Reset active event\n                activeEvent = null;\n            }\n        } else {\n            // No active event, increment cooldown counter\n            cooldownCounter++;\n\n            // Update or create the cooldown counter\n            if (cooldownCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: cooldownCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: cooldownCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n        }\n\n        // Get last event time for event frequency calculation\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        const eventFrequency = (mod.userConfig && mod.userConfig.eventFrequency) || 10;\n        let shouldTriggerEvent = false;\n\n        // Only trigger a new event if:\n        // 1. There's no active event \n        // 2. We have passed the cooldown period (cooldownCounter >= eventFrequency)\n        if (!activeEvent && cooldownCounter >= eventFrequency) {\n            // Base chance to trigger an event\n            shouldTriggerEvent = Math.random() < 0.5; // 50% chance\n\n            // Force an event if we're well past the cooldown period (2x frequency)\n            if (cooldownCounter >= eventFrequency * 2) {\n                shouldTriggerEvent = true;\n            }\n        }\n\n        // If we should trigger a new event, select a random one\n        if (shouldTriggerEvent) {\n            const events = (mod.userConfig && mod.userConfig.marketEvents) || [];\n            if (events.length > 0) {\n                const randomEvent = events[Math.floor(Math.random() * events.length)];\n                activeEvent = randomEvent;\n\n                // Generate a random duration between 1 and defaultEventDuration\n                const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n                const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n                // Save the random duration\n                if (eventDurationVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                        value: randomDuration.toString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'current_event_duration',\n                        value: randomDuration.toString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Reset the event counter to 0\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Reset the cooldown counter\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                // Update active event\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: JSON.stringify(activeEvent)\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'active_market_event',\n                        value: JSON.stringify(activeEvent),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Update event start time\n                if (eventStartTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_start_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Update last event time\n                if (lastEventTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'last_market_event_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Announce the event to all online players\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    // Format sector impacts for announcement\n                    let impactText = \"\";\n                    for (const impact of activeEvent.sectorImpacts) {\n                        const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                        impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n                    }\n\n                    const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${activeEvent.name}\\n${activeEvent.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /market to see opportunities!`;\n\n                    // Split the message if it's too long\n                    const maxLength = 400; // Safe limit for most games\n                    for (let i = 0; i < message.length; i += maxLength) {\n                        await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                            message: message.substring(i, i + maxLength)\n                        });\n                    }\n                }\n            }\n        }\n\n        // Get stocks\n        if (!marketDataVar.data.data[0] || !marketDataVar.data.data[0].value) {\n            // Re-initialize market if value is missing\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        let stocks;\n        try {\n            stocks = JSON.parse(marketDataVar.data.data[0].value);\n            if (!Array.isArray(stocks)) {\n                throw new Error(\"Parsed stocks data is not an array\");\n            }\n        } catch (e) {\n            // Re-initialize market if data is corrupt\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        const significantChanges = [];\n\n        // Update each stock price\n        stocks.forEach(stock => {\n            // Save the current price as lastPrice for change tracking\n            if (!stock.lastPrice) {\n                stock.lastPrice = stock.price;\n            } else {\n                stock.lastPrice = stock.price;\n            }\n\n            // Calculate base price change based on volatility\n            // Using a more normalized random approach\n            // Math.random() * 2 - 1 gives a value between -1 and 1\n            const randomFactor = Math.random() * 2 - 1;\n            const baseChangePercent = randomFactor * stock.volatility;\n            let totalChangePercent = baseChangePercent;\n\n            // Apply active event effects if any\n            if (activeEvent) {\n                const sectorImpact = activeEvent.sectorImpacts.find(impact => impact.sectorId === stock.sector);\n                if (sectorImpact) {\n                    // Convert impact percentage to decimal and apply a random factor\n                    // to create varied effects within each sector\n                    const eventImpactPercentage = sectorImpact.impact; // This is already a percentage\n                    const eventImpactDecimal = eventImpactPercentage / 100; // Convert to decimal\n                    const randomImpactFactor = 0.5 + Math.random(); // Between 0.5 and 1.5\n                    const eventImpact = eventImpactDecimal * randomImpactFactor;\n\n                    // Add the event impact to the total change percent\n                    totalChangePercent += eventImpact;\n                }\n            }\n\n            // Apply the price change\n            const oldPrice = stock.price;\n            const priceChange = stock.price * totalChangePercent;\n            stock.price = Math.max(1, stock.price + priceChange);\n\n            // Check if this is a significant change\n            const changeThreshold = ((mod.userConfig && mod.userConfig.priceAlertThreshold) || 10) / 100;\n            const percentChange = (stock.price - stock.lastPrice) / stock.lastPrice;\n\n            if (Math.abs(percentChange) > changeThreshold) {\n                significantChanges.push({\n                    ...stock,\n                    changePercent: percentChange * 100\n                });\n            }\n        });\n\n        // Save updated prices\n        await takaro.variable.variableControllerUpdate(marketDataVar.data.data[0].id, {\n            value: JSON.stringify(stocks)\n        });\n\n        // Broadcast major changes to all players\n        if (significantChanges.length > 0) {\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                // Sort by absolute change percentage\n                significantChanges.sort((a, b) => Math.abs(b.changePercent) - Math.abs(a.changePercent));\n\n                // Take top 3 most significant changes\n                const topChanges = significantChanges.slice(0, Math.min(3, significantChanges.length));\n\n                // Formulate message about big market changes\n                let message = \"ðŸ“Š STOCK MARKET ALERT ðŸ“Š\\n\";\n                topChanges.forEach(stock => {\n                    const changeDir = stock.changePercent > 0 ? \"up\" : \"down\";\n                    const changePercent = Math.abs(Math.round(stock.changePercent));\n\n                    message += `${stock.id} (${stock.sector}): ${changeDir} ${changePercent}% to $${Math.round(stock.price)}!\\n`;\n                });\n\n                if (activeEvent) {\n                    message += `\\nCurrent market event: ${activeEvent.name}`;\n                }\n\n                // Send the message\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            }\n        }\n    } catch (error) {\n        // If something goes wrong, log it\n        console.log(`Error in updateStockPrices: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            await Promise.allSettled(createPromises);\n        }\n\n        // Only announce if we had to create at least the stock data (indicating a new market)\n        if (marketDataVar.data.data.length === 0) {\n            // Announce market initialization to online players\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /market to see available stocks and /buy to start investing.\";\n\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            }\n        }\n    } catch (error) {\n        // Log the error but don't throw, so the cronjob can continue\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "updatestockprices",
                    "description": null,
                    "temporalValue": "5 4 * * *"
                }
            ],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Allows the player to view market prices and their portfolio",
                    "permission": "STOCK_MARKET_USE",
                    "friendlyName": "Use Stock Market"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows the player to buy and sell stocks",
                    "permission": "STOCK_MARKET_TRADE",
                    "friendlyName": "Trade Stocks"
                },
                {
                    "canHaveCount": false,
                    "description": "VIP status that reduces transaction fees",
                    "permission": "STOCK_MARKET_BROKER",
                    "friendlyName": "Stock Broker"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows admins to manually trigger market events",
                    "permission": "STOCK_MARKET_TRIGGER_EVENT",
                    "friendlyName": "Trigger Market Events"
                }
            ]
        },
        {
            "tag": "0.1.1",
            "description": "**Stock Market: A Dynamic Virtual Trading System**\n\nCreate an immersive economic experience with this comprehensive stock market module that lets players invest, trade, and react to market events.\n\n**Market Features:**\n\n![Market Summary](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stocks.png)\n\n* **Multiple Economic Sectors:** Configure various industry sectors (Resource Extraction, Manufacturing, Defense, etc.) each with their own market dynamics.\n* **Realistic Stock Behavior:** Stocks have configurable volatility, sector-based pricing, and react differently to market events.\n* **Dynamic Market Events:** Random or admin-triggered events like \"Horde Night Approaching\" or \"Societal Collapse Setback\" impact different sectors in realistic ways.\n\n![Market Events](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_events.png)\n\n**Trading System:**\n\n* **Buy & Sell Shares:** Players can purchase stocks and sell them later for profit or loss.\n* **Transaction Fees:** Configurable fee percentage on all trades creates a realistic market economy.\n* **VIP Benefits:** Special permissions for designated \"Stock Brokers\" who receive fee discounts.\n\n![Buy Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_buy.png)\n\nPlayers can track price changes and sell at the right moment to maximize profits or minimize losses.\n\n![Sell Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sell.png)\n\n**Player Portfolio:**\n\n* **Portfolio Tracking:** Players can view their holdings, average purchase prices, and current profit/loss.\n* **Transaction History:** System tracks all buy/sell transactions for each player.\n* **Summary Statistics:** See overall portfolio performance and value across all holdings.\n\n![Portfolio View](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockportfolio.png)\n\n**Market Information:**\n\n* **Detailed Stock Info:** Players can research specific stocks, including risk levels and sector trends.\n* **Industry Filters:** View stocks by specific sectors to better understand market segments.\n* **Market Alerts:** Server-wide notifications for significant price changes keep players engaged.\n\n![Market Alerts](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockpricechange.png)\n\n**Configuration Options:**\n\n* **Sectors & Stocks:** Define your own market sectors and individual stocks with customizable starting prices and volatility.\n* **Market Events:** Create unique events with specific sector impacts to drive market dynamics.\n* **Transaction Settings:** Configure fee percentages, VIP discounts, and alert thresholds.\n* **Event Frequency:** Control how often random market events occur and how long they last.\n\n![Configuration](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_config.png)\n![Sectors](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sectors.png)\n\n**Commands:**\n\n* `/markets [industry]` - View all stocks or filter by industry\n* `/stockinfo [ticker]` - Get detailed information about a specific stock\n* `/buystock <ticker> <amount>` - Purchase shares of a stock\n* `/sellstock <ticker> <amount>` - Sell shares from your portfolio\n* `/stockportfolio` - View your current holdings and performance\n* `/triggerevent [event]` - Admin command to trigger specific market events\n\nWho says the apocalypse can't have a thriving economy? Now players can stress about both zombie hordes AND their Duke's Casino Tokens dropping 40% after a market event! As one trader put it: \"I used to check my 401K daily, and now I check my AMMO stock before every Blood Moon. Some habits die harder than zombies.\"",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sectors\":{\"type\":\"array\",\"title\":\"Wasteland Economic Sectors\",\"description\":\"Define economic sectors relevant to survival in Navezgane\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Sector ID (e.g., RESOURCES)\"},\"name\":{\"type\":\"string\",\"description\":\"Sector name (e.g., Resource Extraction)\"}}},\"default\":[{\"id\":\"RESOURCES\",\"name\":\"Resource Extraction\"},{\"id\":\"MANUFACTURING\",\"name\":\"Manufacturing & Crafting\"},{\"id\":\"DEFENSE\",\"name\":\"Defense & Fortifications\"},{\"id\":\"SURVIVAL\",\"name\":\"Survival Goods\"},{\"id\":\"TRADE\",\"name\":\"Trade & Currency\"}]},\"stocks\":{\"type\":\"array\",\"title\":\"Wasteland Stocks\",\"description\":\"List of stocks representing Navezgane entities and resources\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Stock ticker symbol (e.g., NMC)\"},\"name\":{\"type\":\"string\",\"description\":\"Entity/Resource name\"},\"sector\":{\"type\":\"string\",\"description\":\"Sector ID this stock belongs to\"},\"initialPrice\":{\"type\":\"number\",\"description\":\"Starting price in Dukes\",\"minimum\":1},\"volatility\":{\"type\":\"number\",\"description\":\"Base volatility percentage (5 = 5%)\",\"minimum\":1,\"maximum\":35}}},\"default\":[{\"id\":\"NMC\",\"name\":\"Navezgane Mining Co.\",\"sector\":\"RESOURCES\",\"initialPrice\":50,\"volatility\":15},{\"id\":\"WOOD\",\"name\":\"Wasteland Lumberjacks\",\"sector\":\"RESOURCES\",\"initialPrice\":20,\"volatility\":8},{\"id\":\"SHALE\",\"name\":\"Oil Shale Extractors\",\"sector\":\"RESOURCES\",\"initialPrice\":40,\"volatility\":18},{\"id\":\"FORGE\",\"name\":\"Forge Ahead Metals\",\"sector\":\"MANUFACTURING\",\"initialPrice\":75,\"volatility\":12},{\"id\":\"TOOLS\",\"name\":\"Working Stiff Tools\",\"sector\":\"MANUFACTURING\",\"initialPrice\":60,\"volatility\":10},{\"id\":\"MECH\",\"name\":\"JunkTech Robotics\",\"sector\":\"MANUFACTURING\",\"initialPrice\":110,\"volatility\":20},{\"id\":\"BUILD\",\"name\":\"Barricade Builders\",\"sector\":\"DEFENSE\",\"initialPrice\":45,\"volatility\":9},{\"id\":\"AMMO\",\"name\":\"AmmoNation Surplus\",\"sector\":\"DEFENSE\",\"initialPrice\":90,\"volatility\":25},{\"id\":\"SHAM\",\"name\":\"Shamway Foods\",\"sector\":\"SURVIVAL\",\"initialPrice\":30,\"volatility\":5},{\"id\":\"MEDS\",\"name\":\"Pop-N-Pills Medical\",\"sector\":\"SURVIVAL\",\"initialPrice\":100,\"volatility\":18},{\"id\":\"TRADE\",\"name\":\"Trader Guild Network\",\"sector\":\"TRADE\",\"initialPrice\":150,\"volatility\":10},{\"id\":\"DUKES\",\"name\":\"Duke's Casino Tokens\",\"sector\":\"TRADE\",\"initialPrice\":1,\"volatility\":3}]},\"marketEvents\":{\"type\":\"array\",\"title\":\"Wasteland Events\",\"description\":\"Events impacting the Navezgane economy\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Unique event ID\"},\"name\":{\"type\":\"string\",\"description\":\"Name of the event\"},\"description\":{\"type\":\"string\",\"description\":\"Description of the event's market effect\"},\"sectorImpacts\":{\"type\":\"array\",\"description\":\"How each sector is affected\",\"items\":{\"type\":\"object\",\"properties\":{\"sectorId\":{\"type\":\"string\",\"description\":\"Sector ID\"},\"impact\":{\"type\":\"number\",\"description\":\"Percentage impact (-30 = -30%)\",\"minimum\":-75,\"maximum\":75}}}}}},\"default\":[{\"id\":\"HORDE_INCOMING\",\"name\":\"Horde Night Approaching\",\"description\":\"Increased Zed activity signals the Blood Moon. Survivors prepare defenses.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-15},{\"sectorId\":\"MANUFACTURING\",\"impact\":20},{\"sectorId\":\"DEFENSE\",\"impact\":35},{\"sectorId\":\"SURVIVAL\",\"impact\":5},{\"sectorId\":\"TRADE\",\"impact\":-10}]},{\"id\":\"RESOURCE_SCARCITY\",\"name\":\"Resource Scarcity\",\"description\":\"Key resource veins are depleted, making raw materials harder to find.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-40},{\"sectorId\":\"MANUFACTURING\",\"impact\":-25},{\"sectorId\":\"DEFENSE\",\"impact\":-10},{\"sectorId\":\"SURVIVAL\",\"impact\":0},{\"sectorId\":\"TRADE\",\"impact\":5}]},{\"id\":\"ZED_OUTBREAK\",\"name\":\"Severe Zed Outbreak\",\"description\":\"An unusual concentration of Zed activity makes scavenging and travel extremely dangerous.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-30},{\"sectorId\":\"MANUFACTURING\",\"impact\":-10},{\"sectorId\":\"DEFENSE\",\"impact\":15},{\"sectorId\":\"SURVIVAL\",\"impact\":25},{\"sectorId\":\"TRADE\",\"impact\":-20}]},{\"id\":\"TRADE_ROUTE_SECURED\",\"name\":\"Trade Route Secured\",\"description\":\"Traders have established a safer passage, improving the flow of goods.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":5},{\"sectorId\":\"MANUFACTURING\",\"impact\":10},{\"sectorId\":\"DEFENSE\",\"impact\":0},{\"sectorId\":\"SURVIVAL\",\"impact\":15},{\"sectorId\":\"TRADE\",\"impact\":30}]},{\"id\":\"GENERAL_COLLAPSE\",\"name\":\"Societal Collapse Setback\",\"description\":\"A major setback reminds everyone how fragile survival is. Fear grips the market.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-25},{\"sectorId\":\"MANUFACTURING\",\"impact\":-30},{\"sectorId\":\"DEFENSE\",\"impact\":-15},{\"sectorId\":\"SURVIVAL\",\"impact\":-10},{\"sectorId\":\"TRADE\",\"impact\":-40}]}]},\"eventFrequency\":{\"title\":\"Event Frequency\",\"type\":\"number\",\"description\":\"Average number of update cycles between market events (0 to disable). Depends on mod's update frequency (e.g., per in-game hour?).\",\"default\":8,\"minimum\":1},\"defaultEventDuration\":{\"title\":\"Default Event Duration\",\"type\":\"number\",\"description\":\"Default number of update cycles an event lasts.\",\"default\":3,\"minimum\":1,\"maximum\":96},\"transactionFee\":{\"title\":\"Transaction Fee (Dukes Tax)\",\"type\":\"number\",\"description\":\"Percentage fee charged on all buy/sell transactions (5 = 5%)\",\"default\":3,\"minimum\":0,\"maximum\":25},\"vipDiscount\":{\"title\":\"Trader's Favor Discount\",\"type\":\"number\",\"description\":\"Percentage discount on transaction fees for players with 'STOCK_MARKET_BROKER' permission (50 = 50%)\",\"default\":50,\"minimum\":0,\"maximum\":100},\"priceAlertThreshold\":{\"title\":\"Price Alert Threshold\",\"type\":\"number\",\"description\":\"Percentage change that triggers a market alert (15 = 15%)\",\"default\":15,\"minimum\":5,\"maximum\":50}},\"additionalProperties\":false}",
            "uiSchema": "{\"sectors\":{\"items\":{\"ui:order\":[\"id\",\"name\"]}},\"stocks\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"sector\",\"initialPrice\",\"volatility\"]}},\"marketEvents\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"description\",\"sectorImpacts\"],\"sectorImpacts\":{\"items\":{\"ui:order\":[\"sectorId\",\"impact\"]}}}},\"transactionFee\":{\"ui:widget\":\"range\"},\"vipDiscount\":{\"ui:widget\":\"range\"},\"eventFrequency\":{\"ui:help\":\"Set to 0 to disable random events\"},\"priceAlertThreshold\":{\"ui:widget\":\"range\"}}",
            "commands": [
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // Get player's portfolio\n    const portfolioVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_portfolio'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId],\n            playerId: [player.id]\n        }\n    });\n\n    let portfolio = {};\n    if (portfolioVar.data.data.length > 0) {\n        portfolio = JSON.parse(portfolioVar.data.data[0].value);\n    }\n\n    // Send header\n    await player.pm(\"=== YOUR STOCK PORTFOLIO ===\");\n\n    let hasStocks = false;\n    let totalValue = 0;\n    let totalInvestment = 0;\n\n    // If no stocks, send a simple message\n    if (Object.keys(portfolio).length === 0) {\n        await player.pm(\"You don't own any stocks yet.\\n\" +\n            \"Use /markets to see available stocks and prices.\\n\" +\n            \"Use /buy <stock> <amount> to purchase stocks.\");\n        return;\n    }\n\n    // Send each stock as a separate message to avoid length issues\n    for (const [stockId, data] of Object.entries(portfolio)) {\n        hasStocks = true;\n        const stock = stocks.find(s => s.id === stockId);\n        if (!stock) continue; // Stock might have been removed from config\n\n        const currentValue = stock.price * data.shares;\n        const investmentValue = data.averagePrice * data.shares;\n        totalValue += currentValue;\n        totalInvestment += investmentValue;\n        const profit = currentValue - investmentValue;\n        const profitPercent = ((profit / investmentValue) * 100).toFixed(1);\n\n        let stockMessage = `--- ${stockId} (${stock.sector}) ---\\n`;\n        stockMessage += `Shares: ${data.shares}\\n`;\n        stockMessage += `Avg buy: $${Math.round(data.averagePrice)}\\n`;\n        stockMessage += `Current price: $${Math.round(stock.price)}\\n`;\n        stockMessage += `Total value: $${Math.round(currentValue)}\\n`;\n\n        if (profit >= 0) {\n            stockMessage += `Profit: +$${Math.round(profit)} (+${profitPercent}%)\\n`;\n        } else {\n            stockMessage += `Loss: -$${Math.abs(Math.round(profit))} (${profitPercent}%)\\n`;\n        }\n\n        await player.pm(stockMessage);\n    }\n\n    if (hasStocks) {\n        const totalProfit = totalValue - totalInvestment;\n        const totalProfitPercent = ((totalProfit / totalInvestment) * 100).toFixed(1);\n\n        let summaryMessage = \"=== PORTFOLIO SUMMARY ===\\n\";\n        summaryMessage += `Total investment: $${Math.round(totalInvestment)}\\n`;\n        summaryMessage += `Current value: $${Math.round(totalValue)}\\n`;\n\n        if (totalProfit >= 0) {\n            summaryMessage += `Overall profit: +$${Math.round(totalProfit)} (+${totalProfitPercent}%)\\n`;\n        } else {\n            summaryMessage += `Overall loss: -$${Math.abs(Math.round(totalProfit))} (${totalProfitPercent}%)\\n`;\n        }\n\n        // Get transaction history count\n        try {\n            const historyVar = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: ['stock_transaction_history'],\n                    gameServerId: [gameServerId],\n                    moduleId: [mod.moduleId],\n                    playerId: [player.id]\n                }\n            });\n\n            if (historyVar.data.data.length > 0) {\n                const history = JSON.parse(historyVar.data.data[0].value);\n                const buyCount = history.filter(t => t.type === 'BUY').length;\n                const sellCount = history.filter(t => t.type === 'SELL').length;\n\n                summaryMessage += `\\nTransactions: ${history.length} (${buyCount} buys, ${sellCount} sells)\\n`;\n            }\n        } catch (error) {\n            // Just ignore history errors\n        }\n\n        await player.pm(summaryMessage);\n\n    }\n}\n\nawait main();",
                    "name": "stockportfolio",
                    "description": null,
                    "trigger": "stockportfolio",
                    "helpText": "No help text available",
                    "arguments": []
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === args.stock.toUpperCase());\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${args.stock} not found. Use /market to see available stocks.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate costs using Math.round to ensure we work with integers\n        const subtotal = Math.round(stock.price) * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const totalCost = subtotal + fee;\n\n        // Check if player has enough currency\n        const playerData = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, player.id);\n        const currentBalance = playerData.data.data.currency;\n\n        if (currentBalance < totalCost) {\n            throw new TakaroUserError(`You don't have enough currency. Cost: $${subtotal} + $${fee} fee = $${totalCost}. Your balance: $${currentBalance}`);\n        }\n\n        // Deduct the currency - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerDeductCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: totalCost\n            }\n        );\n\n        // Get player's portfolio or create new one\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        let portfolio;\n        if (portfolioVar.data.data.length === 0) {\n            portfolio = {};\n        } else {\n            portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        }\n\n        // Update portfolio using rounded values for consistency\n        const stockPrice = Math.round(stock.price);\n        if (!portfolio[stock.id]) {\n            portfolio[stock.id] = {\n                shares: amount,\n                averagePrice: stockPrice\n            };\n        } else {\n            const totalShares = portfolio[stock.id].shares + amount;\n            const totalValue = (portfolio[stock.id].shares * portfolio[stock.id].averagePrice) + (amount * stockPrice);\n            portfolio[stock.id].shares = totalShares;\n            portfolio[stock.id].averagePrice = Math.round(totalValue / totalShares);\n        }\n\n        // Save updated portfolio\n        if (portfolioVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_portfolio',\n                value: JSON.stringify(portfolio),\n                gameServerId,\n                moduleId: mod.moduleId,\n                playerId: player.id\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n                value: JSON.stringify(portfolio)\n            });\n        }\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'BUY',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: totalCost,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully bought ${amount} shares of ${stock.id} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Total cost: $${totalCost}\\n`;\n        message += `Current portfolio: ${portfolio[stock.id].shares} shares of ${stock.id}`;\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in buystock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your purchase. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "buystock",
                    "description": null,
                    "trigger": "buystock",
                    "helpText": "Buy shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol ",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to buy",
                            "position": 1
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Handle the industry argument - use \"ALL\" as a special value to show all industries\n    const industryFilter = args.Industry ? args.Industry.toUpperCase() : \"ALL\";\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    // If market data doesn't exist, try to initialize it\n    if (marketDataVar.data.data.length === 0) {\n        const initialized = await initializeMarketIfNeeded(gameServerId, mod);\n        if (!initialized) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        // Get the freshly initialized market data\n        const refreshedMarketData = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (refreshedMarketData.data.data.length === 0) {\n            throw new TakaroUserError(\"There was an issue initializing the stock market. Please try again later.\");\n        }\n\n        // Continue with the refreshed data\n        await displayMarketSummary(player, gameServerId, mod, refreshedMarketData.data.data[0], industryFilter);\n    } else {\n        // Market data exists, display it\n        await displayMarketSummary(player, gameServerId, mod, marketDataVar.data.data[0], industryFilter);\n    }\n}\n\n// Display the market summary to the player\nasync function displayMarketSummary(player, gameServerId, mod, marketDataVariable, industryFilter) {\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Handle empty string or empty object\n            if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (e) {\n            // In case of parsing error\n            activeEvent = null;\n        }\n    }\n\n    const stocks = JSON.parse(marketDataVariable.value);\n\n    // Get all available industries for reference\n    const availableIndustries = [...new Set(stocks.map(stock => stock.sector))];\n\n    // If industry filter is provided and not \"ALL\", check if it's valid\n    if (industryFilter !== \"ALL\") {\n        // Check if the industry exists\n        const industryExists = availableIndustries.includes(industryFilter);\n\n        if (!industryExists) {\n            throw new TakaroUserError(`Industry \"${industryFilter}\" not found. Available industries: ${availableIndustries.join(', ')}\\nUse \"ALL\" to view all industries.`);\n        }\n    }\n\n    // Send header message\n    let headerMessage = \"=== STOCK MARKET SUMMARY ===\\n\";\n\n    // If filtering by industry, mention it in the header\n    if (industryFilter !== \"ALL\") {\n        headerMessage = `=== ${industryFilter} INDUSTRY ===\\n`;\n    }\n\n    // If there's an active event, include it in the header\n    if (activeEvent) {\n        headerMessage += `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n`;\n        headerMessage += `${activeEvent.description}\\n\\n`;\n\n        // If filtering by industry, only show relevant impacts\n        if (industryFilter !== \"ALL\") {\n            const relevantImpact = activeEvent.sectorImpacts.find(\n                impact => impact.sectorId === industryFilter\n            );\n\n            if (relevantImpact) {\n                const direction = relevantImpact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `Industry Impact: ${direction} ${Math.abs(relevantImpact.impact)}%\\n`;\n            } else {\n                headerMessage += \"This industry is not directly affected by the current event.\\n\";\n            }\n        } else {\n            // Show all industry impacts\n            headerMessage += \"Industry Impacts:\\n\";\n            for (const impact of activeEvent.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%\\n`;\n            }\n        }\n    }\n\n    // Send header message first\n    await player.pm(headerMessage);\n\n    // Group stocks by industry\n    const stocksByIndustry = {};\n    stocks.forEach(stock => {\n        if (!stocksByIndustry[stock.sector]) {\n            stocksByIndustry[stock.sector] = [];\n        }\n        stocksByIndustry[stock.sector].push(stock);\n    });\n\n    // If industry filter is not \"ALL\", only show that industry\n    if (industryFilter !== \"ALL\") {\n        const filteredStocks = stocksByIndustry[industryFilter] || [];\n\n        if (filteredStocks.length > 0) {\n            let stockMessage = \"\";\n\n            filteredStocks.forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                stockMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(stockMessage);\n        } else {\n            await player.pm(`No stocks found in the ${industryFilter} industry.`);\n        }\n    } else {\n        // Send each industry as a separate message\n        for (const industryId in stocksByIndustry) {\n            let industryMessage = `=== ${industryId} INDUSTRY ===\\n`;\n\n            stocksByIndustry[industryId].forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                industryMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(industryMessage);\n        }\n    }\n\n    // Add a help message for industry filtering if showing all industries\n    if (industryFilter === \"ALL\") {\n        const allIndustries = Object.keys(stocksByIndustry).join(', ');\n        await player.pm(`\\nTip: Use '/markets [industry]' to view only stocks in a specific industry. Available industries: ${allIndustries}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return false;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            const results = await Promise.allSettled(createPromises);\n            // Check if the critical stock_market_data was created successfully\n            const stockDataPromise = results[0];\n            if (stockDataPromise && stockDataPromise.status === 'rejected') {\n                console.log(`Failed to create stock_market_data: ${stockDataPromise.reason}`);\n                return false;\n            }\n        }\n\n        return true;\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n        return false;\n    }\n}\n\nawait main();",
                    "name": "markets",
                    "description": null,
                    "trigger": "markets",
                    "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. \n",
                    "arguments": [
                        {
                            "name": "Industry",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. ",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get player's portfolio\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        if (portfolioVar.data.data.length === 0) {\n            throw new TakaroUserError(\"You don't own any stocks to sell.\");\n        }\n\n        const portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        const stockId = args.stock.toUpperCase();\n\n        if (!portfolio[stockId] || portfolio[stockId].shares < amount) {\n            throw new TakaroUserError(`You don't own ${amount} shares of ${stockId}.`);\n        }\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === stockId);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${stockId} not found in current market data. Please contact an admin.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate sale proceeds using Math.round to ensure we work with integers\n        const stockPrice = Math.round(stock.price);\n        const subtotal = stockPrice * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const netProceeds = subtotal - fee;\n\n        // Add money to player - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerAddCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: netProceeds\n            }\n        );\n\n        // Calculate profit/loss\n        const profitPerShare = stockPrice - portfolio[stockId].averagePrice;\n        const totalProfit = Math.round(profitPerShare * amount);\n        const profitText = totalProfit >= 0\n            ? `profit of $${totalProfit}`\n            : `loss of $${Math.abs(totalProfit)}`;\n\n        // Update portfolio\n        portfolio[stockId].shares -= amount;\n        if (portfolio[stockId].shares === 0) {\n            delete portfolio[stockId];\n        }\n\n        // Save updated portfolio\n        await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n            value: JSON.stringify(portfolio)\n        });\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'SELL',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: netProceeds,\n            profit: totalProfit,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully sold ${amount} shares of ${stockId} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Net proceeds: $${netProceeds} (${profitText})`;\n\n        // Add remaining shares info if player still has some\n        if (portfolio[stockId]) {\n            message += `\\nRemaining shares: ${portfolio[stockId].shares}`;\n        } else {\n            message += `\\nYou've sold all your ${stockId} shares.`;\n        }\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in sellstock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your sale. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "sellstock",
                    "description": null,
                    "trigger": "sellstock",
                    "helpText": "Sell shares of a stock",
                    "arguments": [
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to sell",
                            "position": 1
                        },
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // If a specific stock ticker is provided, show detailed info for that stock\n    const specificTicker = args.ticker ? args.ticker.toUpperCase() : null;\n\n    if (specificTicker && specificTicker !== \"ALL\") {\n        const stock = stocks.find(s => s.id.toUpperCase() === specificTicker);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${specificTicker} not found. Use /stockinfo without parameters to see all available stocks.`);\n        }\n\n        // Get active event to see if this stock's sector is affected\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let activeEvent = null;\n        let sectorImpact = null;\n\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEvent && activeEvent.sectorImpacts) {\n                    sectorImpact = activeEvent.sectorImpacts.find(impact =>\n                        impact.sectorId === stock.sector\n                    );\n                }\n            } catch (e) {\n                // Ignore parsing errors\n            }\n        }\n\n        // Calculate price change indicators\n        let changeText = '';\n        if (stock.lastPrice) {\n            const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n            const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n            changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n        }\n\n        // Add risk assessment based on volatility without showing the raw value\n        let riskLevel;\n        if (stock.volatility <= 0.05) riskLevel = \"Very Low\";\n        else if (stock.volatility <= 0.10) riskLevel = \"Low\";\n        else if (stock.volatility <= 0.15) riskLevel = \"Moderate\";\n        else if (stock.volatility <= 0.20) riskLevel = \"High\";\n        else riskLevel = \"Very High\";\n\n        // Build detailed stock info message\n        let message = `=== ${stock.id}: ${stock.name} ===\\n\\n`;\n        message += `Sector: ${stock.sector}\\n`;\n        message += `Current Price: $${Math.round(stock.price)}${changeText}\\n`;\n        message += `Risk Level: ${riskLevel}\\n`;\n\n        // Add sector trend info if available from event\n        if (activeEvent && sectorImpact) {\n            const direction = sectorImpact.impact >= 0 ? \"Positive\" : \"Negative\";\n            const strength = Math.abs(sectorImpact.impact);\n            let trend;\n\n            if (strength < 10) trend = \"Slight\";\n            else if (strength < 25) trend = \"Moderate\";\n            else trend = \"Strong\";\n\n            message += `\\nCurrent Trend: ${trend} ${direction} (${activeEvent.name})\\n`;\n            message += `Event: ${activeEvent.description}\\n`;\n        }\n\n        // Add trading guidance based on sector and risk, without mentioning volatility\n        message += `\\nTrading Notes:\\n`;\n\n        if (activeEvent && sectorImpact) {\n            if (sectorImpact.impact > 0) {\n                message += `- Currently bullish due to the ${activeEvent.name} event\\n`;\n            } else {\n                message += `- Currently bearish due to the ${activeEvent.name} event\\n`;\n            }\n        }\n\n        if (riskLevel === \"High\" || riskLevel === \"Very High\") {\n            message += `- Expect significant price fluctuations with this stock\\n`;\n        } else if (riskLevel === \"Low\" || riskLevel === \"Very Low\") {\n            message += `- Typically has stable price movement\\n`;\n        }\n\n        message += `\\nUse /buystock ${stock.id} [amount] to purchase shares`;\n\n        await player.pm(message);\n\n    } else {\n        // No specific ticker provided or ALL specified, show summary of all stocks\n        await player.pm(\"=== STOCK MARKET LISTINGS ===\\n\");\n\n        // Group stocks by sector\n        const stocksBySector = {};\n        stocks.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        // Display stocks by sector\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            let sectorMessage = `\\n--- ${sector} SECTOR ---\\n`;\n\n            sectorStocks.forEach(stock => {\n                // Add price change indicators\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                    changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                // Add risk level based on volatility\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                sectorMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n\n            await player.pm(sectorMessage);\n        }\n\n        // Add legend for risk indicators\n        const legend = \"\\n=== LEGEND ===\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\" +\n            \"Use /stockinfo [ticker] for detailed information about a specific stock\";\n\n        await player.pm(legend);\n    }\n}\n\nawait main();",
                    "name": "stockinfo",
                    "description": null,
                    "trigger": "stockinfo",
                    "helpText": "Shows all available stocks in the market. Use with a ticker symbol (e.g., /stockinfo ticker) to see detailed information about a specific stock.",
                    "arguments": [
                        {
                            "name": "ticker",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "stock ticker or ALL to get detailed information about a specific stock",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRIGGER_EVENT')) {\n        throw new TakaroUserError(\"You don't have permission to trigger market events.\");\n    }\n\n    try {\n        // Get current stock data to check market initialization\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Initialize market if needed\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            await player.pm(\"Market was not initialized. Initializing now...\");\n            return;\n        }\n\n        // Get events from module config\n        const marketEvents = mod.userConfig.marketEvents || [];\n\n        if (marketEvents.length === 0) {\n            throw new TakaroUserError(\"No market events configured in this module.\");\n        }\n\n        // Handle case when no event is specified or \"ALL\" is provided\n        if (!args.EventName || args.EventName.toUpperCase() === \"ALL\") {\n            await player.pm(\"=== AVAILABLE MARKET EVENTS ===\\n\");\n\n            // Group events by category or type if possible\n            const eventCategories = {};\n\n            // Create a simple categorization based on positive/negative impact\n            marketEvents.forEach(event => {\n                let category = \"Mixed\";\n                // Calculate net impact across all sectors\n                const netImpact = event.sectorImpacts.reduce((sum, impact) => sum + impact.impact, 0);\n\n                if (netImpact > 0) category = \"Positive\";\n                else if (netImpact < 0) category = \"Negative\";\n\n                if (!eventCategories[category]) {\n                    eventCategories[category] = [];\n                }\n                eventCategories[category].push(event);\n            });\n\n            // Display events by category\n            for (const [category, events] of Object.entries(eventCategories)) {\n                if (events.length > 0) {\n                    await player.pm(`\\n--- ${category.toUpperCase()} EVENTS ---`);\n\n                    let message = \"\";\n                    events.forEach(event => {\n                        // Format primary sectors affected\n                        const primarySectors = event.sectorImpacts\n                            .filter(impact => Math.abs(impact.impact) >= 15)\n                            .map(impact => {\n                                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                                return `${impact.sectorId} ${direction}${Math.abs(impact.impact)}%`;\n                            })\n                            .join(\", \");\n\n                        message += `${event.id}: ${event.name}\\n`;\n                        message += `   ${event.description}\\n`;\n                        if (primarySectors) {\n                            message += `   Major impacts: ${primarySectors}\\n`;\n                        }\n                        message += \"\\n\";\n                    });\n\n                    await player.pm(message);\n                }\n            }\n\n            await player.pm(\"=== HOW TO USE ===\\nUse `/triggerevent <EventName>` to trigger a specific event (e.g., `/triggerevent TECH_BOOM`)\");\n            return;\n        }\n\n        // Find the requested event\n        const eventId = args.EventName.toUpperCase();\n        const event = marketEvents.find(e => e.id === eventId);\n\n        if (!event) {\n            throw new TakaroUserError(`Event \"${eventId}\" not found. Use /triggerevent without parameters to see all available events.`);\n        }\n\n        // Get necessary variables for managing the event\n        const [activeEventVar, eventStartTimeVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_execution_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_cooldown_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['current_event_duration'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Check if there's an active event we need to cancel\n        let activeEventObj = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEventObj = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEventObj && Object.keys(activeEventObj).length > 0) {\n                    await player.pm(`Cancelling active event \"${activeEventObj.name}\" to trigger new event.`);\n                }\n            } catch (e) {\n                // Invalid event data, will be overwritten\n            }\n        }\n\n        // Generate a random duration for the event\n        const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n        // Update or create all event-related variables\n        const updatePromises = [];\n\n        // Save or update the random duration\n        if (eventDurationVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                    value: randomDuration.toString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'current_event_duration',\n                    value: randomDuration.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the event counter to 0\n        if (eventCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the cooldown counter\n        if (cooldownCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update active event\n        if (activeEventVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                    value: JSON.stringify(event)\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: JSON.stringify(event),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update event start time\n        if (eventStartTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update last event time\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (lastEventTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all updates to complete\n        await Promise.all(updatePromises);\n\n        // Check if there are online players to announce the event\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            // Format sector impacts for announcement\n            let impactText = \"\";\n            for (const impact of event.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n            }\n\n            const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${event.name}\\n${event.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /markets to see opportunities!`;\n\n            // Split the message if it's too long\n            const maxLength = 400; // Safe limit for most games\n            for (let i = 0; i < message.length; i += maxLength) {\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message: message.substring(i, i + maxLength)\n                });\n            }\n        }\n\n        await player.pm(`Successfully triggered the \"${event.name}\" market event for ${randomDuration} cycles!`);\n    } catch (error) {\n        // If something goes wrong, log it and let the player know\n        console.log(`Error in triggerEvent: ${error.message}`);\n        throw new TakaroUserError(`Error triggering event: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Store the stocks data\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_data',\n            value: JSON.stringify(stocks),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize last event time to now\n        await takaro.variable.variableControllerCreate({\n            key: 'last_market_event_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize event start time variable\n        await takaro.variable.variableControllerCreate({\n            key: 'event_start_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize active event (empty string means no active event)\n        await takaro.variable.variableControllerCreate({\n            key: 'active_market_event',\n            value: '',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Mark market as initialized\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_initialized',\n            value: 'true',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Announce market initialization to online players\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /markets to see available stocks and /buystock to start investing.\";\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message\n            });\n        }\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "triggerevent",
                    "description": null,
                    "trigger": "triggerevent",
                    "helpText": "Shows all available market events when run without parameters. Use with an event name (e.g., /triggerevent TECH_BOOM) to trigger a specific market event.",
                    "arguments": [
                        {
                            "name": "EventName",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "Event name to trigger a specific market event",
                            "position": 0
                        }
                    ]
                }
            ],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    try {\n        const { gameServerId, module: mod } = data;\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Check if market is initialized\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return; // Exit after initialization\n        }\n\n        // Get active market event\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event start time\n        const eventStartTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_start_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event execution counter\n        const eventCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_execution_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event cooldown counter\n        const cooldownCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_cooldown_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let eventCounter = 0;\n        if (eventCounterVar.data.data.length > 0) {\n            eventCounter = parseInt(eventCounterVar.data.data[0].value, 10);\n        }\n\n        let cooldownCounter = 0;\n        if (cooldownCounterVar.data.data.length > 0) {\n            cooldownCounter = parseInt(cooldownCounterVar.data.data[0].value, 10);\n        }\n\n        // Get event duration\n        const eventDurationVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['current_event_duration'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Use stored random duration if available, otherwise use defaultEventDuration\n        let eventDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        if (eventDurationVar.data.data.length > 0) {\n            eventDuration = parseInt(eventDurationVar.data.data[0].value, 10);\n        }\n\n        let activeEvent = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                // If it's an empty string, treat as no active event\n                if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                    activeEvent = null;\n                }\n            } catch (e) {\n                // In case of parsing error, consider no active event\n                activeEvent = null;\n            }\n        }\n\n        // Check if the current event should end and increment counter\n        if (activeEvent) {\n            // Increment the event execution counter\n            eventCounter++;\n\n            // Update or create the counter\n            if (eventCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: eventCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: eventCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n\n            // End the event if counter reached duration\n            if (eventCounter >= eventDuration) {\n                // Clear the active event\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: ''\n                    });\n                }\n\n                // Reset counter to 0\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                // Reset cooldown counter to 0 to begin cooldown period\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_cooldown_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Announce the end of the event to all online players\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    const message = `ðŸ“ˆ MARKET UPDATE ðŸ“‰\\n\\nThe \"${activeEvent.name}\" event has ended. Markets are returning to normal conditions.`;\n\n                    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                        message: message\n                    });\n                }\n\n                // Reset active event\n                activeEvent = null;\n            }\n        } else {\n            // No active event, increment cooldown counter\n            cooldownCounter++;\n\n            // Update or create the cooldown counter\n            if (cooldownCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: cooldownCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: cooldownCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n        }\n\n        // Get last event time for event frequency calculation\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        const eventFrequency = (mod.userConfig && mod.userConfig.eventFrequency) || 10;\n        let shouldTriggerEvent = false;\n\n        // Only trigger a new event if:\n        // 1. There's no active event \n        // 2. We have passed the cooldown period (cooldownCounter >= eventFrequency)\n        if (!activeEvent && cooldownCounter >= eventFrequency) {\n            // Base chance to trigger an event\n            shouldTriggerEvent = Math.random() < 0.5; // 50% chance\n\n            // Force an event if we're well past the cooldown period (2x frequency)\n            if (cooldownCounter >= eventFrequency * 2) {\n                shouldTriggerEvent = true;\n            }\n        }\n\n        // If we should trigger a new event, select a random one\n        if (shouldTriggerEvent) {\n            const events = (mod.userConfig && mod.userConfig.marketEvents) || [];\n            if (events.length > 0) {\n                const randomEvent = events[Math.floor(Math.random() * events.length)];\n                activeEvent = randomEvent;\n\n                // Generate a random duration between 1 and defaultEventDuration\n                const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n                const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n                // Save the random duration\n                if (eventDurationVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                        value: randomDuration.toString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'current_event_duration',\n                        value: randomDuration.toString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Reset the event counter to 0\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Reset the cooldown counter\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                // Update active event\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: JSON.stringify(activeEvent)\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'active_market_event',\n                        value: JSON.stringify(activeEvent),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Update event start time\n                if (eventStartTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_start_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Update last event time\n                if (lastEventTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'last_market_event_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Announce the event to all online players\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    // Format sector impacts for announcement\n                    let impactText = \"\";\n                    for (const impact of activeEvent.sectorImpacts) {\n                        const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                        impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n                    }\n\n                    const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${activeEvent.name}\\n${activeEvent.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /market to see opportunities!`;\n\n                    // Split the message if it's too long\n                    const maxLength = 400; // Safe limit for most games\n                    for (let i = 0; i < message.length; i += maxLength) {\n                        await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                            message: message.substring(i, i + maxLength)\n                        });\n                    }\n                }\n            }\n        }\n\n        // Get stocks\n        if (!marketDataVar.data.data[0] || !marketDataVar.data.data[0].value) {\n            // Re-initialize market if value is missing\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        let stocks;\n        try {\n            stocks = JSON.parse(marketDataVar.data.data[0].value);\n            if (!Array.isArray(stocks)) {\n                throw new Error(\"Parsed stocks data is not an array\");\n            }\n        } catch (e) {\n            // Re-initialize market if data is corrupt\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        const significantChanges = [];\n\n        // Update each stock price\n        stocks.forEach(stock => {\n            // Save the current price as lastPrice for change tracking\n            if (!stock.lastPrice) {\n                stock.lastPrice = stock.price;\n            } else {\n                stock.lastPrice = stock.price;\n            }\n\n            // Calculate base price change based on volatility\n            // Using a more normalized random approach\n            // Math.random() * 2 - 1 gives a value between -1 and 1\n            const randomFactor = Math.random() * 2 - 1;\n            const baseChangePercent = randomFactor * stock.volatility;\n            let totalChangePercent = baseChangePercent;\n\n            // Apply active event effects if any\n            if (activeEvent) {\n                const sectorImpact = activeEvent.sectorImpacts.find(impact => impact.sectorId === stock.sector);\n                if (sectorImpact) {\n                    // Convert impact percentage to decimal and apply a random factor\n                    // to create varied effects within each sector\n                    const eventImpactPercentage = sectorImpact.impact; // This is already a percentage\n                    const eventImpactDecimal = eventImpactPercentage / 100; // Convert to decimal\n                    const randomImpactFactor = 0.5 + Math.random(); // Between 0.5 and 1.5\n                    const eventImpact = eventImpactDecimal * randomImpactFactor;\n\n                    // Add the event impact to the total change percent\n                    totalChangePercent += eventImpact;\n                }\n            }\n\n            // Apply the price change\n            const oldPrice = stock.price;\n            const priceChange = stock.price * totalChangePercent;\n            stock.price = Math.max(1, stock.price + priceChange);\n\n            // Check if this is a significant change\n            const changeThreshold = ((mod.userConfig && mod.userConfig.priceAlertThreshold) || 10) / 100;\n            const percentChange = (stock.price - stock.lastPrice) / stock.lastPrice;\n\n            if (Math.abs(percentChange) > changeThreshold) {\n                significantChanges.push({\n                    ...stock,\n                    changePercent: percentChange * 100\n                });\n            }\n        });\n\n        // Save updated prices\n        await takaro.variable.variableControllerUpdate(marketDataVar.data.data[0].id, {\n            value: JSON.stringify(stocks)\n        });\n\n        // Broadcast major changes to all players\n        if (significantChanges.length > 0) {\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                // Sort by absolute change percentage\n                significantChanges.sort((a, b) => Math.abs(b.changePercent) - Math.abs(a.changePercent));\n\n                // Take top 3 most significant changes\n                const topChanges = significantChanges.slice(0, Math.min(3, significantChanges.length));\n\n                // Formulate message about big market changes\n                let message = \"ðŸ“Š STOCK MARKET ALERT ðŸ“Š\\n\";\n                topChanges.forEach(stock => {\n                    const changeDir = stock.changePercent > 0 ? \"up\" : \"down\";\n                    const changePercent = Math.abs(Math.round(stock.changePercent));\n\n                    message += `${stock.id} (${stock.sector}): ${changeDir} ${changePercent}% to $${Math.round(stock.price)}!\\n`;\n                });\n\n                if (activeEvent) {\n                    message += `\\nCurrent market event: ${activeEvent.name}`;\n                }\n\n                // Send the message\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            }\n        }\n    } catch (error) {\n        // If something goes wrong, log it\n        console.log(`Error in updateStockPrices: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            await Promise.allSettled(createPromises);\n        }\n\n        // Only announce if we had to create at least the stock data (indicating a new market)\n        if (marketDataVar.data.data.length === 0) {\n            // Announce market initialization to online players\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /market to see available stocks and /buy to start investing.\";\n\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            }\n        }\n    } catch (error) {\n        // Log the error but don't throw, so the cronjob can continue\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "updatestockprices",
                    "description": null,
                    "temporalValue": "5 4 * * *"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n\n    // Check for online players\n    const currentPlayers = (await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    })).data.meta;\n\n    if (currentPlayers.total === 0) {\n        takaro.log.info('Skipping daily market report: No players online.');\n        return; // No players online, skip the market news\n    }\n\n    // Get current stock data (which should include lastPrice)\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        takaro.log.warn('Skipping daily market report: Market data variable not found.');\n        return; // Market not initialized yet\n    }\n\n    let stocks;\n    try {\n        stocks = JSON.parse(marketDataVar.data.data[0].value);\n        if (!Array.isArray(stocks)) {\n            throw new Error('Parsed market data is not an array.');\n        }\n    } catch (error) {\n        takaro.log.error(`Failed to parse stock_market_data: ${error}`);\n        return; // Invalid market data\n    }\n\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n        } catch (error) {\n            takaro.log.warn(`Failed to parse active_market_event: ${error}`);\n            // Continue without event info if parsing fails\n        }\n    }\n\n    // --- Message 1: Header and active event ---\n    let message1 = \"==== DAILY MARKET REPORT ====\\n\";\n    if (activeEvent && activeEvent.name && activeEvent.description) {\n        message1 += `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n${activeEvent.description}\\n`;\n    } else {\n        message1 += '\\nNo active market events today.\\n';\n    }\n\n    // Send first part of the report\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: message1\n    }).catch(err => takaro.log.error(`Failed to send message 1: ${err}`));\n\n    // --- Calculate stock performance using stock.price and stock.lastPrice ---\n    const stocksWithPerformance = stocks.map(stock => {\n        let change = 0;\n        let percentChange = 0;\n        let changeSymbol = 'â†’'; // Default: No change or insufficient data\n\n        // Ensure required fields exist and lastPrice is a valid number > 0 for percentage calculation\n        if (typeof stock.price === 'number' && typeof stock.lastPrice === 'number' && stock.lastPrice !== 0) {\n            change = stock.price - stock.lastPrice;\n            percentChange = (change / stock.lastPrice) * 100;\n            if (percentChange > 0.05) { // Use a small threshold to avoid 'noise'\n                changeSymbol = 'â†‘';\n            } else if (percentChange < -0.05) {\n                changeSymbol = 'â†“';\n            }\n        } else if (typeof stock.price === 'number' && stock.lastPrice === undefined) {\n            // Handle case where lastPrice might not exist (e.g., new stock)\n            changeSymbol = 'ðŸ†•'; // Indicate 'New' or similar\n            percentChange = 0; // Or handle as needed\n        }\n        // If lastPrice is 0, or types are wrong, change/percentChange remain 0, symbol remains 'â†’'\n\n        return {\n            ...stock,\n            change,         // Absolute change\n            percentChange,  // Percentage change\n            changeSymbol    // Visual indicator\n        };\n    });\n\n    // --- Group by sector ---\n    const sectorPerformance = {};\n    stocksWithPerformance.forEach(stock => {\n        const sectorId = stock.sector || 'Uncategorized'; // Default sector if missing\n        if (!sectorPerformance[sectorId]) {\n            sectorPerformance[sectorId] = {\n                stocks: [],\n                totalPercentChange: 0, // Sum percentages for averaging\n                count: 0\n            };\n        }\n        sectorPerformance[sectorId].stocks.push(stock);\n        // Only include stocks with valid percentage change in the average\n        if (typeof stock.percentChange === 'number' && isFinite(stock.percentChange)) {\n            sectorPerformance[sectorId].totalPercentChange += stock.percentChange;\n            sectorPerformance[sectorId].count++;\n        }\n    });\n\n    // --- Calculate average sector performance ---\n    for (const sectorId in sectorPerformance) {\n        const sectorData = sectorPerformance[sectorId];\n        if (sectorData.count > 0) {\n            sectorData.avgPerformance = sectorData.totalPercentChange / sectorData.count;\n        } else {\n            sectorData.avgPerformance = 0; // Avoid division by zero if no stocks had valid changes\n        }\n    }\n\n    // Sort sectors by average performance\n    const sortedSectors = Object.entries(sectorPerformance)\n        .sort(([, a], [, b]) => b.avgPerformance - a.avgPerformance);\n\n    // --- Message 2: Sector performance ---\n    let message2 = \"\\n=== SECTOR PERFORMANCE ===\\n\";\n    if (sortedSectors.length > 0) {\n        sortedSectors.forEach(([sectorId, data]) => {\n            const avgSymbol = data.avgPerformance > 0.05 ? 'â†‘' : data.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n            message2 += `${sectorId}: ${avgSymbol} ${Math.abs(data.avgPerformance).toFixed(1)}%\\n`; // Use toFixed(1) like command\n        });\n    } else {\n        message2 += \"No sector performance data available.\\n\";\n    }\n\n    // Send sector performance report\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: message2\n    }).catch(err => takaro.log.error(`Failed to send message 2: ${err}`));\n\n\n    // --- Message 3: Top and Worst performers ---\n    // Filter out stocks where percentChange couldn't be calculated properly before sorting\n    const validPerformers = stocksWithPerformance.filter(s => typeof s.percentChange === 'number' && isFinite(s.percentChange));\n\n    // Sort valid performers\n    validPerformers.sort((a, b) => b.percentChange - a.percentChange);\n\n    let message3 = \"\\nðŸ”¥ TOP PERFORMERS ðŸ”¥\\n\";\n    if (validPerformers.length > 0) {\n        for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n            const stock = validPerformers[i];\n            // Use the pre-calculated changeSymbol based on percentChange\n            message3 += `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n        }\n    } else {\n        message3 += \"No top performers today.\\n\";\n    }\n\n\n    message3 += \"\\nðŸ“‰ WORST PERFORMERS ðŸ“‰\\n\";\n    if (validPerformers.length > 0) {\n        // Sort for worst (ascending order) - no need to create a new sorted array if we just reverse iteration\n        const worstStartIndex = Math.max(0, validPerformers.length - 3);\n        for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n            const stock = validPerformers[i];\n            // Use the pre-calculated changeSymbol based on percentChange\n            message3 += `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n        }\n    } else {\n        message3 += \"No worst performers today.\\n\";\n    }\n\n\n    // Send top/worst performers report\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: message3\n    }).catch(err => takaro.log.error(`Failed to send message 3: ${err}`));\n\n    // --- IMPORTANT: REMOVED the update of 'stock_market_yesterday' ---\n    // This script now assumes 'stock_market_data' contains 'lastPrice'.\n    // The responsibility of updating 'lastPrice' and the new 'price'\n    // must lie in another script/process that runs *before* this report.\n\n    takaro.log.info('Daily market report sent successfully.');\n}\n\nawait main();",
                    "name": "marketnews",
                    "description": null,
                    "temporalValue": "0 */1 * * *"
                }
            ],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Allows the player to view market prices and their portfolio",
                    "permission": "STOCK_MARKET_USE",
                    "friendlyName": "Use Stock Market"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows the player to buy and sell stocks",
                    "permission": "STOCK_MARKET_TRADE",
                    "friendlyName": "Trade Stocks"
                },
                {
                    "canHaveCount": false,
                    "description": "VIP status that reduces transaction fees",
                    "permission": "STOCK_MARKET_BROKER",
                    "friendlyName": "Stock Broker"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows admins to manually trigger market events",
                    "permission": "STOCK_MARKET_TRIGGER_EVENT",
                    "friendlyName": "Trigger Market Events"
                }
            ]
        },
        {
            "tag": "0.1.5",
            "description": "**Stock Market: A Dynamic Virtual Trading System**\n\nCreate an immersive economic experience with this comprehensive stock market module that lets players invest, trade, and react to market events.\n\n**Market Features:**\n\n![Market Summary](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stocks.png)\n\n* **Multiple Economic Sectors:** Configure various industry sectors (Resource Extraction, Manufacturing, Defense, etc.) each with their own market dynamics.\n* **Realistic Stock Behavior:** Stocks have configurable volatility, sector-based pricing, and react differently to market events.\n* **Dynamic Market Events:** Random or admin-triggered events like \"Horde Night Approaching\" or \"Societal Collapse Setback\" impact different sectors in realistic ways.\n\n![Market Events](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_events.png)\n\n**Trading System:**\n\n* **Buy & Sell Shares:** Players can purchase stocks and sell them later for profit or loss.\n* **Transaction Fees:** Configurable fee percentage on all trades creates a realistic market economy.\n* **VIP Benefits:** Special permissions for designated \"Stock Brokers\" who receive fee discounts.\n\n![Buy Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_buy.png)\n\nPlayers can track price changes and sell at the right moment to maximize profits or minimize losses.\n\n![Sell Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sell.png)\n\n**Player Portfolio:**\n\n* **Portfolio Tracking:** Players can view their holdings, average purchase prices, and current profit/loss.\n* **Transaction History:** System tracks all buy/sell transactions for each player.\n* **Summary Statistics:** See overall portfolio performance and value across all holdings.\n\n![Portfolio View](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockportfolio.png)\n\n**Market Information:**\n\n* **Detailed Stock Info:** Players can research specific stocks, including risk levels and sector trends.\n* **Industry Filters:** View stocks by specific sectors to better understand market segments.\n* **Market Alerts:** Server-wide notifications for significant price changes keep players engaged.\n\n![Market Alerts](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockpricechange.png)\n\n**Configuration Options:**\n\n* **Sectors & Stocks:** Define your own market sectors and individual stocks with customizable starting prices and volatility.\n* **Market Events:** Create unique events with specific sector impacts to drive market dynamics.\n* **Transaction Settings:** Configure fee percentages, VIP discounts, and alert thresholds.\n* **Event Frequency:** Control how often random market events occur and how long they last.\n\n![Configuration](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_config.png)\n![Sectors](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sectors.png)\n\n**Commands:**\n\n* `/markets [industry]` - View all stocks or filter by industry\n* `/stockinfo [ticker]` - Get detailed information about a specific stock\n* `/buystock <ticker> <amount>` - Purchase shares of a stock\n* `/sellstock <ticker> <amount>` - Sell shares from your portfolio\n* `/stockportfolio` - View your current holdings and performance\n* `/triggerevent [event]` - Admin command to trigger specific market events\n\nWho says the apocalypse can't have a thriving economy? Now players can stress about both zombie hordes AND their Duke's Casino Tokens dropping 40% after a market event! As one trader put it: \"I used to check my 401K daily, and now I check my AMMO stock before every Blood Moon. Some habits die harder than zombies.\"",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sectors\":{\"type\":\"array\",\"title\":\"Wasteland Economic Sectors\",\"description\":\"Define economic sectors relevant to survival in Navezgane\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Sector ID (e.g., RESOURCES)\"},\"name\":{\"type\":\"string\",\"description\":\"Sector name (e.g., Resource Extraction)\"}}},\"default\":[{\"id\":\"RESOURCES\",\"name\":\"Resource Extraction\"},{\"id\":\"MANUFACTURING\",\"name\":\"Manufacturing & Crafting\"},{\"id\":\"DEFENSE\",\"name\":\"Defense & Fortifications\"},{\"id\":\"SURVIVAL\",\"name\":\"Survival Goods\"},{\"id\":\"TRADE\",\"name\":\"Trade & Currency\"}]},\"stocks\":{\"type\":\"array\",\"title\":\"Wasteland Stocks\",\"description\":\"List of stocks representing Navezgane entities and resources\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Stock ticker symbol (e.g., NMC)\"},\"name\":{\"type\":\"string\",\"description\":\"Entity/Resource name\"},\"sector\":{\"type\":\"string\",\"description\":\"Sector ID this stock belongs to\"},\"initialPrice\":{\"type\":\"number\",\"description\":\"Starting price in Dukes\",\"minimum\":1},\"volatility\":{\"type\":\"number\",\"description\":\"Base volatility percentage (5 = 5%)\",\"minimum\":1,\"maximum\":35}}},\"default\":[{\"id\":\"NMC\",\"name\":\"Navezgane Mining Co.\",\"sector\":\"RESOURCES\",\"initialPrice\":50,\"volatility\":15},{\"id\":\"WOOD\",\"name\":\"Wasteland Lumberjacks\",\"sector\":\"RESOURCES\",\"initialPrice\":20,\"volatility\":8},{\"id\":\"SHALE\",\"name\":\"Oil Shale Extractors\",\"sector\":\"RESOURCES\",\"initialPrice\":40,\"volatility\":18},{\"id\":\"FORGE\",\"name\":\"Forge Ahead Metals\",\"sector\":\"MANUFACTURING\",\"initialPrice\":75,\"volatility\":12},{\"id\":\"TOOLS\",\"name\":\"Working Stiff Tools\",\"sector\":\"MANUFACTURING\",\"initialPrice\":60,\"volatility\":10},{\"id\":\"MECH\",\"name\":\"JunkTech Robotics\",\"sector\":\"MANUFACTURING\",\"initialPrice\":110,\"volatility\":20},{\"id\":\"BUILD\",\"name\":\"Barricade Builders\",\"sector\":\"DEFENSE\",\"initialPrice\":45,\"volatility\":9},{\"id\":\"AMMO\",\"name\":\"AmmoNation Surplus\",\"sector\":\"DEFENSE\",\"initialPrice\":90,\"volatility\":18},{\"id\":\"SHAM\",\"name\":\"Shamway Foods\",\"sector\":\"SURVIVAL\",\"initialPrice\":30,\"volatility\":5},{\"id\":\"MEDS\",\"name\":\"Pop-N-Pills Medical\",\"sector\":\"SURVIVAL\",\"initialPrice\":100,\"volatility\":18},{\"id\":\"TRADE\",\"name\":\"Trader Guild Network\",\"sector\":\"TRADE\",\"initialPrice\":150,\"volatility\":10},{\"id\":\"DUKES\",\"name\":\"Duke's Casino Tokens\",\"sector\":\"TRADE\",\"initialPrice\":1,\"volatility\":3}]},\"marketEvents\":{\"type\":\"array\",\"title\":\"Wasteland Events\",\"description\":\"Events impacting the Navezgane economy\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Unique event ID\"},\"name\":{\"type\":\"string\",\"description\":\"Name of the event\"},\"description\":{\"type\":\"string\",\"description\":\"Description of the event's market effect\"},\"sectorImpacts\":{\"type\":\"array\",\"description\":\"How each sector is affected\",\"items\":{\"type\":\"object\",\"properties\":{\"sectorId\":{\"type\":\"string\",\"description\":\"Sector ID\"},\"impact\":{\"type\":\"number\",\"description\":\"Percentage impact (-30 = -30%)\",\"minimum\":-75,\"maximum\":75}}}}}},\"default\":[{\"id\":\"HORDE_INCOMING\",\"name\":\"Horde Night Approaching\",\"description\":\"Increased Zed activity signals the Blood Moon. Survivors prepare defenses.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-5},{\"sectorId\":\"MANUFACTURING\",\"impact\":15},{\"sectorId\":\"DEFENSE\",\"impact\":25},{\"sectorId\":\"SURVIVAL\",\"impact\":10},{\"sectorId\":\"TRADE\",\"impact\":-10}]},{\"id\":\"RESOURCE_SHOCK\",\"name\":\"Resource Shock\",\"description\":\"Key resource veins are depleted, making raw materials expensive and driving up the price of finished goods.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-30},{\"sectorId\":\"MANUFACTURING\",\"impact\":15},{\"sectorId\":\"DEFENSE\",\"impact\":10},{\"sectorId\":\"SURVIVAL\",\"impact\":5},{\"sectorId\":\"TRADE\",\"impact\":5}]},{\"id\":\"ZED_OUTBREAK\",\"name\":\"Severe Zed Outbreak\",\"description\":\"An unusual concentration of Zed activity makes scavenging dangerous. Demand for medical supplies and defenses skyrockets.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-20},{\"sectorId\":\"MANUFACTURING\",\"impact\":-5},{\"sectorId\":\"DEFENSE\",\"impact\":25},{\"sectorId\":\"SURVIVAL\",\"impact\":25},{\"sectorId\":\"TRADE\",\"impact\":-15}]},{\"id\":\"TECH_BREAKTHROUGH\",\"name\":\"Technological Breakthrough\",\"description\":\"A discovery of pre-collapse schematics has revolutionized crafting and manufacturing.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":10},{\"sectorId\":\"MANUFACTURING\",\"impact\":30},{\"sectorId\":\"DEFENSE\",\"impact\":15},{\"sectorId\":\"SURVIVAL\",\"impact\":5},{\"sectorId\":\"TRADE\",\"impact\":15}]},{\"id\":\"TRADE_ROUTE_SECURED\",\"name\":\"Trade Route Secured\",\"description\":\"Traders have established a safer passage, improving the flow of all goods and services.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":20},{\"sectorId\":\"MANUFACTURING\",\"impact\":10},{\"sectorId\":\"DEFENSE\",\"impact\":5},{\"sectorId\":\"SURVIVAL\",\"impact\":15},{\"sectorId\":\"TRADE\",\"impact\":30}]},{\"id\":\"GENERAL_COLLAPSE\",\"name\":\"Societal Collapse Setback\",\"description\":\"A major setback reminds everyone how fragile survival is. Fear grips the market.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-15},{\"sectorId\":\"MANUFACTURING\",\"impact\":-20},{\"sectorId\":\"DEFENSE\",\"impact\":-15},{\"sectorId\":\"SURVIVAL\",\"impact\":0},{\"sectorId\":\"TRADE\",\"impact\":-25}]}]},\"eventFrequency\":{\"title\":\"Event Frequency\",\"type\":\"number\",\"description\":\"Average number of update cycles between market events (0 to disable). Depends on mod's update frequency (e.g., per in-game hour?).\",\"default\":8,\"minimum\":1},\"defaultEventDuration\":{\"title\":\"Default Event Duration\",\"type\":\"number\",\"description\":\"Default number of update cycles an event lasts.\",\"default\":3,\"minimum\":1,\"maximum\":96},\"transactionFee\":{\"title\":\"Transaction Fee (Dukes Tax)\",\"type\":\"number\",\"description\":\"Percentage fee charged on all buy/sell transactions (5 = 5%)\",\"default\":3,\"minimum\":0,\"maximum\":25},\"vipDiscount\":{\"title\":\"Trader's Favor Discount\",\"type\":\"number\",\"description\":\"Percentage discount on transaction fees for players with 'STOCK_MARKET_BROKER' permission (50 = 50%)\",\"default\":50,\"minimum\":0,\"maximum\":100},\"priceAlertThreshold\":{\"title\":\"Price Alert Threshold\",\"type\":\"number\",\"description\":\"Percentage change that triggers a market alert (15 = 15%)\",\"default\":15,\"minimum\":5,\"maximum\":50},\"marketNewsChannelId\":{\"title\":\"Discord Channel ID (for Market News)\",\"type\":\"string\",\"description\":\"The ID of the Discord channel where market news messages should be posted. Leave empty to disable.\",\"default\":\"\"}},\"additionalProperties\":false}",
            "uiSchema": "{\"sectors\":{\"items\":{\"ui:order\":[\"id\",\"name\"]}},\"stocks\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"sector\",\"initialPrice\",\"volatility\"]}},\"marketEvents\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"description\",\"sectorImpacts\"],\"sectorImpacts\":{\"items\":{\"ui:order\":[\"sectorId\",\"impact\"]}}}},\"transactionFee\":{\"ui:widget\":\"range\"},\"vipDiscount\":{\"ui:widget\":\"range\"},\"eventFrequency\":{\"ui:help\":\"Set to 0 to disable random events\"},\"priceAlertThreshold\":{\"ui:widget\":\"range\"}}",
            "commands": [
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === args.stock.toUpperCase());\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${args.stock} not found. Use /market to see available stocks.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate costs using Math.round to ensure we work with integers\n        const subtotal = Math.round(stock.price) * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const totalCost = subtotal + fee;\n\n        // Check if player has enough currency\n        const playerData = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, player.id);\n        const currentBalance = playerData.data.data.currency;\n\n        if (currentBalance < totalCost) {\n            throw new TakaroUserError(`You don't have enough currency. Cost: $${subtotal} + $${fee} fee = $${totalCost}. Your balance: $${currentBalance}`);\n        }\n\n        // Deduct the currency - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerDeductCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: totalCost\n            }\n        );\n\n        // Get player's portfolio or create new one\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        let portfolio;\n        if (portfolioVar.data.data.length === 0) {\n            portfolio = {};\n        } else {\n            portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        }\n\n        // Update portfolio using rounded values for consistency\n        const stockPrice = Math.round(stock.price);\n        if (!portfolio[stock.id]) {\n            portfolio[stock.id] = {\n                shares: amount,\n                averagePrice: stockPrice\n            };\n        } else {\n            const totalShares = portfolio[stock.id].shares + amount;\n            const totalValue = (portfolio[stock.id].shares * portfolio[stock.id].averagePrice) + (amount * stockPrice);\n            portfolio[stock.id].shares = totalShares;\n            portfolio[stock.id].averagePrice = Math.round(totalValue / totalShares);\n        }\n\n        // Save updated portfolio\n        if (portfolioVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_portfolio',\n                value: JSON.stringify(portfolio),\n                gameServerId,\n                moduleId: mod.moduleId,\n                playerId: player.id\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n                value: JSON.stringify(portfolio)\n            });\n        }\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'BUY',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: totalCost,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully bought ${amount} shares of ${stock.id} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Total cost: $${totalCost}\\n`;\n        message += `Current portfolio: ${portfolio[stock.id].shares} shares of ${stock.id}`;\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in buystock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your purchase. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "buystock",
                    "description": null,
                    "trigger": "buystock",
                    "helpText": "Buy shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol ",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to buy",
                            "position": 1
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // Get player's portfolio\n    const portfolioVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_portfolio'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId],\n            playerId: [player.id]\n        }\n    });\n\n    let portfolio = {};\n    if (portfolioVar.data.data.length > 0) {\n        portfolio = JSON.parse(portfolioVar.data.data[0].value);\n    }\n\n    // Send header\n    await player.pm(\"=== YOUR STOCK PORTFOLIO ===\");\n\n    let hasStocks = false;\n    let totalValue = 0;\n    let totalInvestment = 0;\n\n    // If no stocks, send a simple message\n    if (Object.keys(portfolio).length === 0) {\n        await player.pm(\"You don't own any stocks yet.\\n\" +\n            \"Use /markets to see available stocks and prices.\\n\" +\n            \"Use /buy <stock> <amount> to purchase stocks.\");\n        return;\n    }\n\n    // Helper function to format numbers with commas\n    const formatNumber = (num) => {\n        return Math.round(num).toLocaleString();\n    };\n\n    // Send each stock as a separate message to avoid length issues\n    for (const [stockId, data] of Object.entries(portfolio)) {\n        hasStocks = true;\n        const stock = stocks.find(s => s.id === stockId);\n        if (!stock) continue; // Stock might have been removed from config\n\n        const currentValue = stock.price * data.shares;\n        const investmentValue = data.averagePrice * data.shares;\n        totalValue += currentValue;\n        totalInvestment += investmentValue;\n        const profit = currentValue - investmentValue;\n        const profitPercent = ((profit / investmentValue) * 100).toFixed(1);\n\n        let stockMessage = `--- ${stockId} (${stock.sector}) ---\\n`;\n        stockMessage += `Shares: ${data.shares}\\n`;\n        stockMessage += `Avg buy: $${formatNumber(data.averagePrice)}\\n`;\n        stockMessage += `Current price: $${formatNumber(stock.price)}\\n`;\n        stockMessage += `Total value: $${formatNumber(currentValue)}\\n`;\n\n        if (profit >= 0) {\n            stockMessage += `Profit: +$${formatNumber(profit)} (+${profitPercent}%)\\n`;\n        } else {\n            stockMessage += `Loss: -$${formatNumber(Math.abs(profit))} (${profitPercent}%)\\n`;\n        }\n\n        await player.pm(stockMessage);\n    }\n\n    if (hasStocks) {\n        const totalProfit = totalValue - totalInvestment;\n        const totalProfitPercent = ((totalProfit / totalInvestment) * 100).toFixed(1);\n\n        let summaryMessage = \"=== PORTFOLIO SUMMARY ===\\n\";\n        summaryMessage += `Total investment: $${formatNumber(totalInvestment)}\\n`;\n        summaryMessage += `Current value: $${formatNumber(totalValue)}\\n`;\n\n        if (totalProfit >= 0) {\n            summaryMessage += `Overall profit: +$${formatNumber(totalProfit)} (+${totalProfitPercent}%)\\n`;\n        } else {\n            summaryMessage += `Overall loss: -$${formatNumber(Math.abs(totalProfit))} (${totalProfitPercent}%)\\n`;\n        }\n\n        // Get transaction history count\n        try {\n            const historyVar = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: ['stock_transaction_history'],\n                    gameServerId: [gameServerId],\n                    moduleId: [mod.moduleId],\n                    playerId: [player.id]\n                }\n            });\n\n            if (historyVar.data.data.length > 0) {\n                const history = JSON.parse(historyVar.data.data[0].value);\n                const buyCount = history.filter(t => t.type === 'BUY').length;\n                const sellCount = history.filter(t => t.type === 'SELL').length;\n\n                summaryMessage += `\\nTransactions: ${history.length} (${buyCount} buys, ${sellCount} sells)\\n`;\n            }\n        } catch (error) {\n            // Just ignore history errors\n        }\n\n        await player.pm(summaryMessage);\n    }\n}\n\nawait main();",
                    "name": "stockportfolio",
                    "description": null,
                    "trigger": "stockportfolio",
                    "helpText": "No help text available",
                    "arguments": []
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get player's portfolio\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        if (portfolioVar.data.data.length === 0) {\n            throw new TakaroUserError(\"You don't own any stocks to sell.\");\n        }\n\n        const portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        const stockId = args.stock.toUpperCase();\n\n        if (!portfolio[stockId] || portfolio[stockId].shares < amount) {\n            throw new TakaroUserError(`You don't own ${amount} shares of ${stockId}.`);\n        }\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === stockId);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${stockId} not found in current market data. Please contact an admin.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate sale proceeds using Math.round to ensure we work with integers\n        const stockPrice = Math.round(stock.price);\n        const subtotal = stockPrice * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const netProceeds = subtotal - fee;\n\n        // Add money to player - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerAddCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: netProceeds\n            }\n        );\n\n        // Calculate profit/loss\n        const profitPerShare = stockPrice - portfolio[stockId].averagePrice;\n        const totalProfit = Math.round(profitPerShare * amount);\n        const profitText = totalProfit >= 0\n            ? `profit of $${totalProfit}`\n            : `loss of $${Math.abs(totalProfit)}`;\n\n        // Update portfolio\n        portfolio[stockId].shares -= amount;\n        if (portfolio[stockId].shares === 0) {\n            delete portfolio[stockId];\n        }\n\n        // Save updated portfolio\n        await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n            value: JSON.stringify(portfolio)\n        });\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'SELL',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: netProceeds,\n            profit: totalProfit,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully sold ${amount} shares of ${stockId} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Net proceeds: $${netProceeds} (${profitText})`;\n\n        // Add remaining shares info if player still has some\n        if (portfolio[stockId]) {\n            message += `\\nRemaining shares: ${portfolio[stockId].shares}`;\n        } else {\n            message += `\\nYou've sold all your ${stockId} shares.`;\n        }\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in sellstock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your sale. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "sellstock",
                    "description": null,
                    "trigger": "sellstock",
                    "helpText": "Sell shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to sell",
                            "position": 1
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // If a specific stock ticker is provided, show detailed info for that stock\n    const specificTicker = args.ticker ? args.ticker.toUpperCase() : null;\n\n    if (specificTicker && specificTicker !== \"ALL\") {\n        const stock = stocks.find(s => s.id.toUpperCase() === specificTicker);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${specificTicker} not found. Use /stockinfo without parameters to see all available stocks.`);\n        }\n\n        // Get active event to see if this stock's sector is affected\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let activeEvent = null;\n        let sectorImpact = null;\n\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEvent && activeEvent.sectorImpacts) {\n                    sectorImpact = activeEvent.sectorImpacts.find(impact =>\n                        impact.sectorId === stock.sector\n                    );\n                }\n            } catch (e) {\n                // Ignore parsing errors\n            }\n        }\n\n        // Calculate price change indicators\n        let changeText = '';\n        if (stock.lastPrice) {\n            const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n            const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n            changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n        }\n\n        // Add risk assessment based on volatility without showing the raw value\n        let riskLevel;\n        if (stock.volatility <= 0.05) riskLevel = \"Very Low\";\n        else if (stock.volatility <= 0.10) riskLevel = \"Low\";\n        else if (stock.volatility <= 0.15) riskLevel = \"Moderate\";\n        else if (stock.volatility <= 0.20) riskLevel = \"High\";\n        else riskLevel = \"Very High\";\n\n        // Build detailed stock info message\n        let message = `=== ${stock.id}: ${stock.name} ===\\n\\n`;\n        message += `Sector: ${stock.sector}\\n`;\n        message += `Current Price: $${Math.round(stock.price)}${changeText}\\n`;\n        message += `Risk Level: ${riskLevel}\\n`;\n\n        // Add sector trend info if available from event\n        if (activeEvent && sectorImpact) {\n            const direction = sectorImpact.impact >= 0 ? \"Positive\" : \"Negative\";\n            const strength = Math.abs(sectorImpact.impact);\n            let trend;\n\n            if (strength < 10) trend = \"Slight\";\n            else if (strength < 25) trend = \"Moderate\";\n            else trend = \"Strong\";\n\n            message += `\\nCurrent Trend: ${trend} ${direction} (${activeEvent.name})\\n`;\n            message += `Event: ${activeEvent.description}\\n`;\n        }\n\n        // Add trading guidance based on sector and risk, without mentioning volatility\n        message += `\\nTrading Notes:\\n`;\n\n        if (activeEvent && sectorImpact) {\n            if (sectorImpact.impact > 0) {\n                message += `- Currently bullish due to the ${activeEvent.name} event\\n`;\n            } else {\n                message += `- Currently bearish due to the ${activeEvent.name} event\\n`;\n            }\n        }\n\n        if (riskLevel === \"High\" || riskLevel === \"Very High\") {\n            message += `- Expect significant price fluctuations with this stock\\n`;\n        } else if (riskLevel === \"Low\" || riskLevel === \"Very Low\") {\n            message += `- Typically has stable price movement\\n`;\n        }\n\n        message += `\\nUse /buystock ${stock.id} [amount] to purchase shares`;\n\n        await player.pm(message);\n\n    } else {\n        // No specific ticker provided or ALL specified, show summary of all stocks\n        await player.pm(\"=== STOCK MARKET LISTINGS ===\\n\");\n\n        // Group stocks by sector\n        const stocksBySector = {};\n        stocks.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        // Display stocks by sector\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            let sectorMessage = `\\n--- ${sector} SECTOR ---\\n`;\n\n            sectorStocks.forEach(stock => {\n                // Add price change indicators\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                    changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                // Add risk level based on volatility\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                sectorMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n\n            await player.pm(sectorMessage);\n        }\n\n        // Add legend for risk indicators\n        const legend = \"\\n=== LEGEND ===\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\" +\n            \"Use /stockinfo [ticker] for detailed information about a specific stock\";\n\n        await player.pm(legend);\n    }\n}\n\nawait main();",
                    "name": "stockinfo",
                    "description": null,
                    "trigger": "stockinfo",
                    "helpText": "Shows all available stocks in the market. Use with a ticker symbol (e.g., /stockinfo ticker) to see detailed information about a specific stock.",
                    "arguments": [
                        {
                            "name": "ticker",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "stock ticker or ALL to get detailed information about a specific stock",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Handle the industry argument - use \"ALL\" as a special value to show all industries\n    const industryFilter = args.Industry ? args.Industry.toUpperCase() : \"ALL\";\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    // If market data doesn't exist, try to initialize it\n    if (marketDataVar.data.data.length === 0) {\n        const initialized = await initializeMarketIfNeeded(gameServerId, mod);\n        if (!initialized) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        // Get the freshly initialized market data\n        const refreshedMarketData = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (refreshedMarketData.data.data.length === 0) {\n            throw new TakaroUserError(\"There was an issue initializing the stock market. Please try again later.\");\n        }\n\n        // Continue with the refreshed data\n        await displayMarketSummary(player, gameServerId, mod, refreshedMarketData.data.data[0], industryFilter);\n    } else {\n        // Market data exists, display it\n        await displayMarketSummary(player, gameServerId, mod, marketDataVar.data.data[0], industryFilter);\n    }\n}\n\n// Display the market summary to the player\nasync function displayMarketSummary(player, gameServerId, mod, marketDataVariable, industryFilter) {\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Handle empty string or empty object\n            if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (e) {\n            // In case of parsing error\n            activeEvent = null;\n        }\n    }\n\n    const stocks = JSON.parse(marketDataVariable.value);\n\n    // Get all available industries for reference\n    const availableIndustries = [...new Set(stocks.map(stock => stock.sector))];\n\n    // If industry filter is provided and not \"ALL\", check if it's valid\n    if (industryFilter !== \"ALL\") {\n        // Check if the industry exists\n        const industryExists = availableIndustries.includes(industryFilter);\n\n        if (!industryExists) {\n            throw new TakaroUserError(`Industry \"${industryFilter}\" not found. Available industries: ${availableIndustries.join(', ')}\\nUse \"ALL\" to view all industries.`);\n        }\n    }\n\n    // Send header message\n    let headerMessage = \"=== STOCK MARKET SUMMARY ===\\n\";\n\n    // If filtering by industry, mention it in the header\n    if (industryFilter !== \"ALL\") {\n        headerMessage = `=== ${industryFilter} INDUSTRY ===\\n`;\n    }\n\n    // If there's an active event, include it in the header\n    if (activeEvent) {\n        headerMessage += `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n`;\n        headerMessage += `${activeEvent.description}\\n\\n`;\n\n        // If filtering by industry, only show relevant impacts\n        if (industryFilter !== \"ALL\") {\n            const relevantImpact = activeEvent.sectorImpacts.find(\n                impact => impact.sectorId === industryFilter\n            );\n\n            if (relevantImpact) {\n                const direction = relevantImpact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `Industry Impact: ${direction} ${Math.abs(relevantImpact.impact)}%\\n`;\n            } else {\n                headerMessage += \"This industry is not directly affected by the current event.\\n\";\n            }\n        } else {\n            // Show all industry impacts\n            headerMessage += \"Industry Impacts:\\n\";\n            for (const impact of activeEvent.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%\\n`;\n            }\n        }\n    }\n\n    // Send header message first\n    await player.pm(headerMessage);\n\n    // Group stocks by industry\n    const stocksByIndustry = {};\n    stocks.forEach(stock => {\n        if (!stocksByIndustry[stock.sector]) {\n            stocksByIndustry[stock.sector] = [];\n        }\n        stocksByIndustry[stock.sector].push(stock);\n    });\n\n    // If industry filter is not \"ALL\", only show that industry\n    if (industryFilter !== \"ALL\") {\n        const filteredStocks = stocksByIndustry[industryFilter] || [];\n\n        if (filteredStocks.length > 0) {\n            let stockMessage = \"\";\n\n            filteredStocks.forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                stockMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(stockMessage);\n        } else {\n            await player.pm(`No stocks found in the ${industryFilter} industry.`);\n        }\n    } else {\n        // Send each industry as a separate message\n        for (const industryId in stocksByIndustry) {\n            let industryMessage = `=== ${industryId} INDUSTRY ===\\n`;\n\n            stocksByIndustry[industryId].forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                industryMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(industryMessage);\n        }\n    }\n\n    // Add a help message for industry filtering if showing all industries\n    if (industryFilter === \"ALL\") {\n        const allIndustries = Object.keys(stocksByIndustry).join(', ');\n        await player.pm(`\\nTip: Use '/markets [industry]' to view only stocks in a specific industry. Available industries: ${allIndustries}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return false;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            const results = await Promise.allSettled(createPromises);\n            // Check if the critical stock_market_data was created successfully\n            const stockDataPromise = results[0];\n            if (stockDataPromise && stockDataPromise.status === 'rejected') {\n                console.log(`Failed to create stock_market_data: ${stockDataPromise.reason}`);\n                return false;\n            }\n        }\n\n        return true;\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n        return false;\n    }\n}\n\nawait main();",
                    "name": "markets",
                    "description": null,
                    "trigger": "markets",
                    "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. \n",
                    "arguments": [
                        {
                            "name": "Industry",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. ",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRIGGER_EVENT')) {\n        throw new TakaroUserError(\"You don't have permission to trigger market events.\");\n    }\n\n    try {\n        // Get current stock data to check market initialization\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Initialize market if needed\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            await player.pm(\"Market was not initialized. Initializing now...\");\n            return;\n        }\n\n        // Get events from module config\n        const marketEvents = mod.userConfig.marketEvents || [];\n\n        if (marketEvents.length === 0) {\n            throw new TakaroUserError(\"No market events configured in this module.\");\n        }\n\n        // Handle case when no event is specified or \"ALL\" is provided\n        if (!args.EventName || args.EventName.toUpperCase() === \"ALL\") {\n            await player.pm(\"=== AVAILABLE MARKET EVENTS ===\\n\");\n\n            // Group events by category or type if possible\n            const eventCategories = {};\n\n            // Create a simple categorization based on positive/negative impact\n            marketEvents.forEach(event => {\n                let category = \"Mixed\";\n                // Calculate net impact across all sectors\n                const netImpact = event.sectorImpacts.reduce((sum, impact) => sum + impact.impact, 0);\n\n                if (netImpact > 0) category = \"Positive\";\n                else if (netImpact < 0) category = \"Negative\";\n\n                if (!eventCategories[category]) {\n                    eventCategories[category] = [];\n                }\n                eventCategories[category].push(event);\n            });\n\n            // Display events by category\n            for (const [category, events] of Object.entries(eventCategories)) {\n                if (events.length > 0) {\n                    await player.pm(`\\n--- ${category.toUpperCase()} EVENTS ---`);\n\n                    let message = \"\";\n                    events.forEach(event => {\n                        // Format primary sectors affected\n                        const primarySectors = event.sectorImpacts\n                            .filter(impact => Math.abs(impact.impact) >= 15)\n                            .map(impact => {\n                                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                                return `${impact.sectorId} ${direction}${Math.abs(impact.impact)}%`;\n                            })\n                            .join(\", \");\n\n                        message += `${event.id}: ${event.name}\\n`;\n                        message += `   ${event.description}\\n`;\n                        if (primarySectors) {\n                            message += `   Major impacts: ${primarySectors}\\n`;\n                        }\n                        message += \"\\n\";\n                    });\n\n                    await player.pm(message);\n                }\n            }\n\n            await player.pm(\"=== HOW TO USE ===\\nUse `/triggerevent <EventName>` to trigger a specific event (e.g., `/triggerevent TECH_BOOM`)\");\n            return;\n        }\n\n        // Find the requested event\n        const eventId = args.EventName.toUpperCase();\n        const event = marketEvents.find(e => e.id === eventId);\n\n        if (!event) {\n            throw new TakaroUserError(`Event \"${eventId}\" not found. Use /triggerevent without parameters to see all available events.`);\n        }\n\n        // Get necessary variables for managing the event\n        const [activeEventVar, eventStartTimeVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_execution_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_cooldown_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['current_event_duration'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Check if there's an active event we need to cancel\n        let activeEventObj = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEventObj = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEventObj && Object.keys(activeEventObj).length > 0) {\n                    await player.pm(`Cancelling active event \"${activeEventObj.name}\" to trigger new event.`);\n                }\n            } catch (e) {\n                // Invalid event data, will be overwritten\n            }\n        }\n\n        // Generate a random duration for the event\n        const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n        // Update or create all event-related variables\n        const updatePromises = [];\n\n        // Save or update the random duration\n        if (eventDurationVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                    value: randomDuration.toString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'current_event_duration',\n                    value: randomDuration.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the event counter to 0\n        if (eventCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the cooldown counter\n        if (cooldownCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update active event\n        if (activeEventVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                    value: JSON.stringify(event)\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: JSON.stringify(event),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update event start time\n        if (eventStartTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update last event time\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (lastEventTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all updates to complete\n        await Promise.all(updatePromises);\n\n        // Check if there are online players to announce the event\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            // Format sector impacts for announcement\n            let impactText = \"\";\n            for (const impact of event.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n            }\n\n            const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${event.name}\\n${event.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /markets to see opportunities!`;\n\n            // Split the message if it's too long\n            const maxLength = 400; // Safe limit for most games\n            for (let i = 0; i < message.length; i += maxLength) {\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message: message.substring(i, i + maxLength)\n                });\n            }\n        }\n\n        await player.pm(`Successfully triggered the \"${event.name}\" market event for ${randomDuration} cycles!`);\n    } catch (error) {\n        // If something goes wrong, log it and let the player know\n        console.log(`Error in triggerEvent: ${error.message}`);\n        throw new TakaroUserError(`Error triggering event: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Store the stocks data\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_data',\n            value: JSON.stringify(stocks),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize last event time to now\n        await takaro.variable.variableControllerCreate({\n            key: 'last_market_event_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize event start time variable\n        await takaro.variable.variableControllerCreate({\n            key: 'event_start_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize active event (empty string means no active event)\n        await takaro.variable.variableControllerCreate({\n            key: 'active_market_event',\n            value: '',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Mark market as initialized\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_initialized',\n            value: 'true',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Announce market initialization to online players\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /markets to see available stocks and /buystock to start investing.\";\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message\n            });\n        }\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "triggerevent",
                    "description": null,
                    "trigger": "triggerevent",
                    "helpText": "Shows all available market events when run without parameters. Use with an event name (e.g., /triggerevent TECH_BOOM) to trigger a specific market event.",
                    "arguments": [
                        {
                            "name": "EventName",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "Event name to trigger a specific market event",
                            "position": 0
                        }
                    ]
                }
            ],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n\n    // Get the Discord channel ID from module configuration\n    // IMPORTANT: You need to add 'marketNewsChannelId' to your module's configSchema and set its value.\n    const discordChannelId = mod.userConfig.marketNewsChannelId;\n\n    if (!discordChannelId) {\n        takaro.log.info('Market news Discord channel ID (marketNewsChannelId) not configured in module settings. Skipping Discord messages.');\n    }\n\n    // Check for online players\n    const currentPlayers = (await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    })).data.meta;\n\n    if (currentPlayers.total === 0) {\n        takaro.log.info('Skipping daily market report: No players online.');\n        return; // No players online, skip the market news\n    }\n\n    // Get current stock data (which should include lastPrice)\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        takaro.log.warn('Skipping daily market report: Market data variable not found.');\n        return; // Market not initialized yet\n    }\n\n    let stocks;\n    try {\n        stocks = JSON.parse(marketDataVar.data.data[0].value);\n        if (!Array.isArray(stocks)) {\n            throw new Error('Parsed market data is not an array.');\n        }\n    } catch (error) {\n        takaro.log.error(`Failed to parse stock_market_data: ${error}`);\n        return; // Invalid market data\n    }\n\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Ensure activeEvent is an object with data, not an empty string or empty object\n            if (typeof activeEvent !== 'object' || activeEvent === null || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (error) {\n            takaro.log.warn(`Failed to parse active_market_event: ${error}`);\n            activeEvent = null; // Continue without event info if parsing fails\n        }\n    }\n\n    // --- Message 1: Header and active event ---\n    let gameMessage1 = \"==== DAILY MARKET REPORT ====\\n\";\n    let discordMessage1 = \"**==== DAILY MARKET REPORT ====**\\n\"; // Discord version with Markdown\n\n    if (activeEvent && activeEvent.name && activeEvent.description) {\n        const eventText = `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n${activeEvent.description}\\n`;\n        gameMessage1 += eventText;\n        discordMessage1 += eventText;\n    } else {\n        const noEventText = '\\nNo active market events today.\\n';\n        gameMessage1 += noEventText;\n        discordMessage1 += noEventText;\n    }\n\n    // Send first part of the report to game server\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage1\n    }).catch(err => takaro.log.error(`Failed to send game message 1: ${err}`));\n\n    // Send first part of the report to Discord\n    if (discordChannelId) {\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessage1\n        }).catch(err => takaro.log.error(`Failed to send Discord message 1: ${err.message || err}`));\n    }\n\n    // --- Calculate stock performance using stock.price and stock.lastPrice ---\n    const stocksWithPerformance = stocks.map(stock => {\n        let change = 0;\n        let percentChange = 0;\n        let changeSymbol = 'â†’'; // Default: No change or insufficient data\n\n        if (typeof stock.price === 'number' && typeof stock.lastPrice === 'number' && stock.lastPrice !== 0) {\n            change = stock.price - stock.lastPrice;\n            percentChange = (change / stock.lastPrice) * 100;\n            if (percentChange > 0.05) {\n                changeSymbol = 'â†‘';\n            } else if (percentChange < -0.05) {\n                changeSymbol = 'â†“';\n            }\n        } else if (typeof stock.price === 'number' && stock.lastPrice === undefined) {\n            changeSymbol = 'ðŸ†•';\n            percentChange = 0;\n        }\n        return {\n            ...stock,\n            change,\n            percentChange,\n            changeSymbol\n        };\n    });\n\n    // --- Group by sector ---\n    const sectorPerformance = {};\n    stocksWithPerformance.forEach(stock => {\n        const sectorId = stock.sector || 'Uncategorized';\n        if (!sectorPerformance[sectorId]) {\n            sectorPerformance[sectorId] = {\n                stocks: [],\n                totalPercentChange: 0,\n                count: 0\n            };\n        }\n        sectorPerformance[sectorId].stocks.push(stock);\n        if (typeof stock.percentChange === 'number' && isFinite(stock.percentChange)) {\n            sectorPerformance[sectorId].totalPercentChange += stock.percentChange;\n            sectorPerformance[sectorId].count++;\n        }\n    });\n\n    // --- Calculate average sector performance ---\n    for (const sectorId in sectorPerformance) {\n        const sectorData = sectorPerformance[sectorId];\n        if (sectorData.count > 0) {\n            sectorData.avgPerformance = sectorData.totalPercentChange / sectorData.count;\n        } else {\n            sectorData.avgPerformance = 0;\n        }\n    }\n\n    const sortedSectors = Object.entries(sectorPerformance)\n        .sort(([, a], [, b]) => b.avgPerformance - a.avgPerformance);\n\n    // --- Message 2: Sector performance ---\n    let gameMessage2 = \"\\n=== SECTOR PERFORMANCE ===\\n\";\n    let discordMessage2 = \"\\n**=== SECTOR PERFORMANCE ===**\\n\"; // Discord version\n\n    if (sortedSectors.length > 0) {\n        sortedSectors.forEach(([sectorId, sectorData]) => {\n            const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n            const line = `${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n            gameMessage2 += line;\n            discordMessage2 += line;\n        });\n    } else {\n        const noDataText = \"No sector performance data available.\\n\";\n        gameMessage2 += noDataText;\n        discordMessage2 += noDataText;\n    }\n\n    // Send sector performance report to game server\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage2\n    }).catch(err => takaro.log.error(`Failed to send game message 2: ${err}`));\n\n    // Send sector performance report to Discord\n    if (discordChannelId) {\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessage2\n        }).catch(err => takaro.log.error(`Failed to send Discord message 2: ${err.message || err}`));\n    }\n\n    // --- Message 3: Top and Worst performers ---\n    const validPerformers = stocksWithPerformance.filter(s => typeof s.percentChange === 'number' && isFinite(s.percentChange));\n    validPerformers.sort((a, b) => b.percentChange - a.percentChange);\n\n    let gameMessage3 = \"\";\n    let discordMessage3 = \"\";\n\n    const topPerformersTitleGame = \"\\nðŸ”¥ TOP PERFORMERS ðŸ”¥\\n\";\n    const topPerformersTitleDiscord = \"\\n**ðŸ”¥ TOP PERFORMERS ðŸ”¥**\\n\";\n    gameMessage3 += topPerformersTitleGame;\n    discordMessage3 += topPerformersTitleDiscord;\n\n    if (validPerformers.length > 0) {\n        for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n            const stock = validPerformers[i];\n            const line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            gameMessage3 += line;\n            discordMessage3 += line;\n        }\n    } else {\n        const noTopText = \"No top performers today.\\n\";\n        gameMessage3 += noTopText;\n        discordMessage3 += noTopText;\n    }\n\n    const worstPerformersTitleGame = \"\\nðŸ“‰ WORST PERFORMERS ðŸ“‰\\n\";\n    const worstPerformersTitleDiscord = \"\\n**ðŸ“‰ WORST PERFORMERS ðŸ“‰**\\n\";\n    gameMessage3 += worstPerformersTitleGame;\n    discordMessage3 += worstPerformersTitleDiscord;\n\n    if (validPerformers.length > 0) {\n        const worstStartIndex = Math.max(0, validPerformers.length - 3);\n        for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n            const stock = validPerformers[i];\n            const line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            gameMessage3 += line;\n            discordMessage3 += line;\n        }\n    } else {\n        const noWorstText = \"No worst performers today.\\n\";\n        gameMessage3 += noWorstText;\n        discordMessage3 += noWorstText;\n    }\n\n    // Send top/worst performers report to game server\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage3\n    }).catch(err => takaro.log.error(`Failed to send game message 3: ${err}`));\n\n    // Send top/worst performers report to Discord\n    if (discordChannelId) {\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessage3\n        }).catch(err => takaro.log.error(`Failed to send Discord message 3: ${err.message || err}`));\n    }\n\n    takaro.log.info('Daily market report sent successfully (game server and potentially Discord).');\n}\n\nawait main();",
                    "name": "marketnews",
                    "description": null,
                    "temporalValue": "1 */1 * * *"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    try {\n        const { gameServerId, module: mod } = data;\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Check if market is initialized\n        if (marketDataVar.data.data.length === 0) {\n            console.log(\"Market data not found, initializing...\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return; // Exit after initialization\n        }\n\n        // Get active market event\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event start time\n        const eventStartTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_start_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event execution counter\n        const eventCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_execution_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event cooldown counter\n        const cooldownCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_cooldown_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let eventCounter = 0;\n        if (eventCounterVar.data.data.length > 0) {\n            eventCounter = parseInt(eventCounterVar.data.data[0].value, 10);\n            console.log(`Event counter: ${eventCounter}`);\n        }\n\n        let cooldownCounter = 0;\n        if (cooldownCounterVar.data.data.length > 0) {\n            cooldownCounter = parseInt(cooldownCounterVar.data.data[0].value, 10);\n            console.log(`Cooldown counter: ${cooldownCounter}`);\n        }\n\n        // Get event duration\n        const eventDurationVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['current_event_duration'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Use stored random duration if available, otherwise use defaultEventDuration\n        let eventDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        if (eventDurationVar.data.data.length > 0) {\n            eventDuration = parseInt(eventDurationVar.data.data[0].value, 10);\n            console.log(`Event duration: ${eventDuration}`);\n        }\n\n        let activeEvent = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                // If it's an empty string, treat as no active event\n                if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                    activeEvent = null;\n                }\n                console.log(`Active event: ${activeEvent ? activeEvent.name : 'None'}`);\n            } catch (e) {\n                // In case of parsing error, consider no active event\n                activeEvent = null;\n                console.log(`Error parsing active event: ${e.message}`);\n            }\n        }\n\n        // Check if the current event should end and increment counter\n        if (activeEvent) {\n            eventCounter++;\n            console.log(`Incremented event counter to: ${eventCounter}`);\n\n            if (eventCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: eventCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: eventCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n\n            if (eventCounter >= eventDuration) {\n                console.log(\"Event duration reached, ending event.\");\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: ''\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_cooldown_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    const message = `ðŸ“ˆ MARKET UPDATE ðŸ“‰\\n\\nThe \"${activeEvent.name}\" event has ended. Markets are returning to normal conditions.`;\n\n                    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                        message: message\n                    });\n                }\n\n                activeEvent = null;\n            }\n        } else {\n            cooldownCounter++;\n            console.log(`Incremented cooldown counter to: ${cooldownCounter}`);\n\n            if (cooldownCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: cooldownCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: cooldownCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n        }\n\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        const eventFrequency = (mod.userConfig && mod.userConfig.eventFrequency) || 10;\n        let shouldTriggerEvent = false;\n\n        if (!activeEvent && cooldownCounter >= eventFrequency) {\n            shouldTriggerEvent = Math.random() < 0.5;\n            if (cooldownCounter >= eventFrequency * 2) {\n                shouldTriggerEvent = true;\n            }\n            console.log(`Should trigger new event: ${shouldTriggerEvent}`);\n        }\n\n        if (shouldTriggerEvent) {\n            const events = (mod.userConfig && mod.userConfig.marketEvents) || [];\n            if (events.length > 0) {\n                const randomEvent = events[Math.floor(Math.random() * events.length)];\n                activeEvent = randomEvent;\n                console.log(`New event triggered: ${activeEvent.name}`);\n\n                const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n                const randomDuration = Math.floor(Math.random() * maxDuration) + 1;\n\n                if (eventDurationVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                        value: randomDuration.toString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'current_event_duration',\n                        value: randomDuration.toString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: JSON.stringify(activeEvent)\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'active_market_event',\n                        value: JSON.stringify(activeEvent),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventStartTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_start_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (lastEventTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'last_market_event_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    let impactText = \"\";\n                    for (const impact of activeEvent.sectorImpacts) {\n                        const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                        impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n                    }\n\n                    const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${activeEvent.name}\\n${activeEvent.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /market to see opportunities!`;\n\n                    const maxLength = 400;\n                    for (let i = 0; i < message.length; i += maxLength) {\n                        await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                            message: message.substring(i, i + maxLength)\n                        });\n                    }\n                }\n            }\n        }\n\n        // Get stocks\n        if (!marketDataVar.data.data[0] || !marketDataVar.data.data[0].value) {\n            console.log(\"Market data is empty or invalid after initial check, re-initializing.\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        let stocks;\n        try {\n            stocks = JSON.parse(marketDataVar.data.data[0].value);\n            if (!Array.isArray(stocks)) {\n                throw new Error(\"Parsed stocks data is not an array\");\n            }\n            // CRITICAL FIX: Ensure each stock has valid numerical price properties\n            stocks = stocks.map(s => {\n                const sanitizedPrice = typeof s.price === 'number' && s.price > 0 ? s.price : 1;\n                const sanitizedLastPrice = typeof s.lastPrice === 'number' && s.lastPrice > 0 ? s.lastPrice : sanitizedPrice;\n                return {\n                    ...s,\n                    price: sanitizedPrice,\n                    lastPrice: sanitizedLastPrice\n                };\n            });\n            console.log(\"Stocks loaded and sanitized successfully.\");\n            console.log(\"Initial stocks for this cycle:\");\n            stocks.forEach(s => console.log(`  ${s.id}: Price ${s.price}, LastPrice ${s.lastPrice}`));\n\n        } catch (e) {\n            console.log(`Error parsing or sanitizing stock data: ${e.message}`);\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        const significantChanges = [];\n\n        // Update each stock price\n        stocks.forEach(stock => {\n            // Always capture oldPrice at the very beginning of the iteration\n            const oldPrice = stock.price;\n            // Set lastPrice to the value before this current update cycle for accurate change tracking\n            stock.lastPrice = oldPrice;\n\n            console.log(`Processing stock: ${stock.id}, Old Price: ${oldPrice}`);\n\n            // Define the threshold for \"penny stock\" and the chance/magnitude of a breakout\n            const pennyStockThreshold = 1.9;\n            const breakoutChance = 0.6;\n\n            const targetMinPrice = 2.0;\n            const targetMaxPrice = 10.0;\n\n            let calculatedNewPrice;\n\n            // Check if it's a penny stock and qualifies for a breakout\n            if (oldPrice <= pennyStockThreshold && Math.random() < breakoutChance) {\n                console.log(`${stock.id} is a penny stock (${oldPrice}) and hit breakout chance!`);\n                calculatedNewPrice = targetMinPrice + Math.random() * (targetMaxPrice - targetMinPrice);\n                calculatedNewPrice = Math.max(calculatedNewPrice, oldPrice + 0.01); // Ensure at least a penny increase\n                console.log(`${stock.id} calculated breakout price: ${calculatedNewPrice}`);\n            } else {\n                const randomFactor = Math.random() * 2 - 1;\n                const totalChangePercent = randomFactor * stock.volatility;\n                calculatedNewPrice = oldPrice * (1 + totalChangePercent);\n                console.log(`${stock.id} calculated normal price: ${calculatedNewPrice} (Change: ${totalChangePercent * 100}%)`);\n            }\n\n            let finalPrice = calculatedNewPrice;\n            if (activeEvent) {\n                const sectorImpact = activeEvent.sectorImpacts.find(impact => impact.sectorId === stock.sector);\n                if (sectorImpact) {\n                    const eventImpactPercentage = sectorImpact.impact;\n                    const eventImpactDecimal = eventImpactPercentage / 100;\n                    const randomImpactFactor = 0.5 + Math.random();\n                    const eventImpact = eventImpactDecimal * randomImpactFactor;\n\n                    finalPrice = calculatedNewPrice * (1 + eventImpact);\n                    console.log(`${stock.id} final price after event impact: ${finalPrice} (Event impact: ${eventImpact * 100}%)`);\n                }\n            }\n\n            stock.price = finalPrice;\n\n            if (stock.price < 1) {\n                console.log(`${stock.id} price fell below 1, setting to 1.`);\n                stock.price = 1;\n            }\n\n            const actualPercentChange = ((stock.price - oldPrice) / oldPrice) * 100;\n            console.log(`${stock.id} - Final Price: ${stock.price.toFixed(2)}, Actual Change: ${actualPercentChange.toFixed(2)}%`);\n\n            const changeThreshold = ((mod.userConfig && mod.userConfig.priceAlertThreshold) || 10) / 100;\n            if (Math.abs(actualPercentChange) > changeThreshold * 100) {\n                significantChanges.push({\n                    ...stock,\n                    changePercent: actualPercentChange\n                });\n            }\n        });\n\n        console.log(\"All stocks processed, saving updated prices...\");\n        await takaro.variable.variableControllerUpdate(marketDataVar.data.data[0].id, {\n            value: JSON.stringify(stocks)\n        });\n        console.log(\"Updated prices saved.\");\n\n        if (significantChanges.length > 0) {\n            console.log(\"Significant changes detected, sending alert.\");\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                significantChanges.sort((a, b) => Math.abs(b.changePercent) - Math.abs(a.changePercent));\n                const topChanges = significantChanges.slice(0, Math.min(3, significantChanges.length));\n\n                let message = \"ðŸ“Š STOCK MARKET ALERT ðŸ“Š\\n\";\n                topChanges.forEach(stock => {\n                    const changeDir = stock.changePercent > 0 ? \"up\" : \"down\";\n                    const displayPrice = stock.price.toFixed(2);\n                    const changePercent = Math.abs(Math.round(stock.changePercent));\n\n                    message += `${stock.id} (${stock.sector}): ${changeDir} ${changePercent}% to $${displayPrice}!\\n`;\n                });\n\n                if (activeEvent) {\n                    message += `\\nCurrent market event: ${activeEvent.name}`;\n                }\n\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            } else {\n                console.log(\"No online players to send alert to.\");\n            }\n        } else {\n            console.log(\"No significant changes to alert players about.\");\n        }\n    } catch (error) {\n        console.log(`FATAL Error in updateStockPrices: ${error.message}`);\n        // Optionally, send an admin message if a fatal error occurs\n        // await takaro.gameserver.gameServerControllerSendMessage(data.gameServerId, {\n        //     message: `ðŸš¨ Market Error: An error occurred during stock update: ${error.message}`\n        // });\n    }\n}\n\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        console.log(\"Initializing market if needed...\");\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in module configuration for initialization.\");\n            return;\n        }\n\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_data'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['last_market_event_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_start_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['active_market_event'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_initialized'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_execution_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_cooldown_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['current_event_duration'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } })\n            ]);\n\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n        console.log(\"Mapped initial stocks from config.\");\n\n        const createPromises = [];\n\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_data', value: JSON.stringify(stocks), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'last_market_event_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_start_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'active_market_event', value: '', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_execution_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (cooldownCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_cooldown_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventDurationVar.data.data.length === 0) {\n            const defaultDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'current_event_duration', value: defaultDuration.toString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_initialized', value: 'true', gameServerId, moduleId: mod.moduleId }));\n        }\n\n        if (createPromises.length > 0) {\n            console.log(`Creating ${createPromises.length} initial market variables.`);\n            await Promise.allSettled(createPromises);\n        } else {\n            console.log(\"All market variables already exist, no new initialization needed.\");\n        }\n\n        if (marketDataVar.data.data.length === 0) { // Only announce if we actually created the stock_market_data variable\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /market to see available stocks and /buy to start investing.\";\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, { message });\n            }\n        }\n        console.log(\"Market initialization process complete.\");\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "updatestockprices",
                    "description": null,
                    "temporalValue": "0 */1 * * *"
                }
            ],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Allows the player to view market prices and their portfolio",
                    "permission": "STOCK_MARKET_USE",
                    "friendlyName": "Use Stock Market"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows the player to buy and sell stocks",
                    "permission": "STOCK_MARKET_TRADE",
                    "friendlyName": "Trade Stocks"
                },
                {
                    "canHaveCount": false,
                    "description": "VIP status that reduces transaction fees",
                    "permission": "STOCK_MARKET_BROKER",
                    "friendlyName": "Stock Broker"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows admins to manually trigger market events",
                    "permission": "STOCK_MARKET_TRIGGER_EVENT",
                    "friendlyName": "Trigger Market Events"
                }
            ]
        },
        {
            "tag": "0.1.12",
            "description": "**Stock Market: A Dynamic Virtual Trading System**\n\nCreate an immersive economic experience with this comprehensive stock market module that lets players invest, trade, and react to market events.\n\n**Market Features:**\n\n![Market Summary](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stocks.png)\n\n* **Multiple Economic Sectors:** Configure various industry sectors (Resource Extraction, Manufacturing, Defense, etc.) each with their own market dynamics.\n* **Realistic Stock Behavior:** Stocks have configurable volatility, sector-based pricing, and react differently to market events.\n* **Dynamic Market Events:** Random or admin-triggered events like \"Horde Night Approaching\" or \"Societal Collapse Setback\" impact different sectors in realistic ways.\n\n![Market Events](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_events.png)\n\n**Trading System:**\n\n* **Buy & Sell Shares:** Players can purchase stocks and sell them later for profit or loss.\n* **Transaction Fees:** Configurable fee percentage on all trades creates a realistic market economy.\n* **VIP Benefits:** Special permissions for designated \"Stock Brokers\" who receive fee discounts.\n\n![Buy Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_buy.png)\n\nPlayers can track price changes and sell at the right moment to maximize profits or minimize losses.\n\n![Sell Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sell.png)\n\n**Player Portfolio:**\n\n* **Portfolio Tracking:** Players can view their holdings, average purchase prices, and current profit/loss.\n* **Transaction History:** System tracks all buy/sell transactions for each player.\n* **Summary Statistics:** See overall portfolio performance and value across all holdings.\n\n![Portfolio View](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockportfolio.png)\n\n**Market Information:**\n\n* **Detailed Stock Info:** Players can research specific stocks, including risk levels and sector trends.\n* **Industry Filters:** View stocks by specific sectors to better understand market segments.\n* **Market Alerts:** Server-wide notifications for significant price changes keep players engaged.\n\n![Market Alerts](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockpricechange.png)\n\n**Configuration Options:**\n\n* **Sectors & Stocks:** Define your own market sectors and individual stocks with customizable starting prices and volatility.\n* **Market Events:** Create unique events with specific sector impacts to drive market dynamics.\n* **Transaction Settings:** Configure fee percentages, VIP discounts, and alert thresholds.\n* **Event Frequency:** Control how often random market events occur and how long they last.\n\n![Configuration](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_config.png)\n![Sectors](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sectors.png)\n\n**Commands:**\n\n* `/markets [industry]` - View all stocks or filter by industry\n* `/stockinfo [ticker]` - Get detailed information about a specific stock\n* `/buystock <ticker> <amount>` - Purchase shares of a stock\n* `/sellstock <ticker> <amount>` - Sell shares from your portfolio\n* `/stockportfolio` - View your current holdings and performance\n* `/triggerevent [event]` - Admin command to trigger specific market events\n\nWho says the apocalypse can't have a thriving economy? Now players can stress about both zombie hordes AND their Duke's Casino Tokens dropping 40% after a market event! As one trader put it: \"I used to check my 401K daily, and now I check my AMMO stock before every Blood Moon. Some habits die harder than zombies.\"",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sectors\":{\"type\":\"array\",\"title\":\"Wasteland Economic Sectors\",\"description\":\"Define economic sectors relevant to survival in Navezgane\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Sector ID (e.g., VERY_LOW_RISK)\"},\"name\":{\"type\":\"string\",\"description\":\"Sector name (e.g., Very Low Risk)\"}}},\"default\":[{\"id\":\"VERY_LOW_RISK\",\"name\":\"Very Low Risk\"},{\"id\":\"LOW_RISK\",\"name\":\"Low Risk\"},{\"id\":\"MEDIUM_RISK\",\"name\":\"Medium Risk\"},{\"id\":\"HIGH_RISK\",\"name\":\"High Risk\"},{\"id\":\"VERY_HIGH_RISK\",\"name\":\"Very High Risk\"}]},\"stocks\":{\"type\":\"array\",\"title\":\"Wasteland Stocks\",\"description\":\"List of stocks representing Navezgane entities and resources\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Stock ticker symbol (e.g., NMC)\"},\"name\":{\"type\":\"string\",\"description\":\"Entity/Resource name\"},\"sector\":{\"type\":\"string\",\"description\":\"Sector ID this stock belongs to\"},\"initialPrice\":{\"type\":\"number\",\"description\":\"Starting price in Dukes\",\"minimum\":1},\"volatility\":{\"type\":\"number\",\"description\":\"Base volatility percentage (5 = 5%)\",\"minimum\":1,\"maximum\":60}}},\"default\":[{\"id\":\"NMC\",\"name\":\"Navezgane Mining Co.\",\"sector\":\"HIGH_RISK\",\"initialPrice\":50,\"volatility\":15},{\"id\":\"NIOM\",\"name\":\"Navezgane Iron Ore Mining Co.\",\"sector\":\"HIGH_RISK\",\"initialPrice\":55,\"volatility\":16},{\"id\":\"NLMC\",\"name\":\"Navezgane Lead Mining Co.\",\"sector\":\"MEDIUM_RISK\",\"initialPrice\":45,\"volatility\":14},{\"id\":\"WOOD\",\"name\":\"Wasteland Lumberjacks\",\"sector\":\"LOW_RISK\",\"initialPrice\":20,\"volatility\":8},{\"id\":\"SHALE\",\"name\":\"Oil Shale Extractors\",\"sector\":\"VERY_HIGH_RISK\",\"initialPrice\":40,\"volatility\":45},{\"id\":\"FORGE\",\"name\":\"Forge Ahead Metals\",\"sector\":\"MEDIUM_RISK\",\"initialPrice\":75,\"volatility\":12},{\"id\":\"TOOLS\",\"name\":\"Working Stiff Tools\",\"sector\":\"LOW_RISK\",\"initialPrice\":60,\"volatility\":10},{\"id\":\"AIA\",\"name\":\"A1 Auto\",\"sector\":\"MEDIUM_RISK\",\"initialPrice\":40,\"volatility\":14},{\"id\":\"AMC\",\"name\":\"Atlas Metal Company\",\"sector\":\"MEDIUM_RISK\",\"initialPrice\":65,\"volatility\":13},{\"id\":\"COC\",\"name\":\"COC Chemicals\",\"sector\":\"VERY_HIGH_RISK\",\"initialPrice\":55,\"volatility\":50},{\"id\":\"MECH\",\"name\":\"JunkTech Robotics\",\"sector\":\"HIGH_RISK\",\"initialPrice\":110,\"volatility\":25},{\"id\":\"BUILD\",\"name\":\"Barricade Builders\",\"sector\":\"LOW_RISK\",\"initialPrice\":45,\"volatility\":9},{\"id\":\"ZBI\",\"name\":\"Zombie Bashers Inc.\",\"sector\":\"HIGH_RISK\",\"initialPrice\":85,\"volatility\":17},{\"id\":\"TTC\",\"name\":\"Turret Tracker Co.\",\"sector\":\"VERY_HIGH_RISK\",\"initialPrice\":125,\"volatility\":60},{\"id\":\"AMMO\",\"name\":\"AmmoNation Surplus\",\"sector\":\"VERY_HIGH_RISK\",\"initialPrice\":90,\"volatility\":35},{\"id\":\"SHM\",\"name\":\"Shotgun Messiah\",\"sector\":\"VERY_HIGH_RISK\",\"initialPrice\":120,\"volatility\":30},{\"id\":\"SHAM\",\"name\":\"Shamway Foods\",\"sector\":\"VERY_LOW_RISK\",\"initialPrice\":30,\"volatility\":5},{\"id\":\"SSHM\",\"name\":\"Super Shamway\",\"sector\":\"VERY_LOW_RISK\",\"initialPrice\":32,\"volatility\":4},{\"id\":\"MEDS\",\"name\":\"Pop-N-Pills Medical\",\"sector\":\"VERY_HIGH_RISK\",\"initialPrice\":100,\"volatility\":48},{\"id\":\"SAVG\",\"name\":\"Savage Country\",\"sector\":\"LOW_RISK\",\"initialPrice\":35,\"volatility\":6},{\"id\":\"CRKB\",\"name\":\"Crack-A-Book\",\"sector\":\"HIGH_RISK\",\"initialPrice\":80,\"volatility\":16},{\"id\":\"TRADE\",\"name\":\"Trader Guild Network\",\"sector\":\"VERY_HIGH_RISK\",\"initialPrice\":150,\"volatility\":40},{\"id\":\"PNG\",\"name\":\"Pass-N-Gas\",\"sector\":\"MEDIUM_RISK\",\"initialPrice\":50,\"volatility\":11},{\"id\":\"BOB\",\"name\":\"Trader Bob's\",\"sector\":\"LOW_RISK\",\"initialPrice\":160,\"volatility\":9},{\"id\":\"HUGH\",\"name\":\"Trader Hugh's\",\"sector\":\"MEDIUM_RISK\",\"initialPrice\":170,\"volatility\":12},{\"id\":\"JEN\",\"name\":\"Trader Jen's\",\"sector\":\"LOW_RISK\",\"initialPrice\":180,\"volatility\":10},{\"id\":\"JOEL\",\"name\":\"Trader Joel's\",\"sector\":\"LOW_RISK\",\"initialPrice\":175,\"volatility\":11},{\"id\":\"REKT\",\"name\":\"Trader Rekt's\",\"sector\":\"LOW_RISK\",\"initialPrice\":165,\"volatility\":6},{\"id\":\"DUKES\",\"name\":\"Duke's Casino Tokens\",\"sector\":\"VERY_LOW_RISK\",\"initialPrice\":1,\"volatility\":3}]},\"marketEvents\":{\"type\":\"array\",\"title\":\"Wasteland Events\",\"description\":\"Events impacting the Navezgane economy\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Unique event ID\"},\"name\":{\"type\":\"string\",\"description\":\"Name of the event\"},\"description\":{\"type\":\"string\",\"description\":\"Description of the event's market effect\"},\"sectorImpacts\":{\"type\":\"array\",\"description\":\"How each sector is affected\",\"items\":{\"type\":\"object\",\"properties\":{\"sectorId\":{\"type\":\"string\",\"description\":\"Sector ID\"},\"impact\":{\"type\":\"number\",\"description\":\"Percentage impact (-99 = -99%)\",\"minimum\":-99,\"maximum\":75}}}}}},\"default\":[{\"id\":\"HORDE_INCOMING\",\"name\":\"Horde Night Approaching\",\"description\":\"Increased Zed activity signals the Blood Moon. Very High and High Risk defense stocks soar, while Very Low Risk stocks see minimal impact.\",\"sectorImpacts\":[{\"sectorId\":\"VERY_HIGH_RISK\",\"impact\":50},{\"sectorId\":\"HIGH_RISK\",\"impact\":30},{\"sectorId\":\"MEDIUM_RISK\",\"impact\":15},{\"sectorId\":\"LOW_RISK\",\"impact\":5},{\"sectorId\":\"VERY_LOW_RISK\",\"impact\":1}]},{\"id\":\"STABLE_ECONOMY\",\"name\":\"Period of Stability\",\"description\":\"A rare period of peace has settled over the wasteland. Very Low and Low Risk assets flourish, with higher risk stocks seeing less significant gains.\",\"sectorImpacts\":[{\"sectorId\":\"VERY_LOW_RISK\",\"impact\":15},{\"sectorId\":\"LOW_RISK\",\"impact\":10},{\"sectorId\":\"MEDIUM_RISK\",\"impact\":5},{\"sectorId\":\"HIGH_RISK\",\"impact\":2},{\"sectorId\":\"VERY_HIGH_RISK\",\"impact\":1}]},{\"id\":\"GENERAL_PANIC\",\"name\":\"General Market Panic\",\"description\":\"A major setback reminds everyone how fragile survival is. Fear grips the entire market, causing higher volatility sectors to plummet.\",\"sectorImpacts\":[{\"sectorId\":\"VERY_HIGH_RISK\",\"impact\":-90},{\"sectorId\":\"HIGH_RISK\",\"impact\":-70},{\"sectorId\":\"MEDIUM_RISK\",\"impact\":-40},{\"sectorId\":\"LOW_RISK\",\"impact\":-15},{\"sectorId\":\"VERY_LOW_RISK\",\"impact\":-5}]},{\"id\":\"ADVANCED_WEAPONRY_COLLAPSE\",\"name\":\"Turret AI Virus\",\"description\":\"A malicious code is spreading through advanced turret systems, causing them to malfunction violently. Very High Risk weaponry stocks are obliterated.\",\"sectorImpacts\":[{\"sectorId\":\"VERY_HIGH_RISK\",\"impact\":-99},{\"sectorId\":\"HIGH_RISK\",\"impact\":-20}]},{\"id\":\"VOLATILE_CHEMICALS_COLLAPSE\",\"name\":\"Irreversible Contamination\",\"description\":\"A major chemical disaster has occurred. Very High Risk chemical stocks are worthless, impacting related sectors.\",\"sectorImpacts\":[{\"sectorId\":\"VERY_HIGH_RISK\",\"impact\":-99},{\"sectorId\":\"HIGH_RISK\",\"impact\":-25},{\"sectorId\":\"MEDIUM_RISK\",\"impact\":-10}]},{\"id\":\"FOSSIL_FUELS_COLLAPSE\",\"name\":\"Clean Energy Breakthrough\",\"description\":\"A new energy source has been discovered. Very High Risk fossil fuel stocks become obsolete, while other sectors see minor adjustments.\",\"sectorImpacts\":[{\"sectorId\":\"VERY_HIGH_RISK\",\"impact\":-99},{\"sectorId\":\"MEDIUM_RISK\",\"impact\":10},{\"sectorId\":\"LOW_RISK\",\"impact\":5}]},{\"id\":\"PHARMACEUTICALS_COLLAPSE\",\"name\":\"The Cure is Real\",\"description\":\"A cure for the zombie infection has been found! Very High Risk pharmaceutical stocks are wiped out, and even low-risk survival goods see a hit.\",\"sectorImpacts\":[{\"sectorId\":\"VERY_HIGH_RISK\",\"impact\":-99},{\"sectorId\":\"HIGH_RISK\",\"impact\":-30},{\"sectorId\":\"MEDIUM_RISK\",\"impact\":-15},{\"sectorId\":\"LOW_RISK\",\"impact\":-10},{\"sectorId\":\"VERY_LOW_RISK\",\"impact\":-5}]},{\"id\":\"GUILD_OPERATIONS_COLLAPSE\",\"name\":\"Trader Guild Dissolved\",\"description\":\"The Trader's Guild has been formally dissolved. Very High Risk trade operation stocks become worthless, affecting overall trade.\",\"sectorImpacts\":[{\"sectorId\":\"VERY_HIGH_RISK\",\"impact\":-99},{\"sectorId\":\"HIGH_RISK\",\"impact\":-40},{\"sectorId\":\"MEDIUM_RISK\",\"impact\":-20},{\"sectorId\":\"LOW_RISK\",\"impact\":-10}]},{\"id\":\"AMMUNITION_DEPLETION\",\"name\":\"Ammunition Shortage\",\"description\":\"A major supply chain disruption has caused ammunition stockpiles to dwindle. Very High Risk ammunition stocks plummet.\",\"sectorImpacts\":[{\"sectorId\":\"VERY_HIGH_RISK\",\"impact\":-99},{\"sectorId\":\"HIGH_RISK\",\"impact\":-30},{\"sectorId\":\"MEDIUM_RISK\",\"impact\":-15}]},{\"id\":\"RESOURCE_BOOM\",\"name\":\"Resource Discovery\",\"description\":\"A massive new ore deposit has been found! All resource-related stocks are surging, with higher risk ones seeing the biggest gains.\",\"sectorImpacts\":[{\"sectorId\":\"VERY_HIGH_RISK\",\"impact\":60},{\"sectorId\":\"HIGH_RISK\",\"impact\":40},{\"sectorId\":\"MEDIUM_RISK\",\"impact\":20},{\"sectorId\":\"LOW_RISK\",\"impact\":10}]},{\"id\":\"MANUFACTURING_SURGE\",\"name\":\"Innovation Breakthrough\",\"description\":\"New manufacturing techniques have greatly increased production efficiency. Manufacturing stocks are up across the board.\",\"sectorImpacts\":[{\"sectorId\":\"VERY_HIGH_RISK\",\"impact\":40},{\"sectorId\":\"HIGH_RISK\",\"impact\":30},{\"sectorId\":\"MEDIUM_RISK\",\"impact\":20},{\"sectorId\":\"LOW_RISK\",\"impact\":10},{\"sectorId\":\"VERY_LOW_RISK\",\"impact\":5}]},{\"id\":\"TRADE_ROUTE_OPENED\",\"name\":\"New Trade Route Established\",\"description\":\"A secure trade route has been opened, boosting commerce. Trade-related stocks are seeing significant gains.\",\"sectorImpacts\":[{\"sectorId\":\"VERY_HIGH_RISK\",\"impact\":50},{\"sectorId\":\"HIGH_RISK\",\"impact\":30},{\"sectorId\":\"MEDIUM_RISK\",\"impact\":20},{\"sectorId\":\"LOW_RISK\",\"impact\":15},{\"sectorId\":\"VERY_LOW_RISK\",\"impact\":10}]}]},\"eventFrequency\":{\"title\":\"Event Frequency\",\"type\":\"number\",\"description\":\"Average number of update cycles between market events (0 to disable). Depends on mod's update frequency (e.g., per in-game hour?).\",\"default\":8,\"minimum\":1},\"defaultEventDuration\":{\"title\":\"Default Event Duration\",\"type\":\"number\",\"description\":\"Default number of update cycles an event lasts.\",\"default\":3,\"minimum\":1,\"maximum\":96},\"transactionFee\":{\"title\":\"Transaction Fee (Dukes Tax)\",\"type\":\"number\",\"description\":\"Percentage fee charged on all buy/sell transactions (5 = 5%)\",\"default\":3,\"minimum\":0,\"maximum\":25},\"vipDiscount\":{\"title\":\"Trader's Favor Discount\",\"type\":\"number\",\"description\":\"Percentage discount on transaction fees for players with 'STOCK_MARKET_BROKER' permission (50 = 50%)\",\"default\":50,\"minimum\":0,\"maximum\":100},\"priceAlertThreshold\":{\"title\":\"Price Alert Threshold\",\"type\":\"number\",\"description\":\"Percentage change that triggers a market alert (15 = 15%)\",\"default\":15,\"minimum\":5,\"maximum\":50},\"marketNewsChannelId\":{\"title\":\"Discord Channel ID (for Market News)\",\"type\":\"string\",\"description\":\"The ID of the Discord channel where market news messages should be posted. Leave empty to disable.\",\"default\":\"\"}},\"additionalProperties\":false}",
            "uiSchema": "{\"sectors\":{\"items\":{\"ui:order\":[\"id\",\"name\"]}},\"stocks\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"sector\",\"initialPrice\",\"volatility\"]}},\"marketEvents\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"description\",\"sectorImpacts\"],\"sectorImpacts\":{\"items\":{\"ui:order\":[\"sectorId\",\"impact\"]}}}},\"transactionFee\":{\"ui:widget\":\"range\"},\"vipDiscount\":{\"ui:widget\":\"range\"},\"eventFrequency\":{\"ui:help\":\"Set to 0 to disable random events\"},\"priceAlertThreshold\":{\"ui:widget\":\"range\"}}",
            "commands": [
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // If a specific stock ticker is provided, show detailed info for that stock\n    const specificTicker = args.ticker ? args.ticker.toUpperCase() : null;\n\n    if (specificTicker && specificTicker !== \"ALL\") {\n        const stock = stocks.find(s => s.id.toUpperCase() === specificTicker);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${specificTicker} not found. Use /stockinfo without parameters to see all available stocks.`);\n        }\n\n        // Get active event to see if this stock's sector is affected\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let activeEvent = null;\n        let sectorImpact = null;\n\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEvent && activeEvent.sectorImpacts) {\n                    sectorImpact = activeEvent.sectorImpacts.find(impact =>\n                        impact.sectorId === stock.sector\n                    );\n                }\n            } catch (e) {\n                // Ignore parsing errors\n            }\n        }\n\n        // Calculate price change indicators\n        let changeText = '';\n        if (stock.lastPrice) {\n            const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n            const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n            changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n        }\n\n        // Add risk assessment based on volatility without showing the raw value\n        let riskLevel;\n        if (stock.volatility <= 0.05) riskLevel = \"Very Low\";\n        else if (stock.volatility <= 0.10) riskLevel = \"Low\";\n        else if (stock.volatility <= 0.15) riskLevel = \"Moderate\";\n        else if (stock.volatility <= 0.20) riskLevel = \"High\";\n        else riskLevel = \"Very High\";\n\n        // Build detailed stock info message\n        let message = `=== ${stock.id}: ${stock.name} ===\\n\\n`;\n        message += `Sector: ${stock.sector}\\n`;\n        message += `Current Price: $${Math.round(stock.price)}${changeText}\\n`;\n        message += `Risk Level: ${riskLevel}\\n`;\n\n        // Add sector trend info if available from event\n        if (activeEvent && sectorImpact) {\n            const direction = sectorImpact.impact >= 0 ? \"Positive\" : \"Negative\";\n            const strength = Math.abs(sectorImpact.impact);\n            let trend;\n\n            if (strength < 10) trend = \"Slight\";\n            else if (strength < 25) trend = \"Moderate\";\n            else trend = \"Strong\";\n\n            message += `\\nCurrent Trend: ${trend} ${direction} (${activeEvent.name})\\n`;\n            message += `Event: ${activeEvent.description}\\n`;\n        }\n\n        // Add trading guidance based on sector and risk, without mentioning volatility\n        message += `\\nTrading Notes:\\n`;\n\n        if (activeEvent && sectorImpact) {\n            if (sectorImpact.impact > 0) {\n                message += `- Currently bullish due to the ${activeEvent.name} event\\n`;\n            } else {\n                message += `- Currently bearish due to the ${activeEvent.name} event\\n`;\n            }\n        }\n\n        if (riskLevel === \"High\" || riskLevel === \"Very High\") {\n            message += `- Expect significant price fluctuations with this stock\\n`;\n        } else if (riskLevel === \"Low\" || riskLevel === \"Very Low\") {\n            message += `- Typically has stable price movement\\n`;\n        }\n\n        message += `\\nUse /buystock ${stock.id} [amount] to purchase shares`;\n\n        await player.pm(message);\n\n    } else {\n        // No specific ticker provided or ALL specified, show summary of all stocks\n        await player.pm(\"=== STOCK MARKET LISTINGS ===\\n\");\n\n        // Group stocks by sector\n        const stocksBySector = {};\n        stocks.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        // MODIFICATION START\n        // Display stocks by sector, chunking them into messages of 3\n        const chunkSize = 3;\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            for (let i = 0; i < sectorStocks.length; i += chunkSize) {\n                const chunk = sectorStocks.slice(i, i + chunkSize);\n\n                // Add the sector header only to the first message for that sector.\n                let sectorMessage = (i === 0) ? `\\n--- ${sector} SECTOR ---\\n` : '';\n\n                chunk.forEach(stock => {\n                    // Add price change indicators\n                    let changeText = '';\n                    if (stock.lastPrice) {\n                        const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                        const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                        changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                    }\n\n                    // Add risk level based on volatility\n                    let riskIndicator;\n                    if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                    else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                    else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                    else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                    else riskIndicator = \"VH\";\n\n                    sectorMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n                });\n\n                await player.pm(sectorMessage);\n            }\n        }\n        // MODIFICATION END\n\n        // Add legend for risk indicators\n        const legend = \"\\n=== LEGEND ===\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\" +\n            \"Use /stockinfo [ticker] for detailed information about a specific stock\";\n\n        await player.pm(legend);\n    }\n}\n\nawait main();",
                    "name": "stockinfo",
                    "description": null,
                    "trigger": "stockinfo",
                    "helpText": "Shows all available stocks in the market. Use with a ticker symbol (e.g., /stockinfo ticker) to see detailed information about a specific stock.",
                    "arguments": [
                        {
                            "name": "ticker",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "stock ticker or ALL to get detailed information about a specific stock",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRIGGER_EVENT')) {\n        throw new TakaroUserError(\"You don't have permission to trigger market events.\");\n    }\n\n    try {\n        // Get current stock data to check market initialization\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Initialize market if needed\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            await player.pm(\"Market was not initialized. Initializing now...\");\n            return;\n        }\n\n        // Get events from module config\n        const marketEvents = mod.userConfig.marketEvents || [];\n\n        if (marketEvents.length === 0) {\n            throw new TakaroUserError(\"No market events configured in this module.\");\n        }\n\n        // Handle case when no event is specified or \"ALL\" is provided\n        if (!args.EventName || args.EventName.toUpperCase() === \"ALL\") {\n            await player.pm(\"=== AVAILABLE MARKET EVENTS ===\\n\");\n\n            // Group events by category or type if possible\n            const eventCategories = {};\n\n            // Create a simple categorization based on positive/negative impact\n            marketEvents.forEach(event => {\n                let category = \"Mixed\";\n                // Calculate net impact across all sectors\n                const netImpact = event.sectorImpacts.reduce((sum, impact) => sum + impact.impact, 0);\n\n                if (netImpact > 0) category = \"Positive\";\n                else if (netImpact < 0) category = \"Negative\";\n\n                if (!eventCategories[category]) {\n                    eventCategories[category] = [];\n                }\n                eventCategories[category].push(event);\n            });\n\n            // Display events by category\n            for (const [category, events] of Object.entries(eventCategories)) {\n                if (events.length > 0) {\n                    await player.pm(`\\n--- ${category.toUpperCase()} EVENTS ---`);\n\n                    let message = \"\";\n                    events.forEach(event => {\n                        // Format primary sectors affected\n                        const primarySectors = event.sectorImpacts\n                            .filter(impact => Math.abs(impact.impact) >= 15)\n                            .map(impact => {\n                                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                                return `${impact.sectorId} ${direction}${Math.abs(impact.impact)}%`;\n                            })\n                            .join(\", \");\n\n                        message += `${event.id}: ${event.name}\\n`;\n                        message += `   ${event.description}\\n`;\n                        if (primarySectors) {\n                            message += `   Major impacts: ${primarySectors}\\n`;\n                        }\n                        message += \"\\n\";\n                    });\n\n                    await player.pm(message);\n                }\n            }\n\n            await player.pm(\"=== HOW TO USE ===\\nUse `/triggerevent <EventName>` to trigger a specific event (e.g., `/triggerevent TECH_BOOM`)\");\n            return;\n        }\n\n        // Find the requested event\n        const eventId = args.EventName.toUpperCase();\n        const event = marketEvents.find(e => e.id === eventId);\n\n        if (!event) {\n            throw new TakaroUserError(`Event \"${eventId}\" not found. Use /triggerevent without parameters to see all available events.`);\n        }\n\n        // Get necessary variables for managing the event\n        const [activeEventVar, eventStartTimeVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_execution_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_cooldown_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['current_event_duration'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Check if there's an active event we need to cancel\n        let activeEventObj = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEventObj = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEventObj && Object.keys(activeEventObj).length > 0) {\n                    await player.pm(`Cancelling active event \"${activeEventObj.name}\" to trigger new event.`);\n                }\n            } catch (e) {\n                // Invalid event data, will be overwritten\n            }\n        }\n\n        // Generate a random duration for the event\n        const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n        // Update or create all event-related variables\n        const updatePromises = [];\n\n        // Save or update the random duration\n        if (eventDurationVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                    value: randomDuration.toString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'current_event_duration',\n                    value: randomDuration.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the event counter to 0\n        if (eventCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the cooldown counter\n        if (cooldownCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update active event\n        if (activeEventVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                    value: JSON.stringify(event)\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: JSON.stringify(event),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update event start time\n        if (eventStartTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update last event time\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (lastEventTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all updates to complete\n        await Promise.all(updatePromises);\n\n        // Check if there are online players to announce the event\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            // Format sector impacts for announcement\n            let impactText = \"\";\n            for (const impact of event.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n            }\n\n            const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${event.name}\\n${event.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /markets to see opportunities!`;\n\n            // Split the message if it's too long\n            const maxLength = 400; // Safe limit for most games\n            for (let i = 0; i < message.length; i += maxLength) {\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message: message.substring(i, i + maxLength)\n                });\n            }\n        }\n\n        await player.pm(`Successfully triggered the \"${event.name}\" market event for ${randomDuration} cycles!`);\n    } catch (error) {\n        // If something goes wrong, log it and let the player know\n        console.log(`Error in triggerEvent: ${error.message}`);\n        throw new TakaroUserError(`Error triggering event: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Store the stocks data\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_data',\n            value: JSON.stringify(stocks),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize last event time to now\n        await takaro.variable.variableControllerCreate({\n            key: 'last_market_event_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize event start time variable\n        await takaro.variable.variableControllerCreate({\n            key: 'event_start_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize active event (empty string means no active event)\n        await takaro.variable.variableControllerCreate({\n            key: 'active_market_event',\n            value: '',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Mark market as initialized\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_initialized',\n            value: 'true',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Announce market initialization to online players\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /markets to see available stocks and /buystock to start investing.\";\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message\n            });\n        }\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "triggerevent",
                    "description": null,
                    "trigger": "triggerevent",
                    "helpText": "Shows all available market events when run without parameters. Use with an event name (e.g., /triggerevent TECH_BOOM) to trigger a specific market event.",
                    "arguments": [
                        {
                            "name": "EventName",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "Event name to trigger a specific market event",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Handle the industry argument - use \"ALL\" as a special value to show all industries\n    const industryFilter = args.Industry ? args.Industry.toUpperCase() : \"ALL\";\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    // If market data doesn't exist, try to initialize it\n    if (marketDataVar.data.data.length === 0) {\n        const initialized = await initializeMarketIfNeeded(gameServerId, mod);\n        if (!initialized) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        // Get the freshly initialized market data\n        const refreshedMarketData = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (refreshedMarketData.data.data.length === 0) {\n            throw new TakaroUserError(\"There was an issue initializing the stock market. Please try again later.\");\n        }\n\n        // Continue with the refreshed data\n        await displayMarketSummary(player, gameServerId, mod, refreshedMarketData.data.data[0], industryFilter);\n    } else {\n        // Market data exists, display it\n        await displayMarketSummary(player, gameServerId, mod, marketDataVar.data.data[0], industryFilter);\n    }\n}\n\n// Display the market summary to the player\nasync function displayMarketSummary(player, gameServerId, mod, marketDataVariable, industryFilter) {\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Handle empty string or empty object\n            if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (e) {\n            // In case of parsing error\n            activeEvent = null;\n        }\n    }\n\n    const stocks = JSON.parse(marketDataVariable.value);\n\n    // Get all available industries for reference\n    const availableIndustries = [...new Set(stocks.map(stock => stock.sector))];\n\n    // If industry filter is provided and not \"ALL\", check if it's valid\n    if (industryFilter !== \"ALL\") {\n        // Check if the industry exists\n        const industryExists = availableIndustries.includes(industryFilter);\n\n        if (!industryExists) {\n            throw new TakaroUserError(`Industry \"${industryFilter}\" not found. Available industries: ${availableIndustries.join(', ')}\\nUse \"ALL\" to view all industries.`);\n        }\n    }\n\n    // Send header message\n    let headerMessage = \"=== STOCK MARKET SUMMARY ===\\n\";\n\n    // If filtering by industry, mention it in the header\n    if (industryFilter !== \"ALL\") {\n        headerMessage = `=== ${industryFilter} INDUSTRY ===\\n`;\n    }\n\n    // If there's an active event, include it in the header\n    if (activeEvent) {\n        headerMessage += `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n`;\n        headerMessage += `${activeEvent.description}\\n\\n`;\n\n        // If filtering by industry, only show relevant impacts\n        if (industryFilter !== \"ALL\") {\n            const relevantImpact = activeEvent.sectorImpacts.find(\n                impact => impact.sectorId === industryFilter\n            );\n\n            if (relevantImpact) {\n                const direction = relevantImpact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `Industry Impact: ${direction} ${Math.abs(relevantImpact.impact)}%\\n`;\n            } else {\n                headerMessage += \"This industry is not directly affected by the current event.\\n\";\n            }\n        } else {\n            // Show all industry impacts\n            headerMessage += \"Industry Impacts:\\n\";\n            for (const impact of activeEvent.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%\\n`;\n            }\n        }\n    }\n\n    // Send header message first\n    await player.pm(headerMessage);\n\n    // Group stocks by industry\n    const stocksByIndustry = {};\n    stocks.forEach(stock => {\n        if (!stocksByIndustry[stock.sector]) {\n            stocksByIndustry[stock.sector] = [];\n        }\n        stocksByIndustry[stock.sector].push(stock);\n    });\n\n    // If industry filter is not \"ALL\", only show that industry\n    if (industryFilter !== \"ALL\") {\n        const filteredStocks = stocksByIndustry[industryFilter] || [];\n\n        if (filteredStocks.length > 0) {\n            let stockMessage = \"\";\n\n            filteredStocks.forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                stockMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(stockMessage);\n        } else {\n            await player.pm(`No stocks found in the ${industryFilter} industry.`);\n        }\n    } else {\n        // Send each industry as a separate message\n        for (const industryId in stocksByIndustry) {\n            let industryMessage = `=== ${industryId} INDUSTRY ===\\n`;\n\n            stocksByIndustry[industryId].forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                industryMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(industryMessage);\n        }\n    }\n\n    // Add a help message for industry filtering if showing all industries\n    if (industryFilter === \"ALL\") {\n        const allIndustries = Object.keys(stocksByIndustry).join(', ');\n        await player.pm(`\\nTip: Use '/markets [industry]' to view only stocks in a specific industry. Available industries: ${allIndustries}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return false;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            const results = await Promise.allSettled(createPromises);\n            // Check if the critical stock_market_data was created successfully\n            const stockDataPromise = results[0];\n            if (stockDataPromise && stockDataPromise.status === 'rejected') {\n                console.log(`Failed to create stock_market_data: ${stockDataPromise.reason}`);\n                return false;\n            }\n        }\n\n        return true;\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n        return false;\n    }\n}\n\nawait main();",
                    "name": "markets",
                    "description": null,
                    "trigger": "markets",
                    "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. \n",
                    "arguments": [
                        {
                            "name": "Industry",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. ",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get player's portfolio\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        if (portfolioVar.data.data.length === 0) {\n            throw new TakaroUserError(\"You don't own any stocks to sell.\");\n        }\n\n        const portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        const stockId = args.stock.toUpperCase();\n\n        if (!portfolio[stockId] || portfolio[stockId].shares < amount) {\n            throw new TakaroUserError(`You don't own ${amount} shares of ${stockId}.`);\n        }\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === stockId);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${stockId} not found in current market data. Please contact an admin.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate sale proceeds using Math.round to ensure we work with integers\n        const stockPrice = Math.round(stock.price);\n        const subtotal = stockPrice * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const netProceeds = subtotal - fee;\n\n        // Add money to player - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerAddCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: netProceeds\n            }\n        );\n\n        // Calculate profit/loss\n        const profitPerShare = stockPrice - portfolio[stockId].averagePrice;\n        const totalProfit = Math.round(profitPerShare * amount);\n        const profitText = totalProfit >= 0\n            ? `profit of $${totalProfit}`\n            : `loss of $${Math.abs(totalProfit)}`;\n\n        // Update portfolio\n        portfolio[stockId].shares -= amount;\n        if (portfolio[stockId].shares === 0) {\n            delete portfolio[stockId];\n        }\n\n        // Save updated portfolio\n        await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n            value: JSON.stringify(portfolio)\n        });\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'SELL',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: netProceeds,\n            profit: totalProfit,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully sold ${amount} shares of ${stockId} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Net proceeds: $${netProceeds} (${profitText})`;\n\n        // Add remaining shares info if player still has some\n        if (portfolio[stockId]) {\n            message += `\\nRemaining shares: ${portfolio[stockId].shares}`;\n        } else {\n            message += `\\nYou've sold all your ${stockId} shares.`;\n        }\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in sellstock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your sale. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "sellstock",
                    "description": null,
                    "trigger": "sellstock",
                    "helpText": "Sell shares of a stock",
                    "arguments": [
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to sell",
                            "position": 1
                        },
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // Get player's portfolio\n    const portfolioVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_portfolio'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId],\n            playerId: [player.id]\n        }\n    });\n\n    let portfolio = {};\n    if (portfolioVar.data.data.length > 0) {\n        portfolio = JSON.parse(portfolioVar.data.data[0].value);\n    }\n\n    // Send header\n    await player.pm(\"=== YOUR STOCK PORTFOLIO ===\");\n\n    let hasStocks = false;\n    let totalValue = 0;\n    let totalInvestment = 0;\n\n    // If no stocks, send a simple message\n    if (Object.keys(portfolio).length === 0) {\n        await player.pm(\"You don't own any stocks yet.\\n\" +\n            \"Use /markets to see available stocks and prices.\\n\" +\n            \"Use /buy <stock> <amount> to purchase stocks.\");\n        return;\n    }\n\n    // Helper function to format numbers with commas and a dollar sign\n    const formatNumber = (num) => {\n        return `$${Math.round(num).toLocaleString()}`;\n    };\n\n    // Send each stock as a separate message to avoid length issues\n    for (const [stockId, data] of Object.entries(portfolio)) {\n        hasStocks = true;\n        const stock = stocks.find(s => s.id === stockId);\n        if (!stock) continue; // Stock might have been removed from config\n\n        const currentValue = stock.price * data.shares;\n        const investmentValue = data.averagePrice * data.shares;\n        totalValue += currentValue;\n        totalInvestment += investmentValue;\n        const profit = currentValue - investmentValue;\n        const profitPercent = ((profit / investmentValue) * 100).toFixed(1);\n\n        let stockMessage = `--- ${stockId} (${stock.sector}) ---\\n`;\n        stockMessage += `Shares: ${data.shares}\\n`;\n        stockMessage += `Avg buy: ${formatNumber(data.averagePrice)}\\n`;\n        stockMessage += `Current price: ${formatNumber(stock.price)}\\n`;\n        stockMessage += `Total value: ${formatNumber(currentValue)}\\n`;\n\n        if (profit >= 0) {\n            stockMessage += `Profit: +${formatNumber(profit)} (+${profitPercent}%)\\n`;\n        } else {\n            stockMessage += `Loss: -${formatNumber(Math.abs(profit))} (${profitPercent}%)\\n`;\n        }\n\n        await player.pm(stockMessage);\n    }\n\n    if (hasStocks) {\n        const totalProfit = totalValue - totalInvestment;\n        const totalProfitPercent = ((totalProfit / totalInvestment) * 100).toFixed(1);\n\n        let summaryMessage = \"=== PORTFOLIO SUMMARY ===\\n\";\n        summaryMessage += `Total investment: ${formatNumber(totalInvestment)}\\n`;\n        summaryMessage += `Current value: ${formatNumber(totalValue)}\\n`;\n\n        if (totalProfit >= 0) {\n            summaryMessage += `Overall profit: +${formatNumber(totalProfit)} (+${totalProfitPercent}%)\\n`;\n        } else {\n            summaryMessage += `Overall loss: -${formatNumber(Math.abs(totalProfit))} (${totalProfitPercent}%)\\n`;\n        }\n\n        // Get transaction history count\n        try {\n            const historyVar = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: ['stock_transaction_history'],\n                    gameServerId: [gameServerId],\n                    moduleId: [mod.moduleId],\n                    playerId: [player.id]\n                }\n            });\n\n            if (historyVar.data.data.length > 0) {\n                const history = JSON.parse(historyVar.data.data[0].value);\n                const buyCount = history.filter(t => t.type === 'BUY').length;\n                const sellCount = history.filter(t => t.type === 'SELL').length;\n\n                summaryMessage += `\\nTransactions: ${history.length} (${buyCount} buys, ${sellCount} sells)\\n`;\n            }\n        } catch (error) {\n            // Just ignore history errors\n        }\n\n        await player.pm(summaryMessage);\n    }\n}\n\nawait main();",
                    "name": "stockportfolio",
                    "description": null,
                    "trigger": "stockportfolio",
                    "helpText": "No help text available",
                    "arguments": []
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === args.stock.toUpperCase());\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${args.stock} not found. Use /market to see available stocks.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate costs using Math.round to ensure we work with integers\n        const subtotal = Math.round(stock.price) * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const totalCost = subtotal + fee;\n\n        // Check if player has enough currency\n        const playerData = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, player.id);\n        const currentBalance = playerData.data.data.currency;\n\n        if (currentBalance < totalCost) {\n            throw new TakaroUserError(`You don't have enough currency. Cost: $${subtotal} + $${fee} fee = $${totalCost}. Your balance: $${currentBalance}`);\n        }\n\n        // Deduct the currency - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerDeductCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: totalCost\n            }\n        );\n\n        // Get player's portfolio or create new one\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        let portfolio;\n        if (portfolioVar.data.data.length === 0) {\n            portfolio = {};\n        } else {\n            portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        }\n\n        // Update portfolio using rounded values for consistency\n        const stockPrice = Math.round(stock.price);\n        if (!portfolio[stock.id]) {\n            portfolio[stock.id] = {\n                shares: amount,\n                averagePrice: stockPrice\n            };\n        } else {\n            const totalShares = portfolio[stock.id].shares + amount;\n            const totalValue = (portfolio[stock.id].shares * portfolio[stock.id].averagePrice) + (amount * stockPrice);\n            portfolio[stock.id].shares = totalShares;\n            portfolio[stock.id].averagePrice = Math.round(totalValue / totalShares);\n        }\n\n        // Save updated portfolio\n        if (portfolioVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_portfolio',\n                value: JSON.stringify(portfolio),\n                gameServerId,\n                moduleId: mod.moduleId,\n                playerId: player.id\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n                value: JSON.stringify(portfolio)\n            });\n        }\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'BUY',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: totalCost,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully bought ${amount} shares of ${stock.id} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Total cost: $${totalCost}\\n`;\n        message += `Current portfolio: ${portfolio[stock.id].shares} shares of ${stock.id}`;\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in buystock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your purchase. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "buystock",
                    "description": null,
                    "trigger": "buystock",
                    "helpText": "Buy shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol ",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to buy",
                            "position": 1
                        }
                    ]
                }
            ],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n\n    const discordChannelId = mod.userConfig.marketNewsChannelId;\n\n    if (!discordChannelId) {\n        takaro.log.info('Market news Discord channel ID (marketNewsChannelId) not configured in module settings. Skipping Discord messages.');\n    }\n\n    const currentPlayers = (await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    })).data.meta;\n\n    if (currentPlayers.total === 0) {\n        takaro.log.info('Skipping daily market report: No players online.');\n        return;\n    }\n\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        takaro.log.warn('Skipping daily market report: Market data variable not found.');\n        return;\n    }\n\n    let stocks;\n    try {\n        stocks = JSON.parse(marketDataVar.data.data[0].value);\n        if (!Array.isArray(stocks)) {\n            throw new Error('Parsed market data is not an array.');\n        }\n    } catch (error) {\n        takaro.log.error(`Failed to parse stock_market_data: ${error}`);\n        return;\n    }\n\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            if (typeof activeEvent !== 'object' || activeEvent === null || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (error) {\n            takaro.log.warn(`Failed to parse active_market_event: ${error}`);\n            activeEvent = null;\n        }\n    }\n\n    let gameMessage1 = \"==== DAILY MARKET REPORT ====\\n\";\n\n    if (activeEvent && activeEvent.name && activeEvent.description) {\n        const eventText = `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n${activeEvent.description}\\n`;\n        gameMessage1 += eventText;\n    } else {\n        const noEventText = '\\nNo active market events today.\\n';\n        gameMessage1 += noEventText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage1\n    }).catch(err => takaro.log.error(`Failed to send game message 1: ${err}`));\n\n    const stocksWithPerformance = stocks.map(stock => {\n        let change = 0;\n        let percentChange = 0;\n        let changeSymbol = 'â†’';\n\n        if (typeof stock.price === 'number' && typeof stock.lastPrice === 'number' && stock.lastPrice !== 0) {\n            change = stock.price - stock.lastPrice;\n            percentChange = (change / stock.lastPrice) * 100;\n            if (percentChange > 0.05) {\n                changeSymbol = 'â†‘';\n            } else if (percentChange < -0.05) {\n                changeSymbol = 'â†“';\n            }\n        } else if (typeof stock.price === 'number' && stock.lastPrice === undefined) {\n            changeSymbol = 'ðŸ†•';\n            percentChange = 0;\n        }\n        return {\n            ...stock,\n            change,\n            percentChange,\n            changeSymbol\n        };\n    });\n\n    const sectorPerformance = {};\n    stocksWithPerformance.forEach(stock => {\n        const sectorId = stock.sector || 'Uncategorized';\n        if (!sectorPerformance[sectorId]) {\n            sectorPerformance[sectorId] = {\n                stocks: [],\n                totalPercentChange: 0,\n                count: 0\n            };\n        }\n        sectorPerformance[sectorId].stocks.push(stock);\n        if (typeof stock.percentChange === 'number' && isFinite(stock.percentChange)) {\n            sectorPerformance[sectorId].totalPercentChange += stock.percentChange;\n            sectorPerformance[sectorId].count++;\n        }\n    });\n\n    for (const sectorId in sectorPerformance) {\n        const sectorData = sectorPerformance[sectorId];\n        if (sectorData.count > 0) {\n            sectorData.avgPerformance = sectorData.totalPercentChange / sectorData.count;\n        } else {\n            sectorData.avgPerformance = 0;\n        }\n    }\n\n    const sortedSectors = Object.entries(sectorPerformance)\n        .sort(([, a], [, b]) => b.avgPerformance - a.avgPerformance);\n\n    let gameMessage2 = \"\\n=== SECTOR PERFORMANCE ===\\n\";\n\n    if (sortedSectors.length > 0) {\n        sortedSectors.forEach(([sectorId, sectorData]) => {\n            const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n            let line = `${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n\n            if (sectorData.avgPerformance > 0.05) {\n                line = `[70FE02]${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%[-]\\n`;\n            } else if (sectorData.avgPerformance < -0.05) {\n                line = `[FF0001]${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%[-]\\n`;\n            }\n            gameMessage2 += line;\n        });\n    } else {\n        const noDataText = \"No sector performance data available.\\n\";\n        gameMessage2 += noDataText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage2\n    }).catch(err => takaro.log.error(`Failed to send game message 2: ${err}`));\n\n    const validPerformers = stocksWithPerformance.filter(s => typeof s.percentChange === 'number' && isFinite(s.percentChange));\n    validPerformers.sort((a, b) => b.percentChange - a.percentChange);\n\n    let gameMessage3 = \"\";\n\n    const topPerformersTitleGame = \"\\nðŸ”¥ TOP PERFORMERS ðŸ”¥\\n\";\n    gameMessage3 += topPerformersTitleGame;\n\n    if (validPerformers.length > 0) {\n        for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n            const stock = validPerformers[i];\n            gameMessage3 += `[70FE02]${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%[-]\\n`;\n        }\n    } else {\n        gameMessage3 += \"No top performers today.\\n\";\n    }\n\n    const worstPerformersTitleGame = \"\\nðŸ“‰ WORST PERFORMERS ðŸ“‰\\n\";\n    gameMessage3 += worstPerformersTitleGame;\n\n    if (validPerformers.length > 0) {\n        const worstStartIndex = Math.max(0, validPerformers.length - 3);\n        for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n            const stock = validPerformers[i];\n            gameMessage3 += `[FF0001]${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%[-]\\n`;\n        }\n    } else {\n        gameMessage3 += \"No worst performers today.\\n\";\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage3\n    }).catch(err => takaro.log.error(`Failed to send game message 3: ${err}`));\n\n    function hslToRgb(h, s, l) { let a = s * Math.min(l, 1 - l); let f = n => { let k = (n + h / 30) % 12; return l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1)); }; return [Math.round(255 * f(0)), Math.round(255 * f(8)), Math.round(255 * f(4))]; }\n    function rgbToHex(r, g, b) { return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase(); }\n    function stringToHexColor(str) { let hash = 0; for (let i = 0; i < str.length; i++) { hash = str.charCodeAt(i) + ((hash << 5) - hash); } hash = Math.abs(hash); const hue = (hash * 137.508) % 360; const [r, g, b] = hslToRgb(hue, 0.9, 0.7); return rgbToHex(r, g, b); }\n\n    const stockColors = {};\n    stocksWithPerformance.forEach(stock => {\n        stockColors[stock.id] = stringToHexColor(stock.name);\n    });\n\n    const stocksBySectorGame = {};\n    stocksWithPerformance.forEach(stock => {\n        const sector = stock.sector || 'Uncategorized';\n        if (!stocksBySectorGame[sector]) {\n            stocksBySectorGame[sector] = [];\n        }\n        stocksBySectorGame[sector].push(stock);\n    });\n\n    const chunkSize = 3;\n    for (const [sector, sectorStocks] of Object.entries(stocksBySectorGame)) {\n        for (let i = 0; i < sectorStocks.length; i += chunkSize) {\n            const chunk = sectorStocks.slice(i, i + chunkSize);\n            let sectorMessage = (i === 0) ? `\\n--- ${sector} SECTOR ---\\n` : '';\n\n            chunk.forEach(stock => {\n                let changeText = '';\n                let priceColorPrefix = '', priceColorSuffix = '';\n\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeText = ` ${stock.changeSymbol} ${Math.abs(percentChange).toFixed(1)}%`;\n                    if (percentChange > 0) {\n                        priceColorPrefix = '[70FE02]';\n                        priceColorSuffix = '[-]';\n                    } else if (percentChange < 0) {\n                        priceColorPrefix = '[FF0001]';\n                        priceColorSuffix = '[-]';\n                    }\n                }\n\n                const stockNameColorPrefix = stockColors[stock.id] ? `[${stockColors[stock.id]}]` : '';\n                const stockNameColorSuffix = stockColors[stock.id] ? '[-]' : '';\n\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.25) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                sectorMessage += `${stockNameColorPrefix}${stock.name} (${stock.id})${stockNameColorSuffix} (${riskIndicator}): ${priceColorPrefix}$${Math.round(stock.price)}${changeText}${priceColorSuffix}\\n`;\n            });\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message: sectorMessage\n            }).catch(err => takaro.log.error(`Failed to send game message for sector ${sector}: ${err}`));\n        }\n    }\n\n    const legendMessage = \"\\n=== LEGEND ===\\n\" +\n        \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\";\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: legendMessage\n    }).catch(err => takaro.log.error(`Failed to send game legend message: ${err}`));\n\n    if (discordChannelId) {\n        // --- MESSAGE 1: The Summary ---\n        let discordMessageSummary = \"**==== DAILY MARKET REPORT ====**\\n\\n\";\n\n        if (activeEvent && activeEvent.name && activeEvent.description) {\n            discordMessageSummary += `ðŸŒ **ACTIVE EVENT: ${activeEvent.name}** ðŸŒ\\n${activeEvent.description}\\n\\n`;\n        } else {\n            discordMessageSummary += 'No active market events today.\\n\\n';\n        }\n\n        discordMessageSummary += \"**=== SECTOR PERFORMANCE ===**\\n\";\n        if (sortedSectors.length > 0) {\n            sortedSectors.forEach(([sectorId, sectorData]) => {\n                const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n                discordMessageSummary += `${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n            });\n        } else {\n            discordMessageSummary += \"No sector performance data available.\\n\";\n        }\n        discordMessageSummary += \"\\n\";\n\n        discordMessageSummary += \"**ðŸ”¥ TOP PERFORMERS ðŸ”¥**\\n\";\n        if (validPerformers.length > 0) {\n            for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n                const stock = validPerformers[i];\n                discordMessageSummary += `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            }\n        } else {\n            discordMessageSummary += \"No top performers today.\\n\";\n        }\n        discordMessageSummary += \"\\n\";\n\n        discordMessageSummary += \"**ðŸ“‰ WORST PERFORMERS ðŸ“‰**\\n\";\n        if (validPerformers.length > 0) {\n            const worstStartIndex = Math.max(0, validPerformers.length - 3);\n            for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n                const stock = validPerformers[i];\n                discordMessageSummary += `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            }\n        } else {\n            discordMessageSummary += \"No worst performers today.\\n\";\n        }\n\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessageSummary\n        }).catch(err => takaro.log.error(`Failed to send summary Discord message: ${err.message || err}`));\n\n        // --- MESSAGE 2: All Stock Listings ---\n        let discordMessageDetails = \"**=== ALL STOCK LISTINGS ===**\\n\";\n        const stocksBySector = {};\n        stocksWithPerformance.forEach(stock => {\n            const sector = stock.sector || 'Uncategorized';\n            if (!stocksBySector[sector]) {\n                stocksBySector[sector] = [];\n            }\n            stocksBySector[sector].push(stock);\n        });\n\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            discordMessageDetails += `\\n--- **${sector} SECTOR** ---\\n`;\n            sectorStocks.forEach(stock => {\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeText = ` ${stock.changeSymbol} ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.25) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                discordMessageDetails += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n        }\n\n        discordMessageDetails += \"\\n**=== LEGEND ===**\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\";\n\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessageDetails\n        }).catch(err => takaro.log.error(`Failed to send details Discord message: ${err.message || err}`));\n    }\n\n    takaro.log.info('Daily market report sent successfully.');\n}\n\nawait main();",
                    "name": "marketnews",
                    "description": null,
                    "temporalValue": "1 */1 * * *"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    try {\n        const { gameServerId, module: mod } = data;\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Check if market is initialized\n        if (marketDataVar.data.data.length === 0) {\n            console.log(\"Market data not found, initializing...\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return; // Exit after initialization\n        }\n\n        // Get active market event\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event start time\n        const eventStartTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_start_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event execution counter\n        const eventCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_execution_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event cooldown counter\n        const cooldownCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_cooldown_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let eventCounter = 0;\n        if (eventCounterVar.data.data.length > 0) {\n            eventCounter = parseInt(eventCounterVar.data.data[0].value, 10);\n            console.log(`Event counter: ${eventCounter}`);\n        }\n\n        let cooldownCounter = 0;\n        if (cooldownCounterVar.data.data.length > 0) {\n            cooldownCounter = parseInt(cooldownCounterVar.data.data[0].value, 10);\n            console.log(`Cooldown counter: ${cooldownCounter}`);\n        }\n\n        // Get event duration\n        const eventDurationVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['current_event_duration'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Use stored random duration if available, otherwise use defaultEventDuration\n        let eventDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        if (eventDurationVar.data.data.length > 0) {\n            eventDuration = parseInt(eventDurationVar.data.data[0].value, 10);\n            console.log(`Event duration: ${eventDuration}`);\n        }\n\n        let activeEvent = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                // If it's an empty string, treat as no active event\n                if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                    activeEvent = null;\n                }\n                console.log(`Active event: ${activeEvent ? activeEvent.name : 'None'}`);\n            } catch (e) {\n                // In case of parsing error, consider no active event\n                activeEvent = null;\n                console.log(`Error parsing active event: ${e.message}`);\n            }\n        }\n\n        // Check if the current event should end and increment counter\n        if (activeEvent) {\n            eventCounter++;\n            console.log(`Incremented event counter to: ${eventCounter}`);\n\n            if (eventCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: eventCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: eventCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n\n            if (eventCounter >= eventDuration) {\n                console.log(\"Event duration reached, ending event.\");\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: ''\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_cooldown_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    const message = `ðŸ“ˆ MARKET UPDATE ðŸ“‰\\n\\nThe \"${activeEvent.name}\" event has ended. Markets are returning to normal conditions.`;\n\n                    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                        message: message\n                    });\n                }\n\n                activeEvent = null;\n            }\n        } else {\n            cooldownCounter++;\n            console.log(`Incremented cooldown counter to: ${cooldownCounter}`);\n\n            if (cooldownCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: cooldownCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: cooldownCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n        }\n\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        const eventFrequency = (mod.userConfig && mod.userConfig.eventFrequency) || 10;\n        let shouldTriggerEvent = false;\n\n        if (!activeEvent && cooldownCounter >= eventFrequency) {\n            shouldTriggerEvent = Math.random() < 0.5;\n            if (cooldownCounter >= eventFrequency * 2) {\n                shouldTriggerEvent = true;\n            }\n            console.log(`Should trigger new event: ${shouldTriggerEvent}`);\n        }\n\n        if (shouldTriggerEvent) {\n            const events = (mod.userConfig && mod.userConfig.marketEvents) || [];\n            if (events.length > 0) {\n                const randomEvent = events[Math.floor(Math.random() * events.length)];\n                activeEvent = randomEvent;\n                console.log(`New event triggered: ${activeEvent.name}`);\n\n                const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n                const randomDuration = Math.floor(Math.random() * maxDuration) + 1;\n\n                if (eventDurationVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                        value: randomDuration.toString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'current_event_duration',\n                        value: randomDuration.toString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: JSON.stringify(activeEvent)\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'active_market_event',\n                        value: JSON.stringify(activeEvent),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventStartTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_start_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (lastEventTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'last_market_event_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    let impactText = \"\";\n                    for (const impact of activeEvent.sectorImpacts) {\n                        const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                        impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n                    }\n\n                    const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${activeEvent.name}\\n${activeEvent.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /market to see opportunities!`;\n\n                    const maxLength = 400;\n                    for (let i = 0; i < message.length; i += maxLength) {\n                        await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                            message: message.substring(i, i + maxLength)\n                        });\n                    }\n                }\n            }\n        }\n\n        // Get stocks\n        if (!marketDataVar.data.data[0] || !marketDataVar.data.data[0].value) {\n            console.log(\"Market data is empty or invalid after initial check, re-initializing.\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        let stocks;\n        try {\n            stocks = JSON.parse(marketDataVar.data.data[0].value);\n            if (!Array.isArray(stocks)) {\n                throw new Error(\"Parsed stocks data is not an array\");\n            }\n            // CRITICAL FIX: Ensure each stock has valid numerical price properties\n            stocks = stocks.map(s => {\n                const sanitizedPrice = typeof s.price === 'number' && s.price > 0 ? s.price : 1;\n                const sanitizedLastPrice = typeof s.lastPrice === 'number' && s.lastPrice > 0 ? s.lastPrice : sanitizedPrice;\n                return {\n                    ...s,\n                    price: sanitizedPrice,\n                    lastPrice: sanitizedLastPrice\n                };\n            });\n            console.log(\"Stocks loaded and sanitized successfully.\");\n            console.log(\"Initial stocks for this cycle:\");\n            stocks.forEach(s => console.log(`  ${s.id}: Price ${s.price}, LastPrice ${s.lastPrice}`));\n\n        } catch (e) {\n            console.log(`Error parsing or sanitizing stock data: ${e.message}`);\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        const significantChanges = [];\n\n        // Update each stock price\n        stocks.forEach(stock => {\n            // Always capture oldPrice at the very beginning of the iteration\n            const oldPrice = stock.price;\n            // Set lastPrice to the value before this current update cycle for accurate change tracking\n            stock.lastPrice = oldPrice;\n\n            console.log(`Processing stock: ${stock.id}, Old Price: ${oldPrice}`);\n\n            // Define the threshold for \"penny stock\" and the chance/magnitude of a breakout\n            const pennyStockThreshold = 1.9;\n            const breakoutChance = 0.6;\n\n            const targetMinPrice = 2.0;\n            const targetMaxPrice = 10.0;\n\n            let calculatedNewPrice;\n\n            // Check if it's a penny stock and qualifies for a breakout\n            if (oldPrice <= pennyStockThreshold && Math.random() < breakoutChance) {\n                console.log(`${stock.id} is a penny stock (${oldPrice}) and hit breakout chance!`);\n                calculatedNewPrice = targetMinPrice + Math.random() * (targetMaxPrice - targetMinPrice);\n                calculatedNewPrice = Math.max(calculatedNewPrice, oldPrice + 0.01); // Ensure at least a penny increase\n                console.log(`${stock.id} calculated breakout price: ${calculatedNewPrice}`);\n            } else {\n                const randomFactor = Math.random() * 2 - 1;\n                const totalChangePercent = randomFactor * stock.volatility;\n                calculatedNewPrice = oldPrice * (1 + totalChangePercent);\n                console.log(`${stock.id} calculated normal price: ${calculatedNewPrice} (Change: ${totalChangePercent * 100}%)`);\n            }\n\n            let finalPrice = calculatedNewPrice;\n            if (activeEvent) {\n                const sectorImpact = activeEvent.sectorImpacts.find(impact => impact.sectorId === stock.sector);\n                if (sectorImpact) {\n                    const eventImpactPercentage = sectorImpact.impact;\n                    const eventImpactDecimal = eventImpactPercentage / 100;\n                    const randomImpactFactor = 0.5 + Math.random();\n                    const eventImpact = eventImpactDecimal * randomImpactFactor;\n\n                    finalPrice = calculatedNewPrice * (1 + eventImpact);\n                    console.log(`${stock.id} final price after event impact: ${finalPrice} (Event impact: ${eventImpact * 100}%)`);\n                }\n            }\n\n            stock.price = finalPrice;\n\n            if (stock.price < 1) {\n                console.log(`${stock.id} price fell below 1, setting to 1.`);\n                stock.price = 1;\n            }\n\n            const actualPercentChange = ((stock.price - oldPrice) / oldPrice) * 100;\n            console.log(`${stock.id} - Final Price: ${stock.price.toFixed(2)}, Actual Change: ${actualPercentChange.toFixed(2)}%`);\n\n            const changeThreshold = ((mod.userConfig && mod.userConfig.priceAlertThreshold) || 10) / 100;\n            if (Math.abs(actualPercentChange) > changeThreshold * 100) {\n                significantChanges.push({\n                    ...stock,\n                    changePercent: actualPercentChange\n                });\n            }\n        });\n\n        console.log(\"All stocks processed, saving updated prices...\");\n        await takaro.variable.variableControllerUpdate(marketDataVar.data.data[0].id, {\n            value: JSON.stringify(stocks)\n        });\n        console.log(\"Updated prices saved.\");\n\n        if (significantChanges.length > 0) {\n            console.log(\"Significant changes detected, sending alert.\");\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                significantChanges.sort((a, b) => Math.abs(b.changePercent) - Math.abs(a.changePercent));\n                const topChanges = significantChanges.slice(0, Math.min(3, significantChanges.length));\n\n                let message = \"ðŸ“Š STOCK MARKET ALERT ðŸ“Š\\n\";\n                topChanges.forEach(stock => {\n                    const changeDir = stock.changePercent > 0 ? \"up\" : \"down\";\n                    const displayPrice = stock.price.toFixed(2);\n                    const changePercent = Math.abs(Math.round(stock.changePercent));\n\n                    message += `${stock.id} (${stock.sector}): ${changeDir} ${changePercent}% to $${displayPrice}!\\n`;\n                });\n\n                if (activeEvent) {\n                    message += `\\nCurrent market event: ${activeEvent.name}`;\n                }\n\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            } else {\n                console.log(\"No online players to send alert to.\");\n            }\n        } else {\n            console.log(\"No significant changes to alert players about.\");\n        }\n    } catch (error) {\n        console.log(`FATAL Error in updateStockPrices: ${error.message}`);\n        // Optionally, send an admin message if a fatal error occurs\n        // await takaro.gameserver.gameServerControllerSendMessage(data.gameServerId, {\n        //     message: `ðŸš¨ Market Error: An error occurred during stock update: ${error.message}`\n        // });\n    }\n}\n\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        console.log(\"Initializing market if needed...\");\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in module configuration for initialization.\");\n            return;\n        }\n\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_data'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['last_market_event_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_start_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['active_market_event'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_initialized'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_execution_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_cooldown_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['current_event_duration'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } })\n            ]);\n\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n        console.log(\"Mapped initial stocks from config.\");\n\n        const createPromises = [];\n\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_data', value: JSON.stringify(stocks), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'last_market_event_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_start_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'active_market_event', value: '', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_execution_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (cooldownCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_cooldown_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventDurationVar.data.data.length === 0) {\n            const defaultDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'current_event_duration', value: defaultDuration.toString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_initialized', value: 'true', gameServerId, moduleId: mod.moduleId }));\n        }\n\n        if (createPromises.length > 0) {\n            console.log(`Creating ${createPromises.length} initial market variables.`);\n            await Promise.allSettled(createPromises);\n        } else {\n            console.log(\"All market variables already exist, no new initialization needed.\");\n        }\n\n        if (marketDataVar.data.data.length === 0) { // Only announce if we actually created the stock_market_data variable\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /market to see available stocks and /buy to start investing.\";\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, { message });\n            }\n        }\n        console.log(\"Market initialization process complete.\");\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "updatestockprices",
                    "description": null,
                    "temporalValue": "0 */1 * * *"
                }
            ],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Allows the player to view market prices and their portfolio",
                    "permission": "STOCK_MARKET_USE",
                    "friendlyName": "Use Stock Market"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows the player to buy and sell stocks",
                    "permission": "STOCK_MARKET_TRADE",
                    "friendlyName": "Trade Stocks"
                },
                {
                    "canHaveCount": false,
                    "description": "VIP status that reduces transaction fees",
                    "permission": "STOCK_MARKET_BROKER",
                    "friendlyName": "Stock Broker"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows admins to manually trigger market events",
                    "permission": "STOCK_MARKET_TRIGGER_EVENT",
                    "friendlyName": "Trigger Market Events"
                }
            ]
        },
        {
            "tag": "0.1.7",
            "description": "**Stock Market: A Dynamic Virtual Trading System**\n\nCreate an immersive economic experience with this comprehensive stock market module that lets players invest, trade, and react to market events.\n\n**Market Features:**\n\n![Market Summary](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stocks.png)\n\n* **Multiple Economic Sectors:** Configure various industry sectors (Resource Extraction, Manufacturing, Defense, etc.) each with their own market dynamics.\n* **Realistic Stock Behavior:** Stocks have configurable volatility, sector-based pricing, and react differently to market events.\n* **Dynamic Market Events:** Random or admin-triggered events like \"Horde Night Approaching\" or \"Societal Collapse Setback\" impact different sectors in realistic ways.\n\n![Market Events](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_events.png)\n\n**Trading System:**\n\n* **Buy & Sell Shares:** Players can purchase stocks and sell them later for profit or loss.\n* **Transaction Fees:** Configurable fee percentage on all trades creates a realistic market economy.\n* **VIP Benefits:** Special permissions for designated \"Stock Brokers\" who receive fee discounts.\n\n![Buy Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_buy.png)\n\nPlayers can track price changes and sell at the right moment to maximize profits or minimize losses.\n\n![Sell Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sell.png)\n\n**Player Portfolio:**\n\n* **Portfolio Tracking:** Players can view their holdings, average purchase prices, and current profit/loss.\n* **Transaction History:** System tracks all buy/sell transactions for each player.\n* **Summary Statistics:** See overall portfolio performance and value across all holdings.\n\n![Portfolio View](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockportfolio.png)\n\n**Market Information:**\n\n* **Detailed Stock Info:** Players can research specific stocks, including risk levels and sector trends.\n* **Industry Filters:** View stocks by specific sectors to better understand market segments.\n* **Market Alerts:** Server-wide notifications for significant price changes keep players engaged.\n\n![Market Alerts](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockpricechange.png)\n\n**Configuration Options:**\n\n* **Sectors & Stocks:** Define your own market sectors and individual stocks with customizable starting prices and volatility.\n* **Market Events:** Create unique events with specific sector impacts to drive market dynamics.\n* **Transaction Settings:** Configure fee percentages, VIP discounts, and alert thresholds.\n* **Event Frequency:** Control how often random market events occur and how long they last.\n\n![Configuration](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_config.png)\n![Sectors](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sectors.png)\n\n**Commands:**\n\n* `/markets [industry]` - View all stocks or filter by industry\n* `/stockinfo [ticker]` - Get detailed information about a specific stock\n* `/buystock <ticker> <amount>` - Purchase shares of a stock\n* `/sellstock <ticker> <amount>` - Sell shares from your portfolio\n* `/stockportfolio` - View your current holdings and performance\n* `/triggerevent [event]` - Admin command to trigger specific market events\n\nWho says the apocalypse can't have a thriving economy? Now players can stress about both zombie hordes AND their Duke's Casino Tokens dropping 40% after a market event! As one trader put it: \"I used to check my 401K daily, and now I check my AMMO stock before every Blood Moon. Some habits die harder than zombies.\"",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sectors\":{\"type\":\"array\",\"title\":\"Wasteland Economic Sectors\",\"description\":\"Define economic sectors relevant to survival in Navezgane\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Sector ID (e.g., RESOURCES)\"},\"name\":{\"type\":\"string\",\"description\":\"Sector name (e.g., Resource Extraction)\"}}},\"default\":[{\"id\":\"RESOURCES\",\"name\":\"Resource Extraction\"},{\"id\":\"MANUFACTURING\",\"name\":\"Manufacturing & Crafting\"},{\"id\":\"DEFENSE\",\"name\":\"Defense & Fortifications\"},{\"id\":\"SURVIVAL\",\"name\":\"Survival Goods\"},{\"id\":\"TRADE\",\"name\":\"Trade & Currency\"}]},\"stocks\":{\"type\":\"array\",\"title\":\"Wasteland Stocks\",\"description\":\"List of stocks representing Navezgane entities and resources\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Stock ticker symbol (e.g., NMC)\"},\"name\":{\"type\":\"string\",\"description\":\"Entity/Resource name\"},\"sector\":{\"type\":\"string\",\"description\":\"Sector ID this stock belongs to\"},\"initialPrice\":{\"type\":\"number\",\"description\":\"Starting price in Dukes\",\"minimum\":1},\"volatility\":{\"type\":\"number\",\"description\":\"Base volatility percentage (5 = 5%)\",\"minimum\":1,\"maximum\":35}}},\"default\":[{\"id\":\"NMC\",\"name\":\"Navezgane Mining Co.\",\"sector\":\"RESOURCES\",\"initialPrice\":50,\"volatility\":15},{\"id\":\"WOOD\",\"name\":\"Wasteland Lumberjacks\",\"sector\":\"RESOURCES\",\"initialPrice\":20,\"volatility\":8},{\"id\":\"SHALE\",\"name\":\"Oil Shale Extractors\",\"sector\":\"RESOURCES\",\"initialPrice\":40,\"volatility\":18},{\"id\":\"FORGE\",\"name\":\"Forge Ahead Metals\",\"sector\":\"MANUFACTURING\",\"initialPrice\":75,\"volatility\":12},{\"id\":\"TOOLS\",\"name\":\"Working Stiff Tools\",\"sector\":\"MANUFACTURING\",\"initialPrice\":60,\"volatility\":10},{\"id\":\"MECH\",\"name\":\"JunkTech Robotics\",\"sector\":\"MANUFACTURING\",\"initialPrice\":110,\"volatility\":20},{\"id\":\"BUILD\",\"name\":\"Barricade Builders\",\"sector\":\"DEFENSE\",\"initialPrice\":45,\"volatility\":9},{\"id\":\"AMMO\",\"name\":\"AmmoNation Surplus\",\"sector\":\"DEFENSE\",\"initialPrice\":90,\"volatility\":18},{\"id\":\"SHAM\",\"name\":\"Shamway Foods\",\"sector\":\"SURVIVAL\",\"initialPrice\":30,\"volatility\":5},{\"id\":\"MEDS\",\"name\":\"Pop-N-Pills Medical\",\"sector\":\"SURVIVAL\",\"initialPrice\":100,\"volatility\":18},{\"id\":\"TRADE\",\"name\":\"Trader Guild Network\",\"sector\":\"TRADE\",\"initialPrice\":150,\"volatility\":10},{\"id\":\"DUKES\",\"name\":\"Duke's Casino Tokens\",\"sector\":\"TRADE\",\"initialPrice\":1,\"volatility\":3}]},\"marketEvents\":{\"type\":\"array\",\"title\":\"Wasteland Events\",\"description\":\"Events impacting the Navezgane economy\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Unique event ID\"},\"name\":{\"type\":\"string\",\"description\":\"Name of the event\"},\"description\":{\"type\":\"string\",\"description\":\"Description of the event's market effect\"},\"sectorImpacts\":{\"type\":\"array\",\"description\":\"How each sector is affected\",\"items\":{\"type\":\"object\",\"properties\":{\"sectorId\":{\"type\":\"string\",\"description\":\"Sector ID\"},\"impact\":{\"type\":\"number\",\"description\":\"Percentage impact (-30 = -30%)\",\"minimum\":-75,\"maximum\":75}}}}}},\"default\":[{\"id\":\"HORDE_INCOMING\",\"name\":\"Horde Night Approaching\",\"description\":\"Increased Zed activity signals the Blood Moon. Survivors prepare defenses.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-5},{\"sectorId\":\"MANUFACTURING\",\"impact\":15},{\"sectorId\":\"DEFENSE\",\"impact\":25},{\"sectorId\":\"SURVIVAL\",\"impact\":10},{\"sectorId\":\"TRADE\",\"impact\":-10}]},{\"id\":\"RESOURCE_SHOCK\",\"name\":\"Resource Shock\",\"description\":\"Key resource veins are depleted, making raw materials expensive and driving up the price of finished goods.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-30},{\"sectorId\":\"MANUFACTURING\",\"impact\":15},{\"sectorId\":\"DEFENSE\",\"impact\":10},{\"sectorId\":\"SURVIVAL\",\"impact\":5},{\"sectorId\":\"TRADE\",\"impact\":5}]},{\"id\":\"ZED_OUTBREAK\",\"name\":\"Severe Zed Outbreak\",\"description\":\"An unusual concentration of Zed activity makes scavenging dangerous. Demand for medical supplies and defenses skyrockets.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-20},{\"sectorId\":\"MANUFACTURING\",\"impact\":-5},{\"sectorId\":\"DEFENSE\",\"impact\":25},{\"sectorId\":\"SURVIVAL\",\"impact\":25},{\"sectorId\":\"TRADE\",\"impact\":-15}]},{\"id\":\"TECH_BREAKTHROUGH\",\"name\":\"Technological Breakthrough\",\"description\":\"A discovery of pre-collapse schematics has revolutionized crafting and manufacturing.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":10},{\"sectorId\":\"MANUFACTURING\",\"impact\":30},{\"sectorId\":\"DEFENSE\",\"impact\":15},{\"sectorId\":\"SURVIVAL\",\"impact\":5},{\"sectorId\":\"TRADE\",\"impact\":15}]},{\"id\":\"TRADE_ROUTE_SECURED\",\"name\":\"Trade Route Secured\",\"description\":\"Traders have established a safer passage, improving the flow of all goods and services.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":20},{\"sectorId\":\"MANUFACTURING\",\"impact\":10},{\"sectorId\":\"DEFENSE\",\"impact\":5},{\"sectorId\":\"SURVIVAL\",\"impact\":15},{\"sectorId\":\"TRADE\",\"impact\":30}]},{\"id\":\"GENERAL_COLLAPSE\",\"name\":\"Societal Collapse Setback\",\"description\":\"A major setback reminds everyone how fragile survival is. Fear grips the market.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-15},{\"sectorId\":\"MANUFACTURING\",\"impact\":-20},{\"sectorId\":\"DEFENSE\",\"impact\":-15},{\"sectorId\":\"SURVIVAL\",\"impact\":0},{\"sectorId\":\"TRADE\",\"impact\":-25}]}]},\"eventFrequency\":{\"title\":\"Event Frequency\",\"type\":\"number\",\"description\":\"Average number of update cycles between market events (0 to disable). Depends on mod's update frequency (e.g., per in-game hour?).\",\"default\":8,\"minimum\":1},\"defaultEventDuration\":{\"title\":\"Default Event Duration\",\"type\":\"number\",\"description\":\"Default number of update cycles an event lasts.\",\"default\":3,\"minimum\":1,\"maximum\":96},\"transactionFee\":{\"title\":\"Transaction Fee (Dukes Tax)\",\"type\":\"number\",\"description\":\"Percentage fee charged on all buy/sell transactions (5 = 5%)\",\"default\":3,\"minimum\":0,\"maximum\":25},\"vipDiscount\":{\"title\":\"Trader's Favor Discount\",\"type\":\"number\",\"description\":\"Percentage discount on transaction fees for players with 'STOCK_MARKET_BROKER' permission (50 = 50%)\",\"default\":50,\"minimum\":0,\"maximum\":100},\"priceAlertThreshold\":{\"title\":\"Price Alert Threshold\",\"type\":\"number\",\"description\":\"Percentage change that triggers a market alert (15 = 15%)\",\"default\":15,\"minimum\":5,\"maximum\":50},\"marketNewsChannelId\":{\"title\":\"Discord Channel ID (for Market News)\",\"type\":\"string\",\"description\":\"The ID of the Discord channel where market news messages should be posted. Leave empty to disable.\",\"default\":\"\"}},\"additionalProperties\":false}",
            "uiSchema": "{\"sectors\":{\"items\":{\"ui:order\":[\"id\",\"name\"]}},\"stocks\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"sector\",\"initialPrice\",\"volatility\"]}},\"marketEvents\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"description\",\"sectorImpacts\"],\"sectorImpacts\":{\"items\":{\"ui:order\":[\"sectorId\",\"impact\"]}}}},\"transactionFee\":{\"ui:widget\":\"range\"},\"vipDiscount\":{\"ui:widget\":\"range\"},\"eventFrequency\":{\"ui:help\":\"Set to 0 to disable random events\"},\"priceAlertThreshold\":{\"ui:widget\":\"range\"}}",
            "commands": [
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === args.stock.toUpperCase());\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${args.stock} not found. Use /market to see available stocks.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate costs using Math.round to ensure we work with integers\n        const subtotal = Math.round(stock.price) * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const totalCost = subtotal + fee;\n\n        // Check if player has enough currency\n        const playerData = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, player.id);\n        const currentBalance = playerData.data.data.currency;\n\n        if (currentBalance < totalCost) {\n            throw new TakaroUserError(`You don't have enough currency. Cost: $${subtotal} + $${fee} fee = $${totalCost}. Your balance: $${currentBalance}`);\n        }\n\n        // Deduct the currency - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerDeductCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: totalCost\n            }\n        );\n\n        // Get player's portfolio or create new one\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        let portfolio;\n        if (portfolioVar.data.data.length === 0) {\n            portfolio = {};\n        } else {\n            portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        }\n\n        // Update portfolio using rounded values for consistency\n        const stockPrice = Math.round(stock.price);\n        if (!portfolio[stock.id]) {\n            portfolio[stock.id] = {\n                shares: amount,\n                averagePrice: stockPrice\n            };\n        } else {\n            const totalShares = portfolio[stock.id].shares + amount;\n            const totalValue = (portfolio[stock.id].shares * portfolio[stock.id].averagePrice) + (amount * stockPrice);\n            portfolio[stock.id].shares = totalShares;\n            portfolio[stock.id].averagePrice = Math.round(totalValue / totalShares);\n        }\n\n        // Save updated portfolio\n        if (portfolioVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_portfolio',\n                value: JSON.stringify(portfolio),\n                gameServerId,\n                moduleId: mod.moduleId,\n                playerId: player.id\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n                value: JSON.stringify(portfolio)\n            });\n        }\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'BUY',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: totalCost,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully bought ${amount} shares of ${stock.id} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Total cost: $${totalCost}\\n`;\n        message += `Current portfolio: ${portfolio[stock.id].shares} shares of ${stock.id}`;\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in buystock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your purchase. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "buystock",
                    "description": null,
                    "trigger": "buystock",
                    "helpText": "Buy shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol ",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to buy",
                            "position": 1
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // If a specific stock ticker is provided, show detailed info for that stock\n    const specificTicker = args.ticker ? args.ticker.toUpperCase() : null;\n\n    if (specificTicker && specificTicker !== \"ALL\") {\n        const stock = stocks.find(s => s.id.toUpperCase() === specificTicker);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${specificTicker} not found. Use /stockinfo without parameters to see all available stocks.`);\n        }\n\n        // Get active event to see if this stock's sector is affected\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let activeEvent = null;\n        let sectorImpact = null;\n\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEvent && activeEvent.sectorImpacts) {\n                    sectorImpact = activeEvent.sectorImpacts.find(impact =>\n                        impact.sectorId === stock.sector\n                    );\n                }\n            } catch (e) {\n                // Ignore parsing errors\n            }\n        }\n\n        // Calculate price change indicators\n        let changeText = '';\n        if (stock.lastPrice) {\n            const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n            const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n            changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n        }\n\n        // Add risk assessment based on volatility without showing the raw value\n        let riskLevel;\n        if (stock.volatility <= 0.05) riskLevel = \"Very Low\";\n        else if (stock.volatility <= 0.10) riskLevel = \"Low\";\n        else if (stock.volatility <= 0.15) riskLevel = \"Moderate\";\n        else if (stock.volatility <= 0.20) riskLevel = \"High\";\n        else riskLevel = \"Very High\";\n\n        // Build detailed stock info message\n        let message = `=== ${stock.id}: ${stock.name} ===\\n\\n`;\n        message += `Sector: ${stock.sector}\\n`;\n        message += `Current Price: $${Math.round(stock.price)}${changeText}\\n`;\n        message += `Risk Level: ${riskLevel}\\n`;\n\n        // Add sector trend info if available from event\n        if (activeEvent && sectorImpact) {\n            const direction = sectorImpact.impact >= 0 ? \"Positive\" : \"Negative\";\n            const strength = Math.abs(sectorImpact.impact);\n            let trend;\n\n            if (strength < 10) trend = \"Slight\";\n            else if (strength < 25) trend = \"Moderate\";\n            else trend = \"Strong\";\n\n            message += `\\nCurrent Trend: ${trend} ${direction} (${activeEvent.name})\\n`;\n            message += `Event: ${activeEvent.description}\\n`;\n        }\n\n        // Add trading guidance based on sector and risk, without mentioning volatility\n        message += `\\nTrading Notes:\\n`;\n\n        if (activeEvent && sectorImpact) {\n            if (sectorImpact.impact > 0) {\n                message += `- Currently bullish due to the ${activeEvent.name} event\\n`;\n            } else {\n                message += `- Currently bearish due to the ${activeEvent.name} event\\n`;\n            }\n        }\n\n        if (riskLevel === \"High\" || riskLevel === \"Very High\") {\n            message += `- Expect significant price fluctuations with this stock\\n`;\n        } else if (riskLevel === \"Low\" || riskLevel === \"Very Low\") {\n            message += `- Typically has stable price movement\\n`;\n        }\n\n        message += `\\nUse /buystock ${stock.id} [amount] to purchase shares`;\n\n        await player.pm(message);\n\n    } else {\n        // No specific ticker provided or ALL specified, show summary of all stocks\n        await player.pm(\"=== STOCK MARKET LISTINGS ===\\n\");\n\n        // Group stocks by sector\n        const stocksBySector = {};\n        stocks.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        // Display stocks by sector\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            let sectorMessage = `\\n--- ${sector} SECTOR ---\\n`;\n\n            sectorStocks.forEach(stock => {\n                // Add price change indicators\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                    changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                // Add risk level based on volatility\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                sectorMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n\n            await player.pm(sectorMessage);\n        }\n\n        // Add legend for risk indicators\n        const legend = \"\\n=== LEGEND ===\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\" +\n            \"Use /stockinfo [ticker] for detailed information about a specific stock\";\n\n        await player.pm(legend);\n    }\n}\n\nawait main();",
                    "name": "stockinfo",
                    "description": null,
                    "trigger": "stockinfo",
                    "helpText": "Shows all available stocks in the market. Use with a ticker symbol (e.g., /stockinfo ticker) to see detailed information about a specific stock.",
                    "arguments": [
                        {
                            "name": "ticker",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "stock ticker or ALL to get detailed information about a specific stock",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // Get player's portfolio\n    const portfolioVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_portfolio'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId],\n            playerId: [player.id]\n        }\n    });\n\n    let portfolio = {};\n    if (portfolioVar.data.data.length > 0) {\n        portfolio = JSON.parse(portfolioVar.data.data[0].value);\n    }\n\n    // Send header\n    await player.pm(\"=== YOUR STOCK PORTFOLIO ===\");\n\n    let hasStocks = false;\n    let totalValue = 0;\n    let totalInvestment = 0;\n\n    // If no stocks, send a simple message\n    if (Object.keys(portfolio).length === 0) {\n        await player.pm(\"You don't own any stocks yet.\\n\" +\n            \"Use /markets to see available stocks and prices.\\n\" +\n            \"Use /buy <stock> <amount> to purchase stocks.\");\n        return;\n    }\n\n    // Helper function to format numbers with commas\n    const formatNumber = (num) => {\n        return Math.round(num).toLocaleString();\n    };\n\n    // Send each stock as a separate message to avoid length issues\n    for (const [stockId, data] of Object.entries(portfolio)) {\n        hasStocks = true;\n        const stock = stocks.find(s => s.id === stockId);\n        if (!stock) continue; // Stock might have been removed from config\n\n        const currentValue = stock.price * data.shares;\n        const investmentValue = data.averagePrice * data.shares;\n        totalValue += currentValue;\n        totalInvestment += investmentValue;\n        const profit = currentValue - investmentValue;\n        const profitPercent = ((profit / investmentValue) * 100).toFixed(1);\n\n        let stockMessage = `--- ${stockId} (${stock.sector}) ---\\n`;\n        stockMessage += `Shares: ${data.shares}\\n`;\n        stockMessage += `Avg buy: $${formatNumber(data.averagePrice)}\\n`;\n        stockMessage += `Current price: $${formatNumber(stock.price)}\\n`;\n        stockMessage += `Total value: $${formatNumber(currentValue)}\\n`;\n\n        if (profit >= 0) {\n            stockMessage += `Profit: +$${formatNumber(profit)} (+${profitPercent}%)\\n`;\n        } else {\n            stockMessage += `Loss: -$${formatNumber(Math.abs(profit))} (${profitPercent}%)\\n`;\n        }\n\n        await player.pm(stockMessage);\n    }\n\n    if (hasStocks) {\n        const totalProfit = totalValue - totalInvestment;\n        const totalProfitPercent = ((totalProfit / totalInvestment) * 100).toFixed(1);\n\n        let summaryMessage = \"=== PORTFOLIO SUMMARY ===\\n\";\n        summaryMessage += `Total investment: $${formatNumber(totalInvestment)}\\n`;\n        summaryMessage += `Current value: $${formatNumber(totalValue)}\\n`;\n\n        if (totalProfit >= 0) {\n            summaryMessage += `Overall profit: +$${formatNumber(totalProfit)} (+${totalProfitPercent}%)\\n`;\n        } else {\n            summaryMessage += `Overall loss: -$${formatNumber(Math.abs(totalProfit))} (${totalProfitPercent}%)\\n`;\n        }\n\n        // Get transaction history count\n        try {\n            const historyVar = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: ['stock_transaction_history'],\n                    gameServerId: [gameServerId],\n                    moduleId: [mod.moduleId],\n                    playerId: [player.id]\n                }\n            });\n\n            if (historyVar.data.data.length > 0) {\n                const history = JSON.parse(historyVar.data.data[0].value);\n                const buyCount = history.filter(t => t.type === 'BUY').length;\n                const sellCount = history.filter(t => t.type === 'SELL').length;\n\n                summaryMessage += `\\nTransactions: ${history.length} (${buyCount} buys, ${sellCount} sells)\\n`;\n            }\n        } catch (error) {\n            // Just ignore history errors\n        }\n\n        await player.pm(summaryMessage);\n    }\n}\n\nawait main();",
                    "name": "stockportfolio",
                    "description": null,
                    "trigger": "stockportfolio",
                    "helpText": "No help text available",
                    "arguments": []
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get player's portfolio\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        if (portfolioVar.data.data.length === 0) {\n            throw new TakaroUserError(\"You don't own any stocks to sell.\");\n        }\n\n        const portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        const stockId = args.stock.toUpperCase();\n\n        if (!portfolio[stockId] || portfolio[stockId].shares < amount) {\n            throw new TakaroUserError(`You don't own ${amount} shares of ${stockId}.`);\n        }\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === stockId);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${stockId} not found in current market data. Please contact an admin.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate sale proceeds using Math.round to ensure we work with integers\n        const stockPrice = Math.round(stock.price);\n        const subtotal = stockPrice * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const netProceeds = subtotal - fee;\n\n        // Add money to player - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerAddCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: netProceeds\n            }\n        );\n\n        // Calculate profit/loss\n        const profitPerShare = stockPrice - portfolio[stockId].averagePrice;\n        const totalProfit = Math.round(profitPerShare * amount);\n        const profitText = totalProfit >= 0\n            ? `profit of $${totalProfit}`\n            : `loss of $${Math.abs(totalProfit)}`;\n\n        // Update portfolio\n        portfolio[stockId].shares -= amount;\n        if (portfolio[stockId].shares === 0) {\n            delete portfolio[stockId];\n        }\n\n        // Save updated portfolio\n        await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n            value: JSON.stringify(portfolio)\n        });\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'SELL',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: netProceeds,\n            profit: totalProfit,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully sold ${amount} shares of ${stockId} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Net proceeds: $${netProceeds} (${profitText})`;\n\n        // Add remaining shares info if player still has some\n        if (portfolio[stockId]) {\n            message += `\\nRemaining shares: ${portfolio[stockId].shares}`;\n        } else {\n            message += `\\nYou've sold all your ${stockId} shares.`;\n        }\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in sellstock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your sale. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "sellstock",
                    "description": null,
                    "trigger": "sellstock",
                    "helpText": "Sell shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to sell",
                            "position": 1
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Handle the industry argument - use \"ALL\" as a special value to show all industries\n    const industryFilter = args.Industry ? args.Industry.toUpperCase() : \"ALL\";\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    // If market data doesn't exist, try to initialize it\n    if (marketDataVar.data.data.length === 0) {\n        const initialized = await initializeMarketIfNeeded(gameServerId, mod);\n        if (!initialized) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        // Get the freshly initialized market data\n        const refreshedMarketData = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (refreshedMarketData.data.data.length === 0) {\n            throw new TakaroUserError(\"There was an issue initializing the stock market. Please try again later.\");\n        }\n\n        // Continue with the refreshed data\n        await displayMarketSummary(player, gameServerId, mod, refreshedMarketData.data.data[0], industryFilter);\n    } else {\n        // Market data exists, display it\n        await displayMarketSummary(player, gameServerId, mod, marketDataVar.data.data[0], industryFilter);\n    }\n}\n\n// Display the market summary to the player\nasync function displayMarketSummary(player, gameServerId, mod, marketDataVariable, industryFilter) {\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Handle empty string or empty object\n            if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (e) {\n            // In case of parsing error\n            activeEvent = null;\n        }\n    }\n\n    const stocks = JSON.parse(marketDataVariable.value);\n\n    // Get all available industries for reference\n    const availableIndustries = [...new Set(stocks.map(stock => stock.sector))];\n\n    // If industry filter is provided and not \"ALL\", check if it's valid\n    if (industryFilter !== \"ALL\") {\n        // Check if the industry exists\n        const industryExists = availableIndustries.includes(industryFilter);\n\n        if (!industryExists) {\n            throw new TakaroUserError(`Industry \"${industryFilter}\" not found. Available industries: ${availableIndustries.join(', ')}\\nUse \"ALL\" to view all industries.`);\n        }\n    }\n\n    // Send header message\n    let headerMessage = \"=== STOCK MARKET SUMMARY ===\\n\";\n\n    // If filtering by industry, mention it in the header\n    if (industryFilter !== \"ALL\") {\n        headerMessage = `=== ${industryFilter} INDUSTRY ===\\n`;\n    }\n\n    // If there's an active event, include it in the header\n    if (activeEvent) {\n        headerMessage += `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n`;\n        headerMessage += `${activeEvent.description}\\n\\n`;\n\n        // If filtering by industry, only show relevant impacts\n        if (industryFilter !== \"ALL\") {\n            const relevantImpact = activeEvent.sectorImpacts.find(\n                impact => impact.sectorId === industryFilter\n            );\n\n            if (relevantImpact) {\n                const direction = relevantImpact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `Industry Impact: ${direction} ${Math.abs(relevantImpact.impact)}%\\n`;\n            } else {\n                headerMessage += \"This industry is not directly affected by the current event.\\n\";\n            }\n        } else {\n            // Show all industry impacts\n            headerMessage += \"Industry Impacts:\\n\";\n            for (const impact of activeEvent.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%\\n`;\n            }\n        }\n    }\n\n    // Send header message first\n    await player.pm(headerMessage);\n\n    // Group stocks by industry\n    const stocksByIndustry = {};\n    stocks.forEach(stock => {\n        if (!stocksByIndustry[stock.sector]) {\n            stocksByIndustry[stock.sector] = [];\n        }\n        stocksByIndustry[stock.sector].push(stock);\n    });\n\n    // If industry filter is not \"ALL\", only show that industry\n    if (industryFilter !== \"ALL\") {\n        const filteredStocks = stocksByIndustry[industryFilter] || [];\n\n        if (filteredStocks.length > 0) {\n            let stockMessage = \"\";\n\n            filteredStocks.forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                stockMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(stockMessage);\n        } else {\n            await player.pm(`No stocks found in the ${industryFilter} industry.`);\n        }\n    } else {\n        // Send each industry as a separate message\n        for (const industryId in stocksByIndustry) {\n            let industryMessage = `=== ${industryId} INDUSTRY ===\\n`;\n\n            stocksByIndustry[industryId].forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                industryMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(industryMessage);\n        }\n    }\n\n    // Add a help message for industry filtering if showing all industries\n    if (industryFilter === \"ALL\") {\n        const allIndustries = Object.keys(stocksByIndustry).join(', ');\n        await player.pm(`\\nTip: Use '/markets [industry]' to view only stocks in a specific industry. Available industries: ${allIndustries}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return false;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            const results = await Promise.allSettled(createPromises);\n            // Check if the critical stock_market_data was created successfully\n            const stockDataPromise = results[0];\n            if (stockDataPromise && stockDataPromise.status === 'rejected') {\n                console.log(`Failed to create stock_market_data: ${stockDataPromise.reason}`);\n                return false;\n            }\n        }\n\n        return true;\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n        return false;\n    }\n}\n\nawait main();",
                    "name": "markets",
                    "description": null,
                    "trigger": "markets",
                    "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. \n",
                    "arguments": [
                        {
                            "name": "Industry",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. ",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRIGGER_EVENT')) {\n        throw new TakaroUserError(\"You don't have permission to trigger market events.\");\n    }\n\n    try {\n        // Get current stock data to check market initialization\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Initialize market if needed\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            await player.pm(\"Market was not initialized. Initializing now...\");\n            return;\n        }\n\n        // Get events from module config\n        const marketEvents = mod.userConfig.marketEvents || [];\n\n        if (marketEvents.length === 0) {\n            throw new TakaroUserError(\"No market events configured in this module.\");\n        }\n\n        // Handle case when no event is specified or \"ALL\" is provided\n        if (!args.EventName || args.EventName.toUpperCase() === \"ALL\") {\n            await player.pm(\"=== AVAILABLE MARKET EVENTS ===\\n\");\n\n            // Group events by category or type if possible\n            const eventCategories = {};\n\n            // Create a simple categorization based on positive/negative impact\n            marketEvents.forEach(event => {\n                let category = \"Mixed\";\n                // Calculate net impact across all sectors\n                const netImpact = event.sectorImpacts.reduce((sum, impact) => sum + impact.impact, 0);\n\n                if (netImpact > 0) category = \"Positive\";\n                else if (netImpact < 0) category = \"Negative\";\n\n                if (!eventCategories[category]) {\n                    eventCategories[category] = [];\n                }\n                eventCategories[category].push(event);\n            });\n\n            // Display events by category\n            for (const [category, events] of Object.entries(eventCategories)) {\n                if (events.length > 0) {\n                    await player.pm(`\\n--- ${category.toUpperCase()} EVENTS ---`);\n\n                    let message = \"\";\n                    events.forEach(event => {\n                        // Format primary sectors affected\n                        const primarySectors = event.sectorImpacts\n                            .filter(impact => Math.abs(impact.impact) >= 15)\n                            .map(impact => {\n                                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                                return `${impact.sectorId} ${direction}${Math.abs(impact.impact)}%`;\n                            })\n                            .join(\", \");\n\n                        message += `${event.id}: ${event.name}\\n`;\n                        message += `   ${event.description}\\n`;\n                        if (primarySectors) {\n                            message += `   Major impacts: ${primarySectors}\\n`;\n                        }\n                        message += \"\\n\";\n                    });\n\n                    await player.pm(message);\n                }\n            }\n\n            await player.pm(\"=== HOW TO USE ===\\nUse `/triggerevent <EventName>` to trigger a specific event (e.g., `/triggerevent TECH_BOOM`)\");\n            return;\n        }\n\n        // Find the requested event\n        const eventId = args.EventName.toUpperCase();\n        const event = marketEvents.find(e => e.id === eventId);\n\n        if (!event) {\n            throw new TakaroUserError(`Event \"${eventId}\" not found. Use /triggerevent without parameters to see all available events.`);\n        }\n\n        // Get necessary variables for managing the event\n        const [activeEventVar, eventStartTimeVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_execution_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_cooldown_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['current_event_duration'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Check if there's an active event we need to cancel\n        let activeEventObj = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEventObj = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEventObj && Object.keys(activeEventObj).length > 0) {\n                    await player.pm(`Cancelling active event \"${activeEventObj.name}\" to trigger new event.`);\n                }\n            } catch (e) {\n                // Invalid event data, will be overwritten\n            }\n        }\n\n        // Generate a random duration for the event\n        const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n        // Update or create all event-related variables\n        const updatePromises = [];\n\n        // Save or update the random duration\n        if (eventDurationVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                    value: randomDuration.toString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'current_event_duration',\n                    value: randomDuration.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the event counter to 0\n        if (eventCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the cooldown counter\n        if (cooldownCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update active event\n        if (activeEventVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                    value: JSON.stringify(event)\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: JSON.stringify(event),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update event start time\n        if (eventStartTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update last event time\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (lastEventTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all updates to complete\n        await Promise.all(updatePromises);\n\n        // Check if there are online players to announce the event\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            // Format sector impacts for announcement\n            let impactText = \"\";\n            for (const impact of event.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n            }\n\n            const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${event.name}\\n${event.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /markets to see opportunities!`;\n\n            // Split the message if it's too long\n            const maxLength = 400; // Safe limit for most games\n            for (let i = 0; i < message.length; i += maxLength) {\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message: message.substring(i, i + maxLength)\n                });\n            }\n        }\n\n        await player.pm(`Successfully triggered the \"${event.name}\" market event for ${randomDuration} cycles!`);\n    } catch (error) {\n        // If something goes wrong, log it and let the player know\n        console.log(`Error in triggerEvent: ${error.message}`);\n        throw new TakaroUserError(`Error triggering event: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Store the stocks data\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_data',\n            value: JSON.stringify(stocks),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize last event time to now\n        await takaro.variable.variableControllerCreate({\n            key: 'last_market_event_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize event start time variable\n        await takaro.variable.variableControllerCreate({\n            key: 'event_start_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize active event (empty string means no active event)\n        await takaro.variable.variableControllerCreate({\n            key: 'active_market_event',\n            value: '',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Mark market as initialized\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_initialized',\n            value: 'true',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Announce market initialization to online players\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /markets to see available stocks and /buystock to start investing.\";\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message\n            });\n        }\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "triggerevent",
                    "description": null,
                    "trigger": "triggerevent",
                    "helpText": "Shows all available market events when run without parameters. Use with an event name (e.g., /triggerevent TECH_BOOM) to trigger a specific market event.",
                    "arguments": [
                        {
                            "name": "EventName",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "Event name to trigger a specific market event",
                            "position": 0
                        }
                    ]
                }
            ],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n\n    const discordChannelId = mod.userConfig.marketNewsChannelId;\n\n    if (!discordChannelId) {\n        takaro.log.info('Market news Discord channel ID (marketNewsChannelId) not configured in module settings. Skipping Discord messages.');\n    }\n\n    const currentPlayers = (await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    })).data.meta;\n\n    if (currentPlayers.total === 0) {\n        takaro.log.info('Skipping daily market report: No players online.');\n        return;\n    }\n\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        takaro.log.warn('Skipping daily market report: Market data variable not found.');\n        return;\n    }\n\n    let stocks;\n    try {\n        stocks = JSON.parse(marketDataVar.data.data[0].value);\n        if (!Array.isArray(stocks)) {\n            throw new Error('Parsed market data is not an array.');\n        }\n    } catch (error) {\n        takaro.log.error(`Failed to parse stock_market_data: ${error}`);\n        return;\n    }\n\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            if (typeof activeEvent !== 'object' || activeEvent === null || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (error) {\n            takaro.log.warn(`Failed to parse active_market_event: ${error}`);\n            activeEvent = null;\n        }\n    }\n\n    let gameMessage1 = \"==== DAILY MARKET REPORT ====\\n\";\n\n    if (activeEvent && activeEvent.name && activeEvent.description) {\n        const eventText = `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n${activeEvent.description}\\n`;\n        gameMessage1 += eventText;\n    } else {\n        const noEventText = '\\nNo active market events today.\\n';\n        gameMessage1 += noEventText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage1\n    }).catch(err => takaro.log.error(`Failed to send game message 1: ${err}`));\n\n    const stocksWithPerformance = stocks.map(stock => {\n        let change = 0;\n        let percentChange = 0;\n        let changeSymbol = 'â†’';\n\n        if (typeof stock.price === 'number' && typeof stock.lastPrice === 'number' && stock.lastPrice !== 0) {\n            change = stock.price - stock.lastPrice;\n            percentChange = (change / stock.lastPrice) * 100;\n            if (percentChange > 0.05) {\n                changeSymbol = 'â†‘';\n            } else if (percentChange < -0.05) {\n                changeSymbol = 'â†“';\n            }\n        } else if (typeof stock.price === 'number' && stock.lastPrice === undefined) {\n            changeSymbol = 'ðŸ†•';\n            percentChange = 0;\n        }\n        return {\n            ...stock,\n            change,\n            percentChange,\n            changeSymbol\n        };\n    });\n\n    const sectorPerformance = {};\n    stocksWithPerformance.forEach(stock => {\n        const sectorId = stock.sector || 'Uncategorized';\n        if (!sectorPerformance[sectorId]) {\n            sectorPerformance[sectorId] = {\n                stocks: [],\n                totalPercentChange: 0,\n                count: 0\n            };\n        }\n        sectorPerformance[sectorId].stocks.push(stock);\n        if (typeof stock.percentChange === 'number' && isFinite(stock.percentChange)) {\n            sectorPerformance[sectorId].totalPercentChange += stock.percentChange;\n            sectorPerformance[sectorId].count++;\n        }\n    });\n\n    for (const sectorId in sectorPerformance) {\n        const sectorData = sectorPerformance[sectorId];\n        if (sectorData.count > 0) {\n            sectorData.avgPerformance = sectorData.totalPercentChange / sectorData.count;\n        } else {\n            sectorData.avgPerformance = 0;\n        }\n    }\n\n    const sortedSectors = Object.entries(sectorPerformance)\n        .sort(([, a], [, b]) => b.avgPerformance - a.avgPerformance);\n\n    let gameMessage2 = \"\\n=== SECTOR PERFORMANCE ===\\n\";\n\n    if (sortedSectors.length > 0) {\n        sortedSectors.forEach(([sectorId, sectorData]) => {\n            const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n            let line = `${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n\n            if (sectorData.avgPerformance > 0.05) {\n                line = `[70FE02]${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%[-]\\n`;\n            } else if (sectorData.avgPerformance < -0.05) {\n                line = `[FF0001]${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%[-]\\n`;\n            }\n            gameMessage2 += line;\n        });\n    } else {\n        const noDataText = \"No sector performance data available.\\n\";\n        gameMessage2 += noDataText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage2\n    }).catch(err => takaro.log.error(`Failed to send game message 2: ${err}`));\n\n    const validPerformers = stocksWithPerformance.filter(s => typeof s.percentChange === 'number' && isFinite(s.percentChange));\n    validPerformers.sort((a, b) => b.percentChange - a.percentChange);\n\n    let gameMessage3 = \"\";\n\n    const topPerformersTitleGame = \"\\nðŸ”¥ TOP PERFORMERS ðŸ”¥\\n\";\n    gameMessage3 += topPerformersTitleGame;\n\n    if (validPerformers.length > 0) {\n        for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n            const stock = validPerformers[i];\n            let line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            if (stock.percentChange > 0) {\n                line = `[70FE02]${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%[-]\\n`;\n            } else if (stock.percentChange < 0) {\n                line = `[FF0001]${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%[-]\\n`;\n            }\n            gameMessage3 += line;\n        }\n    } else {\n        const noTopText = \"No top performers today.\\n\";\n        gameMessage3 += noTopText;\n    }\n\n    const worstPerformersTitleGame = \"\\nðŸ“‰ WORST PERFORMERS ðŸ“‰\\n\";\n    gameMessage3 += worstPerformersTitleGame;\n\n    if (validPerformers.length > 0) {\n        const worstStartIndex = Math.max(0, validPerformers.length - 3);\n        for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n            const stock = validPerformers[i];\n            let line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            if (stock.percentChange > 0) {\n                line = `[70FE02]${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%[-]\\n`;\n            } else if (stock.percentChange < 0) {\n                line = `[FF0001]${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%[-]\\n`;\n            }\n            gameMessage3 += line;\n        }\n    } else {\n        const noWorstText = \"No worst performers today.\\n\";\n        gameMessage3 += noWorstText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage3\n    }).catch(err => takaro.log.error(`Failed to send game message 3: ${err}`));\n\n    // --- Send each sector's stock listings in separate messages (Game Server Only) ---\n    const stocksBySectorGame = {};\n    stocksWithPerformance.forEach(stock => {\n        if (!stocksBySectorGame[stock.sector]) {\n            stocksBySectorGame[stock.sector] = [];\n        }\n        stocksBySectorGame[stock.sector].push(stock);\n    });\n\n    for (const [sector, sectorStocks] of Object.entries(stocksBySectorGame)) {\n        let sectorMessage = `\\n--- ${sector} SECTOR ---\\n`;\n        sectorStocks.forEach(stock => {\n            let changeText = '';\n            let linePrefix = '';\n            let lineSuffix = '';\n\n            if (stock.lastPrice) {\n                const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                if (percentChange > 0) {\n                    linePrefix = '[70FE02]';\n                    lineSuffix = '[-]';\n                } else if (percentChange < 0) {\n                    linePrefix = '[FF0001]';\n                    lineSuffix = '[-]';\n                }\n            }\n\n            let riskIndicator;\n            if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n            else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n            else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n            else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n            else riskIndicator = \"VH\";\n\n            sectorMessage += `${linePrefix}${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}${lineSuffix}\\n`;\n        });\n\n        await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n            message: sectorMessage\n        }).catch(err => takaro.log.error(`Failed to send game message for sector ${sector}: ${err}`));\n    }\n\n    // Send the legend for risk indicators as a separate message\n    const legendMessage = \"\\n=== LEGEND ===\\n\" +\n        \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\";\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: legendMessage\n    }).catch(err => takaro.log.error(`Failed to send game legend message: ${err}`));\n\n\n    // --- Discord Message: Consolidated Market Report ---\n    if (discordChannelId) {\n        let discordMessage = \"**==== DAILY MARKET REPORT ====**\\n\\n\";\n\n        if (activeEvent && activeEvent.name && activeEvent.description) {\n            discordMessage += `ðŸŒ **ACTIVE EVENT: ${activeEvent.name}** ðŸŒ\\n${activeEvent.description}\\n\\n`;\n        } else {\n            discordMessage += 'No active market events today.\\n\\n';\n        }\n\n        discordMessage += \"**=== SECTOR PERFORMANCE ===**\\n\";\n        if (sortedSectors.length > 0) {\n            sortedSectors.forEach(([sectorId, sectorData]) => {\n                const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n                discordMessage += `${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n            });\n        } else {\n            discordMessage += \"No sector performance data available.\\n\";\n        }\n        discordMessage += \"\\n\";\n\n        discordMessage += \"**ðŸ”¥ TOP PERFORMERS ðŸ”¥**\\n\";\n        if (validPerformers.length > 0) {\n            for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n                const stock = validPerformers[i];\n                const line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n                discordMessage += line;\n            }\n        } else {\n            discordMessage += \"No top performers today.\\n\";\n        }\n        discordMessage += \"\\n\";\n\n        discordMessage += \"**ðŸ“‰ WORST PERFORMERS ðŸ“‰**\\n\";\n        if (validPerformers.length > 0) {\n            const worstStartIndex = Math.max(0, validPerformers.length - 3);\n            for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n                const stock = validPerformers[i];\n                const line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n                discordMessage += line;\n            }\n        } else {\n            discordMessage += \"No worst performers today.\\n\";\n        }\n        discordMessage += \"\\n\";\n\n        discordMessage += \"**=== ALL STOCK LISTINGS ===**\\n\";\n        const stocksBySector = {};\n        stocksWithPerformance.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            discordMessage += `\\n--- **${sector} SECTOR** ---\\n`;\n            sectorStocks.forEach(stock => {\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                    changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                discordMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n        }\n\n        discordMessage += \"\\n**=== LEGEND ===**\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\";\n\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessage\n        }).catch(err => takaro.log.error(`Failed to send consolidated Discord message: ${err.message || err}`));\n    }\n\n    takaro.log.info('Daily market report sent successfully (game server and potentially Discord).');\n}\n\nawait main();",
                    "name": "marketnews",
                    "description": null,
                    "temporalValue": "1 */1 * * *"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    try {\n        const { gameServerId, module: mod } = data;\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Check if market is initialized\n        if (marketDataVar.data.data.length === 0) {\n            console.log(\"Market data not found, initializing...\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return; // Exit after initialization\n        }\n\n        // Get active market event\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event start time\n        const eventStartTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_start_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event execution counter\n        const eventCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_execution_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event cooldown counter\n        const cooldownCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_cooldown_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let eventCounter = 0;\n        if (eventCounterVar.data.data.length > 0) {\n            eventCounter = parseInt(eventCounterVar.data.data[0].value, 10);\n            console.log(`Event counter: ${eventCounter}`);\n        }\n\n        let cooldownCounter = 0;\n        if (cooldownCounterVar.data.data.length > 0) {\n            cooldownCounter = parseInt(cooldownCounterVar.data.data[0].value, 10);\n            console.log(`Cooldown counter: ${cooldownCounter}`);\n        }\n\n        // Get event duration\n        const eventDurationVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['current_event_duration'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Use stored random duration if available, otherwise use defaultEventDuration\n        let eventDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        if (eventDurationVar.data.data.length > 0) {\n            eventDuration = parseInt(eventDurationVar.data.data[0].value, 10);\n            console.log(`Event duration: ${eventDuration}`);\n        }\n\n        let activeEvent = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                // If it's an empty string, treat as no active event\n                if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                    activeEvent = null;\n                }\n                console.log(`Active event: ${activeEvent ? activeEvent.name : 'None'}`);\n            } catch (e) {\n                // In case of parsing error, consider no active event\n                activeEvent = null;\n                console.log(`Error parsing active event: ${e.message}`);\n            }\n        }\n\n        // Check if the current event should end and increment counter\n        if (activeEvent) {\n            eventCounter++;\n            console.log(`Incremented event counter to: ${eventCounter}`);\n\n            if (eventCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: eventCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: eventCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n\n            if (eventCounter >= eventDuration) {\n                console.log(\"Event duration reached, ending event.\");\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: ''\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_cooldown_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    const message = `ðŸ“ˆ MARKET UPDATE ðŸ“‰\\n\\nThe \"${activeEvent.name}\" event has ended. Markets are returning to normal conditions.`;\n\n                    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                        message: message\n                    });\n                }\n\n                activeEvent = null;\n            }\n        } else {\n            cooldownCounter++;\n            console.log(`Incremented cooldown counter to: ${cooldownCounter}`);\n\n            if (cooldownCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: cooldownCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: cooldownCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n        }\n\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        const eventFrequency = (mod.userConfig && mod.userConfig.eventFrequency) || 10;\n        let shouldTriggerEvent = false;\n\n        if (!activeEvent && cooldownCounter >= eventFrequency) {\n            shouldTriggerEvent = Math.random() < 0.5;\n            if (cooldownCounter >= eventFrequency * 2) {\n                shouldTriggerEvent = true;\n            }\n            console.log(`Should trigger new event: ${shouldTriggerEvent}`);\n        }\n\n        if (shouldTriggerEvent) {\n            const events = (mod.userConfig && mod.userConfig.marketEvents) || [];\n            if (events.length > 0) {\n                const randomEvent = events[Math.floor(Math.random() * events.length)];\n                activeEvent = randomEvent;\n                console.log(`New event triggered: ${activeEvent.name}`);\n\n                const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n                const randomDuration = Math.floor(Math.random() * maxDuration) + 1;\n\n                if (eventDurationVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                        value: randomDuration.toString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'current_event_duration',\n                        value: randomDuration.toString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: JSON.stringify(activeEvent)\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'active_market_event',\n                        value: JSON.stringify(activeEvent),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventStartTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_start_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (lastEventTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'last_market_event_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    let impactText = \"\";\n                    for (const impact of activeEvent.sectorImpacts) {\n                        const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                        impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n                    }\n\n                    const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${activeEvent.name}\\n${activeEvent.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /market to see opportunities!`;\n\n                    const maxLength = 400;\n                    for (let i = 0; i < message.length; i += maxLength) {\n                        await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                            message: message.substring(i, i + maxLength)\n                        });\n                    }\n                }\n            }\n        }\n\n        // Get stocks\n        if (!marketDataVar.data.data[0] || !marketDataVar.data.data[0].value) {\n            console.log(\"Market data is empty or invalid after initial check, re-initializing.\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        let stocks;\n        try {\n            stocks = JSON.parse(marketDataVar.data.data[0].value);\n            if (!Array.isArray(stocks)) {\n                throw new Error(\"Parsed stocks data is not an array\");\n            }\n            // CRITICAL FIX: Ensure each stock has valid numerical price properties\n            stocks = stocks.map(s => {\n                const sanitizedPrice = typeof s.price === 'number' && s.price > 0 ? s.price : 1;\n                const sanitizedLastPrice = typeof s.lastPrice === 'number' && s.lastPrice > 0 ? s.lastPrice : sanitizedPrice;\n                return {\n                    ...s,\n                    price: sanitizedPrice,\n                    lastPrice: sanitizedLastPrice\n                };\n            });\n            console.log(\"Stocks loaded and sanitized successfully.\");\n            console.log(\"Initial stocks for this cycle:\");\n            stocks.forEach(s => console.log(`  ${s.id}: Price ${s.price}, LastPrice ${s.lastPrice}`));\n\n        } catch (e) {\n            console.log(`Error parsing or sanitizing stock data: ${e.message}`);\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        const significantChanges = [];\n\n        // Update each stock price\n        stocks.forEach(stock => {\n            // Always capture oldPrice at the very beginning of the iteration\n            const oldPrice = stock.price;\n            // Set lastPrice to the value before this current update cycle for accurate change tracking\n            stock.lastPrice = oldPrice;\n\n            console.log(`Processing stock: ${stock.id}, Old Price: ${oldPrice}`);\n\n            // Define the threshold for \"penny stock\" and the chance/magnitude of a breakout\n            const pennyStockThreshold = 1.9;\n            const breakoutChance = 0.6;\n\n            const targetMinPrice = 2.0;\n            const targetMaxPrice = 10.0;\n\n            let calculatedNewPrice;\n\n            // Check if it's a penny stock and qualifies for a breakout\n            if (oldPrice <= pennyStockThreshold && Math.random() < breakoutChance) {\n                console.log(`${stock.id} is a penny stock (${oldPrice}) and hit breakout chance!`);\n                calculatedNewPrice = targetMinPrice + Math.random() * (targetMaxPrice - targetMinPrice);\n                calculatedNewPrice = Math.max(calculatedNewPrice, oldPrice + 0.01); // Ensure at least a penny increase\n                console.log(`${stock.id} calculated breakout price: ${calculatedNewPrice}`);\n            } else {\n                const randomFactor = Math.random() * 2 - 1;\n                const totalChangePercent = randomFactor * stock.volatility;\n                calculatedNewPrice = oldPrice * (1 + totalChangePercent);\n                console.log(`${stock.id} calculated normal price: ${calculatedNewPrice} (Change: ${totalChangePercent * 100}%)`);\n            }\n\n            let finalPrice = calculatedNewPrice;\n            if (activeEvent) {\n                const sectorImpact = activeEvent.sectorImpacts.find(impact => impact.sectorId === stock.sector);\n                if (sectorImpact) {\n                    const eventImpactPercentage = sectorImpact.impact;\n                    const eventImpactDecimal = eventImpactPercentage / 100;\n                    const randomImpactFactor = 0.5 + Math.random();\n                    const eventImpact = eventImpactDecimal * randomImpactFactor;\n\n                    finalPrice = calculatedNewPrice * (1 + eventImpact);\n                    console.log(`${stock.id} final price after event impact: ${finalPrice} (Event impact: ${eventImpact * 100}%)`);\n                }\n            }\n\n            stock.price = finalPrice;\n\n            if (stock.price < 1) {\n                console.log(`${stock.id} price fell below 1, setting to 1.`);\n                stock.price = 1;\n            }\n\n            const actualPercentChange = ((stock.price - oldPrice) / oldPrice) * 100;\n            console.log(`${stock.id} - Final Price: ${stock.price.toFixed(2)}, Actual Change: ${actualPercentChange.toFixed(2)}%`);\n\n            const changeThreshold = ((mod.userConfig && mod.userConfig.priceAlertThreshold) || 10) / 100;\n            if (Math.abs(actualPercentChange) > changeThreshold * 100) {\n                significantChanges.push({\n                    ...stock,\n                    changePercent: actualPercentChange\n                });\n            }\n        });\n\n        console.log(\"All stocks processed, saving updated prices...\");\n        await takaro.variable.variableControllerUpdate(marketDataVar.data.data[0].id, {\n            value: JSON.stringify(stocks)\n        });\n        console.log(\"Updated prices saved.\");\n\n        if (significantChanges.length > 0) {\n            console.log(\"Significant changes detected, sending alert.\");\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                significantChanges.sort((a, b) => Math.abs(b.changePercent) - Math.abs(a.changePercent));\n                const topChanges = significantChanges.slice(0, Math.min(3, significantChanges.length));\n\n                let message = \"ðŸ“Š STOCK MARKET ALERT ðŸ“Š\\n\";\n                topChanges.forEach(stock => {\n                    const changeDir = stock.changePercent > 0 ? \"up\" : \"down\";\n                    const displayPrice = stock.price.toFixed(2);\n                    const changePercent = Math.abs(Math.round(stock.changePercent));\n\n                    message += `${stock.id} (${stock.sector}): ${changeDir} ${changePercent}% to $${displayPrice}!\\n`;\n                });\n\n                if (activeEvent) {\n                    message += `\\nCurrent market event: ${activeEvent.name}`;\n                }\n\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            } else {\n                console.log(\"No online players to send alert to.\");\n            }\n        } else {\n            console.log(\"No significant changes to alert players about.\");\n        }\n    } catch (error) {\n        console.log(`FATAL Error in updateStockPrices: ${error.message}`);\n        // Optionally, send an admin message if a fatal error occurs\n        // await takaro.gameserver.gameServerControllerSendMessage(data.gameServerId, {\n        //     message: `ðŸš¨ Market Error: An error occurred during stock update: ${error.message}`\n        // });\n    }\n}\n\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        console.log(\"Initializing market if needed...\");\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in module configuration for initialization.\");\n            return;\n        }\n\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_data'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['last_market_event_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_start_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['active_market_event'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_initialized'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_execution_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_cooldown_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['current_event_duration'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } })\n            ]);\n\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n        console.log(\"Mapped initial stocks from config.\");\n\n        const createPromises = [];\n\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_data', value: JSON.stringify(stocks), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'last_market_event_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_start_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'active_market_event', value: '', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_execution_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (cooldownCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_cooldown_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventDurationVar.data.data.length === 0) {\n            const defaultDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'current_event_duration', value: defaultDuration.toString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_initialized', value: 'true', gameServerId, moduleId: mod.moduleId }));\n        }\n\n        if (createPromises.length > 0) {\n            console.log(`Creating ${createPromises.length} initial market variables.`);\n            await Promise.allSettled(createPromises);\n        } else {\n            console.log(\"All market variables already exist, no new initialization needed.\");\n        }\n\n        if (marketDataVar.data.data.length === 0) { // Only announce if we actually created the stock_market_data variable\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /market to see available stocks and /buy to start investing.\";\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, { message });\n            }\n        }\n        console.log(\"Market initialization process complete.\");\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "updatestockprices",
                    "description": null,
                    "temporalValue": "0 */1 * * *"
                }
            ],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Allows the player to view market prices and their portfolio",
                    "permission": "STOCK_MARKET_USE",
                    "friendlyName": "Use Stock Market"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows the player to buy and sell stocks",
                    "permission": "STOCK_MARKET_TRADE",
                    "friendlyName": "Trade Stocks"
                },
                {
                    "canHaveCount": false,
                    "description": "VIP status that reduces transaction fees",
                    "permission": "STOCK_MARKET_BROKER",
                    "friendlyName": "Stock Broker"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows admins to manually trigger market events",
                    "permission": "STOCK_MARKET_TRIGGER_EVENT",
                    "friendlyName": "Trigger Market Events"
                }
            ]
        },
        {
            "tag": "0.1.9",
            "description": "**Stock Market: A Dynamic Virtual Trading System**\n\nCreate an immersive economic experience with this comprehensive stock market module that lets players invest, trade, and react to market events.\n\n**Market Features:**\n\n![Market Summary](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stocks.png)\n\n* **Multiple Economic Sectors:** Configure various industry sectors (Resource Extraction, Manufacturing, Defense, etc.) each with their own market dynamics.\n* **Realistic Stock Behavior:** Stocks have configurable volatility, sector-based pricing, and react differently to market events.\n* **Dynamic Market Events:** Random or admin-triggered events like \"Horde Night Approaching\" or \"Societal Collapse Setback\" impact different sectors in realistic ways.\n\n![Market Events](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_events.png)\n\n**Trading System:**\n\n* **Buy & Sell Shares:** Players can purchase stocks and sell them later for profit or loss.\n* **Transaction Fees:** Configurable fee percentage on all trades creates a realistic market economy.\n* **VIP Benefits:** Special permissions for designated \"Stock Brokers\" who receive fee discounts.\n\n![Buy Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_buy.png)\n\nPlayers can track price changes and sell at the right moment to maximize profits or minimize losses.\n\n![Sell Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sell.png)\n\n**Player Portfolio:**\n\n* **Portfolio Tracking:** Players can view their holdings, average purchase prices, and current profit/loss.\n* **Transaction History:** System tracks all buy/sell transactions for each player.\n* **Summary Statistics:** See overall portfolio performance and value across all holdings.\n\n![Portfolio View](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockportfolio.png)\n\n**Market Information:**\n\n* **Detailed Stock Info:** Players can research specific stocks, including risk levels and sector trends.\n* **Industry Filters:** View stocks by specific sectors to better understand market segments.\n* **Market Alerts:** Server-wide notifications for significant price changes keep players engaged.\n\n![Market Alerts](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockpricechange.png)\n\n**Configuration Options:**\n\n* **Sectors & Stocks:** Define your own market sectors and individual stocks with customizable starting prices and volatility.\n* **Market Events:** Create unique events with specific sector impacts to drive market dynamics.\n* **Transaction Settings:** Configure fee percentages, VIP discounts, and alert thresholds.\n* **Event Frequency:** Control how often random market events occur and how long they last.\n\n![Configuration](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_config.png)\n![Sectors](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sectors.png)\n\n**Commands:**\n\n* `/markets [industry]` - View all stocks or filter by industry\n* `/stockinfo [ticker]` - Get detailed information about a specific stock\n* `/buystock <ticker> <amount>` - Purchase shares of a stock\n* `/sellstock <ticker> <amount>` - Sell shares from your portfolio\n* `/stockportfolio` - View your current holdings and performance\n* `/triggerevent [event]` - Admin command to trigger specific market events\n\nWho says the apocalypse can't have a thriving economy? Now players can stress about both zombie hordes AND their Duke's Casino Tokens dropping 40% after a market event! As one trader put it: \"I used to check my 401K daily, and now I check my AMMO stock before every Blood Moon. Some habits die harder than zombies.\"",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sectors\":{\"type\":\"array\",\"title\":\"Wasteland Economic Sectors\",\"description\":\"Define economic sectors relevant to survival in Navezgane\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Sector ID (e.g., RESOURCES)\"},\"name\":{\"type\":\"string\",\"description\":\"Sector name (e.g., Resource Extraction)\"}}},\"default\":[{\"id\":\"RESOURCES\",\"name\":\"Resource Extraction\"},{\"id\":\"MANUFACTURING\",\"name\":\"Manufacturing & Crafting\"},{\"id\":\"DEFENSE\",\"name\":\"Defense & Fortifications\"},{\"id\":\"SURVIVAL\",\"name\":\"Survival Goods\"},{\"id\":\"TRADE\",\"name\":\"Trade & Currency\"}]},\"stocks\":{\"type\":\"array\",\"title\":\"Wasteland Stocks\",\"description\":\"List of stocks representing Navezgane entities and resources\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Stock ticker symbol (e.g., NMC)\"},\"name\":{\"type\":\"string\",\"description\":\"Entity/Resource name\"},\"sector\":{\"type\":\"string\",\"description\":\"Sector ID this stock belongs to\"},\"initialPrice\":{\"type\":\"number\",\"description\":\"Starting price in Dukes\",\"minimum\":1},\"volatility\":{\"type\":\"number\",\"description\":\"Base volatility percentage (5 = 5%)\",\"minimum\":1,\"maximum\":35}}},\"default\":[{\"id\":\"NMC\",\"name\":\"Navezgane Mining Co.\",\"sector\":\"RESOURCES\",\"initialPrice\":50,\"volatility\":15},{\"id\":\"WOOD\",\"name\":\"Wasteland Lumberjacks\",\"sector\":\"RESOURCES\",\"initialPrice\":20,\"volatility\":8},{\"id\":\"SHALE\",\"name\":\"Oil Shale Extractors\",\"sector\":\"RESOURCES\",\"initialPrice\":40,\"volatility\":18},{\"id\":\"FORGE\",\"name\":\"Forge Ahead Metals\",\"sector\":\"MANUFACTURING\",\"initialPrice\":75,\"volatility\":12},{\"id\":\"TOOLS\",\"name\":\"Working Stiff Tools\",\"sector\":\"MANUFACTURING\",\"initialPrice\":60,\"volatility\":10},{\"id\":\"MECH\",\"name\":\"JunkTech Robotics\",\"sector\":\"MANUFACTURING\",\"initialPrice\":110,\"volatility\":20},{\"id\":\"BUILD\",\"name\":\"Barricade Builders\",\"sector\":\"DEFENSE\",\"initialPrice\":45,\"volatility\":9},{\"id\":\"AMMO\",\"name\":\"AmmoNation Surplus\",\"sector\":\"DEFENSE\",\"initialPrice\":90,\"volatility\":18},{\"id\":\"SHAM\",\"name\":\"Shamway Foods\",\"sector\":\"SURVIVAL\",\"initialPrice\":30,\"volatility\":5},{\"id\":\"MEDS\",\"name\":\"Pop-N-Pills Medical\",\"sector\":\"SURVIVAL\",\"initialPrice\":100,\"volatility\":18},{\"id\":\"TRADE\",\"name\":\"Trader Guild Network\",\"sector\":\"TRADE\",\"initialPrice\":150,\"volatility\":10},{\"id\":\"DUKES\",\"name\":\"Duke's Casino Tokens\",\"sector\":\"TRADE\",\"initialPrice\":1,\"volatility\":3}]},\"marketEvents\":{\"type\":\"array\",\"title\":\"Wasteland Events\",\"description\":\"Events impacting the Navezgane economy\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Unique event ID\"},\"name\":{\"type\":\"string\",\"description\":\"Name of the event\"},\"description\":{\"type\":\"string\",\"description\":\"Description of the event's market effect\"},\"sectorImpacts\":{\"type\":\"array\",\"description\":\"How each sector is affected\",\"items\":{\"type\":\"object\",\"properties\":{\"sectorId\":{\"type\":\"string\",\"description\":\"Sector ID\"},\"impact\":{\"type\":\"number\",\"description\":\"Percentage impact (-30 = -30%)\",\"minimum\":-75,\"maximum\":75}}}}}},\"default\":[{\"id\":\"HORDE_INCOMING\",\"name\":\"Horde Night Approaching\",\"description\":\"Increased Zed activity signals the Blood Moon. Survivors prepare defenses.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-5},{\"sectorId\":\"MANUFACTURING\",\"impact\":15},{\"sectorId\":\"DEFENSE\",\"impact\":25},{\"sectorId\":\"SURVIVAL\",\"impact\":10},{\"sectorId\":\"TRADE\",\"impact\":-10}]},{\"id\":\"RESOURCE_SHOCK\",\"name\":\"Resource Shock\",\"description\":\"Key resource veins are depleted, making raw materials expensive and driving up the price of finished goods.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-30},{\"sectorId\":\"MANUFACTURING\",\"impact\":15},{\"sectorId\":\"DEFENSE\",\"impact\":10},{\"sectorId\":\"SURVIVAL\",\"impact\":5},{\"sectorId\":\"TRADE\",\"impact\":5}]},{\"id\":\"ZED_OUTBREAK\",\"name\":\"Severe Zed Outbreak\",\"description\":\"An unusual concentration of Zed activity makes scavenging dangerous. Demand for medical supplies and defenses skyrockets.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-20},{\"sectorId\":\"MANUFACTURING\",\"impact\":-5},{\"sectorId\":\"DEFENSE\",\"impact\":25},{\"sectorId\":\"SURVIVAL\",\"impact\":25},{\"sectorId\":\"TRADE\",\"impact\":-15}]},{\"id\":\"TECH_BREAKTHROUGH\",\"name\":\"Technological Breakthrough\",\"description\":\"A discovery of pre-collapse schematics has revolutionized crafting and manufacturing.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":10},{\"sectorId\":\"MANUFACTURING\",\"impact\":30},{\"sectorId\":\"DEFENSE\",\"impact\":15},{\"sectorId\":\"SURVIVAL\",\"impact\":5},{\"sectorId\":\"TRADE\",\"impact\":15}]},{\"id\":\"TRADE_ROUTE_SECURED\",\"name\":\"Trade Route Secured\",\"description\":\"Traders have established a safer passage, improving the flow of all goods and services.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":20},{\"sectorId\":\"MANUFACTURING\",\"impact\":10},{\"sectorId\":\"DEFENSE\",\"impact\":5},{\"sectorId\":\"SURVIVAL\",\"impact\":15},{\"sectorId\":\"TRADE\",\"impact\":30}]},{\"id\":\"GENERAL_COLLAPSE\",\"name\":\"Societal Collapse Setback\",\"description\":\"A major setback reminds everyone how fragile survival is. Fear grips the market.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-15},{\"sectorId\":\"MANUFACTURING\",\"impact\":-20},{\"sectorId\":\"DEFENSE\",\"impact\":-15},{\"sectorId\":\"SURVIVAL\",\"impact\":0},{\"sectorId\":\"TRADE\",\"impact\":-25}]}]},\"eventFrequency\":{\"title\":\"Event Frequency\",\"type\":\"number\",\"description\":\"Average number of update cycles between market events (0 to disable). Depends on mod's update frequency (e.g., per in-game hour?).\",\"default\":8,\"minimum\":1},\"defaultEventDuration\":{\"title\":\"Default Event Duration\",\"type\":\"number\",\"description\":\"Default number of update cycles an event lasts.\",\"default\":3,\"minimum\":1,\"maximum\":96},\"transactionFee\":{\"title\":\"Transaction Fee (Dukes Tax)\",\"type\":\"number\",\"description\":\"Percentage fee charged on all buy/sell transactions (5 = 5%)\",\"default\":3,\"minimum\":0,\"maximum\":25},\"vipDiscount\":{\"title\":\"Trader's Favor Discount\",\"type\":\"number\",\"description\":\"Percentage discount on transaction fees for players with 'STOCK_MARKET_BROKER' permission (50 = 50%)\",\"default\":50,\"minimum\":0,\"maximum\":100},\"priceAlertThreshold\":{\"title\":\"Price Alert Threshold\",\"type\":\"number\",\"description\":\"Percentage change that triggers a market alert (15 = 15%)\",\"default\":15,\"minimum\":5,\"maximum\":50},\"marketNewsChannelId\":{\"title\":\"Discord Channel ID (for Market News)\",\"type\":\"string\",\"description\":\"The ID of the Discord channel where market news messages should be posted. Leave empty to disable.\",\"default\":\"\"}},\"additionalProperties\":false}",
            "uiSchema": "{\"sectors\":{\"items\":{\"ui:order\":[\"id\",\"name\"]}},\"stocks\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"sector\",\"initialPrice\",\"volatility\"]}},\"marketEvents\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"description\",\"sectorImpacts\"],\"sectorImpacts\":{\"items\":{\"ui:order\":[\"sectorId\",\"impact\"]}}}},\"transactionFee\":{\"ui:widget\":\"range\"},\"vipDiscount\":{\"ui:widget\":\"range\"},\"eventFrequency\":{\"ui:help\":\"Set to 0 to disable random events\"},\"priceAlertThreshold\":{\"ui:widget\":\"range\"}}",
            "commands": [
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === args.stock.toUpperCase());\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${args.stock} not found. Use /market to see available stocks.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate costs using Math.round to ensure we work with integers\n        const subtotal = Math.round(stock.price) * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const totalCost = subtotal + fee;\n\n        // Check if player has enough currency\n        const playerData = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, player.id);\n        const currentBalance = playerData.data.data.currency;\n\n        if (currentBalance < totalCost) {\n            throw new TakaroUserError(`You don't have enough currency. Cost: $${subtotal} + $${fee} fee = $${totalCost}. Your balance: $${currentBalance}`);\n        }\n\n        // Deduct the currency - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerDeductCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: totalCost\n            }\n        );\n\n        // Get player's portfolio or create new one\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        let portfolio;\n        if (portfolioVar.data.data.length === 0) {\n            portfolio = {};\n        } else {\n            portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        }\n\n        // Update portfolio using rounded values for consistency\n        const stockPrice = Math.round(stock.price);\n        if (!portfolio[stock.id]) {\n            portfolio[stock.id] = {\n                shares: amount,\n                averagePrice: stockPrice\n            };\n        } else {\n            const totalShares = portfolio[stock.id].shares + amount;\n            const totalValue = (portfolio[stock.id].shares * portfolio[stock.id].averagePrice) + (amount * stockPrice);\n            portfolio[stock.id].shares = totalShares;\n            portfolio[stock.id].averagePrice = Math.round(totalValue / totalShares);\n        }\n\n        // Save updated portfolio\n        if (portfolioVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_portfolio',\n                value: JSON.stringify(portfolio),\n                gameServerId,\n                moduleId: mod.moduleId,\n                playerId: player.id\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n                value: JSON.stringify(portfolio)\n            });\n        }\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'BUY',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: totalCost,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully bought ${amount} shares of ${stock.id} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Total cost: $${totalCost}\\n`;\n        message += `Current portfolio: ${portfolio[stock.id].shares} shares of ${stock.id}`;\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in buystock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your purchase. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "buystock",
                    "description": null,
                    "trigger": "buystock",
                    "helpText": "Buy shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol ",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to buy",
                            "position": 1
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // Get player's portfolio\n    const portfolioVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_portfolio'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId],\n            playerId: [player.id]\n        }\n    });\n\n    let portfolio = {};\n    if (portfolioVar.data.data.length > 0) {\n        portfolio = JSON.parse(portfolioVar.data.data[0].value);\n    }\n\n    // Send header\n    await player.pm(\"=== YOUR STOCK PORTFOLIO ===\");\n\n    let hasStocks = false;\n    let totalValue = 0;\n    let totalInvestment = 0;\n\n    // If no stocks, send a simple message\n    if (Object.keys(portfolio).length === 0) {\n        await player.pm(\"You don't own any stocks yet.\\n\" +\n            \"Use /markets to see available stocks and prices.\\n\" +\n            \"Use /buy <stock> <amount> to purchase stocks.\");\n        return;\n    }\n\n    // Helper function to format numbers with commas\n    const formatNumber = (num) => {\n        return Math.round(num).toLocaleString();\n    };\n\n    // Send each stock as a separate message to avoid length issues\n    for (const [stockId, data] of Object.entries(portfolio)) {\n        hasStocks = true;\n        const stock = stocks.find(s => s.id === stockId);\n        if (!stock) continue; // Stock might have been removed from config\n\n        const currentValue = stock.price * data.shares;\n        const investmentValue = data.averagePrice * data.shares;\n        totalValue += currentValue;\n        totalInvestment += investmentValue;\n        const profit = currentValue - investmentValue;\n        const profitPercent = ((profit / investmentValue) * 100).toFixed(1);\n\n        let stockMessage = `--- ${stockId} (${stock.sector}) ---\\n`;\n        stockMessage += `Shares: ${data.shares}\\n`;\n        stockMessage += `Avg buy: $${formatNumber(data.averagePrice)}\\n`;\n        stockMessage += `Current price: $${formatNumber(stock.price)}\\n`;\n        stockMessage += `Total value: $${formatNumber(currentValue)}\\n`;\n\n        if (profit >= 0) {\n            stockMessage += `Profit: +$${formatNumber(profit)} (+${profitPercent}%)\\n`;\n        } else {\n            stockMessage += `Loss: -$${formatNumber(Math.abs(profit))} (${profitPercent}%)\\n`;\n        }\n\n        await player.pm(stockMessage);\n    }\n\n    if (hasStocks) {\n        const totalProfit = totalValue - totalInvestment;\n        const totalProfitPercent = ((totalProfit / totalInvestment) * 100).toFixed(1);\n\n        let summaryMessage = \"=== PORTFOLIO SUMMARY ===\\n\";\n        summaryMessage += `Total investment: $${formatNumber(totalInvestment)}\\n`;\n        summaryMessage += `Current value: $${formatNumber(totalValue)}\\n`;\n\n        if (totalProfit >= 0) {\n            summaryMessage += `Overall profit: +$${formatNumber(totalProfit)} (+${totalProfitPercent}%)\\n`;\n        } else {\n            summaryMessage += `Overall loss: -$${formatNumber(Math.abs(totalProfit))} (${totalProfitPercent}%)\\n`;\n        }\n\n        // Get transaction history count\n        try {\n            const historyVar = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: ['stock_transaction_history'],\n                    gameServerId: [gameServerId],\n                    moduleId: [mod.moduleId],\n                    playerId: [player.id]\n                }\n            });\n\n            if (historyVar.data.data.length > 0) {\n                const history = JSON.parse(historyVar.data.data[0].value);\n                const buyCount = history.filter(t => t.type === 'BUY').length;\n                const sellCount = history.filter(t => t.type === 'SELL').length;\n\n                summaryMessage += `\\nTransactions: ${history.length} (${buyCount} buys, ${sellCount} sells)\\n`;\n            }\n        } catch (error) {\n            // Just ignore history errors\n        }\n\n        await player.pm(summaryMessage);\n    }\n}\n\nawait main();",
                    "name": "stockportfolio",
                    "description": null,
                    "trigger": "stockportfolio",
                    "helpText": "No help text available",
                    "arguments": []
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get player's portfolio\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        if (portfolioVar.data.data.length === 0) {\n            throw new TakaroUserError(\"You don't own any stocks to sell.\");\n        }\n\n        const portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        const stockId = args.stock.toUpperCase();\n\n        if (!portfolio[stockId] || portfolio[stockId].shares < amount) {\n            throw new TakaroUserError(`You don't own ${amount} shares of ${stockId}.`);\n        }\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === stockId);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${stockId} not found in current market data. Please contact an admin.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate sale proceeds using Math.round to ensure we work with integers\n        const stockPrice = Math.round(stock.price);\n        const subtotal = stockPrice * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const netProceeds = subtotal - fee;\n\n        // Add money to player - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerAddCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: netProceeds\n            }\n        );\n\n        // Calculate profit/loss\n        const profitPerShare = stockPrice - portfolio[stockId].averagePrice;\n        const totalProfit = Math.round(profitPerShare * amount);\n        const profitText = totalProfit >= 0\n            ? `profit of $${totalProfit}`\n            : `loss of $${Math.abs(totalProfit)}`;\n\n        // Update portfolio\n        portfolio[stockId].shares -= amount;\n        if (portfolio[stockId].shares === 0) {\n            delete portfolio[stockId];\n        }\n\n        // Save updated portfolio\n        await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n            value: JSON.stringify(portfolio)\n        });\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'SELL',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: netProceeds,\n            profit: totalProfit,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully sold ${amount} shares of ${stockId} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Net proceeds: $${netProceeds} (${profitText})`;\n\n        // Add remaining shares info if player still has some\n        if (portfolio[stockId]) {\n            message += `\\nRemaining shares: ${portfolio[stockId].shares}`;\n        } else {\n            message += `\\nYou've sold all your ${stockId} shares.`;\n        }\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in sellstock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your sale. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "sellstock",
                    "description": null,
                    "trigger": "sellstock",
                    "helpText": "Sell shares of a stock",
                    "arguments": [
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to sell",
                            "position": 1
                        },
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // If a specific stock ticker is provided, show detailed info for that stock\n    const specificTicker = args.ticker ? args.ticker.toUpperCase() : null;\n\n    if (specificTicker && specificTicker !== \"ALL\") {\n        const stock = stocks.find(s => s.id.toUpperCase() === specificTicker);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${specificTicker} not found. Use /stockinfo without parameters to see all available stocks.`);\n        }\n\n        // Get active event to see if this stock's sector is affected\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let activeEvent = null;\n        let sectorImpact = null;\n\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEvent && activeEvent.sectorImpacts) {\n                    sectorImpact = activeEvent.sectorImpacts.find(impact =>\n                        impact.sectorId === stock.sector\n                    );\n                }\n            } catch (e) {\n                // Ignore parsing errors\n            }\n        }\n\n        // Calculate price change indicators\n        let changeText = '';\n        if (stock.lastPrice) {\n            const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n            const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n            changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n        }\n\n        // Add risk assessment based on volatility without showing the raw value\n        let riskLevel;\n        if (stock.volatility <= 0.05) riskLevel = \"Very Low\";\n        else if (stock.volatility <= 0.10) riskLevel = \"Low\";\n        else if (stock.volatility <= 0.15) riskLevel = \"Moderate\";\n        else if (stock.volatility <= 0.20) riskLevel = \"High\";\n        else riskLevel = \"Very High\";\n\n        // Build detailed stock info message\n        let message = `=== ${stock.id}: ${stock.name} ===\\n\\n`;\n        message += `Sector: ${stock.sector}\\n`;\n        message += `Current Price: $${Math.round(stock.price)}${changeText}\\n`;\n        message += `Risk Level: ${riskLevel}\\n`;\n\n        // Add sector trend info if available from event\n        if (activeEvent && sectorImpact) {\n            const direction = sectorImpact.impact >= 0 ? \"Positive\" : \"Negative\";\n            const strength = Math.abs(sectorImpact.impact);\n            let trend;\n\n            if (strength < 10) trend = \"Slight\";\n            else if (strength < 25) trend = \"Moderate\";\n            else trend = \"Strong\";\n\n            message += `\\nCurrent Trend: ${trend} ${direction} (${activeEvent.name})\\n`;\n            message += `Event: ${activeEvent.description}\\n`;\n        }\n\n        // Add trading guidance based on sector and risk, without mentioning volatility\n        message += `\\nTrading Notes:\\n`;\n\n        if (activeEvent && sectorImpact) {\n            if (sectorImpact.impact > 0) {\n                message += `- Currently bullish due to the ${activeEvent.name} event\\n`;\n            } else {\n                message += `- Currently bearish due to the ${activeEvent.name} event\\n`;\n            }\n        }\n\n        if (riskLevel === \"High\" || riskLevel === \"Very High\") {\n            message += `- Expect significant price fluctuations with this stock\\n`;\n        } else if (riskLevel === \"Low\" || riskLevel === \"Very Low\") {\n            message += `- Typically has stable price movement\\n`;\n        }\n\n        message += `\\nUse /buystock ${stock.id} [amount] to purchase shares`;\n\n        await player.pm(message);\n\n    } else {\n        // No specific ticker provided or ALL specified, show summary of all stocks\n        await player.pm(\"=== STOCK MARKET LISTINGS ===\\n\");\n\n        // Group stocks by sector\n        const stocksBySector = {};\n        stocks.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        // Display stocks by sector\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            let sectorMessage = `\\n--- ${sector} SECTOR ---\\n`;\n\n            sectorStocks.forEach(stock => {\n                // Add price change indicators\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                    changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                // Add risk level based on volatility\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                sectorMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n\n            await player.pm(sectorMessage);\n        }\n\n        // Add legend for risk indicators\n        const legend = \"\\n=== LEGEND ===\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\" +\n            \"Use /stockinfo [ticker] for detailed information about a specific stock\";\n\n        await player.pm(legend);\n    }\n}\n\nawait main();",
                    "name": "stockinfo",
                    "description": null,
                    "trigger": "stockinfo",
                    "helpText": "Shows all available stocks in the market. Use with a ticker symbol (e.g., /stockinfo ticker) to see detailed information about a specific stock.",
                    "arguments": [
                        {
                            "name": "ticker",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "stock ticker or ALL to get detailed information about a specific stock",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRIGGER_EVENT')) {\n        throw new TakaroUserError(\"You don't have permission to trigger market events.\");\n    }\n\n    try {\n        // Get current stock data to check market initialization\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Initialize market if needed\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            await player.pm(\"Market was not initialized. Initializing now...\");\n            return;\n        }\n\n        // Get events from module config\n        const marketEvents = mod.userConfig.marketEvents || [];\n\n        if (marketEvents.length === 0) {\n            throw new TakaroUserError(\"No market events configured in this module.\");\n        }\n\n        // Handle case when no event is specified or \"ALL\" is provided\n        if (!args.EventName || args.EventName.toUpperCase() === \"ALL\") {\n            await player.pm(\"=== AVAILABLE MARKET EVENTS ===\\n\");\n\n            // Group events by category or type if possible\n            const eventCategories = {};\n\n            // Create a simple categorization based on positive/negative impact\n            marketEvents.forEach(event => {\n                let category = \"Mixed\";\n                // Calculate net impact across all sectors\n                const netImpact = event.sectorImpacts.reduce((sum, impact) => sum + impact.impact, 0);\n\n                if (netImpact > 0) category = \"Positive\";\n                else if (netImpact < 0) category = \"Negative\";\n\n                if (!eventCategories[category]) {\n                    eventCategories[category] = [];\n                }\n                eventCategories[category].push(event);\n            });\n\n            // Display events by category\n            for (const [category, events] of Object.entries(eventCategories)) {\n                if (events.length > 0) {\n                    await player.pm(`\\n--- ${category.toUpperCase()} EVENTS ---`);\n\n                    let message = \"\";\n                    events.forEach(event => {\n                        // Format primary sectors affected\n                        const primarySectors = event.sectorImpacts\n                            .filter(impact => Math.abs(impact.impact) >= 15)\n                            .map(impact => {\n                                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                                return `${impact.sectorId} ${direction}${Math.abs(impact.impact)}%`;\n                            })\n                            .join(\", \");\n\n                        message += `${event.id}: ${event.name}\\n`;\n                        message += `   ${event.description}\\n`;\n                        if (primarySectors) {\n                            message += `   Major impacts: ${primarySectors}\\n`;\n                        }\n                        message += \"\\n\";\n                    });\n\n                    await player.pm(message);\n                }\n            }\n\n            await player.pm(\"=== HOW TO USE ===\\nUse `/triggerevent <EventName>` to trigger a specific event (e.g., `/triggerevent TECH_BOOM`)\");\n            return;\n        }\n\n        // Find the requested event\n        const eventId = args.EventName.toUpperCase();\n        const event = marketEvents.find(e => e.id === eventId);\n\n        if (!event) {\n            throw new TakaroUserError(`Event \"${eventId}\" not found. Use /triggerevent without parameters to see all available events.`);\n        }\n\n        // Get necessary variables for managing the event\n        const [activeEventVar, eventStartTimeVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_execution_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_cooldown_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['current_event_duration'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Check if there's an active event we need to cancel\n        let activeEventObj = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEventObj = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEventObj && Object.keys(activeEventObj).length > 0) {\n                    await player.pm(`Cancelling active event \"${activeEventObj.name}\" to trigger new event.`);\n                }\n            } catch (e) {\n                // Invalid event data, will be overwritten\n            }\n        }\n\n        // Generate a random duration for the event\n        const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n        // Update or create all event-related variables\n        const updatePromises = [];\n\n        // Save or update the random duration\n        if (eventDurationVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                    value: randomDuration.toString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'current_event_duration',\n                    value: randomDuration.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the event counter to 0\n        if (eventCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the cooldown counter\n        if (cooldownCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update active event\n        if (activeEventVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                    value: JSON.stringify(event)\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: JSON.stringify(event),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update event start time\n        if (eventStartTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update last event time\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (lastEventTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all updates to complete\n        await Promise.all(updatePromises);\n\n        // Check if there are online players to announce the event\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            // Format sector impacts for announcement\n            let impactText = \"\";\n            for (const impact of event.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n            }\n\n            const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${event.name}\\n${event.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /markets to see opportunities!`;\n\n            // Split the message if it's too long\n            const maxLength = 400; // Safe limit for most games\n            for (let i = 0; i < message.length; i += maxLength) {\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message: message.substring(i, i + maxLength)\n                });\n            }\n        }\n\n        await player.pm(`Successfully triggered the \"${event.name}\" market event for ${randomDuration} cycles!`);\n    } catch (error) {\n        // If something goes wrong, log it and let the player know\n        console.log(`Error in triggerEvent: ${error.message}`);\n        throw new TakaroUserError(`Error triggering event: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Store the stocks data\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_data',\n            value: JSON.stringify(stocks),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize last event time to now\n        await takaro.variable.variableControllerCreate({\n            key: 'last_market_event_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize event start time variable\n        await takaro.variable.variableControllerCreate({\n            key: 'event_start_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize active event (empty string means no active event)\n        await takaro.variable.variableControllerCreate({\n            key: 'active_market_event',\n            value: '',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Mark market as initialized\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_initialized',\n            value: 'true',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Announce market initialization to online players\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /markets to see available stocks and /buystock to start investing.\";\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message\n            });\n        }\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "triggerevent",
                    "description": null,
                    "trigger": "triggerevent",
                    "helpText": "Shows all available market events when run without parameters. Use with an event name (e.g., /triggerevent TECH_BOOM) to trigger a specific market event.",
                    "arguments": [
                        {
                            "name": "EventName",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "Event name to trigger a specific market event",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Handle the industry argument - use \"ALL\" as a special value to show all industries\n    const industryFilter = args.Industry ? args.Industry.toUpperCase() : \"ALL\";\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    // If market data doesn't exist, try to initialize it\n    if (marketDataVar.data.data.length === 0) {\n        const initialized = await initializeMarketIfNeeded(gameServerId, mod);\n        if (!initialized) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        // Get the freshly initialized market data\n        const refreshedMarketData = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (refreshedMarketData.data.data.length === 0) {\n            throw new TakaroUserError(\"There was an issue initializing the stock market. Please try again later.\");\n        }\n\n        // Continue with the refreshed data\n        await displayMarketSummary(player, gameServerId, mod, refreshedMarketData.data.data[0], industryFilter);\n    } else {\n        // Market data exists, display it\n        await displayMarketSummary(player, gameServerId, mod, marketDataVar.data.data[0], industryFilter);\n    }\n}\n\n// Display the market summary to the player\nasync function displayMarketSummary(player, gameServerId, mod, marketDataVariable, industryFilter) {\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Handle empty string or empty object\n            if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (e) {\n            // In case of parsing error\n            activeEvent = null;\n        }\n    }\n\n    const stocks = JSON.parse(marketDataVariable.value);\n\n    // Get all available industries for reference\n    const availableIndustries = [...new Set(stocks.map(stock => stock.sector))];\n\n    // If industry filter is provided and not \"ALL\", check if it's valid\n    if (industryFilter !== \"ALL\") {\n        // Check if the industry exists\n        const industryExists = availableIndustries.includes(industryFilter);\n\n        if (!industryExists) {\n            throw new TakaroUserError(`Industry \"${industryFilter}\" not found. Available industries: ${availableIndustries.join(', ')}\\nUse \"ALL\" to view all industries.`);\n        }\n    }\n\n    // Send header message\n    let headerMessage = \"=== STOCK MARKET SUMMARY ===\\n\";\n\n    // If filtering by industry, mention it in the header\n    if (industryFilter !== \"ALL\") {\n        headerMessage = `=== ${industryFilter} INDUSTRY ===\\n`;\n    }\n\n    // If there's an active event, include it in the header\n    if (activeEvent) {\n        headerMessage += `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n`;\n        headerMessage += `${activeEvent.description}\\n\\n`;\n\n        // If filtering by industry, only show relevant impacts\n        if (industryFilter !== \"ALL\") {\n            const relevantImpact = activeEvent.sectorImpacts.find(\n                impact => impact.sectorId === industryFilter\n            );\n\n            if (relevantImpact) {\n                const direction = relevantImpact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `Industry Impact: ${direction} ${Math.abs(relevantImpact.impact)}%\\n`;\n            } else {\n                headerMessage += \"This industry is not directly affected by the current event.\\n\";\n            }\n        } else {\n            // Show all industry impacts\n            headerMessage += \"Industry Impacts:\\n\";\n            for (const impact of activeEvent.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%\\n`;\n            }\n        }\n    }\n\n    // Send header message first\n    await player.pm(headerMessage);\n\n    // Group stocks by industry\n    const stocksByIndustry = {};\n    stocks.forEach(stock => {\n        if (!stocksByIndustry[stock.sector]) {\n            stocksByIndustry[stock.sector] = [];\n        }\n        stocksByIndustry[stock.sector].push(stock);\n    });\n\n    // If industry filter is not \"ALL\", only show that industry\n    if (industryFilter !== \"ALL\") {\n        const filteredStocks = stocksByIndustry[industryFilter] || [];\n\n        if (filteredStocks.length > 0) {\n            let stockMessage = \"\";\n\n            filteredStocks.forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                stockMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(stockMessage);\n        } else {\n            await player.pm(`No stocks found in the ${industryFilter} industry.`);\n        }\n    } else {\n        // Send each industry as a separate message\n        for (const industryId in stocksByIndustry) {\n            let industryMessage = `=== ${industryId} INDUSTRY ===\\n`;\n\n            stocksByIndustry[industryId].forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                industryMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(industryMessage);\n        }\n    }\n\n    // Add a help message for industry filtering if showing all industries\n    if (industryFilter === \"ALL\") {\n        const allIndustries = Object.keys(stocksByIndustry).join(', ');\n        await player.pm(`\\nTip: Use '/markets [industry]' to view only stocks in a specific industry. Available industries: ${allIndustries}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return false;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            const results = await Promise.allSettled(createPromises);\n            // Check if the critical stock_market_data was created successfully\n            const stockDataPromise = results[0];\n            if (stockDataPromise && stockDataPromise.status === 'rejected') {\n                console.log(`Failed to create stock_market_data: ${stockDataPromise.reason}`);\n                return false;\n            }\n        }\n\n        return true;\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n        return false;\n    }\n}\n\nawait main();",
                    "name": "markets",
                    "description": null,
                    "trigger": "markets",
                    "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. \n",
                    "arguments": [
                        {
                            "name": "Industry",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. ",
                            "position": 0
                        }
                    ]
                }
            ],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n\n    const discordChannelId = mod.userConfig.marketNewsChannelId;\n\n    if (!discordChannelId) {\n        takaro.log.info('Market news Discord channel ID (marketNewsChannelId) not configured in module settings. Skipping Discord messages.');\n    }\n\n    const currentPlayers = (await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    })).data.meta;\n\n    if (currentPlayers.total === 0) {\n        takaro.log.info('Skipping daily market report: No players online.');\n        return;\n    }\n\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        takaro.log.warn('Skipping daily market report: Market data variable not found.');\n        return;\n    }\n\n    let stocks;\n    try {\n        stocks = JSON.parse(marketDataVar.data.data[0].value);\n        if (!Array.isArray(stocks)) {\n            throw new Error('Parsed market data is not an array.');\n        }\n    } catch (error) {\n        takaro.log.error(`Failed to parse stock_market_data: ${error}`);\n        return;\n    }\n\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            if (typeof activeEvent !== 'object' || activeEvent === null || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (error) {\n            takaro.log.warn(`Failed to parse active_market_event: ${error}`);\n            activeEvent = null;\n        }\n    }\n\n    let gameMessage1 = \"==== DAILY MARKET REPORT ====\\n\";\n\n    if (activeEvent && activeEvent.name && activeEvent.description) {\n        const eventText = `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n${activeEvent.description}\\n`;\n        gameMessage1 += eventText;\n    } else {\n        const noEventText = '\\nNo active market events today.\\n';\n        gameMessage1 += noEventText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage1\n    }).catch(err => takaro.log.error(`Failed to send game message 1: ${err}`));\n\n    const stocksWithPerformance = stocks.map(stock => {\n        let change = 0;\n        let percentChange = 0;\n        let changeSymbol = 'â†’';\n\n        if (typeof stock.price === 'number' && typeof stock.lastPrice === 'number' && stock.lastPrice !== 0) {\n            change = stock.price - stock.lastPrice;\n            percentChange = (change / stock.lastPrice) * 100;\n            if (percentChange > 0.05) {\n                changeSymbol = 'â†‘';\n            } else if (percentChange < -0.05) {\n                changeSymbol = 'â†“';\n            }\n        } else if (typeof stock.price === 'number' && stock.lastPrice === undefined) {\n            changeSymbol = 'ðŸ†•';\n            percentChange = 0;\n        }\n        return {\n            ...stock,\n            change,\n            percentChange,\n            changeSymbol\n        };\n    });\n\n    const sectorPerformance = {};\n    stocksWithPerformance.forEach(stock => {\n        const sectorId = stock.sector || 'Uncategorized';\n        if (!sectorPerformance[sectorId]) {\n            sectorPerformance[sectorId] = {\n                stocks: [],\n                totalPercentChange: 0,\n                count: 0\n            };\n        }\n        sectorPerformance[sectorId].stocks.push(stock);\n        if (typeof stock.percentChange === 'number' && isFinite(stock.percentChange)) {\n            sectorPerformance[sectorId].totalPercentChange += stock.percentChange;\n            sectorPerformance[sectorId].count++;\n        }\n    });\n\n    for (const sectorId in sectorPerformance) {\n        const sectorData = sectorPerformance[sectorId];\n        if (sectorData.count > 0) {\n            sectorData.avgPerformance = sectorData.totalPercentChange / sectorData.count;\n        } else {\n            sectorData.avgPerformance = 0;\n        }\n    }\n\n    const sortedSectors = Object.entries(sectorPerformance)\n        .sort(([, a], [, b]) => b.avgPerformance - a.avgPerformance);\n\n    let gameMessage2 = \"\\n=== SECTOR PERFORMANCE ===\\n\";\n\n    if (sortedSectors.length > 0) {\n        sortedSectors.forEach(([sectorId, sectorData]) => {\n            const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n            let line = `${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n\n            if (sectorData.avgPerformance > 0.05) {\n                line = `[70FE02]${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%[-]\\n`;\n            } else if (sectorData.avgPerformance < -0.05) {\n                line = `[FF0001]${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%[-]\\n`;\n            }\n            gameMessage2 += line;\n        });\n    } else {\n        const noDataText = \"No sector performance data available.\\n\";\n        gameMessage2 += noDataText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage2\n    }).catch(err => takaro.log.error(`Failed to send game message 2: ${err}`));\n\n    const validPerformers = stocksWithPerformance.filter(s => typeof s.percentChange === 'number' && isFinite(s.percentChange));\n    validPerformers.sort((a, b) => b.percentChange - a.percentChange);\n\n    let gameMessage3 = \"\";\n\n    const topPerformersTitleGame = \"\\nðŸ”¥ TOP PERFORMERS ðŸ”¥\\n\";\n    gameMessage3 += topPerformersTitleGame;\n\n    if (validPerformers.length > 0) {\n        for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n            const stock = validPerformers[i];\n            let linePrefix = '';\n            let lineSuffix = '';\n\n            if (stock.percentChange > 0) {\n                linePrefix = '[70FE02]';\n                lineSuffix = '[-]';\n            } else if (stock.percentChange < 0) {\n                linePrefix = '[FF0001]';\n                lineSuffix = '[-]';\n            }\n            // Applying color to the entire line for top/worst performers as before\n            gameMessage3 += `${linePrefix}${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%${lineSuffix}\\n`;\n        }\n    } else {\n        const noTopText = \"No top performers today.\\n\";\n        gameMessage3 += noTopText;\n    }\n\n    const worstPerformersTitleGame = \"\\nðŸ“‰ WORST PERFORMERS ðŸ“‰\\n\";\n    gameMessage3 += worstPerformersTitleGame;\n\n    if (validPerformers.length > 0) {\n        const worstStartIndex = Math.max(0, validPerformers.length - 3);\n        for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n            const stock = validPerformers[i];\n            let linePrefix = '';\n            let lineSuffix = '';\n\n            if (stock.percentChange > 0) {\n                linePrefix = '[70FE02]';\n                lineSuffix = '[-]';\n            } else if (stock.percentChange < 0) {\n                linePrefix = '[FF0001]';\n                lineSuffix = '[-]';\n            }\n            // Applying color to the entire line for top/worst performers as before\n            gameMessage3 += `${linePrefix}${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%${lineSuffix}\\n`;\n        }\n    } else {\n        const noWorstText = \"No worst performers today.\\n\";\n        gameMessage3 += noWorstText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage3\n    }).catch(err => takaro.log.error(`Failed to send game message 3: ${err}`));\n\n    // Helper function to convert HSL to RGB\n    function hslToRgb(h, s, l) {\n        let c = (1 - Math.abs(2 * l - 1)) * s;\n        let x = c * (1 - Math.abs((h / 60) % 2 - 1));\n        let m = l - c / 2;\n        let r = 0, g = 0, b = 0;\n\n        if (0 <= h && h < 60) {\n            r = c; g = x; b = 0;\n        } else if (60 <= h && h < 120) {\n            r = x; g = c; b = 0;\n        } else if (120 <= h && h < 180) {\n            r = 0; g = c; b = x;\n        } else if (180 <= h && h < 240) {\n            r = 0; g = x; b = c;\n        } else if (240 <= h && h < 300) {\n            r = x; g = 0; b = c;\n        } else if (300 <= h && h < 360) {\n            r = c; g = 0; b = x;\n        }\n        r = Math.round((r + m) * 255);\n        g = Math.round((g + m) * 255);\n        b = Math.round((b + m) * 255);\n\n        return [r, g, b];\n    }\n\n    // Helper function to convert RGB to Hex\n    function rgbToHex(r, g, b) {\n        return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();\n    }\n\n    // Function to generate a consistent BRIGHT and DISTINCT hex color from a string\n    function stringToHexColor(str) {\n        let hash = 0;\n        for (let i = 0; i < str.length; i++) {\n            hash = str.charCodeAt(i) + ((hash << 5) - hash);\n        }\n        // Ensure hash is non-negative\n        hash = Math.abs(hash);\n\n        // Use a \"golden angle\" to distribute hues more evenly across the spectrum\n        // This helps in generating visually distinct colors.\n        const goldenAngle = 137.508; // Degrees\n        let hue = (hash * goldenAngle) % 360;\n\n        // Set high saturation and lightness for bright colors\n        const saturation = 0.9; // 90%\n        const lightness = 0.7;  // 70%\n\n        const [r, g, b] = hslToRgb(hue, saturation, lightness);\n        return rgbToHex(r, g, b);\n    }\n\n    const stockColors = {};\n    stocksWithPerformance.forEach(stock => {\n        // Use stock.name for color generation to ensure consistent unique colors for full names\n        stockColors[stock.id] = stringToHexColor(stock.name);\n    });\n\n    // --- Send each sector's stock listings in separate messages (Game Server Only) ---\n    const stocksBySectorGame = {};\n    stocksWithPerformance.forEach(stock => {\n        if (!stocksBySectorGame[stock.sector]) {\n            stocksBySectorGame[stock.sector] = [];\n        }\n        stocksBySectorGame[stock.sector].push(stock);\n    });\n\n    for (const [sector, sectorStocks] of Object.entries(stocksBySectorGame)) {\n        let sectorMessage = `\\n--- ${sector} SECTOR ---\\n`;\n        sectorStocks.forEach(stock => {\n            let changeText = '';\n            let priceColorPrefix = '';\n            let priceColorSuffix = '';\n\n            if (stock.lastPrice) {\n                const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                if (percentChange > 0) {\n                    priceColorPrefix = '[70FE02]';\n                    priceColorSuffix = '[-]';\n                } else if (percentChange < 0) {\n                    priceColorPrefix = '[FF0001]';\n                    priceColorSuffix = '[-]';\n                }\n            }\n\n            // Apply distinct hex color for stock name\n            // The unique color is for the *full stock name* like \"AmmoNation Surplus\"\n            const stockNameColorPrefix = stockColors[stock.id] ? `[${stockColors[stock.id]}]` : '';\n            const stockNameColorSuffix = stockColors[stock.id] ? '[-]' : '';\n\n            let riskIndicator;\n            if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n            else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n            else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n            else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n            else riskIndicator = \"VH\";\n\n            // Corrected concatenation for nested colors:\n            // Stock name color opens, then risk indicator, then price color opens, then price/change, then close all.\n            // Ensure the stock name is wrapped by its unique color.\n            // Ensure the price/change is wrapped by its red/green color.\n            sectorMessage += `${stockNameColorPrefix}${stock.name}${stockNameColorSuffix} (${riskIndicator}): ${priceColorPrefix}$${Math.round(stock.price)}${changeText}${priceColorSuffix}\\n`;\n        });\n\n        await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n            message: sectorMessage\n        }).catch(err => takaro.log.error(`Failed to send game message for sector ${sector}: ${err}`));\n    }\n\n    // Send the legend for risk indicators as a separate message\n    const legendMessage = \"\\n=== LEGEND ===\\n\" +\n        \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\";\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: legendMessage\n    }).catch(err => takaro.log.error(`Failed to send game legend message: ${err}`));\n\n\n    // --- Discord Message: Consolidated Market Report ---\n    if (discordChannelId) {\n        let discordMessage = \"**==== DAILY MARKET REPORT ====**\\n\\n\";\n\n        if (activeEvent && activeEvent.name && activeEvent.description) {\n            discordMessage += `ðŸŒ **ACTIVE EVENT: ${activeEvent.name}** ðŸŒ\\n${activeEvent.description}\\n\\n`;\n        } else {\n            discordMessage += 'No active market events today.\\n\\n';\n        }\n\n        discordMessage += \"**=== SECTOR PERFORMANCE ===**\\n\";\n        if (sortedSectors.length > 0) {\n            sortedSectors.forEach(([sectorId, sectorData]) => {\n                const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n                discordMessage += `${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n            });\n        } else {\n            discordMessage += \"No sector performance data available.\\n\";\n        }\n        discordMessage += \"\\n\";\n\n        discordMessage += \"**ðŸ”¥ TOP PERFORMERS ðŸ”¥**\\n\";\n        if (validPerformers.length > 0) {\n            for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n                const stock = validPerformers[i];\n                const line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n                discordMessage += line;\n            }\n        } else {\n            discordMessage += \"No top performers today.\\n\";\n        }\n        discordMessage += \"\\n\";\n\n        discordMessage += \"**ðŸ“‰ WORST PERFORMERS ðŸ“‰**\\n\";\n        if (validPerformers.length > 0) {\n            const worstStartIndex = Math.max(0, validPerformers.length - 3);\n            for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n                const stock = validPerformers[i];\n                const line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n                discordMessage += line;\n            }\n        } else {\n            discordMessage += \"No worst performers today.\\n\";\n        }\n        discordMessage += \"\\n\";\n\n        discordMessage += \"**=== ALL STOCK LISTINGS ===**\\n\";\n        const stocksBySector = {};\n        stocksWithPerformance.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            discordMessage += `\\n--- **${sector} SECTOR** ---\\n`;\n            sectorStocks.forEach(stock => {\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                    changeText = ` ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                discordMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n        }\n\n        discordMessage += \"\\n**=== LEGEND ===**\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\";\n\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessage\n        }).catch(err => takaro.log.error(`Failed to send consolidated Discord message: ${err.message || err}`));\n    }\n\n    takaro.log.info('Daily market report sent successfully (game server and potentially Discord).');\n}\n\nawait main();",
                    "name": "marketnews",
                    "description": null,
                    "temporalValue": "1 */1 * * *"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    try {\n        const { gameServerId, module: mod } = data;\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Check if market is initialized\n        if (marketDataVar.data.data.length === 0) {\n            console.log(\"Market data not found, initializing...\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return; // Exit after initialization\n        }\n\n        // Get active market event\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event start time\n        const eventStartTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_start_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event execution counter\n        const eventCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_execution_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event cooldown counter\n        const cooldownCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_cooldown_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let eventCounter = 0;\n        if (eventCounterVar.data.data.length > 0) {\n            eventCounter = parseInt(eventCounterVar.data.data[0].value, 10);\n            console.log(`Event counter: ${eventCounter}`);\n        }\n\n        let cooldownCounter = 0;\n        if (cooldownCounterVar.data.data.length > 0) {\n            cooldownCounter = parseInt(cooldownCounterVar.data.data[0].value, 10);\n            console.log(`Cooldown counter: ${cooldownCounter}`);\n        }\n\n        // Get event duration\n        const eventDurationVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['current_event_duration'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Use stored random duration if available, otherwise use defaultEventDuration\n        let eventDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        if (eventDurationVar.data.data.length > 0) {\n            eventDuration = parseInt(eventDurationVar.data.data[0].value, 10);\n            console.log(`Event duration: ${eventDuration}`);\n        }\n\n        let activeEvent = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                // If it's an empty string, treat as no active event\n                if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                    activeEvent = null;\n                }\n                console.log(`Active event: ${activeEvent ? activeEvent.name : 'None'}`);\n            } catch (e) {\n                // In case of parsing error, consider no active event\n                activeEvent = null;\n                console.log(`Error parsing active event: ${e.message}`);\n            }\n        }\n\n        // Check if the current event should end and increment counter\n        if (activeEvent) {\n            eventCounter++;\n            console.log(`Incremented event counter to: ${eventCounter}`);\n\n            if (eventCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: eventCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: eventCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n\n            if (eventCounter >= eventDuration) {\n                console.log(\"Event duration reached, ending event.\");\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: ''\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_cooldown_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    const message = `ðŸ“ˆ MARKET UPDATE ðŸ“‰\\n\\nThe \"${activeEvent.name}\" event has ended. Markets are returning to normal conditions.`;\n\n                    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                        message: message\n                    });\n                }\n\n                activeEvent = null;\n            }\n        } else {\n            cooldownCounter++;\n            console.log(`Incremented cooldown counter to: ${cooldownCounter}`);\n\n            if (cooldownCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: cooldownCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: cooldownCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n        }\n\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        const eventFrequency = (mod.userConfig && mod.userConfig.eventFrequency) || 10;\n        let shouldTriggerEvent = false;\n\n        if (!activeEvent && cooldownCounter >= eventFrequency) {\n            shouldTriggerEvent = Math.random() < 0.5;\n            if (cooldownCounter >= eventFrequency * 2) {\n                shouldTriggerEvent = true;\n            }\n            console.log(`Should trigger new event: ${shouldTriggerEvent}`);\n        }\n\n        if (shouldTriggerEvent) {\n            const events = (mod.userConfig && mod.userConfig.marketEvents) || [];\n            if (events.length > 0) {\n                const randomEvent = events[Math.floor(Math.random() * events.length)];\n                activeEvent = randomEvent;\n                console.log(`New event triggered: ${activeEvent.name}`);\n\n                const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n                const randomDuration = Math.floor(Math.random() * maxDuration) + 1;\n\n                if (eventDurationVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                        value: randomDuration.toString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'current_event_duration',\n                        value: randomDuration.toString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: JSON.stringify(activeEvent)\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'active_market_event',\n                        value: JSON.stringify(activeEvent),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventStartTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_start_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (lastEventTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'last_market_event_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    let impactText = \"\";\n                    for (const impact of activeEvent.sectorImpacts) {\n                        const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                        impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n                    }\n\n                    const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${activeEvent.name}\\n${activeEvent.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /market to see opportunities!`;\n\n                    const maxLength = 400;\n                    for (let i = 0; i < message.length; i += maxLength) {\n                        await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                            message: message.substring(i, i + maxLength)\n                        });\n                    }\n                }\n            }\n        }\n\n        // Get stocks\n        if (!marketDataVar.data.data[0] || !marketDataVar.data.data[0].value) {\n            console.log(\"Market data is empty or invalid after initial check, re-initializing.\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        let stocks;\n        try {\n            stocks = JSON.parse(marketDataVar.data.data[0].value);\n            if (!Array.isArray(stocks)) {\n                throw new Error(\"Parsed stocks data is not an array\");\n            }\n            // CRITICAL FIX: Ensure each stock has valid numerical price properties\n            stocks = stocks.map(s => {\n                const sanitizedPrice = typeof s.price === 'number' && s.price > 0 ? s.price : 1;\n                const sanitizedLastPrice = typeof s.lastPrice === 'number' && s.lastPrice > 0 ? s.lastPrice : sanitizedPrice;\n                return {\n                    ...s,\n                    price: sanitizedPrice,\n                    lastPrice: sanitizedLastPrice\n                };\n            });\n            console.log(\"Stocks loaded and sanitized successfully.\");\n            console.log(\"Initial stocks for this cycle:\");\n            stocks.forEach(s => console.log(`  ${s.id}: Price ${s.price}, LastPrice ${s.lastPrice}`));\n\n        } catch (e) {\n            console.log(`Error parsing or sanitizing stock data: ${e.message}`);\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        const significantChanges = [];\n\n        // Update each stock price\n        stocks.forEach(stock => {\n            // Always capture oldPrice at the very beginning of the iteration\n            const oldPrice = stock.price;\n            // Set lastPrice to the value before this current update cycle for accurate change tracking\n            stock.lastPrice = oldPrice;\n\n            console.log(`Processing stock: ${stock.id}, Old Price: ${oldPrice}`);\n\n            // Define the threshold for \"penny stock\" and the chance/magnitude of a breakout\n            const pennyStockThreshold = 1.9;\n            const breakoutChance = 0.6;\n\n            const targetMinPrice = 2.0;\n            const targetMaxPrice = 10.0;\n\n            let calculatedNewPrice;\n\n            // Check if it's a penny stock and qualifies for a breakout\n            if (oldPrice <= pennyStockThreshold && Math.random() < breakoutChance) {\n                console.log(`${stock.id} is a penny stock (${oldPrice}) and hit breakout chance!`);\n                calculatedNewPrice = targetMinPrice + Math.random() * (targetMaxPrice - targetMinPrice);\n                calculatedNewPrice = Math.max(calculatedNewPrice, oldPrice + 0.01); // Ensure at least a penny increase\n                console.log(`${stock.id} calculated breakout price: ${calculatedNewPrice}`);\n            } else {\n                const randomFactor = Math.random() * 2 - 1;\n                const totalChangePercent = randomFactor * stock.volatility;\n                calculatedNewPrice = oldPrice * (1 + totalChangePercent);\n                console.log(`${stock.id} calculated normal price: ${calculatedNewPrice} (Change: ${totalChangePercent * 100}%)`);\n            }\n\n            let finalPrice = calculatedNewPrice;\n            if (activeEvent) {\n                const sectorImpact = activeEvent.sectorImpacts.find(impact => impact.sectorId === stock.sector);\n                if (sectorImpact) {\n                    const eventImpactPercentage = sectorImpact.impact;\n                    const eventImpactDecimal = eventImpactPercentage / 100;\n                    const randomImpactFactor = 0.5 + Math.random();\n                    const eventImpact = eventImpactDecimal * randomImpactFactor;\n\n                    finalPrice = calculatedNewPrice * (1 + eventImpact);\n                    console.log(`${stock.id} final price after event impact: ${finalPrice} (Event impact: ${eventImpact * 100}%)`);\n                }\n            }\n\n            stock.price = finalPrice;\n\n            if (stock.price < 1) {\n                console.log(`${stock.id} price fell below 1, setting to 1.`);\n                stock.price = 1;\n            }\n\n            const actualPercentChange = ((stock.price - oldPrice) / oldPrice) * 100;\n            console.log(`${stock.id} - Final Price: ${stock.price.toFixed(2)}, Actual Change: ${actualPercentChange.toFixed(2)}%`);\n\n            const changeThreshold = ((mod.userConfig && mod.userConfig.priceAlertThreshold) || 10) / 100;\n            if (Math.abs(actualPercentChange) > changeThreshold * 100) {\n                significantChanges.push({\n                    ...stock,\n                    changePercent: actualPercentChange\n                });\n            }\n        });\n\n        console.log(\"All stocks processed, saving updated prices...\");\n        await takaro.variable.variableControllerUpdate(marketDataVar.data.data[0].id, {\n            value: JSON.stringify(stocks)\n        });\n        console.log(\"Updated prices saved.\");\n\n        if (significantChanges.length > 0) {\n            console.log(\"Significant changes detected, sending alert.\");\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                significantChanges.sort((a, b) => Math.abs(b.changePercent) - Math.abs(a.changePercent));\n                const topChanges = significantChanges.slice(0, Math.min(3, significantChanges.length));\n\n                let message = \"ðŸ“Š STOCK MARKET ALERT ðŸ“Š\\n\";\n                topChanges.forEach(stock => {\n                    const changeDir = stock.changePercent > 0 ? \"up\" : \"down\";\n                    const displayPrice = stock.price.toFixed(2);\n                    const changePercent = Math.abs(Math.round(stock.changePercent));\n\n                    message += `${stock.id} (${stock.sector}): ${changeDir} ${changePercent}% to $${displayPrice}!\\n`;\n                });\n\n                if (activeEvent) {\n                    message += `\\nCurrent market event: ${activeEvent.name}`;\n                }\n\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            } else {\n                console.log(\"No online players to send alert to.\");\n            }\n        } else {\n            console.log(\"No significant changes to alert players about.\");\n        }\n    } catch (error) {\n        console.log(`FATAL Error in updateStockPrices: ${error.message}`);\n        // Optionally, send an admin message if a fatal error occurs\n        // await takaro.gameserver.gameServerControllerSendMessage(data.gameServerId, {\n        //     message: `ðŸš¨ Market Error: An error occurred during stock update: ${error.message}`\n        // });\n    }\n}\n\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        console.log(\"Initializing market if needed...\");\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in module configuration for initialization.\");\n            return;\n        }\n\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_data'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['last_market_event_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_start_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['active_market_event'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_initialized'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_execution_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_cooldown_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['current_event_duration'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } })\n            ]);\n\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n        console.log(\"Mapped initial stocks from config.\");\n\n        const createPromises = [];\n\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_data', value: JSON.stringify(stocks), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'last_market_event_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_start_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'active_market_event', value: '', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_execution_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (cooldownCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_cooldown_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventDurationVar.data.data.length === 0) {\n            const defaultDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'current_event_duration', value: defaultDuration.toString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_initialized', value: 'true', gameServerId, moduleId: mod.moduleId }));\n        }\n\n        if (createPromises.length > 0) {\n            console.log(`Creating ${createPromises.length} initial market variables.`);\n            await Promise.allSettled(createPromises);\n        } else {\n            console.log(\"All market variables already exist, no new initialization needed.\");\n        }\n\n        if (marketDataVar.data.data.length === 0) { // Only announce if we actually created the stock_market_data variable\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /market to see available stocks and /buy to start investing.\";\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, { message });\n            }\n        }\n        console.log(\"Market initialization process complete.\");\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "updatestockprices",
                    "description": null,
                    "temporalValue": "0 */1 * * *"
                }
            ],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Allows the player to view market prices and their portfolio",
                    "permission": "STOCK_MARKET_USE",
                    "friendlyName": "Use Stock Market"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows the player to buy and sell stocks",
                    "permission": "STOCK_MARKET_TRADE",
                    "friendlyName": "Trade Stocks"
                },
                {
                    "canHaveCount": false,
                    "description": "VIP status that reduces transaction fees",
                    "permission": "STOCK_MARKET_BROKER",
                    "friendlyName": "Stock Broker"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows admins to manually trigger market events",
                    "permission": "STOCK_MARKET_TRIGGER_EVENT",
                    "friendlyName": "Trigger Market Events"
                }
            ]
        },
        {
            "tag": "0.1.3",
            "description": "**Stock Market: A Dynamic Virtual Trading System**\n\nCreate an immersive economic experience with this comprehensive stock market module that lets players invest, trade, and react to market events.\n\n**Market Features:**\n\n![Market Summary](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stocks.png)\n\n* **Multiple Economic Sectors:** Configure various industry sectors (Resource Extraction, Manufacturing, Defense, etc.) each with their own market dynamics.\n* **Realistic Stock Behavior:** Stocks have configurable volatility, sector-based pricing, and react differently to market events.\n* **Dynamic Market Events:** Random or admin-triggered events like \"Horde Night Approaching\" or \"Societal Collapse Setback\" impact different sectors in realistic ways.\n\n![Market Events](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_events.png)\n\n**Trading System:**\n\n* **Buy & Sell Shares:** Players can purchase stocks and sell them later for profit or loss.\n* **Transaction Fees:** Configurable fee percentage on all trades creates a realistic market economy.\n* **VIP Benefits:** Special permissions for designated \"Stock Brokers\" who receive fee discounts.\n\n![Buy Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_buy.png)\n\nPlayers can track price changes and sell at the right moment to maximize profits or minimize losses.\n\n![Sell Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sell.png)\n\n**Player Portfolio:**\n\n* **Portfolio Tracking:** Players can view their holdings, average purchase prices, and current profit/loss.\n* **Transaction History:** System tracks all buy/sell transactions for each player.\n* **Summary Statistics:** See overall portfolio performance and value across all holdings.\n\n![Portfolio View](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockportfolio.png)\n\n**Market Information:**\n\n* **Detailed Stock Info:** Players can research specific stocks, including risk levels and sector trends.\n* **Industry Filters:** View stocks by specific sectors to better understand market segments.\n* **Market Alerts:** Server-wide notifications for significant price changes keep players engaged.\n\n![Market Alerts](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockpricechange.png)\n\n**Configuration Options:**\n\n* **Sectors & Stocks:** Define your own market sectors and individual stocks with customizable starting prices and volatility.\n* **Market Events:** Create unique events with specific sector impacts to drive market dynamics.\n* **Transaction Settings:** Configure fee percentages, VIP discounts, and alert thresholds.\n* **Event Frequency:** Control how often random market events occur and how long they last.\n\n![Configuration](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_config.png)\n![Sectors](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sectors.png)\n\n**Commands:**\n\n* `/markets [industry]` - View all stocks or filter by industry\n* `/stockinfo [ticker]` - Get detailed information about a specific stock\n* `/buystock <ticker> <amount>` - Purchase shares of a stock\n* `/sellstock <ticker> <amount>` - Sell shares from your portfolio\n* `/stockportfolio` - View your current holdings and performance\n* `/triggerevent [event]` - Admin command to trigger specific market events\n\nWho says the apocalypse can't have a thriving economy? Now players can stress about both zombie hordes AND their Duke's Casino Tokens dropping 40% after a market event! As one trader put it: \"I used to check my 401K daily, and now I check my AMMO stock before every Blood Moon. Some habits die harder than zombies.\"",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sectors\":{\"type\":\"array\",\"title\":\"Wasteland Economic Sectors\",\"description\":\"Define economic sectors relevant to survival in Navezgane\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Sector ID (e.g., RESOURCES)\"},\"name\":{\"type\":\"string\",\"description\":\"Sector name (e.g., Resource Extraction)\"}}},\"default\":[{\"id\":\"RESOURCES\",\"name\":\"Resource Extraction\"},{\"id\":\"MANUFACTURING\",\"name\":\"Manufacturing & Crafting\"},{\"id\":\"DEFENSE\",\"name\":\"Defense & Fortifications\"},{\"id\":\"SURVIVAL\",\"name\":\"Survival Goods\"},{\"id\":\"TRADE\",\"name\":\"Trade & Currency\"}]},\"stocks\":{\"type\":\"array\",\"title\":\"Wasteland Stocks\",\"description\":\"List of stocks representing Navezgane entities and resources\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Stock ticker symbol (e.g., NMC)\"},\"name\":{\"type\":\"string\",\"description\":\"Entity/Resource name\"},\"sector\":{\"type\":\"string\",\"description\":\"Sector ID this stock belongs to\"},\"initialPrice\":{\"type\":\"number\",\"description\":\"Starting price in Dukes\",\"minimum\":1},\"volatility\":{\"type\":\"number\",\"description\":\"Base volatility percentage (5 = 5%)\",\"minimum\":1,\"maximum\":35}}},\"default\":[{\"id\":\"NMC\",\"name\":\"Navezgane Mining Co.\",\"sector\":\"RESOURCES\",\"initialPrice\":50,\"volatility\":15},{\"id\":\"WOOD\",\"name\":\"Wasteland Lumberjacks\",\"sector\":\"RESOURCES\",\"initialPrice\":20,\"volatility\":8},{\"id\":\"SHALE\",\"name\":\"Oil Shale Extractors\",\"sector\":\"RESOURCES\",\"initialPrice\":40,\"volatility\":18},{\"id\":\"FORGE\",\"name\":\"Forge Ahead Metals\",\"sector\":\"MANUFACTURING\",\"initialPrice\":75,\"volatility\":12},{\"id\":\"TOOLS\",\"name\":\"Working Stiff Tools\",\"sector\":\"MANUFACTURING\",\"initialPrice\":60,\"volatility\":10},{\"id\":\"MECH\",\"name\":\"JunkTech Robotics\",\"sector\":\"MANUFACTURING\",\"initialPrice\":110,\"volatility\":20},{\"id\":\"BUILD\",\"name\":\"Barricade Builders\",\"sector\":\"DEFENSE\",\"initialPrice\":45,\"volatility\":9},{\"id\":\"AMMO\",\"name\":\"AmmoNation Surplus\",\"sector\":\"DEFENSE\",\"initialPrice\":90,\"volatility\":18},{\"id\":\"SHAM\",\"name\":\"Shamway Foods\",\"sector\":\"SURVIVAL\",\"initialPrice\":30,\"volatility\":5},{\"id\":\"MEDS\",\"name\":\"Pop-N-Pills Medical\",\"sector\":\"SURVIVAL\",\"initialPrice\":100,\"volatility\":18},{\"id\":\"TRADE\",\"name\":\"Trader Guild Network\",\"sector\":\"TRADE\",\"initialPrice\":150,\"volatility\":10},{\"id\":\"DUKES\",\"name\":\"Duke's Casino Tokens\",\"sector\":\"TRADE\",\"initialPrice\":1,\"volatility\":3}]},\"marketEvents\":{\"type\":\"array\",\"title\":\"Wasteland Events\",\"description\":\"Events impacting the Navezgane economy\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Unique event ID\"},\"name\":{\"type\":\"string\",\"description\":\"Name of the event\"},\"description\":{\"type\":\"string\",\"description\":\"Description of the event's market effect\"},\"sectorImpacts\":{\"type\":\"array\",\"description\":\"How each sector is affected\",\"items\":{\"type\":\"object\",\"properties\":{\"sectorId\":{\"type\":\"string\",\"description\":\"Sector ID\"},\"impact\":{\"type\":\"number\",\"description\":\"Percentage impact (-30 = -30%)\",\"minimum\":-75,\"maximum\":75}}}}}},\"default\":[{\"id\":\"HORDE_INCOMING\",\"name\":\"Horde Night Approaching\",\"description\":\"Increased Zed activity signals the Blood Moon. Survivors prepare defenses.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-5},{\"sectorId\":\"MANUFACTURING\",\"impact\":15},{\"sectorId\":\"DEFENSE\",\"impact\":25},{\"sectorId\":\"SURVIVAL\",\"impact\":10},{\"sectorId\":\"TRADE\",\"impact\":-10}]},{\"id\":\"RESOURCE_SHOCK\",\"name\":\"Resource Shock\",\"description\":\"Key resource veins are depleted, making raw materials expensive and driving up the price of finished goods.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-30},{\"sectorId\":\"MANUFACTURING\",\"impact\":15},{\"sectorId\":\"DEFENSE\",\"impact\":10},{\"sectorId\":\"SURVIVAL\",\"impact\":5},{\"sectorId\":\"TRADE\",\"impact\":5}]},{\"id\":\"ZED_OUTBREAK\",\"name\":\"Severe Zed Outbreak\",\"description\":\"An unusual concentration of Zed activity makes scavenging dangerous. Demand for medical supplies and defenses skyrockets.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-20},{\"sectorId\":\"MANUFACTURING\",\"impact\":-5},{\"sectorId\":\"DEFENSE\",\"impact\":25},{\"sectorId\":\"SURVIVAL\",\"impact\":25},{\"sectorId\":\"TRADE\",\"impact\":-15}]},{\"id\":\"TECH_BREAKTHROUGH\",\"name\":\"Technological Breakthrough\",\"description\":\"A discovery of pre-collapse schematics has revolutionized crafting and manufacturing.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":10},{\"sectorId\":\"MANUFACTURING\",\"impact\":30},{\"sectorId\":\"DEFENSE\",\"impact\":15},{\"sectorId\":\"SURVIVAL\",\"impact\":5},{\"sectorId\":\"TRADE\",\"impact\":15}]},{\"id\":\"TRADE_ROUTE_SECURED\",\"name\":\"Trade Route Secured\",\"description\":\"Traders have established a safer passage, improving the flow of all goods and services.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":20},{\"sectorId\":\"MANUFACTURING\",\"impact\":10},{\"sectorId\":\"DEFENSE\",\"impact\":5},{\"sectorId\":\"SURVIVAL\",\"impact\":15},{\"sectorId\":\"TRADE\",\"impact\":30}]},{\"id\":\"GENERAL_COLLAPSE\",\"name\":\"Societal Collapse Setback\",\"description\":\"A major setback reminds everyone how fragile survival is. Fear grips the market.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-15},{\"sectorId\":\"MANUFACTURING\",\"impact\":-20},{\"sectorId\":\"DEFENSE\",\"impact\":-15},{\"sectorId\":\"SURVIVAL\",\"impact\":0},{\"sectorId\":\"TRADE\",\"impact\":-25}]}]},\"eventFrequency\":{\"title\":\"Event Frequency\",\"type\":\"number\",\"description\":\"Average number of update cycles between market events (0 to disable). Depends on mod's update frequency (e.g., per in-game hour?).\",\"default\":8,\"minimum\":1},\"defaultEventDuration\":{\"title\":\"Default Event Duration\",\"type\":\"number\",\"description\":\"Default number of update cycles an event lasts.\",\"default\":3,\"minimum\":1,\"maximum\":96},\"transactionFee\":{\"title\":\"Transaction Fee (Dukes Tax)\",\"type\":\"number\",\"description\":\"Percentage fee charged on all buy/sell transactions (5 = 5%)\",\"default\":3,\"minimum\":0,\"maximum\":25},\"vipDiscount\":{\"title\":\"Trader's Favor Discount\",\"type\":\"number\",\"description\":\"Percentage discount on transaction fees for players with 'STOCK_MARKET_BROKER' permission (50 = 50%)\",\"default\":50,\"minimum\":0,\"maximum\":100},\"priceAlertThreshold\":{\"title\":\"Price Alert Threshold\",\"type\":\"number\",\"description\":\"Percentage change that triggers a market alert (15 = 15%)\",\"default\":15,\"minimum\":5,\"maximum\":50},\"marketNewsChannelId\":{\"title\":\"Discord Channel ID (for Market News)\",\"type\":\"string\",\"description\":\"The ID of the Discord channel where market news messages should be posted. Leave empty to disable.\",\"default\":\"\"}},\"additionalProperties\":false}",
            "uiSchema": "{\"sectors\":{\"items\":{\"ui:order\":[\"id\",\"name\"]}},\"stocks\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"sector\",\"initialPrice\",\"volatility\"]}},\"marketEvents\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"description\",\"sectorImpacts\"],\"sectorImpacts\":{\"items\":{\"ui:order\":[\"sectorId\",\"impact\"]}}}},\"transactionFee\":{\"ui:widget\":\"range\"},\"vipDiscount\":{\"ui:widget\":\"range\"},\"eventFrequency\":{\"ui:help\":\"Set to 0 to disable random events\"},\"priceAlertThreshold\":{\"ui:widget\":\"range\"}}",
            "commands": [
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Handle the industry argument - use \"ALL\" as a special value to show all industries\n    const industryFilter = args.Industry ? args.Industry.toUpperCase() : \"ALL\";\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    // If market data doesn't exist, try to initialize it\n    if (marketDataVar.data.data.length === 0) {\n        const initialized = await initializeMarketIfNeeded(gameServerId, mod);\n        if (!initialized) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        // Get the freshly initialized market data\n        const refreshedMarketData = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (refreshedMarketData.data.data.length === 0) {\n            throw new TakaroUserError(\"There was an issue initializing the stock market. Please try again later.\");\n        }\n\n        // Continue with the refreshed data\n        await displayMarketSummary(player, gameServerId, mod, refreshedMarketData.data.data[0], industryFilter);\n    } else {\n        // Market data exists, display it\n        await displayMarketSummary(player, gameServerId, mod, marketDataVar.data.data[0], industryFilter);\n    }\n}\n\n// Display the market summary to the player\nasync function displayMarketSummary(player, gameServerId, mod, marketDataVariable, industryFilter) {\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Handle empty string or empty object\n            if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (e) {\n            // In case of parsing error\n            activeEvent = null;\n        }\n    }\n\n    const stocks = JSON.parse(marketDataVariable.value);\n\n    // Get all available industries for reference\n    const availableIndustries = [...new Set(stocks.map(stock => stock.sector))];\n\n    // If industry filter is provided and not \"ALL\", check if it's valid\n    if (industryFilter !== \"ALL\") {\n        // Check if the industry exists\n        const industryExists = availableIndustries.includes(industryFilter);\n\n        if (!industryExists) {\n            throw new TakaroUserError(`Industry \"${industryFilter}\" not found. Available industries: ${availableIndustries.join(', ')}\\nUse \"ALL\" to view all industries.`);\n        }\n    }\n\n    // Send header message\n    let headerMessage = \"=== STOCK MARKET SUMMARY ===\\n\";\n\n    // If filtering by industry, mention it in the header\n    if (industryFilter !== \"ALL\") {\n        headerMessage = `=== ${industryFilter} INDUSTRY ===\\n`;\n    }\n\n    // If there's an active event, include it in the header\n    if (activeEvent) {\n        headerMessage += `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n`;\n        headerMessage += `${activeEvent.description}\\n\\n`;\n\n        // If filtering by industry, only show relevant impacts\n        if (industryFilter !== \"ALL\") {\n            const relevantImpact = activeEvent.sectorImpacts.find(\n                impact => impact.sectorId === industryFilter\n            );\n\n            if (relevantImpact) {\n                const direction = relevantImpact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `Industry Impact: ${direction} ${Math.abs(relevantImpact.impact)}%\\n`;\n            } else {\n                headerMessage += \"This industry is not directly affected by the current event.\\n\";\n            }\n        } else {\n            // Show all industry impacts\n            headerMessage += \"Industry Impacts:\\n\";\n            for (const impact of activeEvent.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%\\n`;\n            }\n        }\n    }\n\n    // Send header message first\n    await player.pm(headerMessage);\n\n    // Group stocks by industry\n    const stocksByIndustry = {};\n    stocks.forEach(stock => {\n        if (!stocksByIndustry[stock.sector]) {\n            stocksByIndustry[stock.sector] = [];\n        }\n        stocksByIndustry[stock.sector].push(stock);\n    });\n\n    // If industry filter is not \"ALL\", only show that industry\n    if (industryFilter !== \"ALL\") {\n        const filteredStocks = stocksByIndustry[industryFilter] || [];\n\n        if (filteredStocks.length > 0) {\n            let stockMessage = \"\";\n\n            filteredStocks.forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                stockMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(stockMessage);\n        } else {\n            await player.pm(`No stocks found in the ${industryFilter} industry.`);\n        }\n    } else {\n        // Send each industry as a separate message\n        for (const industryId in stocksByIndustry) {\n            let industryMessage = `=== ${industryId} INDUSTRY ===\\n`;\n\n            stocksByIndustry[industryId].forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                industryMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(industryMessage);\n        }\n    }\n\n    // Add a help message for industry filtering if showing all industries\n    if (industryFilter === \"ALL\") {\n        const allIndustries = Object.keys(stocksByIndustry).join(', ');\n        await player.pm(`\\nTip: Use '/markets [industry]' to view only stocks in a specific industry. Available industries: ${allIndustries}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return false;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            const results = await Promise.allSettled(createPromises);\n            // Check if the critical stock_market_data was created successfully\n            const stockDataPromise = results[0];\n            if (stockDataPromise && stockDataPromise.status === 'rejected') {\n                console.log(`Failed to create stock_market_data: ${stockDataPromise.reason}`);\n                return false;\n            }\n        }\n\n        return true;\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n        return false;\n    }\n}\n\nawait main();",
                    "name": "markets",
                    "description": null,
                    "trigger": "markets",
                    "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. \n",
                    "arguments": [
                        {
                            "name": "Industry",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. ",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get player's portfolio\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        if (portfolioVar.data.data.length === 0) {\n            throw new TakaroUserError(\"You don't own any stocks to sell.\");\n        }\n\n        const portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        const stockId = args.stock.toUpperCase();\n\n        if (!portfolio[stockId] || portfolio[stockId].shares < amount) {\n            throw new TakaroUserError(`You don't own ${amount} shares of ${stockId}.`);\n        }\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === stockId);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${stockId} not found in current market data. Please contact an admin.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate sale proceeds using Math.round to ensure we work with integers\n        const stockPrice = Math.round(stock.price);\n        const subtotal = stockPrice * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const netProceeds = subtotal - fee;\n\n        // Add money to player - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerAddCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: netProceeds\n            }\n        );\n\n        // Calculate profit/loss\n        const profitPerShare = stockPrice - portfolio[stockId].averagePrice;\n        const totalProfit = Math.round(profitPerShare * amount);\n        const profitText = totalProfit >= 0\n            ? `profit of $${totalProfit}`\n            : `loss of $${Math.abs(totalProfit)}`;\n\n        // Update portfolio\n        portfolio[stockId].shares -= amount;\n        if (portfolio[stockId].shares === 0) {\n            delete portfolio[stockId];\n        }\n\n        // Save updated portfolio\n        await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n            value: JSON.stringify(portfolio)\n        });\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'SELL',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: netProceeds,\n            profit: totalProfit,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully sold ${amount} shares of ${stockId} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Net proceeds: $${netProceeds} (${profitText})`;\n\n        // Add remaining shares info if player still has some\n        if (portfolio[stockId]) {\n            message += `\\nRemaining shares: ${portfolio[stockId].shares}`;\n        } else {\n            message += `\\nYou've sold all your ${stockId} shares.`;\n        }\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in sellstock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your sale. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "sellstock",
                    "description": null,
                    "trigger": "sellstock",
                    "helpText": "Sell shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to sell",
                            "position": 1
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // Get player's portfolio\n    const portfolioVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_portfolio'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId],\n            playerId: [player.id]\n        }\n    });\n\n    let portfolio = {};\n    if (portfolioVar.data.data.length > 0) {\n        portfolio = JSON.parse(portfolioVar.data.data[0].value);\n    }\n\n    // Send header\n    await player.pm(\"=== YOUR STOCK PORTFOLIO ===\");\n\n    let hasStocks = false;\n    let totalValue = 0;\n    let totalInvestment = 0;\n\n    // If no stocks, send a simple message\n    if (Object.keys(portfolio).length === 0) {\n        await player.pm(\"You don't own any stocks yet.\\n\" +\n            \"Use /markets to see available stocks and prices.\\n\" +\n            \"Use /buy <stock> <amount> to purchase stocks.\");\n        return;\n    }\n\n    // Send each stock as a separate message to avoid length issues\n    for (const [stockId, data] of Object.entries(portfolio)) {\n        hasStocks = true;\n        const stock = stocks.find(s => s.id === stockId);\n        if (!stock) continue; // Stock might have been removed from config\n\n        const currentValue = stock.price * data.shares;\n        const investmentValue = data.averagePrice * data.shares;\n        totalValue += currentValue;\n        totalInvestment += investmentValue;\n        const profit = currentValue - investmentValue;\n        const profitPercent = ((profit / investmentValue) * 100).toFixed(1);\n\n        let stockMessage = `--- ${stockId} (${stock.sector}) ---\\n`;\n        stockMessage += `Shares: ${data.shares}\\n`;\n        stockMessage += `Avg buy: $${Math.round(data.averagePrice)}\\n`;\n        stockMessage += `Current price: $${Math.round(stock.price)}\\n`;\n        stockMessage += `Total value: $${Math.round(currentValue)}\\n`;\n\n        if (profit >= 0) {\n            stockMessage += `Profit: +$${Math.round(profit)} (+${profitPercent}%)\\n`;\n        } else {\n            stockMessage += `Loss: -$${Math.abs(Math.round(profit))} (${profitPercent}%)\\n`;\n        }\n\n        await player.pm(stockMessage);\n    }\n\n    if (hasStocks) {\n        const totalProfit = totalValue - totalInvestment;\n        const totalProfitPercent = ((totalProfit / totalInvestment) * 100).toFixed(1);\n\n        let summaryMessage = \"=== PORTFOLIO SUMMARY ===\\n\";\n        summaryMessage += `Total investment: $${Math.round(totalInvestment)}\\n`;\n        summaryMessage += `Current value: $${Math.round(totalValue)}\\n`;\n\n        if (totalProfit >= 0) {\n            summaryMessage += `Overall profit: +$${Math.round(totalProfit)} (+${totalProfitPercent}%)\\n`;\n        } else {\n            summaryMessage += `Overall loss: -$${Math.abs(Math.round(totalProfit))} (${totalProfitPercent}%)\\n`;\n        }\n\n        // Get transaction history count\n        try {\n            const historyVar = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: ['stock_transaction_history'],\n                    gameServerId: [gameServerId],\n                    moduleId: [mod.moduleId],\n                    playerId: [player.id]\n                }\n            });\n\n            if (historyVar.data.data.length > 0) {\n                const history = JSON.parse(historyVar.data.data[0].value);\n                const buyCount = history.filter(t => t.type === 'BUY').length;\n                const sellCount = history.filter(t => t.type === 'SELL').length;\n\n                summaryMessage += `\\nTransactions: ${history.length} (${buyCount} buys, ${sellCount} sells)\\n`;\n            }\n        } catch (error) {\n            // Just ignore history errors\n        }\n\n        await player.pm(summaryMessage);\n\n    }\n}\n\nawait main();",
                    "name": "stockportfolio",
                    "description": null,
                    "trigger": "stockportfolio",
                    "helpText": "No help text available",
                    "arguments": []
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === args.stock.toUpperCase());\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${args.stock} not found. Use /market to see available stocks.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate costs using Math.round to ensure we work with integers\n        const subtotal = Math.round(stock.price) * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const totalCost = subtotal + fee;\n\n        // Check if player has enough currency\n        const playerData = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, player.id);\n        const currentBalance = playerData.data.data.currency;\n\n        if (currentBalance < totalCost) {\n            throw new TakaroUserError(`You don't have enough currency. Cost: $${subtotal} + $${fee} fee = $${totalCost}. Your balance: $${currentBalance}`);\n        }\n\n        // Deduct the currency - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerDeductCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: totalCost\n            }\n        );\n\n        // Get player's portfolio or create new one\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        let portfolio;\n        if (portfolioVar.data.data.length === 0) {\n            portfolio = {};\n        } else {\n            portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        }\n\n        // Update portfolio using rounded values for consistency\n        const stockPrice = Math.round(stock.price);\n        if (!portfolio[stock.id]) {\n            portfolio[stock.id] = {\n                shares: amount,\n                averagePrice: stockPrice\n            };\n        } else {\n            const totalShares = portfolio[stock.id].shares + amount;\n            const totalValue = (portfolio[stock.id].shares * portfolio[stock.id].averagePrice) + (amount * stockPrice);\n            portfolio[stock.id].shares = totalShares;\n            portfolio[stock.id].averagePrice = Math.round(totalValue / totalShares);\n        }\n\n        // Save updated portfolio\n        if (portfolioVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_portfolio',\n                value: JSON.stringify(portfolio),\n                gameServerId,\n                moduleId: mod.moduleId,\n                playerId: player.id\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n                value: JSON.stringify(portfolio)\n            });\n        }\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'BUY',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: totalCost,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully bought ${amount} shares of ${stock.id} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Total cost: $${totalCost}\\n`;\n        message += `Current portfolio: ${portfolio[stock.id].shares} shares of ${stock.id}`;\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in buystock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your purchase. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "buystock",
                    "description": null,
                    "trigger": "buystock",
                    "helpText": "Buy shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol ",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to buy",
                            "position": 1
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // If a specific stock ticker is provided, show detailed info for that stock\n    const specificTicker = args.ticker ? args.ticker.toUpperCase() : null;\n\n    if (specificTicker && specificTicker !== \"ALL\") {\n        const stock = stocks.find(s => s.id.toUpperCase() === specificTicker);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${specificTicker} not found. Use /stockinfo without parameters to see all available stocks.`);\n        }\n\n        // Get active event to see if this stock's sector is affected\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let activeEvent = null;\n        let sectorImpact = null;\n\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEvent && activeEvent.sectorImpacts) {\n                    sectorImpact = activeEvent.sectorImpacts.find(impact =>\n                        impact.sectorId === stock.sector\n                    );\n                }\n            } catch (e) {\n                // Ignore parsing errors\n            }\n        }\n\n        // Calculate price change indicators\n        let changeText = '';\n        if (stock.lastPrice) {\n            const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n            const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n            changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n        }\n\n        // Add risk assessment based on volatility without showing the raw value\n        let riskLevel;\n        if (stock.volatility <= 0.05) riskLevel = \"Very Low\";\n        else if (stock.volatility <= 0.10) riskLevel = \"Low\";\n        else if (stock.volatility <= 0.15) riskLevel = \"Moderate\";\n        else if (stock.volatility <= 0.20) riskLevel = \"High\";\n        else riskLevel = \"Very High\";\n\n        // Build detailed stock info message\n        let message = `=== ${stock.id}: ${stock.name} ===\\n\\n`;\n        message += `Sector: ${stock.sector}\\n`;\n        message += `Current Price: $${Math.round(stock.price)}${changeText}\\n`;\n        message += `Risk Level: ${riskLevel}\\n`;\n\n        // Add sector trend info if available from event\n        if (activeEvent && sectorImpact) {\n            const direction = sectorImpact.impact >= 0 ? \"Positive\" : \"Negative\";\n            const strength = Math.abs(sectorImpact.impact);\n            let trend;\n\n            if (strength < 10) trend = \"Slight\";\n            else if (strength < 25) trend = \"Moderate\";\n            else trend = \"Strong\";\n\n            message += `\\nCurrent Trend: ${trend} ${direction} (${activeEvent.name})\\n`;\n            message += `Event: ${activeEvent.description}\\n`;\n        }\n\n        // Add trading guidance based on sector and risk, without mentioning volatility\n        message += `\\nTrading Notes:\\n`;\n\n        if (activeEvent && sectorImpact) {\n            if (sectorImpact.impact > 0) {\n                message += `- Currently bullish due to the ${activeEvent.name} event\\n`;\n            } else {\n                message += `- Currently bearish due to the ${activeEvent.name} event\\n`;\n            }\n        }\n\n        if (riskLevel === \"High\" || riskLevel === \"Very High\") {\n            message += `- Expect significant price fluctuations with this stock\\n`;\n        } else if (riskLevel === \"Low\" || riskLevel === \"Very Low\") {\n            message += `- Typically has stable price movement\\n`;\n        }\n\n        message += `\\nUse /buystock ${stock.id} [amount] to purchase shares`;\n\n        await player.pm(message);\n\n    } else {\n        // No specific ticker provided or ALL specified, show summary of all stocks\n        await player.pm(\"=== STOCK MARKET LISTINGS ===\\n\");\n\n        // Group stocks by sector\n        const stocksBySector = {};\n        stocks.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        // Display stocks by sector\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            let sectorMessage = `\\n--- ${sector} SECTOR ---\\n`;\n\n            sectorStocks.forEach(stock => {\n                // Add price change indicators\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                    changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                // Add risk level based on volatility\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                sectorMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n\n            await player.pm(sectorMessage);\n        }\n\n        // Add legend for risk indicators\n        const legend = \"\\n=== LEGEND ===\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\" +\n            \"Use /stockinfo [ticker] for detailed information about a specific stock\";\n\n        await player.pm(legend);\n    }\n}\n\nawait main();",
                    "name": "stockinfo",
                    "description": null,
                    "trigger": "stockinfo",
                    "helpText": "Shows all available stocks in the market. Use with a ticker symbol (e.g., /stockinfo ticker) to see detailed information about a specific stock.",
                    "arguments": [
                        {
                            "name": "ticker",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "stock ticker or ALL to get detailed information about a specific stock",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRIGGER_EVENT')) {\n        throw new TakaroUserError(\"You don't have permission to trigger market events.\");\n    }\n\n    try {\n        // Get current stock data to check market initialization\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Initialize market if needed\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            await player.pm(\"Market was not initialized. Initializing now...\");\n            return;\n        }\n\n        // Get events from module config\n        const marketEvents = mod.userConfig.marketEvents || [];\n\n        if (marketEvents.length === 0) {\n            throw new TakaroUserError(\"No market events configured in this module.\");\n        }\n\n        // Handle case when no event is specified or \"ALL\" is provided\n        if (!args.EventName || args.EventName.toUpperCase() === \"ALL\") {\n            await player.pm(\"=== AVAILABLE MARKET EVENTS ===\\n\");\n\n            // Group events by category or type if possible\n            const eventCategories = {};\n\n            // Create a simple categorization based on positive/negative impact\n            marketEvents.forEach(event => {\n                let category = \"Mixed\";\n                // Calculate net impact across all sectors\n                const netImpact = event.sectorImpacts.reduce((sum, impact) => sum + impact.impact, 0);\n\n                if (netImpact > 0) category = \"Positive\";\n                else if (netImpact < 0) category = \"Negative\";\n\n                if (!eventCategories[category]) {\n                    eventCategories[category] = [];\n                }\n                eventCategories[category].push(event);\n            });\n\n            // Display events by category\n            for (const [category, events] of Object.entries(eventCategories)) {\n                if (events.length > 0) {\n                    await player.pm(`\\n--- ${category.toUpperCase()} EVENTS ---`);\n\n                    let message = \"\";\n                    events.forEach(event => {\n                        // Format primary sectors affected\n                        const primarySectors = event.sectorImpacts\n                            .filter(impact => Math.abs(impact.impact) >= 15)\n                            .map(impact => {\n                                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                                return `${impact.sectorId} ${direction}${Math.abs(impact.impact)}%`;\n                            })\n                            .join(\", \");\n\n                        message += `${event.id}: ${event.name}\\n`;\n                        message += `   ${event.description}\\n`;\n                        if (primarySectors) {\n                            message += `   Major impacts: ${primarySectors}\\n`;\n                        }\n                        message += \"\\n\";\n                    });\n\n                    await player.pm(message);\n                }\n            }\n\n            await player.pm(\"=== HOW TO USE ===\\nUse `/triggerevent <EventName>` to trigger a specific event (e.g., `/triggerevent TECH_BOOM`)\");\n            return;\n        }\n\n        // Find the requested event\n        const eventId = args.EventName.toUpperCase();\n        const event = marketEvents.find(e => e.id === eventId);\n\n        if (!event) {\n            throw new TakaroUserError(`Event \"${eventId}\" not found. Use /triggerevent without parameters to see all available events.`);\n        }\n\n        // Get necessary variables for managing the event\n        const [activeEventVar, eventStartTimeVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_execution_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_cooldown_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['current_event_duration'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Check if there's an active event we need to cancel\n        let activeEventObj = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEventObj = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEventObj && Object.keys(activeEventObj).length > 0) {\n                    await player.pm(`Cancelling active event \"${activeEventObj.name}\" to trigger new event.`);\n                }\n            } catch (e) {\n                // Invalid event data, will be overwritten\n            }\n        }\n\n        // Generate a random duration for the event\n        const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n        // Update or create all event-related variables\n        const updatePromises = [];\n\n        // Save or update the random duration\n        if (eventDurationVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                    value: randomDuration.toString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'current_event_duration',\n                    value: randomDuration.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the event counter to 0\n        if (eventCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the cooldown counter\n        if (cooldownCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update active event\n        if (activeEventVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                    value: JSON.stringify(event)\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: JSON.stringify(event),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update event start time\n        if (eventStartTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update last event time\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (lastEventTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all updates to complete\n        await Promise.all(updatePromises);\n\n        // Check if there are online players to announce the event\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            // Format sector impacts for announcement\n            let impactText = \"\";\n            for (const impact of event.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n            }\n\n            const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${event.name}\\n${event.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /markets to see opportunities!`;\n\n            // Split the message if it's too long\n            const maxLength = 400; // Safe limit for most games\n            for (let i = 0; i < message.length; i += maxLength) {\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message: message.substring(i, i + maxLength)\n                });\n            }\n        }\n\n        await player.pm(`Successfully triggered the \"${event.name}\" market event for ${randomDuration} cycles!`);\n    } catch (error) {\n        // If something goes wrong, log it and let the player know\n        console.log(`Error in triggerEvent: ${error.message}`);\n        throw new TakaroUserError(`Error triggering event: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Store the stocks data\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_data',\n            value: JSON.stringify(stocks),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize last event time to now\n        await takaro.variable.variableControllerCreate({\n            key: 'last_market_event_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize event start time variable\n        await takaro.variable.variableControllerCreate({\n            key: 'event_start_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize active event (empty string means no active event)\n        await takaro.variable.variableControllerCreate({\n            key: 'active_market_event',\n            value: '',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Mark market as initialized\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_initialized',\n            value: 'true',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Announce market initialization to online players\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /markets to see available stocks and /buystock to start investing.\";\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message\n            });\n        }\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "triggerevent",
                    "description": null,
                    "trigger": "triggerevent",
                    "helpText": "Shows all available market events when run without parameters. Use with an event name (e.g., /triggerevent TECH_BOOM) to trigger a specific market event.",
                    "arguments": [
                        {
                            "name": "EventName",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "Event name to trigger a specific market event",
                            "position": 0
                        }
                    ]
                }
            ],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n\n    // Get the Discord channel ID from module configuration\n    // IMPORTANT: You need to add 'marketNewsChannelId' to your module's configSchema and set its value.\n    const discordChannelId = mod.userConfig.marketNewsChannelId;\n\n    if (!discordChannelId) {\n        takaro.log.info('Market news Discord channel ID (marketNewsChannelId) not configured in module settings. Skipping Discord messages.');\n    }\n\n    // Check for online players\n    const currentPlayers = (await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    })).data.meta;\n\n    if (currentPlayers.total === 0) {\n        takaro.log.info('Skipping daily market report: No players online.');\n        return; // No players online, skip the market news\n    }\n\n    // Get current stock data (which should include lastPrice)\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        takaro.log.warn('Skipping daily market report: Market data variable not found.');\n        return; // Market not initialized yet\n    }\n\n    let stocks;\n    try {\n        stocks = JSON.parse(marketDataVar.data.data[0].value);\n        if (!Array.isArray(stocks)) {\n            throw new Error('Parsed market data is not an array.');\n        }\n    } catch (error) {\n        takaro.log.error(`Failed to parse stock_market_data: ${error}`);\n        return; // Invalid market data\n    }\n\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Ensure activeEvent is an object with data, not an empty string or empty object\n            if (typeof activeEvent !== 'object' || activeEvent === null || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (error) {\n            takaro.log.warn(`Failed to parse active_market_event: ${error}`);\n            activeEvent = null; // Continue without event info if parsing fails\n        }\n    }\n\n    // --- Message 1: Header and active event ---\n    let gameMessage1 = \"==== DAILY MARKET REPORT ====\\n\";\n    let discordMessage1 = \"**==== DAILY MARKET REPORT ====**\\n\"; // Discord version with Markdown\n\n    if (activeEvent && activeEvent.name && activeEvent.description) {\n        const eventText = `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n${activeEvent.description}\\n`;\n        gameMessage1 += eventText;\n        discordMessage1 += eventText;\n    } else {\n        const noEventText = '\\nNo active market events today.\\n';\n        gameMessage1 += noEventText;\n        discordMessage1 += noEventText;\n    }\n\n    // Send first part of the report to game server\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage1\n    }).catch(err => takaro.log.error(`Failed to send game message 1: ${err}`));\n\n    // Send first part of the report to Discord\n    if (discordChannelId) {\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessage1\n        }).catch(err => takaro.log.error(`Failed to send Discord message 1: ${err.message || err}`));\n    }\n\n    // --- Calculate stock performance using stock.price and stock.lastPrice ---\n    const stocksWithPerformance = stocks.map(stock => {\n        let change = 0;\n        let percentChange = 0;\n        let changeSymbol = 'â†’'; // Default: No change or insufficient data\n\n        if (typeof stock.price === 'number' && typeof stock.lastPrice === 'number' && stock.lastPrice !== 0) {\n            change = stock.price - stock.lastPrice;\n            percentChange = (change / stock.lastPrice) * 100;\n            if (percentChange > 0.05) {\n                changeSymbol = 'â†‘';\n            } else if (percentChange < -0.05) {\n                changeSymbol = 'â†“';\n            }\n        } else if (typeof stock.price === 'number' && stock.lastPrice === undefined) {\n            changeSymbol = 'ðŸ†•';\n            percentChange = 0;\n        }\n        return {\n            ...stock,\n            change,\n            percentChange,\n            changeSymbol\n        };\n    });\n\n    // --- Group by sector ---\n    const sectorPerformance = {};\n    stocksWithPerformance.forEach(stock => {\n        const sectorId = stock.sector || 'Uncategorized';\n        if (!sectorPerformance[sectorId]) {\n            sectorPerformance[sectorId] = {\n                stocks: [],\n                totalPercentChange: 0,\n                count: 0\n            };\n        }\n        sectorPerformance[sectorId].stocks.push(stock);\n        if (typeof stock.percentChange === 'number' && isFinite(stock.percentChange)) {\n            sectorPerformance[sectorId].totalPercentChange += stock.percentChange;\n            sectorPerformance[sectorId].count++;\n        }\n    });\n\n    // --- Calculate average sector performance ---\n    for (const sectorId in sectorPerformance) {\n        const sectorData = sectorPerformance[sectorId];\n        if (sectorData.count > 0) {\n            sectorData.avgPerformance = sectorData.totalPercentChange / sectorData.count;\n        } else {\n            sectorData.avgPerformance = 0;\n        }\n    }\n\n    const sortedSectors = Object.entries(sectorPerformance)\n        .sort(([, a], [, b]) => b.avgPerformance - a.avgPerformance);\n\n    // --- Message 2: Sector performance ---\n    let gameMessage2 = \"\\n=== SECTOR PERFORMANCE ===\\n\";\n    let discordMessage2 = \"\\n**=== SECTOR PERFORMANCE ===**\\n\"; // Discord version\n\n    if (sortedSectors.length > 0) {\n        sortedSectors.forEach(([sectorId, sectorData]) => {\n            const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n            const line = `${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n            gameMessage2 += line;\n            discordMessage2 += line;\n        });\n    } else {\n        const noDataText = \"No sector performance data available.\\n\";\n        gameMessage2 += noDataText;\n        discordMessage2 += noDataText;\n    }\n\n    // Send sector performance report to game server\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage2\n    }).catch(err => takaro.log.error(`Failed to send game message 2: ${err}`));\n\n    // Send sector performance report to Discord\n    if (discordChannelId) {\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessage2\n        }).catch(err => takaro.log.error(`Failed to send Discord message 2: ${err.message || err}`));\n    }\n\n    // --- Message 3: Top and Worst performers ---\n    const validPerformers = stocksWithPerformance.filter(s => typeof s.percentChange === 'number' && isFinite(s.percentChange));\n    validPerformers.sort((a, b) => b.percentChange - a.percentChange);\n\n    let gameMessage3 = \"\";\n    let discordMessage3 = \"\";\n\n    const topPerformersTitleGame = \"\\nðŸ”¥ TOP PERFORMERS ðŸ”¥\\n\";\n    const topPerformersTitleDiscord = \"\\n**ðŸ”¥ TOP PERFORMERS ðŸ”¥**\\n\";\n    gameMessage3 += topPerformersTitleGame;\n    discordMessage3 += topPerformersTitleDiscord;\n\n    if (validPerformers.length > 0) {\n        for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n            const stock = validPerformers[i];\n            const line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            gameMessage3 += line;\n            discordMessage3 += line;\n        }\n    } else {\n        const noTopText = \"No top performers today.\\n\";\n        gameMessage3 += noTopText;\n        discordMessage3 += noTopText;\n    }\n\n    const worstPerformersTitleGame = \"\\nðŸ“‰ WORST PERFORMERS ðŸ“‰\\n\";\n    const worstPerformersTitleDiscord = \"\\n**ðŸ“‰ WORST PERFORMERS ðŸ“‰**\\n\";\n    gameMessage3 += worstPerformersTitleGame;\n    discordMessage3 += worstPerformersTitleDiscord;\n\n    if (validPerformers.length > 0) {\n        const worstStartIndex = Math.max(0, validPerformers.length - 3);\n        for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n            const stock = validPerformers[i];\n            const line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            gameMessage3 += line;\n            discordMessage3 += line;\n        }\n    } else {\n        const noWorstText = \"No worst performers today.\\n\";\n        gameMessage3 += noWorstText;\n        discordMessage3 += noWorstText;\n    }\n\n    // Send top/worst performers report to game server\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage3\n    }).catch(err => takaro.log.error(`Failed to send game message 3: ${err}`));\n\n    // Send top/worst performers report to Discord\n    if (discordChannelId) {\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessage3\n        }).catch(err => takaro.log.error(`Failed to send Discord message 3: ${err.message || err}`));\n    }\n\n    takaro.log.info('Daily market report sent successfully (game server and potentially Discord).');\n}\n\nawait main();",
                    "name": "marketnews",
                    "description": null,
                    "temporalValue": "1 */1 * * *"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    try {\n        const { gameServerId, module: mod } = data;\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Check if market is initialized\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return; // Exit after initialization\n        }\n\n        // Get active market event\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event start time\n        const eventStartTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_start_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event execution counter\n        const eventCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_execution_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event cooldown counter\n        const cooldownCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_cooldown_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let eventCounter = 0;\n        if (eventCounterVar.data.data.length > 0) {\n            eventCounter = parseInt(eventCounterVar.data.data[0].value, 10);\n        }\n\n        let cooldownCounter = 0;\n        if (cooldownCounterVar.data.data.length > 0) {\n            cooldownCounter = parseInt(cooldownCounterVar.data.data[0].value, 10);\n        }\n\n        // Get event duration\n        const eventDurationVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['current_event_duration'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Use stored random duration if available, otherwise use defaultEventDuration\n        let eventDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        if (eventDurationVar.data.data.length > 0) {\n            eventDuration = parseInt(eventDurationVar.data.data[0].value, 10);\n        }\n\n        let activeEvent = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                // If it's an empty string, treat as no active event\n                if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                    activeEvent = null;\n                }\n            } catch (e) {\n                // In case of parsing error, consider no active event\n                activeEvent = null;\n            }\n        }\n\n        // Check if the current event should end and increment counter\n        if (activeEvent) {\n            // Increment the event execution counter\n            eventCounter++;\n\n            // Update or create the counter\n            if (eventCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: eventCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: eventCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n\n            // End the event if counter reached duration\n            if (eventCounter >= eventDuration) {\n                // Clear the active event\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: ''\n                    });\n                }\n\n                // Reset counter to 0\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                // Reset cooldown counter to 0 to begin cooldown period\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_cooldown_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Announce the end of the event to all online players\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    const message = `ðŸ“ˆ MARKET UPDATE ðŸ“‰\\n\\nThe \"${activeEvent.name}\" event has ended. Markets are returning to normal conditions.`;\n\n                    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                        message: message\n                    });\n                }\n\n                // Reset active event\n                activeEvent = null;\n            }\n        } else {\n            // No active event, increment cooldown counter\n            cooldownCounter++;\n\n            // Update or create the cooldown counter\n            if (cooldownCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: cooldownCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: cooldownCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n        }\n\n        // Get last event time for event frequency calculation\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        const eventFrequency = (mod.userConfig && mod.userConfig.eventFrequency) || 10;\n        let shouldTriggerEvent = false;\n\n        // Only trigger a new event if:\n        // 1. There's no active event \n        // 2. We have passed the cooldown period (cooldownCounter >= eventFrequency)\n        if (!activeEvent && cooldownCounter >= eventFrequency) {\n            // Base chance to trigger an event\n            shouldTriggerEvent = Math.random() < 0.5; // 50% chance\n\n            // Force an event if we're well past the cooldown period (2x frequency)\n            if (cooldownCounter >= eventFrequency * 2) {\n                shouldTriggerEvent = true;\n            }\n        }\n\n        // If we should trigger a new event, select a random one\n        if (shouldTriggerEvent) {\n            const events = (mod.userConfig && mod.userConfig.marketEvents) || [];\n            if (events.length > 0) {\n                const randomEvent = events[Math.floor(Math.random() * events.length)];\n                activeEvent = randomEvent;\n\n                // Generate a random duration between 1 and defaultEventDuration\n                const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n                const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n                // Save the random duration\n                if (eventDurationVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                        value: randomDuration.toString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'current_event_duration',\n                        value: randomDuration.toString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Reset the event counter to 0\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Reset the cooldown counter\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                // Update active event\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: JSON.stringify(activeEvent)\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'active_market_event',\n                        value: JSON.stringify(activeEvent),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Update event start time\n                if (eventStartTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_start_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Update last event time\n                if (lastEventTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'last_market_event_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Announce the event to all online players\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    // Format sector impacts for announcement\n                    let impactText = \"\";\n                    for (const impact of activeEvent.sectorImpacts) {\n                        const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                        impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n                    }\n\n                    const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${activeEvent.name}\\n${activeEvent.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /market to see opportunities!`;\n\n                    // Split the message if it's too long\n                    const maxLength = 400; // Safe limit for most games\n                    for (let i = 0; i < message.length; i += maxLength) {\n                        await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                            message: message.substring(i, i + maxLength)\n                        });\n                    }\n                }\n            }\n        }\n\n        // Get stocks\n        if (!marketDataVar.data.data[0] || !marketDataVar.data.data[0].value) {\n            // Re-initialize market if value is missing\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        let stocks;\n        try {\n            stocks = JSON.parse(marketDataVar.data.data[0].value);\n            if (!Array.isArray(stocks)) {\n                throw new Error(\"Parsed stocks data is not an array\");\n            }\n        } catch (e) {\n            // Re-initialize market if data is corrupt\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        const significantChanges = [];\n\n        // Update each stock price\n        stocks.forEach(stock => {\n            // Save the current price as lastPrice for change tracking\n            if (!stock.lastPrice) {\n                stock.lastPrice = stock.price;\n            } else {\n                stock.lastPrice = stock.price;\n            }\n\n            // Calculate base price change based on volatility\n            // Using a more normalized random approach\n            // Math.random() * 2 - 1 gives a value between -1 and 1\n            const randomFactor = Math.random() * 2 - 1;\n            const baseChangePercent = randomFactor * stock.volatility;\n            let totalChangePercent = baseChangePercent;\n\n            // Apply active event effects if any\n            if (activeEvent) {\n                const sectorImpact = activeEvent.sectorImpacts.find(impact => impact.sectorId === stock.sector);\n                if (sectorImpact) {\n                    // Convert impact percentage to decimal and apply a random factor\n                    // to create varied effects within each sector\n                    const eventImpactPercentage = sectorImpact.impact; // This is already a percentage\n                    const eventImpactDecimal = eventImpactPercentage / 100; // Convert to decimal\n                    const randomImpactFactor = 0.5 + Math.random(); // Between 0.5 and 1.5\n                    const eventImpact = eventImpactDecimal * randomImpactFactor;\n\n                    // Add the event impact to the total change percent\n                    totalChangePercent += eventImpact;\n                }\n            }\n\n            // Apply the price change\n            const oldPrice = stock.price;\n            const priceChange = stock.price * totalChangePercent;\n            stock.price = Math.max(1, stock.price + priceChange);\n\n            // Check if this is a significant change\n            const changeThreshold = ((mod.userConfig && mod.userConfig.priceAlertThreshold) || 10) / 100;\n            const percentChange = (stock.price - stock.lastPrice) / stock.lastPrice;\n\n            if (Math.abs(percentChange) > changeThreshold) {\n                significantChanges.push({\n                    ...stock,\n                    changePercent: percentChange * 100\n                });\n            }\n        });\n\n        // Save updated prices\n        await takaro.variable.variableControllerUpdate(marketDataVar.data.data[0].id, {\n            value: JSON.stringify(stocks)\n        });\n\n        // Broadcast major changes to all players\n        if (significantChanges.length > 0) {\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                // Sort by absolute change percentage\n                significantChanges.sort((a, b) => Math.abs(b.changePercent) - Math.abs(a.changePercent));\n\n                // Take top 3 most significant changes\n                const topChanges = significantChanges.slice(0, Math.min(3, significantChanges.length));\n\n                // Formulate message about big market changes\n                let message = \"ðŸ“Š STOCK MARKET ALERT ðŸ“Š\\n\";\n                topChanges.forEach(stock => {\n                    const changeDir = stock.changePercent > 0 ? \"up\" : \"down\";\n                    const changePercent = Math.abs(Math.round(stock.changePercent));\n\n                    message += `${stock.id} (${stock.sector}): ${changeDir} ${changePercent}% to $${Math.round(stock.price)}!\\n`;\n                });\n\n                if (activeEvent) {\n                    message += `\\nCurrent market event: ${activeEvent.name}`;\n                }\n\n                // Send the message\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            }\n        }\n    } catch (error) {\n        // If something goes wrong, log it\n        console.log(`Error in updateStockPrices: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            await Promise.allSettled(createPromises);\n        }\n\n        // Only announce if we had to create at least the stock data (indicating a new market)\n        if (marketDataVar.data.data.length === 0) {\n            // Announce market initialization to online players\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /market to see available stocks and /buy to start investing.\";\n\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            }\n        }\n    } catch (error) {\n        // Log the error but don't throw, so the cronjob can continue\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "updatestockprices",
                    "description": null,
                    "temporalValue": "0 */1 * * *"
                }
            ],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Allows the player to view market prices and their portfolio",
                    "permission": "STOCK_MARKET_USE",
                    "friendlyName": "Use Stock Market"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows the player to buy and sell stocks",
                    "permission": "STOCK_MARKET_TRADE",
                    "friendlyName": "Trade Stocks"
                },
                {
                    "canHaveCount": false,
                    "description": "VIP status that reduces transaction fees",
                    "permission": "STOCK_MARKET_BROKER",
                    "friendlyName": "Stock Broker"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows admins to manually trigger market events",
                    "permission": "STOCK_MARKET_TRIGGER_EVENT",
                    "friendlyName": "Trigger Market Events"
                }
            ]
        },
        {
            "tag": "0.1.11",
            "description": "**Stock Market: A Dynamic Virtual Trading System**\n\nCreate an immersive economic experience with this comprehensive stock market module that lets players invest, trade, and react to market events.\n\n**Market Features:**\n\n![Market Summary](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stocks.png)\n\n* **Multiple Economic Sectors:** Configure various industry sectors (Resource Extraction, Manufacturing, Defense, etc.) each with their own market dynamics.\n* **Realistic Stock Behavior:** Stocks have configurable volatility, sector-based pricing, and react differently to market events.\n* **Dynamic Market Events:** Random or admin-triggered events like \"Horde Night Approaching\" or \"Societal Collapse Setback\" impact different sectors in realistic ways.\n\n![Market Events](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_events.png)\n\n**Trading System:**\n\n* **Buy & Sell Shares:** Players can purchase stocks and sell them later for profit or loss.\n* **Transaction Fees:** Configurable fee percentage on all trades creates a realistic market economy.\n* **VIP Benefits:** Special permissions for designated \"Stock Brokers\" who receive fee discounts.\n\n![Buy Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_buy.png)\n\nPlayers can track price changes and sell at the right moment to maximize profits or minimize losses.\n\n![Sell Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sell.png)\n\n**Player Portfolio:**\n\n* **Portfolio Tracking:** Players can view their holdings, average purchase prices, and current profit/loss.\n* **Transaction History:** System tracks all buy/sell transactions for each player.\n* **Summary Statistics:** See overall portfolio performance and value across all holdings.\n\n![Portfolio View](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockportfolio.png)\n\n**Market Information:**\n\n* **Detailed Stock Info:** Players can research specific stocks, including risk levels and sector trends.\n* **Industry Filters:** View stocks by specific sectors to better understand market segments.\n* **Market Alerts:** Server-wide notifications for significant price changes keep players engaged.\n\n![Market Alerts](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockpricechange.png)\n\n**Configuration Options:**\n\n* **Sectors & Stocks:** Define your own market sectors and individual stocks with customizable starting prices and volatility.\n* **Market Events:** Create unique events with specific sector impacts to drive market dynamics.\n* **Transaction Settings:** Configure fee percentages, VIP discounts, and alert thresholds.\n* **Event Frequency:** Control how often random market events occur and how long they last.\n\n![Configuration](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_config.png)\n![Sectors](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sectors.png)\n\n**Commands:**\n\n* `/markets [industry]` - View all stocks or filter by industry\n* `/stockinfo [ticker]` - Get detailed information about a specific stock\n* `/buystock <ticker> <amount>` - Purchase shares of a stock\n* `/sellstock <ticker> <amount>` - Sell shares from your portfolio\n* `/stockportfolio` - View your current holdings and performance\n* `/triggerevent [event]` - Admin command to trigger specific market events\n\nWho says the apocalypse can't have a thriving economy? Now players can stress about both zombie hordes AND their Duke's Casino Tokens dropping 40% after a market event! As one trader put it: \"I used to check my 401K daily, and now I check my AMMO stock before every Blood Moon. Some habits die harder than zombies.\"",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sectors\":{\"type\":\"array\",\"title\":\"Wasteland Economic Sectors\",\"description\":\"Define economic sectors relevant to survival in Navezgane\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Sector ID (e.g., RESOURCES)\"},\"name\":{\"type\":\"string\",\"description\":\"Sector name (e.g., Resource Extraction)\"}}},\"default\":[{\"id\":\"RESOURCES\",\"name\":\"Resource Extraction\"},{\"id\":\"FOSSIL_FUELS\",\"name\":\"Fossil Fuel Extraction (High Volatility)\"},{\"id\":\"MANUFACTURING\",\"name\":\"Manufacturing & Crafting\"},{\"id\":\"VOLATILE_CHEMICALS\",\"name\":\"Volatile Chemicals (High Volatility)\"},{\"id\":\"DEFENSE\",\"name\":\"Defense & Fortifications\"},{\"id\":\"ADVANCED_WEAPONRY\",\"name\":\"Advanced Weaponry (High Volatility)\"},{\"id\":\"SURVIVAL\",\"name\":\"Survival Goods\"},{\"id\":\"PHARMACEUTICALS\",\"name\":\"Pharmaceuticals (High Volatility)\"},{\"id\":\"TRADE\",\"name\":\"Trade & Currency\"},{\"id\":\"GUILD_OPERATIONS\",\"name\":\"Trader Guild Operations (High Volatility)\"}]},\"stocks\":{\"type\":\"array\",\"title\":\"Wasteland Stocks\",\"description\":\"List of stocks representing Navezgane entities and resources\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Stock ticker symbol (e.g., NMC)\"},\"name\":{\"type\":\"string\",\"description\":\"Entity/Resource name\"},\"sector\":{\"type\":\"string\",\"description\":\"Sector ID this stock belongs to\"},\"initialPrice\":{\"type\":\"number\",\"description\":\"Starting price in Dukes\",\"minimum\":1},\"volatility\":{\"type\":\"number\",\"description\":\"Base volatility percentage (5 = 5%)\",\"minimum\":1,\"maximum\":60}}},\"default\":[{\"id\":\"NMC\",\"name\":\"Navezgane Mining Co.\",\"sector\":\"RESOURCES\",\"initialPrice\":50,\"volatility\":15},{\"id\":\"NIOM\",\"name\":\"Navezgane Iron Ore Mining Co.\",\"sector\":\"RESOURCES\",\"initialPrice\":55,\"volatility\":16},{\"id\":\"NLMC\",\"name\":\"Navezgane Lead Mining Co.\",\"sector\":\"RESOURCES\",\"initialPrice\":45,\"volatility\":14},{\"id\":\"WOOD\",\"name\":\"Wasteland Lumberjacks\",\"sector\":\"RESOURCES\",\"initialPrice\":20,\"volatility\":8},{\"id\":\"SHALE\",\"name\":\"Oil Shale Extractors\",\"sector\":\"FOSSIL_FUELS\",\"initialPrice\":40,\"volatility\":45},{\"id\":\"FORGE\",\"name\":\"Forge Ahead Metals\",\"sector\":\"MANUFACTURING\",\"initialPrice\":75,\"volatility\":12},{\"id\":\"TOOLS\",\"name\":\"Working Stiff Tools\",\"sector\":\"MANUFACTURING\",\"initialPrice\":60,\"volatility\":10},{\"id\":\"AIA\",\"name\":\"A1 Auto\",\"sector\":\"MANUFACTURING\",\"initialPrice\":40,\"volatility\":14},{\"id\":\"AMC\",\"name\":\"Atlas Metal Company\",\"sector\":\"MANUFACTURING\",\"initialPrice\":65,\"volatility\":13},{\"id\":\"COC\",\"name\":\"COC Chemicals\",\"sector\":\"VOLATILE_CHEMICALS\",\"initialPrice\":55,\"volatility\":50},{\"id\":\"MECH\",\"name\":\"JunkTech Robotics\",\"sector\":\"MANUFACTURING\",\"initialPrice\":110,\"volatility\":25},{\"id\":\"BUILD\",\"name\":\"Barricade Builders\",\"sector\":\"DEFENSE\",\"initialPrice\":45,\"volatility\":9},{\"id\":\"ZBI\",\"name\":\"Zombie Bashers Inc.\",\"sector\":\"DEFENSE\",\"initialPrice\":85,\"volatility\":17},{\"id\":\"TTC\",\"name\":\"Turret Tracker Co.\",\"sector\":\"ADVANCED_WEAPONRY\",\"initialPrice\":125,\"volatility\":60},{\"id\":\"AMMO\",\"name\":\"AmmoNation Surplus\",\"sector\":\"DEFENSE\",\"initialPrice\":90,\"volatility\":18},{\"id\":\"SHM\",\"name\":\"Shotgun Messiah\",\"sector\":\"DEFENSE\",\"initialPrice\":120,\"volatility\":30},{\"id\":\"SHAM\",\"name\":\"Shamway Foods\",\"sector\":\"SURVIVAL\",\"initialPrice\":30,\"volatility\":5},{\"id\":\"SSHM\",\"name\":\"Super Shamway\",\"sector\":\"SURVIVAL\",\"initialPrice\":32,\"volatility\":4},{\"id\":\"MEDS\",\"name\":\"Pop-N-Pills Medical\",\"sector\":\"PHARMACEUTICALS\",\"initialPrice\":100,\"volatility\":48},{\"id\":\"SAVG\",\"name\":\"Savage Country\",\"sector\":\"SURVIVAL\",\"initialPrice\":35,\"volatility\":6},{\"id\":\"CRKB\",\"name\":\"Crack-A-Book\",\"sector\":\"SURVIVAL\",\"initialPrice\":80,\"volatility\":16},{\"id\":\"TRADE\",\"name\":\"Trader Guild Network\",\"sector\":\"GUILD_OPERATIONS\",\"initialPrice\":150,\"volatility\":40},{\"id\":\"PNG\",\"name\":\"Pass-N-Gas\",\"sector\":\"TRADE\",\"initialPrice\":50,\"volatility\":11},{\"id\":\"BOB\",\"name\":\"Trader Bob's\",\"sector\":\"TRADE\",\"initialPrice\":160,\"volatility\":9},{\"id\":\"HUGH\",\"name\":\"Trader Hugh's\",\"sector\":\"TRADE\",\"initialPrice\":170,\"volatility\":12},{\"id\":\"JEN\",\"name\":\"Trader Jen's\",\"sector\":\"TRADE\",\"initialPrice\":180,\"volatility\":10},{\"id\":\"JOEL\",\"name\":\"Trader Joel's\",\"sector\":\"TRADE\",\"initialPrice\":175,\"volatility\":11},{\"id\":\"REKT\",\"name\":\"Trader Rekt's\",\"sector\":\"TRADE\",\"initialPrice\":165,\"volatility\":6},{\"id\":\"DUKES\",\"name\":\"Duke's Casino Tokens\",\"sector\":\"TRADE\",\"initialPrice\":1,\"volatility\":3}]},\"marketEvents\":{\"type\":\"array\",\"title\":\"Wasteland Events\",\"description\":\"Events impacting the Navezgane economy\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Unique event ID\"},\"name\":{\"type\":\"string\",\"description\":\"Name of the event\"},\"description\":{\"type\":\"string\",\"description\":\"Description of the event's market effect\"},\"sectorImpacts\":{\"type\":\"array\",\"description\":\"How each sector is affected\",\"items\":{\"type\":\"object\",\"properties\":{\"sectorId\":{\"type\":\"string\",\"description\":\"Sector ID\"},\"impact\":{\"type\":\"number\",\"description\":\"Percentage impact (-99 = -99%)\",\"minimum\":-99,\"maximum\":75}}}}}},\"default\":[{\"id\":\"HORDE_INCOMING\",\"name\":\"Horde Night Approaching\",\"description\":\"Increased Zed activity signals the Blood Moon. General defense and manufacturing stocks are up.\",\"sectorImpacts\":[{\"sectorId\":\"DEFENSE\",\"impact\":20},{\"sectorId\":\"MANUFACTURING\",\"impact\":10},{\"sectorId\":\"SURVIVAL\",\"impact\":10},{\"sectorId\":\"TRADE\",\"impact\":-15}]},{\"id\":\"STABLE_ECONOMY\",\"name\":\"Period of Stability\",\"description\":\"A rare period of peace has settled over the wasteland. Low-risk assets and basic trade are flourishing.\",\"sectorImpacts\":[{\"sectorId\":\"TRADE\",\"impact\":25},{\"sectorId\":\"SURVIVAL\",\"impact\":20},{\"sectorId\":\"MANUFACTURING\",\"impact\":5},{\"sectorId\":\"RESOURCES\",\"impact\":5}]},{\"id\":\"GENERAL_PANIC\",\"name\":\"General Market Panic\",\"description\":\"A major setback reminds everyone how fragile survival is. Fear grips the entire market, causing a broad downturn.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-25},{\"sectorId\":\"MANUFACTURING\",\"impact\":-30},{\"sectorId\":\"DEFENSE\",\"impact\":-30},{\"sectorId\":\"SURVIVAL\",\"impact\":-20},{\"sectorId\":\"TRADE\",\"impact\":-40},{\"sectorId\":\"FOSSIL_FUELS\",\"impact\":-35},{\"sectorId\":\"VOLATILE_CHEMICALS\",\"impact\":-45},{\"sectorId\":\"ADVANCED_WEAPONRY\",\"impact\":-50},{\"sectorId\":\"PHARMACEUTICALS\",\"impact\":-25},{\"sectorId\":\"GUILD_OPERATIONS\",\"impact\":-40}]},{\"id\":\"ADVANCED_WEAPONRY_COLLAPSE\",\"name\":\"Turret AI Virus\",\"description\":\"A malicious code is spreading through advanced turret systems, causing them to malfunction violently. TTC's stock has been obliterated.\",\"sectorImpacts\":[{\"sectorId\":\"ADVANCED_WEAPONRY\",\"impact\":-99},{\"sectorId\":\"DEFENSE\",\"impact\":-10}]},{\"id\":\"VOLATILE_CHEMICALS_COLLAPSE\",\"name\":\"Irreversible Contamination\",\"description\":\"The COC chemical disaster is worse than imagined. The company is bankrupt and its assets are worthless.\",\"sectorImpacts\":[{\"sectorId\":\"VOLATILE_CHEMICALS\",\"impact\":-99},{\"sectorId\":\"MANUFACTURING\",\"impact\":-20}]},{\"id\":\"FOSSIL_FUELS_COLLAPSE\",\"name\":\"Clean Energy Breakthrough\",\"description\":\"A scavenger has replicated a pre-collapse fusion generator. The demand for oil shale has evaporated overnight.\",\"sectorImpacts\":[{\"sectorId\":\"FOSSIL_FUELS\",\"impact\":-99},{\"sectorId\":\"MANUFACTURING\",\"impact\":25}]},{\"id\":\"PHARMACEUTICALS_COLLAPSE\",\"name\":\"The Cure is Real\",\"description\":\"A cure for the zombie infection is real and easily replicated. The panic is over, and with it, the market for Pop-N-Pills.\",\"sectorImpacts\":[{\"sectorId\":\"PHARMACEUTICALS\",\"impact\":-99},{\"sectorId\":\"SURVIVAL\",\"impact\":-50}]},{\"id\":\"GUILD_OPERATIONS_COLLAPSE\",\"name\":\"Trader Guild Dissolved\",\"description\":\"The Trader's Guild has been formally dissolved. Its centralized network is gone, and its stock is now worthless paper.\",\"sectorImpacts\":[{\"sectorId\":\"GUILD_OPERATIONS\",\"impact\":-99},{\"sectorId\":\"TRADE\",\"impact\":-30}]}]},\"eventFrequency\":{\"title\":\"Event Frequency\",\"type\":\"number\",\"description\":\"Average number of update cycles between market events (0 to disable). Depends on mod's update frequency (e.g., per in-game hour?).\",\"default\":8,\"minimum\":1},\"defaultEventDuration\":{\"title\":\"Default Event Duration\",\"type\":\"number\",\"description\":\"Default number of update cycles an event lasts.\",\"default\":3,\"minimum\":1,\"maximum\":96},\"transactionFee\":{\"title\":\"Transaction Fee (Dukes Tax)\",\"type\":\"number\",\"description\":\"Percentage fee charged on all buy/sell transactions (5 = 5%)\",\"default\":3,\"minimum\":0,\"maximum\":25},\"vipDiscount\":{\"title\":\"Trader's Favor Discount\",\"type\":\"number\",\"description\":\"Percentage discount on transaction fees for players with 'STOCK_MARKET_BROKER' permission (50 = 50%)\",\"default\":50,\"minimum\":0,\"maximum\":100},\"priceAlertThreshold\":{\"title\":\"Price Alert Threshold\",\"type\":\"number\",\"description\":\"Percentage change that triggers a market alert (15 = 15%)\",\"default\":15,\"minimum\":5,\"maximum\":50},\"marketNewsChannelId\":{\"title\":\"Discord Channel ID (for Market News)\",\"type\":\"string\",\"description\":\"The ID of the Discord channel where market news messages should be posted. Leave empty to disable.\",\"default\":\"\"}},\"additionalProperties\":false}",
            "uiSchema": "{\"sectors\":{\"items\":{\"ui:order\":[\"id\",\"name\"]}},\"stocks\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"sector\",\"initialPrice\",\"volatility\"]}},\"marketEvents\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"description\",\"sectorImpacts\"],\"sectorImpacts\":{\"items\":{\"ui:order\":[\"sectorId\",\"impact\"]}}}},\"transactionFee\":{\"ui:widget\":\"range\"},\"vipDiscount\":{\"ui:widget\":\"range\"},\"eventFrequency\":{\"ui:help\":\"Set to 0 to disable random events\"},\"priceAlertThreshold\":{\"ui:widget\":\"range\"}}",
            "commands": [
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Handle the industry argument - use \"ALL\" as a special value to show all industries\n    const industryFilter = args.Industry ? args.Industry.toUpperCase() : \"ALL\";\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    // If market data doesn't exist, try to initialize it\n    if (marketDataVar.data.data.length === 0) {\n        const initialized = await initializeMarketIfNeeded(gameServerId, mod);\n        if (!initialized) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        // Get the freshly initialized market data\n        const refreshedMarketData = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (refreshedMarketData.data.data.length === 0) {\n            throw new TakaroUserError(\"There was an issue initializing the stock market. Please try again later.\");\n        }\n\n        // Continue with the refreshed data\n        await displayMarketSummary(player, gameServerId, mod, refreshedMarketData.data.data[0], industryFilter);\n    } else {\n        // Market data exists, display it\n        await displayMarketSummary(player, gameServerId, mod, marketDataVar.data.data[0], industryFilter);\n    }\n}\n\n// Display the market summary to the player\nasync function displayMarketSummary(player, gameServerId, mod, marketDataVariable, industryFilter) {\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Handle empty string or empty object\n            if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (e) {\n            // In case of parsing error\n            activeEvent = null;\n        }\n    }\n\n    const stocks = JSON.parse(marketDataVariable.value);\n\n    // Get all available industries for reference\n    const availableIndustries = [...new Set(stocks.map(stock => stock.sector))];\n\n    // If industry filter is provided and not \"ALL\", check if it's valid\n    if (industryFilter !== \"ALL\") {\n        // Check if the industry exists\n        const industryExists = availableIndustries.includes(industryFilter);\n\n        if (!industryExists) {\n            throw new TakaroUserError(`Industry \"${industryFilter}\" not found. Available industries: ${availableIndustries.join(', ')}\\nUse \"ALL\" to view all industries.`);\n        }\n    }\n\n    // Send header message\n    let headerMessage = \"=== STOCK MARKET SUMMARY ===\\n\";\n\n    // If filtering by industry, mention it in the header\n    if (industryFilter !== \"ALL\") {\n        headerMessage = `=== ${industryFilter} INDUSTRY ===\\n`;\n    }\n\n    // If there's an active event, include it in the header\n    if (activeEvent) {\n        headerMessage += `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n`;\n        headerMessage += `${activeEvent.description}\\n\\n`;\n\n        // If filtering by industry, only show relevant impacts\n        if (industryFilter !== \"ALL\") {\n            const relevantImpact = activeEvent.sectorImpacts.find(\n                impact => impact.sectorId === industryFilter\n            );\n\n            if (relevantImpact) {\n                const direction = relevantImpact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `Industry Impact: ${direction} ${Math.abs(relevantImpact.impact)}%\\n`;\n            } else {\n                headerMessage += \"This industry is not directly affected by the current event.\\n\";\n            }\n        } else {\n            // Show all industry impacts\n            headerMessage += \"Industry Impacts:\\n\";\n            for (const impact of activeEvent.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%\\n`;\n            }\n        }\n    }\n\n    // Send header message first\n    await player.pm(headerMessage);\n\n    // Group stocks by industry\n    const stocksByIndustry = {};\n    stocks.forEach(stock => {\n        if (!stocksByIndustry[stock.sector]) {\n            stocksByIndustry[stock.sector] = [];\n        }\n        stocksByIndustry[stock.sector].push(stock);\n    });\n\n    // If industry filter is not \"ALL\", only show that industry\n    if (industryFilter !== \"ALL\") {\n        const filteredStocks = stocksByIndustry[industryFilter] || [];\n\n        if (filteredStocks.length > 0) {\n            let stockMessage = \"\";\n\n            filteredStocks.forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                stockMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(stockMessage);\n        } else {\n            await player.pm(`No stocks found in the ${industryFilter} industry.`);\n        }\n    } else {\n        // Send each industry as a separate message\n        for (const industryId in stocksByIndustry) {\n            let industryMessage = `=== ${industryId} INDUSTRY ===\\n`;\n\n            stocksByIndustry[industryId].forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                industryMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(industryMessage);\n        }\n    }\n\n    // Add a help message for industry filtering if showing all industries\n    if (industryFilter === \"ALL\") {\n        const allIndustries = Object.keys(stocksByIndustry).join(', ');\n        await player.pm(`\\nTip: Use '/markets [industry]' to view only stocks in a specific industry. Available industries: ${allIndustries}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return false;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            const results = await Promise.allSettled(createPromises);\n            // Check if the critical stock_market_data was created successfully\n            const stockDataPromise = results[0];\n            if (stockDataPromise && stockDataPromise.status === 'rejected') {\n                console.log(`Failed to create stock_market_data: ${stockDataPromise.reason}`);\n                return false;\n            }\n        }\n\n        return true;\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n        return false;\n    }\n}\n\nawait main();",
                    "name": "markets",
                    "description": null,
                    "trigger": "markets",
                    "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. \n",
                    "arguments": [
                        {
                            "name": "Industry",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. ",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get player's portfolio\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        if (portfolioVar.data.data.length === 0) {\n            throw new TakaroUserError(\"You don't own any stocks to sell.\");\n        }\n\n        const portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        const stockId = args.stock.toUpperCase();\n\n        if (!portfolio[stockId] || portfolio[stockId].shares < amount) {\n            throw new TakaroUserError(`You don't own ${amount} shares of ${stockId}.`);\n        }\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === stockId);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${stockId} not found in current market data. Please contact an admin.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate sale proceeds using Math.round to ensure we work with integers\n        const stockPrice = Math.round(stock.price);\n        const subtotal = stockPrice * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const netProceeds = subtotal - fee;\n\n        // Add money to player - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerAddCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: netProceeds\n            }\n        );\n\n        // Calculate profit/loss\n        const profitPerShare = stockPrice - portfolio[stockId].averagePrice;\n        const totalProfit = Math.round(profitPerShare * amount);\n        const profitText = totalProfit >= 0\n            ? `profit of $${totalProfit}`\n            : `loss of $${Math.abs(totalProfit)}`;\n\n        // Update portfolio\n        portfolio[stockId].shares -= amount;\n        if (portfolio[stockId].shares === 0) {\n            delete portfolio[stockId];\n        }\n\n        // Save updated portfolio\n        await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n            value: JSON.stringify(portfolio)\n        });\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'SELL',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: netProceeds,\n            profit: totalProfit,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully sold ${amount} shares of ${stockId} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Net proceeds: $${netProceeds} (${profitText})`;\n\n        // Add remaining shares info if player still has some\n        if (portfolio[stockId]) {\n            message += `\\nRemaining shares: ${portfolio[stockId].shares}`;\n        } else {\n            message += `\\nYou've sold all your ${stockId} shares.`;\n        }\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in sellstock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your sale. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "sellstock",
                    "description": null,
                    "trigger": "sellstock",
                    "helpText": "Sell shares of a stock",
                    "arguments": [
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to sell",
                            "position": 1
                        },
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRIGGER_EVENT')) {\n        throw new TakaroUserError(\"You don't have permission to trigger market events.\");\n    }\n\n    try {\n        // Get current stock data to check market initialization\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Initialize market if needed\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            await player.pm(\"Market was not initialized. Initializing now...\");\n            return;\n        }\n\n        // Get events from module config\n        const marketEvents = mod.userConfig.marketEvents || [];\n\n        if (marketEvents.length === 0) {\n            throw new TakaroUserError(\"No market events configured in this module.\");\n        }\n\n        // Handle case when no event is specified or \"ALL\" is provided\n        if (!args.EventName || args.EventName.toUpperCase() === \"ALL\") {\n            await player.pm(\"=== AVAILABLE MARKET EVENTS ===\\n\");\n\n            // Group events by category or type if possible\n            const eventCategories = {};\n\n            // Create a simple categorization based on positive/negative impact\n            marketEvents.forEach(event => {\n                let category = \"Mixed\";\n                // Calculate net impact across all sectors\n                const netImpact = event.sectorImpacts.reduce((sum, impact) => sum + impact.impact, 0);\n\n                if (netImpact > 0) category = \"Positive\";\n                else if (netImpact < 0) category = \"Negative\";\n\n                if (!eventCategories[category]) {\n                    eventCategories[category] = [];\n                }\n                eventCategories[category].push(event);\n            });\n\n            // Display events by category\n            for (const [category, events] of Object.entries(eventCategories)) {\n                if (events.length > 0) {\n                    await player.pm(`\\n--- ${category.toUpperCase()} EVENTS ---`);\n\n                    let message = \"\";\n                    events.forEach(event => {\n                        // Format primary sectors affected\n                        const primarySectors = event.sectorImpacts\n                            .filter(impact => Math.abs(impact.impact) >= 15)\n                            .map(impact => {\n                                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                                return `${impact.sectorId} ${direction}${Math.abs(impact.impact)}%`;\n                            })\n                            .join(\", \");\n\n                        message += `${event.id}: ${event.name}\\n`;\n                        message += `   ${event.description}\\n`;\n                        if (primarySectors) {\n                            message += `   Major impacts: ${primarySectors}\\n`;\n                        }\n                        message += \"\\n\";\n                    });\n\n                    await player.pm(message);\n                }\n            }\n\n            await player.pm(\"=== HOW TO USE ===\\nUse `/triggerevent <EventName>` to trigger a specific event (e.g., `/triggerevent TECH_BOOM`)\");\n            return;\n        }\n\n        // Find the requested event\n        const eventId = args.EventName.toUpperCase();\n        const event = marketEvents.find(e => e.id === eventId);\n\n        if (!event) {\n            throw new TakaroUserError(`Event \"${eventId}\" not found. Use /triggerevent without parameters to see all available events.`);\n        }\n\n        // Get necessary variables for managing the event\n        const [activeEventVar, eventStartTimeVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_execution_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_cooldown_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['current_event_duration'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Check if there's an active event we need to cancel\n        let activeEventObj = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEventObj = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEventObj && Object.keys(activeEventObj).length > 0) {\n                    await player.pm(`Cancelling active event \"${activeEventObj.name}\" to trigger new event.`);\n                }\n            } catch (e) {\n                // Invalid event data, will be overwritten\n            }\n        }\n\n        // Generate a random duration for the event\n        const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n        // Update or create all event-related variables\n        const updatePromises = [];\n\n        // Save or update the random duration\n        if (eventDurationVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                    value: randomDuration.toString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'current_event_duration',\n                    value: randomDuration.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the event counter to 0\n        if (eventCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the cooldown counter\n        if (cooldownCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update active event\n        if (activeEventVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                    value: JSON.stringify(event)\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: JSON.stringify(event),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update event start time\n        if (eventStartTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update last event time\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (lastEventTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all updates to complete\n        await Promise.all(updatePromises);\n\n        // Check if there are online players to announce the event\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            // Format sector impacts for announcement\n            let impactText = \"\";\n            for (const impact of event.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n            }\n\n            const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${event.name}\\n${event.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /markets to see opportunities!`;\n\n            // Split the message if it's too long\n            const maxLength = 400; // Safe limit for most games\n            for (let i = 0; i < message.length; i += maxLength) {\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message: message.substring(i, i + maxLength)\n                });\n            }\n        }\n\n        await player.pm(`Successfully triggered the \"${event.name}\" market event for ${randomDuration} cycles!`);\n    } catch (error) {\n        // If something goes wrong, log it and let the player know\n        console.log(`Error in triggerEvent: ${error.message}`);\n        throw new TakaroUserError(`Error triggering event: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Store the stocks data\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_data',\n            value: JSON.stringify(stocks),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize last event time to now\n        await takaro.variable.variableControllerCreate({\n            key: 'last_market_event_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize event start time variable\n        await takaro.variable.variableControllerCreate({\n            key: 'event_start_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize active event (empty string means no active event)\n        await takaro.variable.variableControllerCreate({\n            key: 'active_market_event',\n            value: '',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Mark market as initialized\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_initialized',\n            value: 'true',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Announce market initialization to online players\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /markets to see available stocks and /buystock to start investing.\";\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message\n            });\n        }\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "triggerevent",
                    "description": null,
                    "trigger": "triggerevent",
                    "helpText": "Shows all available market events when run without parameters. Use with an event name (e.g., /triggerevent TECH_BOOM) to trigger a specific market event.",
                    "arguments": [
                        {
                            "name": "EventName",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "Event name to trigger a specific market event",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // If a specific stock ticker is provided, show detailed info for that stock\n    const specificTicker = args.ticker ? args.ticker.toUpperCase() : null;\n\n    if (specificTicker && specificTicker !== \"ALL\") {\n        const stock = stocks.find(s => s.id.toUpperCase() === specificTicker);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${specificTicker} not found. Use /stockinfo without parameters to see all available stocks.`);\n        }\n\n        // Get active event to see if this stock's sector is affected\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let activeEvent = null;\n        let sectorImpact = null;\n\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEvent && activeEvent.sectorImpacts) {\n                    sectorImpact = activeEvent.sectorImpacts.find(impact =>\n                        impact.sectorId === stock.sector\n                    );\n                }\n            } catch (e) {\n                // Ignore parsing errors\n            }\n        }\n\n        // Calculate price change indicators\n        let changeText = '';\n        if (stock.lastPrice) {\n            const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n            const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n            changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n        }\n\n        // Add risk assessment based on volatility without showing the raw value\n        let riskLevel;\n        if (stock.volatility <= 0.05) riskLevel = \"Very Low\";\n        else if (stock.volatility <= 0.10) riskLevel = \"Low\";\n        else if (stock.volatility <= 0.15) riskLevel = \"Moderate\";\n        else if (stock.volatility <= 0.20) riskLevel = \"High\";\n        else riskLevel = \"Very High\";\n\n        // Build detailed stock info message\n        let message = `=== ${stock.id}: ${stock.name} ===\\n\\n`;\n        message += `Sector: ${stock.sector}\\n`;\n        message += `Current Price: $${Math.round(stock.price)}${changeText}\\n`;\n        message += `Risk Level: ${riskLevel}\\n`;\n\n        // Add sector trend info if available from event\n        if (activeEvent && sectorImpact) {\n            const direction = sectorImpact.impact >= 0 ? \"Positive\" : \"Negative\";\n            const strength = Math.abs(sectorImpact.impact);\n            let trend;\n\n            if (strength < 10) trend = \"Slight\";\n            else if (strength < 25) trend = \"Moderate\";\n            else trend = \"Strong\";\n\n            message += `\\nCurrent Trend: ${trend} ${direction} (${activeEvent.name})\\n`;\n            message += `Event: ${activeEvent.description}\\n`;\n        }\n\n        // Add trading guidance based on sector and risk, without mentioning volatility\n        message += `\\nTrading Notes:\\n`;\n\n        if (activeEvent && sectorImpact) {\n            if (sectorImpact.impact > 0) {\n                message += `- Currently bullish due to the ${activeEvent.name} event\\n`;\n            } else {\n                message += `- Currently bearish due to the ${activeEvent.name} event\\n`;\n            }\n        }\n\n        if (riskLevel === \"High\" || riskLevel === \"Very High\") {\n            message += `- Expect significant price fluctuations with this stock\\n`;\n        } else if (riskLevel === \"Low\" || riskLevel === \"Very Low\") {\n            message += `- Typically has stable price movement\\n`;\n        }\n\n        message += `\\nUse /buystock ${stock.id} [amount] to purchase shares`;\n\n        await player.pm(message);\n\n    } else {\n        // No specific ticker provided or ALL specified, show summary of all stocks\n        await player.pm(\"=== STOCK MARKET LISTINGS ===\\n\");\n\n        // Group stocks by sector\n        const stocksBySector = {};\n        stocks.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        // MODIFICATION START\n        // Display stocks by sector, chunking them into messages of 3\n        const chunkSize = 3;\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            for (let i = 0; i < sectorStocks.length; i += chunkSize) {\n                const chunk = sectorStocks.slice(i, i + chunkSize);\n\n                // Add the sector header only to the first message for that sector.\n                let sectorMessage = (i === 0) ? `\\n--- ${sector} SECTOR ---\\n` : '';\n\n                chunk.forEach(stock => {\n                    // Add price change indicators\n                    let changeText = '';\n                    if (stock.lastPrice) {\n                        const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                        const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                        changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                    }\n\n                    // Add risk level based on volatility\n                    let riskIndicator;\n                    if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                    else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                    else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                    else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                    else riskIndicator = \"VH\";\n\n                    sectorMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n                });\n\n                await player.pm(sectorMessage);\n            }\n        }\n        // MODIFICATION END\n\n        // Add legend for risk indicators\n        const legend = \"\\n=== LEGEND ===\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\" +\n            \"Use /stockinfo [ticker] for detailed information about a specific stock\";\n\n        await player.pm(legend);\n    }\n}\n\nawait main();",
                    "name": "stockinfo",
                    "description": null,
                    "trigger": "stockinfo",
                    "helpText": "Shows all available stocks in the market. Use with a ticker symbol (e.g., /stockinfo ticker) to see detailed information about a specific stock.",
                    "arguments": [
                        {
                            "name": "ticker",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "stock ticker or ALL to get detailed information about a specific stock",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // Get player's portfolio\n    const portfolioVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_portfolio'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId],\n            playerId: [player.id]\n        }\n    });\n\n    let portfolio = {};\n    if (portfolioVar.data.data.length > 0) {\n        portfolio = JSON.parse(portfolioVar.data.data[0].value);\n    }\n\n    // Send header\n    await player.pm(\"=== YOUR STOCK PORTFOLIO ===\");\n\n    let hasStocks = false;\n    let totalValue = 0;\n    let totalInvestment = 0;\n\n    // If no stocks, send a simple message\n    if (Object.keys(portfolio).length === 0) {\n        await player.pm(\"You don't own any stocks yet.\\n\" +\n            \"Use /markets to see available stocks and prices.\\n\" +\n            \"Use /buy <stock> <amount> to purchase stocks.\");\n        return;\n    }\n\n    // Helper function to format numbers with commas\n    const formatNumber = (num) => {\n        return Math.round(num).toLocaleString();\n    };\n\n    // Send each stock as a separate message to avoid length issues\n    for (const [stockId, data] of Object.entries(portfolio)) {\n        hasStocks = true;\n        const stock = stocks.find(s => s.id === stockId);\n        if (!stock) continue; // Stock might have been removed from config\n\n        const currentValue = stock.price * data.shares;\n        const investmentValue = data.averagePrice * data.shares;\n        totalValue += currentValue;\n        totalInvestment += investmentValue;\n        const profit = currentValue - investmentValue;\n        const profitPercent = ((profit / investmentValue) * 100).toFixed(1);\n\n        let stockMessage = `--- ${stockId} (${stock.sector}) ---\\n`;\n        stockMessage += `Shares: ${data.shares}\\n`;\n        stockMessage += `Avg buy: $${formatNumber(data.averagePrice)}\\n`;\n        stockMessage += `Current price: $${formatNumber(stock.price)}\\n`;\n        stockMessage += `Total value: $${formatNumber(currentValue)}\\n`;\n\n        if (profit >= 0) {\n            stockMessage += `Profit: +$${formatNumber(profit)} (+${profitPercent}%)\\n`;\n        } else {\n            stockMessage += `Loss: -$${formatNumber(Math.abs(profit))} (${profitPercent}%)\\n`;\n        }\n\n        await player.pm(stockMessage);\n    }\n\n    if (hasStocks) {\n        const totalProfit = totalValue - totalInvestment;\n        const totalProfitPercent = ((totalProfit / totalInvestment) * 100).toFixed(1);\n\n        let summaryMessage = \"=== PORTFOLIO SUMMARY ===\\n\";\n        summaryMessage += `Total investment: $${formatNumber(totalInvestment)}\\n`;\n        summaryMessage += `Current value: $${formatNumber(totalValue)}\\n`;\n\n        if (totalProfit >= 0) {\n            summaryMessage += `Overall profit: +$${formatNumber(totalProfit)} (+${totalProfitPercent}%)\\n`;\n        } else {\n            summaryMessage += `Overall loss: -$${formatNumber(Math.abs(totalProfit))} (${totalProfitPercent}%)\\n`;\n        }\n\n        // Get transaction history count\n        try {\n            const historyVar = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: ['stock_transaction_history'],\n                    gameServerId: [gameServerId],\n                    moduleId: [mod.moduleId],\n                    playerId: [player.id]\n                }\n            });\n\n            if (historyVar.data.data.length > 0) {\n                const history = JSON.parse(historyVar.data.data[0].value);\n                const buyCount = history.filter(t => t.type === 'BUY').length;\n                const sellCount = history.filter(t => t.type === 'SELL').length;\n\n                summaryMessage += `\\nTransactions: ${history.length} (${buyCount} buys, ${sellCount} sells)\\n`;\n            }\n        } catch (error) {\n            // Just ignore history errors\n        }\n\n        await player.pm(summaryMessage);\n    }\n}\n\nawait main();",
                    "name": "stockportfolio",
                    "description": null,
                    "trigger": "stockportfolio",
                    "helpText": "No help text available",
                    "arguments": []
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === args.stock.toUpperCase());\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${args.stock} not found. Use /market to see available stocks.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate costs using Math.round to ensure we work with integers\n        const subtotal = Math.round(stock.price) * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const totalCost = subtotal + fee;\n\n        // Check if player has enough currency\n        const playerData = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, player.id);\n        const currentBalance = playerData.data.data.currency;\n\n        if (currentBalance < totalCost) {\n            throw new TakaroUserError(`You don't have enough currency. Cost: $${subtotal} + $${fee} fee = $${totalCost}. Your balance: $${currentBalance}`);\n        }\n\n        // Deduct the currency - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerDeductCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: totalCost\n            }\n        );\n\n        // Get player's portfolio or create new one\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        let portfolio;\n        if (portfolioVar.data.data.length === 0) {\n            portfolio = {};\n        } else {\n            portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        }\n\n        // Update portfolio using rounded values for consistency\n        const stockPrice = Math.round(stock.price);\n        if (!portfolio[stock.id]) {\n            portfolio[stock.id] = {\n                shares: amount,\n                averagePrice: stockPrice\n            };\n        } else {\n            const totalShares = portfolio[stock.id].shares + amount;\n            const totalValue = (portfolio[stock.id].shares * portfolio[stock.id].averagePrice) + (amount * stockPrice);\n            portfolio[stock.id].shares = totalShares;\n            portfolio[stock.id].averagePrice = Math.round(totalValue / totalShares);\n        }\n\n        // Save updated portfolio\n        if (portfolioVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_portfolio',\n                value: JSON.stringify(portfolio),\n                gameServerId,\n                moduleId: mod.moduleId,\n                playerId: player.id\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n                value: JSON.stringify(portfolio)\n            });\n        }\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'BUY',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: totalCost,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully bought ${amount} shares of ${stock.id} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Total cost: $${totalCost}\\n`;\n        message += `Current portfolio: ${portfolio[stock.id].shares} shares of ${stock.id}`;\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in buystock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your purchase. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "buystock",
                    "description": null,
                    "trigger": "buystock",
                    "helpText": "Buy shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol ",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to buy",
                            "position": 1
                        }
                    ]
                }
            ],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n\n    const discordChannelId = mod.userConfig.marketNewsChannelId;\n\n    if (!discordChannelId) {\n        takaro.log.info('Market news Discord channel ID (marketNewsChannelId) not configured in module settings. Skipping Discord messages.');\n    }\n\n    const currentPlayers = (await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    })).data.meta;\n\n    if (currentPlayers.total === 0) {\n        takaro.log.info('Skipping daily market report: No players online.');\n        return;\n    }\n\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        takaro.log.warn('Skipping daily market report: Market data variable not found.');\n        return;\n    }\n\n    let stocks;\n    try {\n        stocks = JSON.parse(marketDataVar.data.data[0].value);\n        if (!Array.isArray(stocks)) {\n            throw new Error('Parsed market data is not an array.');\n        }\n    } catch (error) {\n        takaro.log.error(`Failed to parse stock_market_data: ${error}`);\n        return;\n    }\n\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            if (typeof activeEvent !== 'object' || activeEvent === null || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (error) {\n            takaro.log.warn(`Failed to parse active_market_event: ${error}`);\n            activeEvent = null;\n        }\n    }\n\n    let gameMessage1 = \"==== DAILY MARKET REPORT ====\\n\";\n\n    if (activeEvent && activeEvent.name && activeEvent.description) {\n        const eventText = `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n${activeEvent.description}\\n`;\n        gameMessage1 += eventText;\n    } else {\n        const noEventText = '\\nNo active market events today.\\n';\n        gameMessage1 += noEventText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage1\n    }).catch(err => takaro.log.error(`Failed to send game message 1: ${err}`));\n\n    const stocksWithPerformance = stocks.map(stock => {\n        let change = 0;\n        let percentChange = 0;\n        let changeSymbol = 'â†’';\n\n        if (typeof stock.price === 'number' && typeof stock.lastPrice === 'number' && stock.lastPrice !== 0) {\n            change = stock.price - stock.lastPrice;\n            percentChange = (change / stock.lastPrice) * 100;\n            if (percentChange > 0.05) {\n                changeSymbol = 'â†‘';\n            } else if (percentChange < -0.05) {\n                changeSymbol = 'â†“';\n            }\n        } else if (typeof stock.price === 'number' && stock.lastPrice === undefined) {\n            changeSymbol = 'ðŸ†•';\n            percentChange = 0;\n        }\n        return {\n            ...stock,\n            change,\n            percentChange,\n            changeSymbol\n        };\n    });\n\n    const sectorPerformance = {};\n    stocksWithPerformance.forEach(stock => {\n        const sectorId = stock.sector || 'Uncategorized';\n        if (!sectorPerformance[sectorId]) {\n            sectorPerformance[sectorId] = {\n                stocks: [],\n                totalPercentChange: 0,\n                count: 0\n            };\n        }\n        sectorPerformance[sectorId].stocks.push(stock);\n        if (typeof stock.percentChange === 'number' && isFinite(stock.percentChange)) {\n            sectorPerformance[sectorId].totalPercentChange += stock.percentChange;\n            sectorPerformance[sectorId].count++;\n        }\n    });\n\n    for (const sectorId in sectorPerformance) {\n        const sectorData = sectorPerformance[sectorId];\n        if (sectorData.count > 0) {\n            sectorData.avgPerformance = sectorData.totalPercentChange / sectorData.count;\n        } else {\n            sectorData.avgPerformance = 0;\n        }\n    }\n\n    const sortedSectors = Object.entries(sectorPerformance)\n        .sort(([, a], [, b]) => b.avgPerformance - a.avgPerformance);\n\n    let gameMessage2 = \"\\n=== SECTOR PERFORMANCE ===\\n\";\n\n    if (sortedSectors.length > 0) {\n        sortedSectors.forEach(([sectorId, sectorData]) => {\n            const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n            let line = `${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n\n            if (sectorData.avgPerformance > 0.05) {\n                line = `[70FE02]${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%[-]\\n`;\n            } else if (sectorData.avgPerformance < -0.05) {\n                line = `[FF0001]${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%[-]\\n`;\n            }\n            gameMessage2 += line;\n        });\n    } else {\n        const noDataText = \"No sector performance data available.\\n\";\n        gameMessage2 += noDataText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage2\n    }).catch(err => takaro.log.error(`Failed to send game message 2: ${err}`));\n\n    const validPerformers = stocksWithPerformance.filter(s => typeof s.percentChange === 'number' && isFinite(s.percentChange));\n    validPerformers.sort((a, b) => b.percentChange - a.percentChange);\n\n    let gameMessage3 = \"\";\n\n    const topPerformersTitleGame = \"\\nðŸ”¥ TOP PERFORMERS ðŸ”¥\\n\";\n    gameMessage3 += topPerformersTitleGame;\n\n    if (validPerformers.length > 0) {\n        for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n            const stock = validPerformers[i];\n            gameMessage3 += `[70FE02]${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%[-]\\n`;\n        }\n    } else {\n        gameMessage3 += \"No top performers today.\\n\";\n    }\n\n    const worstPerformersTitleGame = \"\\nðŸ“‰ WORST PERFORMERS ðŸ“‰\\n\";\n    gameMessage3 += worstPerformersTitleGame;\n\n    if (validPerformers.length > 0) {\n        const worstStartIndex = Math.max(0, validPerformers.length - 3);\n        for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n            const stock = validPerformers[i];\n            gameMessage3 += `[FF0001]${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%[-]\\n`;\n        }\n    } else {\n        gameMessage3 += \"No worst performers today.\\n\";\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage3\n    }).catch(err => takaro.log.error(`Failed to send game message 3: ${err}`));\n\n    function hslToRgb(h, s, l) { let a = s * Math.min(l, 1 - l); let f = n => { let k = (n + h / 30) % 12; return l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1)); }; return [Math.round(255 * f(0)), Math.round(255 * f(8)), Math.round(255 * f(4))]; }\n    function rgbToHex(r, g, b) { return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase(); }\n    function stringToHexColor(str) { let hash = 0; for (let i = 0; i < str.length; i++) { hash = str.charCodeAt(i) + ((hash << 5) - hash); } hash = Math.abs(hash); const hue = (hash * 137.508) % 360; const [r, g, b] = hslToRgb(hue, 0.9, 0.7); return rgbToHex(r, g, b); }\n\n    const stockColors = {};\n    stocksWithPerformance.forEach(stock => {\n        stockColors[stock.id] = stringToHexColor(stock.name);\n    });\n\n    const stocksBySectorGame = {};\n    stocksWithPerformance.forEach(stock => {\n        const sector = stock.sector || 'Uncategorized';\n        if (!stocksBySectorGame[sector]) {\n            stocksBySectorGame[sector] = [];\n        }\n        stocksBySectorGame[sector].push(stock);\n    });\n\n    const chunkSize = 3;\n    for (const [sector, sectorStocks] of Object.entries(stocksBySectorGame)) {\n        for (let i = 0; i < sectorStocks.length; i += chunkSize) {\n            const chunk = sectorStocks.slice(i, i + chunkSize);\n            let sectorMessage = (i === 0) ? `\\n--- ${sector} SECTOR ---\\n` : '';\n\n            chunk.forEach(stock => {\n                let changeText = '';\n                let priceColorPrefix = '', priceColorSuffix = '';\n\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeText = ` ${stock.changeSymbol} ${Math.abs(percentChange).toFixed(1)}%`;\n                    if (percentChange > 0) {\n                        priceColorPrefix = '[70FE02]';\n                        priceColorSuffix = '[-]';\n                    } else if (percentChange < 0) {\n                        priceColorPrefix = '[FF0001]';\n                        priceColorSuffix = '[-]';\n                    }\n                }\n\n                const stockNameColorPrefix = stockColors[stock.id] ? `[${stockColors[stock.id]}]` : '';\n                const stockNameColorSuffix = stockColors[stock.id] ? '[-]' : '';\n\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.25) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                sectorMessage += `${stockNameColorPrefix}${stock.name} (${stock.id})${stockNameColorSuffix} (${riskIndicator}): ${priceColorPrefix}$${Math.round(stock.price)}${changeText}${priceColorSuffix}\\n`;\n            });\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message: sectorMessage\n            }).catch(err => takaro.log.error(`Failed to send game message for sector ${sector}: ${err}`));\n        }\n    }\n\n    const legendMessage = \"\\n=== LEGEND ===\\n\" +\n        \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\";\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: legendMessage\n    }).catch(err => takaro.log.error(`Failed to send game legend message: ${err}`));\n\n    if (discordChannelId) {\n        // --- MESSAGE 1: The Summary ---\n        let discordMessageSummary = \"**==== DAILY MARKET REPORT ====**\\n\\n\";\n\n        if (activeEvent && activeEvent.name && activeEvent.description) {\n            discordMessageSummary += `ðŸŒ **ACTIVE EVENT: ${activeEvent.name}** ðŸŒ\\n${activeEvent.description}\\n\\n`;\n        } else {\n            discordMessageSummary += 'No active market events today.\\n\\n';\n        }\n\n        discordMessageSummary += \"**=== SECTOR PERFORMANCE ===**\\n\";\n        if (sortedSectors.length > 0) {\n            sortedSectors.forEach(([sectorId, sectorData]) => {\n                const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n                discordMessageSummary += `${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n            });\n        } else {\n            discordMessageSummary += \"No sector performance data available.\\n\";\n        }\n        discordMessageSummary += \"\\n\";\n\n        discordMessageSummary += \"**ðŸ”¥ TOP PERFORMERS ðŸ”¥**\\n\";\n        if (validPerformers.length > 0) {\n            for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n                const stock = validPerformers[i];\n                discordMessageSummary += `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            }\n        } else {\n            discordMessageSummary += \"No top performers today.\\n\";\n        }\n        discordMessageSummary += \"\\n\";\n\n        discordMessageSummary += \"**ðŸ“‰ WORST PERFORMERS ðŸ“‰**\\n\";\n        if (validPerformers.length > 0) {\n            const worstStartIndex = Math.max(0, validPerformers.length - 3);\n            for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n                const stock = validPerformers[i];\n                discordMessageSummary += `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            }\n        } else {\n            discordMessageSummary += \"No worst performers today.\\n\";\n        }\n\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessageSummary\n        }).catch(err => takaro.log.error(`Failed to send summary Discord message: ${err.message || err}`));\n\n        // --- MESSAGE 2: All Stock Listings ---\n        let discordMessageDetails = \"**=== ALL STOCK LISTINGS ===**\\n\";\n        const stocksBySector = {};\n        stocksWithPerformance.forEach(stock => {\n            const sector = stock.sector || 'Uncategorized';\n            if (!stocksBySector[sector]) {\n                stocksBySector[sector] = [];\n            }\n            stocksBySector[sector].push(stock);\n        });\n\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            discordMessageDetails += `\\n--- **${sector} SECTOR** ---\\n`;\n            sectorStocks.forEach(stock => {\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeText = ` ${stock.changeSymbol} ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.25) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                discordMessageDetails += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n        }\n\n        discordMessageDetails += \"\\n**=== LEGEND ===**\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\";\n\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessageDetails\n        }).catch(err => takaro.log.error(`Failed to send details Discord message: ${err.message || err}`));\n    }\n\n    takaro.log.info('Daily market report sent successfully.');\n}\n\nawait main();",
                    "name": "marketnews",
                    "description": null,
                    "temporalValue": "1 */1 * * *"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    try {\n        const { gameServerId, module: mod } = data;\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Check if market is initialized\n        if (marketDataVar.data.data.length === 0) {\n            console.log(\"Market data not found, initializing...\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return; // Exit after initialization\n        }\n\n        // Get active market event\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event start time\n        const eventStartTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_start_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event execution counter\n        const eventCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_execution_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event cooldown counter\n        const cooldownCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_cooldown_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let eventCounter = 0;\n        if (eventCounterVar.data.data.length > 0) {\n            eventCounter = parseInt(eventCounterVar.data.data[0].value, 10);\n            console.log(`Event counter: ${eventCounter}`);\n        }\n\n        let cooldownCounter = 0;\n        if (cooldownCounterVar.data.data.length > 0) {\n            cooldownCounter = parseInt(cooldownCounterVar.data.data[0].value, 10);\n            console.log(`Cooldown counter: ${cooldownCounter}`);\n        }\n\n        // Get event duration\n        const eventDurationVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['current_event_duration'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Use stored random duration if available, otherwise use defaultEventDuration\n        let eventDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        if (eventDurationVar.data.data.length > 0) {\n            eventDuration = parseInt(eventDurationVar.data.data[0].value, 10);\n            console.log(`Event duration: ${eventDuration}`);\n        }\n\n        let activeEvent = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                // If it's an empty string, treat as no active event\n                if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                    activeEvent = null;\n                }\n                console.log(`Active event: ${activeEvent ? activeEvent.name : 'None'}`);\n            } catch (e) {\n                // In case of parsing error, consider no active event\n                activeEvent = null;\n                console.log(`Error parsing active event: ${e.message}`);\n            }\n        }\n\n        // Check if the current event should end and increment counter\n        if (activeEvent) {\n            eventCounter++;\n            console.log(`Incremented event counter to: ${eventCounter}`);\n\n            if (eventCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: eventCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: eventCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n\n            if (eventCounter >= eventDuration) {\n                console.log(\"Event duration reached, ending event.\");\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: ''\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_cooldown_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    const message = `ðŸ“ˆ MARKET UPDATE ðŸ“‰\\n\\nThe \"${activeEvent.name}\" event has ended. Markets are returning to normal conditions.`;\n\n                    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                        message: message\n                    });\n                }\n\n                activeEvent = null;\n            }\n        } else {\n            cooldownCounter++;\n            console.log(`Incremented cooldown counter to: ${cooldownCounter}`);\n\n            if (cooldownCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: cooldownCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: cooldownCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n        }\n\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        const eventFrequency = (mod.userConfig && mod.userConfig.eventFrequency) || 10;\n        let shouldTriggerEvent = false;\n\n        if (!activeEvent && cooldownCounter >= eventFrequency) {\n            shouldTriggerEvent = Math.random() < 0.5;\n            if (cooldownCounter >= eventFrequency * 2) {\n                shouldTriggerEvent = true;\n            }\n            console.log(`Should trigger new event: ${shouldTriggerEvent}`);\n        }\n\n        if (shouldTriggerEvent) {\n            const events = (mod.userConfig && mod.userConfig.marketEvents) || [];\n            if (events.length > 0) {\n                const randomEvent = events[Math.floor(Math.random() * events.length)];\n                activeEvent = randomEvent;\n                console.log(`New event triggered: ${activeEvent.name}`);\n\n                const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n                const randomDuration = Math.floor(Math.random() * maxDuration) + 1;\n\n                if (eventDurationVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                        value: randomDuration.toString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'current_event_duration',\n                        value: randomDuration.toString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: JSON.stringify(activeEvent)\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'active_market_event',\n                        value: JSON.stringify(activeEvent),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventStartTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_start_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (lastEventTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'last_market_event_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    let impactText = \"\";\n                    for (const impact of activeEvent.sectorImpacts) {\n                        const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                        impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n                    }\n\n                    const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${activeEvent.name}\\n${activeEvent.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /market to see opportunities!`;\n\n                    const maxLength = 400;\n                    for (let i = 0; i < message.length; i += maxLength) {\n                        await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                            message: message.substring(i, i + maxLength)\n                        });\n                    }\n                }\n            }\n        }\n\n        // Get stocks\n        if (!marketDataVar.data.data[0] || !marketDataVar.data.data[0].value) {\n            console.log(\"Market data is empty or invalid after initial check, re-initializing.\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        let stocks;\n        try {\n            stocks = JSON.parse(marketDataVar.data.data[0].value);\n            if (!Array.isArray(stocks)) {\n                throw new Error(\"Parsed stocks data is not an array\");\n            }\n            // CRITICAL FIX: Ensure each stock has valid numerical price properties\n            stocks = stocks.map(s => {\n                const sanitizedPrice = typeof s.price === 'number' && s.price > 0 ? s.price : 1;\n                const sanitizedLastPrice = typeof s.lastPrice === 'number' && s.lastPrice > 0 ? s.lastPrice : sanitizedPrice;\n                return {\n                    ...s,\n                    price: sanitizedPrice,\n                    lastPrice: sanitizedLastPrice\n                };\n            });\n            console.log(\"Stocks loaded and sanitized successfully.\");\n            console.log(\"Initial stocks for this cycle:\");\n            stocks.forEach(s => console.log(`  ${s.id}: Price ${s.price}, LastPrice ${s.lastPrice}`));\n\n        } catch (e) {\n            console.log(`Error parsing or sanitizing stock data: ${e.message}`);\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        const significantChanges = [];\n\n        // Update each stock price\n        stocks.forEach(stock => {\n            // Always capture oldPrice at the very beginning of the iteration\n            const oldPrice = stock.price;\n            // Set lastPrice to the value before this current update cycle for accurate change tracking\n            stock.lastPrice = oldPrice;\n\n            console.log(`Processing stock: ${stock.id}, Old Price: ${oldPrice}`);\n\n            // Define the threshold for \"penny stock\" and the chance/magnitude of a breakout\n            const pennyStockThreshold = 1.9;\n            const breakoutChance = 0.6;\n\n            const targetMinPrice = 2.0;\n            const targetMaxPrice = 10.0;\n\n            let calculatedNewPrice;\n\n            // Check if it's a penny stock and qualifies for a breakout\n            if (oldPrice <= pennyStockThreshold && Math.random() < breakoutChance) {\n                console.log(`${stock.id} is a penny stock (${oldPrice}) and hit breakout chance!`);\n                calculatedNewPrice = targetMinPrice + Math.random() * (targetMaxPrice - targetMinPrice);\n                calculatedNewPrice = Math.max(calculatedNewPrice, oldPrice + 0.01); // Ensure at least a penny increase\n                console.log(`${stock.id} calculated breakout price: ${calculatedNewPrice}`);\n            } else {\n                const randomFactor = Math.random() * 2 - 1;\n                const totalChangePercent = randomFactor * stock.volatility;\n                calculatedNewPrice = oldPrice * (1 + totalChangePercent);\n                console.log(`${stock.id} calculated normal price: ${calculatedNewPrice} (Change: ${totalChangePercent * 100}%)`);\n            }\n\n            let finalPrice = calculatedNewPrice;\n            if (activeEvent) {\n                const sectorImpact = activeEvent.sectorImpacts.find(impact => impact.sectorId === stock.sector);\n                if (sectorImpact) {\n                    const eventImpactPercentage = sectorImpact.impact;\n                    const eventImpactDecimal = eventImpactPercentage / 100;\n                    const randomImpactFactor = 0.5 + Math.random();\n                    const eventImpact = eventImpactDecimal * randomImpactFactor;\n\n                    finalPrice = calculatedNewPrice * (1 + eventImpact);\n                    console.log(`${stock.id} final price after event impact: ${finalPrice} (Event impact: ${eventImpact * 100}%)`);\n                }\n            }\n\n            stock.price = finalPrice;\n\n            if (stock.price < 1) {\n                console.log(`${stock.id} price fell below 1, setting to 1.`);\n                stock.price = 1;\n            }\n\n            const actualPercentChange = ((stock.price - oldPrice) / oldPrice) * 100;\n            console.log(`${stock.id} - Final Price: ${stock.price.toFixed(2)}, Actual Change: ${actualPercentChange.toFixed(2)}%`);\n\n            const changeThreshold = ((mod.userConfig && mod.userConfig.priceAlertThreshold) || 10) / 100;\n            if (Math.abs(actualPercentChange) > changeThreshold * 100) {\n                significantChanges.push({\n                    ...stock,\n                    changePercent: actualPercentChange\n                });\n            }\n        });\n\n        console.log(\"All stocks processed, saving updated prices...\");\n        await takaro.variable.variableControllerUpdate(marketDataVar.data.data[0].id, {\n            value: JSON.stringify(stocks)\n        });\n        console.log(\"Updated prices saved.\");\n\n        if (significantChanges.length > 0) {\n            console.log(\"Significant changes detected, sending alert.\");\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                significantChanges.sort((a, b) => Math.abs(b.changePercent) - Math.abs(a.changePercent));\n                const topChanges = significantChanges.slice(0, Math.min(3, significantChanges.length));\n\n                let message = \"ðŸ“Š STOCK MARKET ALERT ðŸ“Š\\n\";\n                topChanges.forEach(stock => {\n                    const changeDir = stock.changePercent > 0 ? \"up\" : \"down\";\n                    const displayPrice = stock.price.toFixed(2);\n                    const changePercent = Math.abs(Math.round(stock.changePercent));\n\n                    message += `${stock.id} (${stock.sector}): ${changeDir} ${changePercent}% to $${displayPrice}!\\n`;\n                });\n\n                if (activeEvent) {\n                    message += `\\nCurrent market event: ${activeEvent.name}`;\n                }\n\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            } else {\n                console.log(\"No online players to send alert to.\");\n            }\n        } else {\n            console.log(\"No significant changes to alert players about.\");\n        }\n    } catch (error) {\n        console.log(`FATAL Error in updateStockPrices: ${error.message}`);\n        // Optionally, send an admin message if a fatal error occurs\n        // await takaro.gameserver.gameServerControllerSendMessage(data.gameServerId, {\n        //     message: `ðŸš¨ Market Error: An error occurred during stock update: ${error.message}`\n        // });\n    }\n}\n\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        console.log(\"Initializing market if needed...\");\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in module configuration for initialization.\");\n            return;\n        }\n\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_data'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['last_market_event_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_start_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['active_market_event'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_initialized'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_execution_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_cooldown_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['current_event_duration'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } })\n            ]);\n\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n        console.log(\"Mapped initial stocks from config.\");\n\n        const createPromises = [];\n\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_data', value: JSON.stringify(stocks), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'last_market_event_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_start_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'active_market_event', value: '', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_execution_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (cooldownCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_cooldown_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventDurationVar.data.data.length === 0) {\n            const defaultDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'current_event_duration', value: defaultDuration.toString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_initialized', value: 'true', gameServerId, moduleId: mod.moduleId }));\n        }\n\n        if (createPromises.length > 0) {\n            console.log(`Creating ${createPromises.length} initial market variables.`);\n            await Promise.allSettled(createPromises);\n        } else {\n            console.log(\"All market variables already exist, no new initialization needed.\");\n        }\n\n        if (marketDataVar.data.data.length === 0) { // Only announce if we actually created the stock_market_data variable\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /market to see available stocks and /buy to start investing.\";\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, { message });\n            }\n        }\n        console.log(\"Market initialization process complete.\");\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "updatestockprices",
                    "description": null,
                    "temporalValue": "0 */1 * * *"
                }
            ],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Allows the player to view market prices and their portfolio",
                    "permission": "STOCK_MARKET_USE",
                    "friendlyName": "Use Stock Market"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows the player to buy and sell stocks",
                    "permission": "STOCK_MARKET_TRADE",
                    "friendlyName": "Trade Stocks"
                },
                {
                    "canHaveCount": false,
                    "description": "VIP status that reduces transaction fees",
                    "permission": "STOCK_MARKET_BROKER",
                    "friendlyName": "Stock Broker"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows admins to manually trigger market events",
                    "permission": "STOCK_MARKET_TRIGGER_EVENT",
                    "friendlyName": "Trigger Market Events"
                }
            ]
        },
        {
            "tag": "0.0.6",
            "description": "**Stock Market: A Dynamic Virtual Trading System**\n\nCreate an immersive economic experience with this comprehensive stock market module that lets players invest, trade, and react to market events.\n\n**Market Features:**\n\n![Market Summary](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stocks.png)\n\n* **Multiple Economic Sectors:** Configure various industry sectors (Resource Extraction, Manufacturing, Defense, etc.) each with their own market dynamics.\n* **Realistic Stock Behavior:** Stocks have configurable volatility, sector-based pricing, and react differently to market events.\n* **Dynamic Market Events:** Random or admin-triggered events like \"Horde Night Approaching\" or \"Societal Collapse Setback\" impact different sectors in realistic ways.\n\n![Market Events](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_events.png)\n\n**Trading System:**\n\n* **Buy & Sell Shares:** Players can purchase stocks and sell them later for profit or loss.\n* **Transaction Fees:** Configurable fee percentage on all trades creates a realistic market economy.\n* **VIP Benefits:** Special permissions for designated \"Stock Brokers\" who receive fee discounts.\n\n![Buy Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_buy.png)\n\nPlayers can track price changes and sell at the right moment to maximize profits or minimize losses.\n\n![Sell Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sell.png)\n\n**Player Portfolio:**\n\n* **Portfolio Tracking:** Players can view their holdings, average purchase prices, and current profit/loss.\n* **Transaction History:** System tracks all buy/sell transactions for each player.\n* **Summary Statistics:** See overall portfolio performance and value across all holdings.\n\n![Portfolio View](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockportfolio.png)\n\n**Market Information:**\n\n* **Detailed Stock Info:** Players can research specific stocks, including risk levels and sector trends.\n* **Industry Filters:** View stocks by specific sectors to better understand market segments.\n* **Market Alerts:** Server-wide notifications for significant price changes keep players engaged.\n\n![Market Alerts](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockpricechange.png)\n\n**Configuration Options:**\n\n* **Sectors & Stocks:** Define your own market sectors and individual stocks with customizable starting prices and volatility.\n* **Market Events:** Create unique events with specific sector impacts to drive market dynamics.\n* **Transaction Settings:** Configure fee percentages, VIP discounts, and alert thresholds.\n* **Event Frequency:** Control how often random market events occur and how long they last.\n\n![Configuration](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_config.png)\n![Sectors](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sectors.png)\n\n**Commands:**\n\n* `/markets [industry]` - View all stocks or filter by industry\n* `/stockinfo [ticker]` - Get detailed information about a specific stock\n* `/buystock <ticker> <amount>` - Purchase shares of a stock\n* `/sellstock <ticker> <amount>` - Sell shares from your portfolio\n* `/stockportfolio` - View your current holdings and performance\n* `/triggerevent [event]` - Admin command to trigger specific market events\n\nWho says the apocalypse can't have a thriving economy? Now players can stress about both zombie hordes AND their Duke's Casino Tokens dropping 40% after a market event! As one trader put it: \"I used to check my 401K daily, and now I check my AMMO stock before every Blood Moon. Some habits die harder than zombies.\"",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sectors\":{\"type\":\"array\",\"title\":\"Wasteland Economic Sectors\",\"description\":\"Define economic sectors relevant to survival in Navezgane\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Sector ID (e.g., RESOURCES)\"},\"name\":{\"type\":\"string\",\"description\":\"Sector name (e.g., Resource Extraction)\"}}},\"default\":[{\"id\":\"RESOURCES\",\"name\":\"Resource Extraction\"},{\"id\":\"MANUFACTURING\",\"name\":\"Manufacturing & Crafting\"},{\"id\":\"DEFENSE\",\"name\":\"Defense & Fortifications\"},{\"id\":\"SURVIVAL\",\"name\":\"Survival Goods\"},{\"id\":\"TRADE\",\"name\":\"Trade & Currency\"}]},\"stocks\":{\"type\":\"array\",\"title\":\"Wasteland Stocks\",\"description\":\"List of stocks representing Navezgane entities and resources\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Stock ticker symbol (e.g., NMC)\"},\"name\":{\"type\":\"string\",\"description\":\"Entity/Resource name\"},\"sector\":{\"type\":\"string\",\"description\":\"Sector ID this stock belongs to\"},\"initialPrice\":{\"type\":\"number\",\"description\":\"Starting price in Dukes\",\"minimum\":1},\"volatility\":{\"type\":\"number\",\"description\":\"Base volatility percentage (5 = 5%)\",\"minimum\":1,\"maximum\":35}}},\"default\":[{\"id\":\"NMC\",\"name\":\"Navezgane Mining Co.\",\"sector\":\"RESOURCES\",\"initialPrice\":50,\"volatility\":15},{\"id\":\"WOOD\",\"name\":\"Wasteland Lumberjacks\",\"sector\":\"RESOURCES\",\"initialPrice\":20,\"volatility\":8},{\"id\":\"SHALE\",\"name\":\"Oil Shale Extractors\",\"sector\":\"RESOURCES\",\"initialPrice\":40,\"volatility\":18},{\"id\":\"FORGE\",\"name\":\"Forge Ahead Metals\",\"sector\":\"MANUFACTURING\",\"initialPrice\":75,\"volatility\":12},{\"id\":\"TOOLS\",\"name\":\"Working Stiff Tools\",\"sector\":\"MANUFACTURING\",\"initialPrice\":60,\"volatility\":10},{\"id\":\"MECH\",\"name\":\"JunkTech Robotics\",\"sector\":\"MANUFACTURING\",\"initialPrice\":110,\"volatility\":20},{\"id\":\"BUILD\",\"name\":\"Barricade Builders\",\"sector\":\"DEFENSE\",\"initialPrice\":45,\"volatility\":9},{\"id\":\"AMMO\",\"name\":\"AmmoNation Surplus\",\"sector\":\"DEFENSE\",\"initialPrice\":90,\"volatility\":25},{\"id\":\"SHAM\",\"name\":\"Shamway Foods\",\"sector\":\"SURVIVAL\",\"initialPrice\":30,\"volatility\":5},{\"id\":\"MEDS\",\"name\":\"Pop-N-Pills Medical\",\"sector\":\"SURVIVAL\",\"initialPrice\":100,\"volatility\":18},{\"id\":\"TRADE\",\"name\":\"Trader Guild Network\",\"sector\":\"TRADE\",\"initialPrice\":150,\"volatility\":10},{\"id\":\"DUKES\",\"name\":\"Duke's Casino Tokens\",\"sector\":\"TRADE\",\"initialPrice\":1,\"volatility\":3}]},\"marketEvents\":{\"type\":\"array\",\"title\":\"Wasteland Events\",\"description\":\"Events impacting the Navezgane economy\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Unique event ID\"},\"name\":{\"type\":\"string\",\"description\":\"Name of the event\"},\"description\":{\"type\":\"string\",\"description\":\"Description of the event's market effect\"},\"sectorImpacts\":{\"type\":\"array\",\"description\":\"How each sector is affected\",\"items\":{\"type\":\"object\",\"properties\":{\"sectorId\":{\"type\":\"string\",\"description\":\"Sector ID\"},\"impact\":{\"type\":\"number\",\"description\":\"Percentage impact (-30 = -30%)\",\"minimum\":-75,\"maximum\":75}}}}}},\"default\":[{\"id\":\"HORDE_INCOMING\",\"name\":\"Horde Night Approaching\",\"description\":\"Increased Zed activity signals the Blood Moon. Survivors prepare defenses.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-15},{\"sectorId\":\"MANUFACTURING\",\"impact\":20},{\"sectorId\":\"DEFENSE\",\"impact\":35},{\"sectorId\":\"SURVIVAL\",\"impact\":5},{\"sectorId\":\"TRADE\",\"impact\":-10}]},{\"id\":\"RESOURCE_SCARCITY\",\"name\":\"Resource Scarcity\",\"description\":\"Key resource veins are depleted, making raw materials harder to find.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-40},{\"sectorId\":\"MANUFACTURING\",\"impact\":-25},{\"sectorId\":\"DEFENSE\",\"impact\":-10},{\"sectorId\":\"SURVIVAL\",\"impact\":0},{\"sectorId\":\"TRADE\",\"impact\":5}]},{\"id\":\"ZED_OUTBREAK\",\"name\":\"Severe Zed Outbreak\",\"description\":\"An unusual concentration of Zed activity makes scavenging and travel extremely dangerous.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-30},{\"sectorId\":\"MANUFACTURING\",\"impact\":-10},{\"sectorId\":\"DEFENSE\",\"impact\":15},{\"sectorId\":\"SURVIVAL\",\"impact\":25},{\"sectorId\":\"TRADE\",\"impact\":-20}]},{\"id\":\"TRADE_ROUTE_SECURED\",\"name\":\"Trade Route Secured\",\"description\":\"Traders have established a safer passage, improving the flow of goods.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":5},{\"sectorId\":\"MANUFACTURING\",\"impact\":10},{\"sectorId\":\"DEFENSE\",\"impact\":0},{\"sectorId\":\"SURVIVAL\",\"impact\":15},{\"sectorId\":\"TRADE\",\"impact\":30}]},{\"id\":\"GENERAL_COLLAPSE\",\"name\":\"Societal Collapse Setback\",\"description\":\"A major setback reminds everyone how fragile survival is. Fear grips the market.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-25},{\"sectorId\":\"MANUFACTURING\",\"impact\":-30},{\"sectorId\":\"DEFENSE\",\"impact\":-15},{\"sectorId\":\"SURVIVAL\",\"impact\":-10},{\"sectorId\":\"TRADE\",\"impact\":-40}]}]},\"eventFrequency\":{\"title\":\"Event Frequency\",\"type\":\"number\",\"description\":\"Average number of update cycles between market events (0 to disable). Depends on mod's update frequency (e.g., per in-game hour?).\",\"default\":8,\"minimum\":1},\"defaultEventDuration\":{\"title\":\"Default Event Duration\",\"type\":\"number\",\"description\":\"Default number of update cycles an event lasts.\",\"default\":3,\"minimum\":1,\"maximum\":96},\"transactionFee\":{\"title\":\"Transaction Fee (Dukes Tax)\",\"type\":\"number\",\"description\":\"Percentage fee charged on all buy/sell transactions (5 = 5%)\",\"default\":3,\"minimum\":0,\"maximum\":25},\"vipDiscount\":{\"title\":\"Trader's Favor Discount\",\"type\":\"number\",\"description\":\"Percentage discount on transaction fees for players with 'STOCK_MARKET_BROKER' permission (50 = 50%)\",\"default\":50,\"minimum\":0,\"maximum\":100},\"priceAlertThreshold\":{\"title\":\"Price Alert Threshold\",\"type\":\"number\",\"description\":\"Percentage change that triggers a market alert (15 = 15%)\",\"default\":15,\"minimum\":5,\"maximum\":50}},\"additionalProperties\":false}",
            "uiSchema": "{\"sectors\":{\"items\":{\"ui:order\":[\"id\",\"name\"]}},\"stocks\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"sector\",\"initialPrice\",\"volatility\"]}},\"marketEvents\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"description\",\"sectorImpacts\"],\"sectorImpacts\":{\"items\":{\"ui:order\":[\"sectorId\",\"impact\"]}}}},\"transactionFee\":{\"ui:widget\":\"range\"},\"vipDiscount\":{\"ui:widget\":\"range\"},\"eventFrequency\":{\"ui:help\":\"Set to 0 to disable random events\"},\"priceAlertThreshold\":{\"ui:widget\":\"range\"}}",
            "commands": [
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRIGGER_EVENT')) {\n        throw new TakaroUserError(\"You don't have permission to trigger market events.\");\n    }\n\n    try {\n        // Get current stock data to check market initialization\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Initialize market if needed\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            await player.pm(\"Market was not initialized. Initializing now...\");\n            return;\n        }\n\n        // Get events from module config\n        const marketEvents = mod.userConfig.marketEvents || [];\n\n        if (marketEvents.length === 0) {\n            throw new TakaroUserError(\"No market events configured in this module.\");\n        }\n\n        // Handle case when no event is specified or \"ALL\" is provided\n        if (!args.EventName || args.EventName.toUpperCase() === \"ALL\") {\n            await player.pm(\"=== AVAILABLE MARKET EVENTS ===\\n\");\n\n            // Group events by category or type if possible\n            const eventCategories = {};\n\n            // Create a simple categorization based on positive/negative impact\n            marketEvents.forEach(event => {\n                let category = \"Mixed\";\n                // Calculate net impact across all sectors\n                const netImpact = event.sectorImpacts.reduce((sum, impact) => sum + impact.impact, 0);\n\n                if (netImpact > 0) category = \"Positive\";\n                else if (netImpact < 0) category = \"Negative\";\n\n                if (!eventCategories[category]) {\n                    eventCategories[category] = [];\n                }\n                eventCategories[category].push(event);\n            });\n\n            // Display events by category\n            for (const [category, events] of Object.entries(eventCategories)) {\n                if (events.length > 0) {\n                    await player.pm(`\\n--- ${category.toUpperCase()} EVENTS ---`);\n\n                    let message = \"\";\n                    events.forEach(event => {\n                        // Format primary sectors affected\n                        const primarySectors = event.sectorImpacts\n                            .filter(impact => Math.abs(impact.impact) >= 15)\n                            .map(impact => {\n                                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                                return `${impact.sectorId} ${direction}${Math.abs(impact.impact)}%`;\n                            })\n                            .join(\", \");\n\n                        message += `${event.id}: ${event.name}\\n`;\n                        message += `   ${event.description}\\n`;\n                        if (primarySectors) {\n                            message += `   Major impacts: ${primarySectors}\\n`;\n                        }\n                        message += \"\\n\";\n                    });\n\n                    await player.pm(message);\n                }\n            }\n\n            await player.pm(\"=== HOW TO USE ===\\nUse `/triggerevent <EventName>` to trigger a specific event (e.g., `/triggerevent TECH_BOOM`)\");\n            return;\n        }\n\n        // Find the requested event\n        const eventId = args.EventName.toUpperCase();\n        const event = marketEvents.find(e => e.id === eventId);\n\n        if (!event) {\n            throw new TakaroUserError(`Event \"${eventId}\" not found. Use /triggerevent without parameters to see all available events.`);\n        }\n\n        // Get necessary variables for managing the event\n        const [activeEventVar, eventStartTimeVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_execution_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_cooldown_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['current_event_duration'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Check if there's an active event we need to cancel\n        let activeEventObj = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEventObj = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEventObj && Object.keys(activeEventObj).length > 0) {\n                    await player.pm(`Cancelling active event \"${activeEventObj.name}\" to trigger new event.`);\n                }\n            } catch (e) {\n                // Invalid event data, will be overwritten\n            }\n        }\n\n        // Generate a random duration for the event\n        const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n        // Update or create all event-related variables\n        const updatePromises = [];\n\n        // Save or update the random duration\n        if (eventDurationVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                    value: randomDuration.toString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'current_event_duration',\n                    value: randomDuration.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the event counter to 0\n        if (eventCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the cooldown counter\n        if (cooldownCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update active event\n        if (activeEventVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                    value: JSON.stringify(event)\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: JSON.stringify(event),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update event start time\n        if (eventStartTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update last event time\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (lastEventTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all updates to complete\n        await Promise.all(updatePromises);\n\n        // Check if there are online players to announce the event\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            // Format sector impacts for announcement\n            let impactText = \"\";\n            for (const impact of event.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n            }\n\n            const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${event.name}\\n${event.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /markets to see opportunities!`;\n\n            // Split the message if it's too long\n            const maxLength = 400; // Safe limit for most games\n            for (let i = 0; i < message.length; i += maxLength) {\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message: message.substring(i, i + maxLength)\n                });\n            }\n        }\n\n        await player.pm(`Successfully triggered the \"${event.name}\" market event for ${randomDuration} cycles!`);\n    } catch (error) {\n        // If something goes wrong, log it and let the player know\n        console.log(`Error in triggerEvent: ${error.message}`);\n        throw new TakaroUserError(`Error triggering event: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Store the stocks data\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_data',\n            value: JSON.stringify(stocks),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize last event time to now\n        await takaro.variable.variableControllerCreate({\n            key: 'last_market_event_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize event start time variable\n        await takaro.variable.variableControllerCreate({\n            key: 'event_start_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize active event (empty string means no active event)\n        await takaro.variable.variableControllerCreate({\n            key: 'active_market_event',\n            value: '',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Mark market as initialized\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_initialized',\n            value: 'true',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Announce market initialization to online players\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /markets to see available stocks and /buystock to start investing.\";\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message\n            });\n        }\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "triggerevent",
                    "description": null,
                    "trigger": "triggerevent",
                    "helpText": "Shows all available market events when run without parameters. Use with an event name (e.g., /triggerevent TECH_BOOM) to trigger a specific market event.",
                    "arguments": [
                        {
                            "name": "EventName",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "Event name to trigger a specific market event",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get player's portfolio\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        if (portfolioVar.data.data.length === 0) {\n            throw new TakaroUserError(\"You don't own any stocks to sell.\");\n        }\n\n        const portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        const stockId = args.stock.toUpperCase();\n\n        if (!portfolio[stockId] || portfolio[stockId].shares < amount) {\n            throw new TakaroUserError(`You don't own ${amount} shares of ${stockId}.`);\n        }\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === stockId);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${stockId} not found in current market data. Please contact an admin.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate sale proceeds using Math.round to ensure we work with integers\n        const stockPrice = Math.round(stock.price);\n        const subtotal = stockPrice * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const netProceeds = subtotal - fee;\n\n        // Add money to player - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerAddCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: netProceeds\n            }\n        );\n\n        // Calculate profit/loss\n        const profitPerShare = stockPrice - portfolio[stockId].averagePrice;\n        const totalProfit = Math.round(profitPerShare * amount);\n        const profitText = totalProfit >= 0\n            ? `profit of $${totalProfit}`\n            : `loss of $${Math.abs(totalProfit)}`;\n\n        // Update portfolio\n        portfolio[stockId].shares -= amount;\n        if (portfolio[stockId].shares === 0) {\n            delete portfolio[stockId];\n        }\n\n        // Save updated portfolio\n        await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n            value: JSON.stringify(portfolio)\n        });\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'SELL',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: netProceeds,\n            profit: totalProfit,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully sold ${amount} shares of ${stockId} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Net proceeds: $${netProceeds} (${profitText})`;\n\n        // Add remaining shares info if player still has some\n        if (portfolio[stockId]) {\n            message += `\\nRemaining shares: ${portfolio[stockId].shares}`;\n        } else {\n            message += `\\nYou've sold all your ${stockId} shares.`;\n        }\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in sellstock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your sale. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "sellstock",
                    "description": null,
                    "trigger": "sellstock",
                    "helpText": "Sell shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to sell",
                            "position": 1
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === args.stock.toUpperCase());\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${args.stock} not found. Use /market to see available stocks.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate costs using Math.round to ensure we work with integers\n        const subtotal = Math.round(stock.price) * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const totalCost = subtotal + fee;\n\n        // Check if player has enough currency\n        const playerData = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, player.id);\n        const currentBalance = playerData.data.data.currency;\n\n        if (currentBalance < totalCost) {\n            throw new TakaroUserError(`You don't have enough currency. Cost: $${subtotal} + $${fee} fee = $${totalCost}. Your balance: $${currentBalance}`);\n        }\n\n        // Deduct the currency - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerDeductCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: totalCost\n            }\n        );\n\n        // Get player's portfolio or create new one\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        let portfolio;\n        if (portfolioVar.data.data.length === 0) {\n            portfolio = {};\n        } else {\n            portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        }\n\n        // Update portfolio using rounded values for consistency\n        const stockPrice = Math.round(stock.price);\n        if (!portfolio[stock.id]) {\n            portfolio[stock.id] = {\n                shares: amount,\n                averagePrice: stockPrice\n            };\n        } else {\n            const totalShares = portfolio[stock.id].shares + amount;\n            const totalValue = (portfolio[stock.id].shares * portfolio[stock.id].averagePrice) + (amount * stockPrice);\n            portfolio[stock.id].shares = totalShares;\n            portfolio[stock.id].averagePrice = Math.round(totalValue / totalShares);\n        }\n\n        // Save updated portfolio\n        if (portfolioVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_portfolio',\n                value: JSON.stringify(portfolio),\n                gameServerId,\n                moduleId: mod.moduleId,\n                playerId: player.id\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n                value: JSON.stringify(portfolio)\n            });\n        }\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'BUY',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: totalCost,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully bought ${amount} shares of ${stock.id} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Total cost: $${totalCost}\\n`;\n        message += `Current portfolio: ${portfolio[stock.id].shares} shares of ${stock.id}`;\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in buystock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your purchase. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "buystock",
                    "description": null,
                    "trigger": "buystock",
                    "helpText": "Buy shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol ",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to buy",
                            "position": 1
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // If a specific stock ticker is provided, show detailed info for that stock\n    const specificTicker = args.ticker ? args.ticker.toUpperCase() : null;\n\n    if (specificTicker && specificTicker !== \"ALL\") {\n        const stock = stocks.find(s => s.id.toUpperCase() === specificTicker);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${specificTicker} not found. Use /stockinfo without parameters to see all available stocks.`);\n        }\n\n        // Get active event to see if this stock's sector is affected\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let activeEvent = null;\n        let sectorImpact = null;\n\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEvent && activeEvent.sectorImpacts) {\n                    sectorImpact = activeEvent.sectorImpacts.find(impact =>\n                        impact.sectorId === stock.sector\n                    );\n                }\n            } catch (e) {\n                // Ignore parsing errors\n            }\n        }\n\n        // Calculate price change indicators\n        let changeText = '';\n        if (stock.lastPrice) {\n            const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n            const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n            changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n        }\n\n        // Add risk assessment based on volatility without showing the raw value\n        let riskLevel;\n        if (stock.volatility <= 0.05) riskLevel = \"Very Low\";\n        else if (stock.volatility <= 0.10) riskLevel = \"Low\";\n        else if (stock.volatility <= 0.15) riskLevel = \"Moderate\";\n        else if (stock.volatility <= 0.20) riskLevel = \"High\";\n        else riskLevel = \"Very High\";\n\n        // Build detailed stock info message\n        let message = `=== ${stock.id}: ${stock.name} ===\\n\\n`;\n        message += `Sector: ${stock.sector}\\n`;\n        message += `Current Price: $${Math.round(stock.price)}${changeText}\\n`;\n        message += `Risk Level: ${riskLevel}\\n`;\n\n        // Add sector trend info if available from event\n        if (activeEvent && sectorImpact) {\n            const direction = sectorImpact.impact >= 0 ? \"Positive\" : \"Negative\";\n            const strength = Math.abs(sectorImpact.impact);\n            let trend;\n\n            if (strength < 10) trend = \"Slight\";\n            else if (strength < 25) trend = \"Moderate\";\n            else trend = \"Strong\";\n\n            message += `\\nCurrent Trend: ${trend} ${direction} (${activeEvent.name})\\n`;\n            message += `Event: ${activeEvent.description}\\n`;\n        }\n\n        // Add trading guidance based on sector and risk, without mentioning volatility\n        message += `\\nTrading Notes:\\n`;\n\n        if (activeEvent && sectorImpact) {\n            if (sectorImpact.impact > 0) {\n                message += `- Currently bullish due to the ${activeEvent.name} event\\n`;\n            } else {\n                message += `- Currently bearish due to the ${activeEvent.name} event\\n`;\n            }\n        }\n\n        if (riskLevel === \"High\" || riskLevel === \"Very High\") {\n            message += `- Expect significant price fluctuations with this stock\\n`;\n        } else if (riskLevel === \"Low\" || riskLevel === \"Very Low\") {\n            message += `- Typically has stable price movement\\n`;\n        }\n\n        message += `\\nUse /buystock ${stock.id} [amount] to purchase shares`;\n\n        await player.pm(message);\n\n    } else {\n        // No specific ticker provided or ALL specified, show summary of all stocks\n        await player.pm(\"=== STOCK MARKET LISTINGS ===\\n\");\n\n        // Group stocks by sector\n        const stocksBySector = {};\n        stocks.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        // Display stocks by sector\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            let sectorMessage = `\\n--- ${sector} SECTOR ---\\n`;\n\n            sectorStocks.forEach(stock => {\n                // Add price change indicators\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                    changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                // Add risk level based on volatility\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                sectorMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n\n            await player.pm(sectorMessage);\n        }\n\n        // Add legend for risk indicators\n        const legend = \"\\n=== LEGEND ===\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\" +\n            \"Use /stockinfo [ticker] for detailed information about a specific stock\";\n\n        await player.pm(legend);\n    }\n}\n\nawait main();",
                    "name": "stockinfo",
                    "description": null,
                    "trigger": "stockinfo",
                    "helpText": "Shows all available stocks in the market. Use with a ticker symbol (e.g., /stockinfo ticker) to see detailed information about a specific stock.",
                    "arguments": [
                        {
                            "name": "ticker",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "stock ticker or ALL to get detailed information about a specific stock",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Handle the industry argument - use \"ALL\" as a special value to show all industries\n    const industryFilter = args.Industry ? args.Industry.toUpperCase() : \"ALL\";\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    // If market data doesn't exist, try to initialize it\n    if (marketDataVar.data.data.length === 0) {\n        const initialized = await initializeMarketIfNeeded(gameServerId, mod);\n        if (!initialized) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        // Get the freshly initialized market data\n        const refreshedMarketData = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (refreshedMarketData.data.data.length === 0) {\n            throw new TakaroUserError(\"There was an issue initializing the stock market. Please try again later.\");\n        }\n\n        // Continue with the refreshed data\n        await displayMarketSummary(player, gameServerId, mod, refreshedMarketData.data.data[0], industryFilter);\n    } else {\n        // Market data exists, display it\n        await displayMarketSummary(player, gameServerId, mod, marketDataVar.data.data[0], industryFilter);\n    }\n}\n\n// Display the market summary to the player\nasync function displayMarketSummary(player, gameServerId, mod, marketDataVariable, industryFilter) {\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Handle empty string or empty object\n            if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (e) {\n            // In case of parsing error\n            activeEvent = null;\n        }\n    }\n\n    const stocks = JSON.parse(marketDataVariable.value);\n\n    // Get all available industries for reference\n    const availableIndustries = [...new Set(stocks.map(stock => stock.sector))];\n\n    // If industry filter is provided and not \"ALL\", check if it's valid\n    if (industryFilter !== \"ALL\") {\n        // Check if the industry exists\n        const industryExists = availableIndustries.includes(industryFilter);\n\n        if (!industryExists) {\n            throw new TakaroUserError(`Industry \"${industryFilter}\" not found. Available industries: ${availableIndustries.join(', ')}\\nUse \"ALL\" to view all industries.`);\n        }\n    }\n\n    // Send header message\n    let headerMessage = \"=== STOCK MARKET SUMMARY ===\\n\";\n\n    // If filtering by industry, mention it in the header\n    if (industryFilter !== \"ALL\") {\n        headerMessage = `=== ${industryFilter} INDUSTRY ===\\n`;\n    }\n\n    // If there's an active event, include it in the header\n    if (activeEvent) {\n        headerMessage += `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n`;\n        headerMessage += `${activeEvent.description}\\n\\n`;\n\n        // If filtering by industry, only show relevant impacts\n        if (industryFilter !== \"ALL\") {\n            const relevantImpact = activeEvent.sectorImpacts.find(\n                impact => impact.sectorId === industryFilter\n            );\n\n            if (relevantImpact) {\n                const direction = relevantImpact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `Industry Impact: ${direction} ${Math.abs(relevantImpact.impact)}%\\n`;\n            } else {\n                headerMessage += \"This industry is not directly affected by the current event.\\n\";\n            }\n        } else {\n            // Show all industry impacts\n            headerMessage += \"Industry Impacts:\\n\";\n            for (const impact of activeEvent.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%\\n`;\n            }\n        }\n    }\n\n    // Send header message first\n    await player.pm(headerMessage);\n\n    // Group stocks by industry\n    const stocksByIndustry = {};\n    stocks.forEach(stock => {\n        if (!stocksByIndustry[stock.sector]) {\n            stocksByIndustry[stock.sector] = [];\n        }\n        stocksByIndustry[stock.sector].push(stock);\n    });\n\n    // If industry filter is not \"ALL\", only show that industry\n    if (industryFilter !== \"ALL\") {\n        const filteredStocks = stocksByIndustry[industryFilter] || [];\n\n        if (filteredStocks.length > 0) {\n            let stockMessage = \"\";\n\n            filteredStocks.forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                stockMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(stockMessage);\n        } else {\n            await player.pm(`No stocks found in the ${industryFilter} industry.`);\n        }\n    } else {\n        // Send each industry as a separate message\n        for (const industryId in stocksByIndustry) {\n            let industryMessage = `=== ${industryId} INDUSTRY ===\\n`;\n\n            stocksByIndustry[industryId].forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                industryMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(industryMessage);\n        }\n    }\n\n    // Add a help message for industry filtering if showing all industries\n    if (industryFilter === \"ALL\") {\n        const allIndustries = Object.keys(stocksByIndustry).join(', ');\n        await player.pm(`\\nTip: Use '/markets [industry]' to view only stocks in a specific industry. Available industries: ${allIndustries}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return false;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            const results = await Promise.allSettled(createPromises);\n            // Check if the critical stock_market_data was created successfully\n            const stockDataPromise = results[0];\n            if (stockDataPromise && stockDataPromise.status === 'rejected') {\n                console.log(`Failed to create stock_market_data: ${stockDataPromise.reason}`);\n                return false;\n            }\n        }\n\n        return true;\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n        return false;\n    }\n}\n\nawait main();",
                    "name": "markets",
                    "description": null,
                    "trigger": "markets",
                    "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. \n",
                    "arguments": [
                        {
                            "name": "Industry",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. ",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // Get player's portfolio\n    const portfolioVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_portfolio'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId],\n            playerId: [player.id]\n        }\n    });\n\n    let portfolio = {};\n    if (portfolioVar.data.data.length > 0) {\n        portfolio = JSON.parse(portfolioVar.data.data[0].value);\n    }\n\n    // Send header\n    await player.pm(\"=== YOUR STOCK PORTFOLIO ===\");\n\n    let hasStocks = false;\n    let totalValue = 0;\n    let totalInvestment = 0;\n\n    // If no stocks, send a simple message\n    if (Object.keys(portfolio).length === 0) {\n        await player.pm(\"You don't own any stocks yet.\\n\" +\n            \"Use /markets to see available stocks and prices.\\n\" +\n            \"Use /buy <stock> <amount> to purchase stocks.\");\n        return;\n    }\n\n    // Send each stock as a separate message to avoid length issues\n    for (const [stockId, data] of Object.entries(portfolio)) {\n        hasStocks = true;\n        const stock = stocks.find(s => s.id === stockId);\n        if (!stock) continue; // Stock might have been removed from config\n\n        const currentValue = stock.price * data.shares;\n        const investmentValue = data.averagePrice * data.shares;\n        totalValue += currentValue;\n        totalInvestment += investmentValue;\n        const profit = currentValue - investmentValue;\n        const profitPercent = ((profit / investmentValue) * 100).toFixed(1);\n\n        let stockMessage = `--- ${stockId} (${stock.sector}) ---\\n`;\n        stockMessage += `Shares: ${data.shares}\\n`;\n        stockMessage += `Avg buy: $${Math.round(data.averagePrice)}\\n`;\n        stockMessage += `Current price: $${Math.round(stock.price)}\\n`;\n        stockMessage += `Total value: $${Math.round(currentValue)}\\n`;\n\n        if (profit >= 0) {\n            stockMessage += `Profit: +$${Math.round(profit)} (+${profitPercent}%)\\n`;\n        } else {\n            stockMessage += `Loss: -$${Math.abs(Math.round(profit))} (${profitPercent}%)\\n`;\n        }\n\n        await player.pm(stockMessage);\n    }\n\n    if (hasStocks) {\n        const totalProfit = totalValue - totalInvestment;\n        const totalProfitPercent = ((totalProfit / totalInvestment) * 100).toFixed(1);\n\n        let summaryMessage = \"=== PORTFOLIO SUMMARY ===\\n\";\n        summaryMessage += `Total investment: $${Math.round(totalInvestment)}\\n`;\n        summaryMessage += `Current value: $${Math.round(totalValue)}\\n`;\n\n        if (totalProfit >= 0) {\n            summaryMessage += `Overall profit: +$${Math.round(totalProfit)} (+${totalProfitPercent}%)\\n`;\n        } else {\n            summaryMessage += `Overall loss: -$${Math.abs(Math.round(totalProfit))} (${totalProfitPercent}%)\\n`;\n        }\n\n        // Get transaction history count\n        try {\n            const historyVar = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: ['stock_transaction_history'],\n                    gameServerId: [gameServerId],\n                    moduleId: [mod.moduleId],\n                    playerId: [player.id]\n                }\n            });\n\n            if (historyVar.data.data.length > 0) {\n                const history = JSON.parse(historyVar.data.data[0].value);\n                const buyCount = history.filter(t => t.type === 'BUY').length;\n                const sellCount = history.filter(t => t.type === 'SELL').length;\n\n                summaryMessage += `\\nTransactions: ${history.length} (${buyCount} buys, ${sellCount} sells)\\n`;\n            }\n        } catch (error) {\n            // Just ignore history errors\n        }\n\n        await player.pm(summaryMessage);\n\n    }\n}\n\nawait main();",
                    "name": "stockportfolio",
                    "description": null,
                    "trigger": "stockportfolio",
                    "helpText": "No help text available",
                    "arguments": []
                }
            ],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    try {\n        const { gameServerId, module: mod } = data;\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Check if market is initialized\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return; // Exit after initialization\n        }\n\n        // Get active market event\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event start time\n        const eventStartTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_start_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event execution counter\n        const eventCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_execution_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event cooldown counter\n        const cooldownCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_cooldown_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let eventCounter = 0;\n        if (eventCounterVar.data.data.length > 0) {\n            eventCounter = parseInt(eventCounterVar.data.data[0].value, 10);\n        }\n\n        let cooldownCounter = 0;\n        if (cooldownCounterVar.data.data.length > 0) {\n            cooldownCounter = parseInt(cooldownCounterVar.data.data[0].value, 10);\n        }\n\n        // Get event duration\n        const eventDurationVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['current_event_duration'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Use stored random duration if available, otherwise use defaultEventDuration\n        let eventDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        if (eventDurationVar.data.data.length > 0) {\n            eventDuration = parseInt(eventDurationVar.data.data[0].value, 10);\n        }\n\n        let activeEvent = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                // If it's an empty string, treat as no active event\n                if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                    activeEvent = null;\n                }\n            } catch (e) {\n                // In case of parsing error, consider no active event\n                activeEvent = null;\n            }\n        }\n\n        // Check if the current event should end and increment counter\n        if (activeEvent) {\n            // Increment the event execution counter\n            eventCounter++;\n\n            // Update or create the counter\n            if (eventCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: eventCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: eventCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n\n            // End the event if counter reached duration\n            if (eventCounter >= eventDuration) {\n                // Clear the active event\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: ''\n                    });\n                }\n\n                // Reset counter to 0\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                // Reset cooldown counter to 0 to begin cooldown period\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_cooldown_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Announce the end of the event to all online players\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    const message = `ðŸ“ˆ MARKET UPDATE ðŸ“‰\\n\\nThe \"${activeEvent.name}\" event has ended. Markets are returning to normal conditions.`;\n\n                    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                        message: message\n                    });\n                }\n\n                // Reset active event\n                activeEvent = null;\n            }\n        } else {\n            // No active event, increment cooldown counter\n            cooldownCounter++;\n\n            // Update or create the cooldown counter\n            if (cooldownCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: cooldownCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: cooldownCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n        }\n\n        // Get last event time for event frequency calculation\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        const eventFrequency = (mod.userConfig && mod.userConfig.eventFrequency) || 10;\n        let shouldTriggerEvent = false;\n\n        // Only trigger a new event if:\n        // 1. There's no active event \n        // 2. We have passed the cooldown period (cooldownCounter >= eventFrequency)\n        if (!activeEvent && cooldownCounter >= eventFrequency) {\n            // Base chance to trigger an event\n            shouldTriggerEvent = Math.random() < 0.5; // 50% chance\n\n            // Force an event if we're well past the cooldown period (2x frequency)\n            if (cooldownCounter >= eventFrequency * 2) {\n                shouldTriggerEvent = true;\n            }\n        }\n\n        // If we should trigger a new event, select a random one\n        if (shouldTriggerEvent) {\n            const events = (mod.userConfig && mod.userConfig.marketEvents) || [];\n            if (events.length > 0) {\n                const randomEvent = events[Math.floor(Math.random() * events.length)];\n                activeEvent = randomEvent;\n\n                // Generate a random duration between 1 and defaultEventDuration\n                const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n                const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n                // Save the random duration\n                if (eventDurationVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                        value: randomDuration.toString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'current_event_duration',\n                        value: randomDuration.toString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Reset the event counter to 0\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Reset the cooldown counter\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                // Update active event\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: JSON.stringify(activeEvent)\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'active_market_event',\n                        value: JSON.stringify(activeEvent),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Update event start time\n                if (eventStartTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_start_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Update last event time\n                if (lastEventTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'last_market_event_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Announce the event to all online players\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    // Format sector impacts for announcement\n                    let impactText = \"\";\n                    for (const impact of activeEvent.sectorImpacts) {\n                        const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                        impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n                    }\n\n                    const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${activeEvent.name}\\n${activeEvent.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /market to see opportunities!`;\n\n                    // Split the message if it's too long\n                    const maxLength = 400; // Safe limit for most games\n                    for (let i = 0; i < message.length; i += maxLength) {\n                        await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                            message: message.substring(i, i + maxLength)\n                        });\n                    }\n                }\n            }\n        }\n\n        // Get stocks\n        if (!marketDataVar.data.data[0] || !marketDataVar.data.data[0].value) {\n            // Re-initialize market if value is missing\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        let stocks;\n        try {\n            stocks = JSON.parse(marketDataVar.data.data[0].value);\n            if (!Array.isArray(stocks)) {\n                throw new Error(\"Parsed stocks data is not an array\");\n            }\n        } catch (e) {\n            // Re-initialize market if data is corrupt\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        const significantChanges = [];\n\n        // Update each stock price\n        stocks.forEach(stock => {\n            // Save the current price as lastPrice for change tracking\n            if (!stock.lastPrice) {\n                stock.lastPrice = stock.price;\n            } else {\n                stock.lastPrice = stock.price;\n            }\n\n            // Calculate base price change based on volatility\n            // Using a more normalized random approach\n            // Math.random() * 2 - 1 gives a value between -1 and 1\n            const randomFactor = Math.random() * 2 - 1;\n            const baseChangePercent = randomFactor * stock.volatility;\n            let totalChangePercent = baseChangePercent;\n\n            // Apply active event effects if any\n            if (activeEvent) {\n                const sectorImpact = activeEvent.sectorImpacts.find(impact => impact.sectorId === stock.sector);\n                if (sectorImpact) {\n                    // Convert impact percentage to decimal and apply a random factor\n                    // to create varied effects within each sector\n                    const eventImpactPercentage = sectorImpact.impact; // This is already a percentage\n                    const eventImpactDecimal = eventImpactPercentage / 100; // Convert to decimal\n                    const randomImpactFactor = 0.5 + Math.random(); // Between 0.5 and 1.5\n                    const eventImpact = eventImpactDecimal * randomImpactFactor;\n\n                    // Add the event impact to the total change percent\n                    totalChangePercent += eventImpact;\n                }\n            }\n\n            // Apply the price change\n            const oldPrice = stock.price;\n            const priceChange = stock.price * totalChangePercent;\n            stock.price = Math.max(1, stock.price + priceChange);\n\n            // Check if this is a significant change\n            const changeThreshold = ((mod.userConfig && mod.userConfig.priceAlertThreshold) || 10) / 100;\n            const percentChange = (stock.price - stock.lastPrice) / stock.lastPrice;\n\n            if (Math.abs(percentChange) > changeThreshold) {\n                significantChanges.push({\n                    ...stock,\n                    changePercent: percentChange * 100\n                });\n            }\n        });\n\n        // Save updated prices\n        await takaro.variable.variableControllerUpdate(marketDataVar.data.data[0].id, {\n            value: JSON.stringify(stocks)\n        });\n\n        // Broadcast major changes to all players\n        if (significantChanges.length > 0) {\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                // Sort by absolute change percentage\n                significantChanges.sort((a, b) => Math.abs(b.changePercent) - Math.abs(a.changePercent));\n\n                // Take top 3 most significant changes\n                const topChanges = significantChanges.slice(0, Math.min(3, significantChanges.length));\n\n                // Formulate message about big market changes\n                let message = \"ðŸ“Š STOCK MARKET ALERT ðŸ“Š\\n\";\n                topChanges.forEach(stock => {\n                    const changeDir = stock.changePercent > 0 ? \"up\" : \"down\";\n                    const changePercent = Math.abs(Math.round(stock.changePercent));\n\n                    message += `${stock.id} (${stock.sector}): ${changeDir} ${changePercent}% to $${Math.round(stock.price)}!\\n`;\n                });\n\n                if (activeEvent) {\n                    message += `\\nCurrent market event: ${activeEvent.name}`;\n                }\n\n                // Send the message\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            }\n        }\n    } catch (error) {\n        // If something goes wrong, log it\n        console.log(`Error in updateStockPrices: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            await Promise.allSettled(createPromises);\n        }\n\n        // Only announce if we had to create at least the stock data (indicating a new market)\n        if (marketDataVar.data.data.length === 0) {\n            // Announce market initialization to online players\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /market to see available stocks and /buy to start investing.\";\n\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            }\n        }\n    } catch (error) {\n        // Log the error but don't throw, so the cronjob can continue\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "updatestockprices",
                    "description": null,
                    "temporalValue": "5 4 * * *"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n\n    // Check for online players\n    const currentPlayers = (await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    })).data.meta;\n\n    if (currentPlayers.total === 0) {\n        takaro.log.info('Skipping daily market report: No players online.');\n        return; // No players online, skip the market news\n    }\n\n    // Get current stock data (which should include lastPrice)\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        takaro.log.warn('Skipping daily market report: Market data variable not found.');\n        return; // Market not initialized yet\n    }\n\n    let stocks;\n    try {\n        stocks = JSON.parse(marketDataVar.data.data[0].value);\n        if (!Array.isArray(stocks)) {\n            throw new Error('Parsed market data is not an array.');\n        }\n    } catch (error) {\n        takaro.log.error(`Failed to parse stock_market_data: ${error}`);\n        return; // Invalid market data\n    }\n\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n        } catch (error) {\n            takaro.log.warn(`Failed to parse active_market_event: ${error}`);\n            // Continue without event info if parsing fails\n        }\n    }\n\n    // --- Message 1: Header and active event ---\n    let message1 = \"==== DAILY MARKET REPORT ====\\n\";\n    if (activeEvent && activeEvent.name && activeEvent.description) {\n        message1 += `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n${activeEvent.description}\\n`;\n    } else {\n        message1 += '\\nNo active market events today.\\n';\n    }\n\n    // Send first part of the report\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: message1\n    }).catch(err => takaro.log.error(`Failed to send message 1: ${err}`));\n\n    // --- Calculate stock performance using stock.price and stock.lastPrice ---\n    const stocksWithPerformance = stocks.map(stock => {\n        let change = 0;\n        let percentChange = 0;\n        let changeSymbol = 'â†’'; // Default: No change or insufficient data\n\n        // Ensure required fields exist and lastPrice is a valid number > 0 for percentage calculation\n        if (typeof stock.price === 'number' && typeof stock.lastPrice === 'number' && stock.lastPrice !== 0) {\n            change = stock.price - stock.lastPrice;\n            percentChange = (change / stock.lastPrice) * 100;\n            if (percentChange > 0.05) { // Use a small threshold to avoid 'noise'\n                changeSymbol = 'â†‘';\n            } else if (percentChange < -0.05) {\n                changeSymbol = 'â†“';\n            }\n        } else if (typeof stock.price === 'number' && stock.lastPrice === undefined) {\n            // Handle case where lastPrice might not exist (e.g., new stock)\n            changeSymbol = 'ðŸ†•'; // Indicate 'New' or similar\n            percentChange = 0; // Or handle as needed\n        }\n        // If lastPrice is 0, or types are wrong, change/percentChange remain 0, symbol remains 'â†’'\n\n        return {\n            ...stock,\n            change,         // Absolute change\n            percentChange,  // Percentage change\n            changeSymbol    // Visual indicator\n        };\n    });\n\n    // --- Group by sector ---\n    const sectorPerformance = {};\n    stocksWithPerformance.forEach(stock => {\n        const sectorId = stock.sector || 'Uncategorized'; // Default sector if missing\n        if (!sectorPerformance[sectorId]) {\n            sectorPerformance[sectorId] = {\n                stocks: [],\n                totalPercentChange: 0, // Sum percentages for averaging\n                count: 0\n            };\n        }\n        sectorPerformance[sectorId].stocks.push(stock);\n        // Only include stocks with valid percentage change in the average\n        if (typeof stock.percentChange === 'number' && isFinite(stock.percentChange)) {\n            sectorPerformance[sectorId].totalPercentChange += stock.percentChange;\n            sectorPerformance[sectorId].count++;\n        }\n    });\n\n    // --- Calculate average sector performance ---\n    for (const sectorId in sectorPerformance) {\n        const sectorData = sectorPerformance[sectorId];\n        if (sectorData.count > 0) {\n            sectorData.avgPerformance = sectorData.totalPercentChange / sectorData.count;\n        } else {\n            sectorData.avgPerformance = 0; // Avoid division by zero if no stocks had valid changes\n        }\n    }\n\n    // Sort sectors by average performance\n    const sortedSectors = Object.entries(sectorPerformance)\n        .sort(([, a], [, b]) => b.avgPerformance - a.avgPerformance);\n\n    // --- Message 2: Sector performance ---\n    let message2 = \"\\n=== SECTOR PERFORMANCE ===\\n\";\n    if (sortedSectors.length > 0) {\n        sortedSectors.forEach(([sectorId, data]) => {\n            const avgSymbol = data.avgPerformance > 0.05 ? 'â†‘' : data.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n            message2 += `${sectorId}: ${avgSymbol} ${Math.abs(data.avgPerformance).toFixed(1)}%\\n`; // Use toFixed(1) like command\n        });\n    } else {\n        message2 += \"No sector performance data available.\\n\";\n    }\n\n    // Send sector performance report\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: message2\n    }).catch(err => takaro.log.error(`Failed to send message 2: ${err}`));\n\n\n    // --- Message 3: Top and Worst performers ---\n    // Filter out stocks where percentChange couldn't be calculated properly before sorting\n    const validPerformers = stocksWithPerformance.filter(s => typeof s.percentChange === 'number' && isFinite(s.percentChange));\n\n    // Sort valid performers\n    validPerformers.sort((a, b) => b.percentChange - a.percentChange);\n\n    let message3 = \"\\nðŸ”¥ TOP PERFORMERS ðŸ”¥\\n\";\n    if (validPerformers.length > 0) {\n        for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n            const stock = validPerformers[i];\n            // Use the pre-calculated changeSymbol based on percentChange\n            message3 += `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n        }\n    } else {\n        message3 += \"No top performers today.\\n\";\n    }\n\n\n    message3 += \"\\nðŸ“‰ WORST PERFORMERS ðŸ“‰\\n\";\n    if (validPerformers.length > 0) {\n        // Sort for worst (ascending order) - no need to create a new sorted array if we just reverse iteration\n        const worstStartIndex = Math.max(0, validPerformers.length - 3);\n        for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n            const stock = validPerformers[i];\n            // Use the pre-calculated changeSymbol based on percentChange\n            message3 += `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n        }\n    } else {\n        message3 += \"No worst performers today.\\n\";\n    }\n\n\n    // Send top/worst performers report\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: message3\n    }).catch(err => takaro.log.error(`Failed to send message 3: ${err}`));\n\n    // --- IMPORTANT: REMOVED the update of 'stock_market_yesterday' ---\n    // This script now assumes 'stock_market_data' contains 'lastPrice'.\n    // The responsibility of updating 'lastPrice' and the new 'price'\n    // must lie in another script/process that runs *before* this report.\n\n    takaro.log.info('Daily market report sent successfully.');\n}\n\nawait main();",
                    "name": "marketnews",
                    "description": null,
                    "temporalValue": "0 */1 * * *"
                }
            ],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Allows the player to view market prices and their portfolio",
                    "permission": "STOCK_MARKET_USE",
                    "friendlyName": "Use Stock Market"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows the player to buy and sell stocks",
                    "permission": "STOCK_MARKET_TRADE",
                    "friendlyName": "Trade Stocks"
                },
                {
                    "canHaveCount": false,
                    "description": "VIP status that reduces transaction fees",
                    "permission": "STOCK_MARKET_BROKER",
                    "friendlyName": "Stock Broker"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows admins to manually trigger market events",
                    "permission": "STOCK_MARKET_TRIGGER_EVENT",
                    "friendlyName": "Trigger Market Events"
                }
            ]
        },
        {
            "tag": "0.1.13",
            "description": "**Stock Market: A Dynamic Virtual Trading System**\n\nCreate an immersive economic experience with this comprehensive stock market module that lets players invest, trade, and react to market events.\n\n**Market Features:**\n\n![Market Summary](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stocks.png)\n\n* **Multiple Economic Sectors:** Configure various industry sectors (Resource Extraction, Manufacturing, Defense, etc.) each with their own market dynamics.\n* **Realistic Stock Behavior:** Stocks have configurable volatility, sector-based pricing, and react differently to market events.\n* **Dynamic Market Events:** Random or admin-triggered events like \"Horde Night Approaching\" or \"Societal Collapse Setback\" impact different sectors in realistic ways.\n\n![Market Events](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_events.png)\n\n**Trading System:**\n\n* **Buy & Sell Shares:** Players can purchase stocks and sell them later for profit or loss.\n* **Transaction Fees:** Configurable fee percentage on all trades creates a realistic market economy.\n* **VIP Benefits:** Special permissions for designated \"Stock Brokers\" who receive fee discounts.\n\n![Buy Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_buy.png)\n\nPlayers can track price changes and sell at the right moment to maximize profits or minimize losses.\n\n![Sell Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sell.png)\n\n**Player Portfolio:**\n\n* **Portfolio Tracking:** Players can view their holdings, average purchase prices, and current profit/loss.\n* **Transaction History:** System tracks all buy/sell transactions for each player.\n* **Summary Statistics:** See overall portfolio performance and value across all holdings.\n\n![Portfolio View](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockportfolio.png)\n\n**Market Information:**\n\n* **Detailed Stock Info:** Players can research specific stocks, including risk levels and sector trends.\n* **Industry Filters:** View stocks by specific sectors to better understand market segments.\n* **Market Alerts:** Server-wide notifications for significant price changes keep players engaged.\n\n![Market Alerts](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockpricechange.png)\n\n**Configuration Options:**\n\n* **Sectors & Stocks:** Define your own market sectors and individual stocks with customizable starting prices and volatility.\n* **Market Events:** Create unique events with specific sector impacts to drive market dynamics.\n* **Transaction Settings:** Configure fee percentages, VIP discounts, and alert thresholds.\n* **Event Frequency:** Control how often random market events occur and how long they last.\n\n![Configuration](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_config.png)\n![Sectors](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sectors.png)\n\n**Commands:**\n\n* `/markets [industry]` - View all stocks or filter by industry\n* `/stockinfo [ticker]` - Get detailed information about a specific stock\n* `/buystock <ticker> <amount>` - Purchase shares of a stock\n* `/sellstock <ticker> <amount>` - Sell shares from your portfolio\n* `/stockportfolio` - View your current holdings and performance\n* `/triggerevent [event]` - Admin command to trigger specific market events\n\nWho says the apocalypse can't have a thriving economy? Now players can stress about both zombie hordes AND their Duke's Casino Tokens dropping 40% after a market event! As one trader put it: \"I used to check my 401K daily, and now I check my AMMO stock before every Blood Moon. Some habits die harder than zombies.\"",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sectors\":{\"type\":\"array\",\"title\":\"Wasteland Economic Sectors\",\"description\":\"Define economic sectors relevant to survival in Navezgane\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Sector ID (e.g., Very Low Risk)\"},\"name\":{\"type\":\"string\",\"description\":\"Sector name (e.g., Very Low Risk)\"}}},\"default\":[{\"id\":\"Very High Risk\",\"name\":\"Very High Risk\"},{\"id\":\"High Risk\",\"name\":\"High Risk\"},{\"id\":\"Medium Risk\",\"name\":\"Medium Risk\"},{\"id\":\"Low Risk\",\"name\":\"Low Risk\"},{\"id\":\"Very Low Risk\",\"name\":\"Very Low Risk\"}]},\"stocks\":{\"type\":\"array\",\"title\":\"Wasteland Stocks\",\"description\":\"List of stocks representing Navezgane entities and resources\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Stock ticker symbol (e.g., NMC)\"},\"name\":{\"type\":\"string\",\"description\":\"Entity/Resource name\"},\"sector\":{\"type\":\"string\",\"description\":\"Sector ID this stock belongs to\"},\"initialPrice\":{\"type\":\"number\",\"description\":\"Starting price in Dukes\",\"minimum\":1},\"volatility\":{\"type\":\"number\",\"description\":\"Base volatility percentage (5 = 5%)\",\"minimum\":1,\"maximum\":60}}},\"default\":[{\"id\":\"NMC\",\"name\":\"Navezgane Mining Co.\",\"sector\":\"High Risk\",\"initialPrice\":50,\"volatility\":15},{\"id\":\"NIOM\",\"name\":\"Navezgane Iron Ore Mining Co.\",\"sector\":\"High Risk\",\"initialPrice\":55,\"volatility\":16},{\"id\":\"NLMC\",\"name\":\"Navezgane Lead Mining Co.\",\"sector\":\"Medium Risk\",\"initialPrice\":45,\"volatility\":14},{\"id\":\"WOOD\",\"name\":\"Wasteland Lumberjacks\",\"sector\":\"Low Risk\",\"initialPrice\":20,\"volatility\":8},{\"id\":\"SHALE\",\"name\":\"Oil Shale Extractors\",\"sector\":\"Very High Risk\",\"initialPrice\":40,\"volatility\":45},{\"id\":\"FORGE\",\"name\":\"Forge Ahead Metals\",\"sector\":\"Medium Risk\",\"initialPrice\":75,\"volatility\":12},{\"id\":\"TOOLS\",\"name\":\"Working Stiff Tools\",\"sector\":\"Low Risk\",\"initialPrice\":60,\"volatility\":10},{\"id\":\"AIA\",\"name\":\"A1 Auto\",\"sector\":\"Medium Risk\",\"initialPrice\":40,\"volatility\":14},{\"id\":\"AMC\",\"name\":\"Atlas Metal Company\",\"sector\":\"Medium Risk\",\"initialPrice\":65,\"volatility\":13},{\"id\":\"COC\",\"name\":\"COC Chemicals\",\"sector\":\"Very High Risk\",\"initialPrice\":55,\"volatility\":50},{\"id\":\"MECH\",\"name\":\"JunkTech Robotics\",\"sector\":\"High Risk\",\"initialPrice\":110,\"volatility\":25},{\"id\":\"BUILD\",\"name\":\"Barricade Builders\",\"sector\":\"Low Risk\",\"initialPrice\":45,\"volatility\":9},{\"id\":\"ZBI\",\"name\":\"Zombie Bashers Inc.\",\"sector\":\"High Risk\",\"initialPrice\":85,\"volatility\":17},{\"id\":\"TTC\",\"name\":\"Turret Tracker Co.\",\"sector\":\"Very High Risk\",\"initialPrice\":125,\"volatility\":60},{\"id\":\"AMMO\",\"name\":\"AmmoNation Surplus\",\"sector\":\"Very High Risk\",\"initialPrice\":90,\"volatility\":35},{\"id\":\"SHM\",\"name\":\"Shotgun Messiah\",\"sector\":\"Very High Risk\",\"initialPrice\":120,\"volatility\":30},{\"id\":\"SHAM\",\"name\":\"Shamway Foods\",\"sector\":\"Very Low Risk\",\"initialPrice\":30,\"volatility\":5},{\"id\":\"SSHM\",\"name\":\"Super Shamway\",\"sector\":\"Very Low Risk\",\"initialPrice\":32,\"volatility\":4},{\"id\":\"MEDS\",\"name\":\"Pop-N-Pills Medical\",\"sector\":\"Very High Risk\",\"initialPrice\":100,\"volatility\":48},{\"id\":\"SAVG\",\"name\":\"Savage Country\",\"sector\":\"Low Risk\",\"initialPrice\":35,\"volatility\":6},{\"id\":\"CRKB\",\"name\":\"Crack-A-Book\",\"sector\":\"High Risk\",\"initialPrice\":80,\"volatility\":16},{\"id\":\"TRADE\",\"name\":\"Trader Guild Network\",\"sector\":\"Very High Risk\",\"initialPrice\":150,\"volatility\":40},{\"id\":\"PNG\",\"name\":\"Pass-N-Gas\",\"sector\":\"Medium Risk\",\"initialPrice\":50,\"volatility\":11},{\"id\":\"BOB\",\"name\":\"Trader Bob's\",\"sector\":\"Low Risk\",\"initialPrice\":160,\"volatility\":9},{\"id\":\"HUGH\",\"name\":\"Trader Hugh's\",\"sector\":\"Medium Risk\",\"initialPrice\":170,\"volatility\":12},{\"id\":\"JEN\",\"name\":\"Trader Jen's\",\"sector\":\"Low Risk\",\"initialPrice\":180,\"volatility\":10},{\"id\":\"JOEL\",\"name\":\"Trader Joel's\",\"sector\":\"Low Risk\",\"initialPrice\":175,\"volatility\":11},{\"id\":\"REKT\",\"name\":\"Trader Rekt's\",\"sector\":\"Low Risk\",\"initialPrice\":165,\"volatility\":6},{\"id\":\"DUKES\",\"name\":\"Duke's Casino Tokens\",\"sector\":\"Very Low Risk\",\"initialPrice\":1,\"volatility\":3}]},\"marketEvents\":{\"type\":\"array\",\"title\":\"Wasteland Events\",\"description\":\"Events impacting the Navezgane economy\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Unique event ID\"},\"name\":{\"type\":\"string\",\"description\":\"Name of the event\"},\"description\":{\"type\":\"string\",\"description\":\"Description of the event's market effect\"},\"sectorImpacts\":{\"type\":\"array\",\"description\":\"How each sector is affected\",\"items\":{\"type\":\"object\",\"properties\":{\"sectorId\":{\"type\":\"string\",\"description\":\"Sector ID\"},\"impact\":{\"type\":\"number\",\"description\":\"Percentage impact (-99 = -99%)\",\"minimum\":-99,\"maximum\":75}}}}}},\"default\":[{\"id\":\"HORDE_INCOMING\",\"name\":\"Horde Night Approaching\",\"description\":\"Increased Zed activity signals the Blood Moon. Very High and High Risk defense stocks soar, while Very Low Risk stocks see minimal impact.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":50},{\"sectorId\":\"High Risk\",\"impact\":30},{\"sectorId\":\"Medium Risk\",\"impact\":15},{\"sectorId\":\"Low Risk\",\"impact\":5},{\"sectorId\":\"Very Low Risk\",\"impact\":1}]},{\"id\":\"STABLE_ECONOMY\",\"name\":\"Period of Stability\",\"description\":\"A rare period of peace has settled over the wasteland. Very Low and Low Risk assets flourish, with higher risk stocks seeing less significant gains. High risk assets might see slight pull-back.\",\"sectorImpacts\":[{\"sectorId\":\"Very Low Risk\",\"impact\":15},{\"sectorId\":\"Low Risk\",\"impact\":10},{\"sectorId\":\"Medium Risk\",\"impact\":5},{\"sectorId\":\"High Risk\",\"impact\":-5},{\"sectorId\":\"Very High Risk\",\"impact\":-10}]},{\"id\":\"GENERAL_PANIC\",\"name\":\"General Market Panic\",\"description\":\"A major setback reminds everyone how fragile survival is. Fear grips the entire market, causing higher volatility sectors to plummet.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-90},{\"sectorId\":\"High Risk\",\"impact\":-70},{\"sectorId\":\"Medium Risk\",\"impact\":-45},{\"sectorId\":\"Low Risk\",\"impact\":-20},{\"sectorId\":\"Very Low Risk\",\"impact\":-10}]},{\"id\":\"ADVANCED_WEAPONRY_COLLAPSE\",\"name\":\"Turret AI Virus\",\"description\":\"A malicious code is spreading through advanced turret systems, causing them to malfunction violently. Very High Risk weaponry stocks are obliterated.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-99},{\"sectorId\":\"High Risk\",\"impact\":-20}]},{\"id\":\"VOLATILE_CHEMICALS_COLLAPSE\",\"name\":\"Irreversible Contamination\",\"description\":\"A major chemical disaster has occurred. Very High Risk chemical stocks are worthless, impacting related sectors.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-99},{\"sectorId\":\"High Risk\",\"impact\":-25},{\"sectorId\":\"Medium Risk\",\"impact\":-10}]},{\"id\":\"FOSSIL_FUELS_COLLAPSE\",\"name\":\"Clean Energy Breakthrough\",\"description\":\"A new energy source has been discovered. Very High Risk fossil fuel stocks become obsolete, while other sectors see minor adjustments.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-99},{\"sectorId\":\"Medium Risk\",\"impact\":10},{\"sectorId\":\"Low Risk\",\"impact\":5}]},{\"id\":\"PHARMACEUTICALS_COLLAPSE\",\"name\":\"The Cure is Real\",\"description\":\"A cure for the zombie infection has been found! Very High Risk pharmaceutical stocks are wiped out, and even low-risk survival goods see a hit.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-99},{\"sectorId\":\"High Risk\",\"impact\":-30},{\"sectorId\":\"Medium Risk\",\"impact\":-15},{\"sectorId\":\"Low Risk\",\"impact\":-10},{\"sectorId\":\"Very Low Risk\",\"impact\":-5}]},{\"id\":\"GUILD_OPERATIONS_COLLAPSE\",\"name\":\"Trader Guild Dissolved\",\"description\":\"The Trader's Guild has been formally dissolved. Very High Risk trade operation stocks become worthless, affecting overall trade.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-99},{\"sectorId\":\"High Risk\",\"impact\":-40},{\"sectorId\":\"Medium Risk\",\"impact\":-20},{\"sectorId\":\"Low Risk\",\"impact\":-10}]},{\"id\":\"AMMUNITION_DEPLETION\",\"name\":\"Ammunition Shortage\",\"description\":\"A major supply chain disruption has caused ammunition stockpiles to dwindle. Very High Risk ammunition stocks plummet.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-99},{\"sectorId\":\"High Risk\",\"impact\":-30},{\"sectorId\":\"Medium Risk\",\"impact\":-15}]},{\"id\":\"RESOURCE_BOOM\",\"name\":\"Resource Discovery\",\"description\":\"A massive new ore deposit has been found! All resource-related stocks are surging, with higher risk ones seeing the biggest gains.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":60},{\"sectorId\":\"High Risk\",\"impact\":40},{\"sectorId\":\"Medium Risk\",\"impact\":20},{\"sectorId\":\"Low Risk\",\"impact\":10}]},{\"id\":\"MANUFACTURING_SURGE\",\"name\":\"Innovation Breakthrough\",\"description\":\"New manufacturing techniques have greatly increased production efficiency. Manufacturing stocks are up across the board.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":40},{\"sectorId\":\"High Risk\",\"impact\":30},{\"sectorId\":\"Medium Risk\",\"impact\":20},{\"sectorId\":\"Low Risk\",\"impact\":10},{\"sectorId\":\"Very Low Risk\",\"impact\":5}]},{\"id\":\"TRADE_ROUTE_OPENED\",\"name\":\"New Trade Route Established\",\"description\":\"A secure trade route has been opened, boosting commerce. Trade-related stocks are seeing significant gains.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":50},{\"sectorId\":\"High Risk\",\"impact\":30},{\"sectorId\":\"Medium Risk\",\"impact\":20},{\"sectorId\":\"Low Risk\",\"impact\":15},{\"sectorId\":\"Very Low Risk\",\"impact\":10}]},{\"id\":\"MARKET_CORRECTION\",\"name\":\"Market Correction Wave\",\"description\":\"After a period of unusual growth, the market corrects itself. All sectors see a downturn.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-50},{\"sectorId\":\"High Risk\",\"impact\":-35},{\"sectorId\":\"Medium Risk\",\"impact\":-25},{\"sectorId\":\"Low Risk\",\"impact\":-15},{\"sectorId\":\"Very Low Risk\",\"impact\":-10}]},{\"id\":\"GLOBAL_SLOWDOWN\",\"name\":\"Global Economic Slowdown\",\"description\":\"Uncertainty spreads across all sectors, leading to a general market downturn. Less severe than a full panic, but widespread.\",\"sectorImpacts\":[{\"sectorId\":\"Very High Risk\",\"impact\":-30},{\"sectorId\":\"High Risk\",\"impact\":-20},{\"sectorId\":\"Medium Risk\",\"impact\":-15},{\"sectorId\":\"Low Risk\",\"impact\":-10},{\"sectorId\":\"Very Low Risk\",\"impact\":-5}]}]},\"eventFrequency\":{\"title\":\"Event Frequency\",\"type\":\"number\",\"description\":\"Average number of update cycles between market events (0 to disable). Depends on mod's update frequency (e.g., per in-game hour?).\",\"default\":8,\"minimum\":1},\"defaultEventDuration\":{\"title\":\"Default Event Duration\",\"type\":\"number\",\"description\":\"Default number of update cycles an event lasts.\",\"default\":3,\"minimum\":1,\"maximum\":96},\"transactionFee\":{\"title\":\"Transaction Fee (Dukes Tax)\",\"type\":\"number\",\"description\":\"Percentage fee charged on all buy/sell transactions (5 = 5%)\",\"default\":3,\"minimum\":0,\"maximum\":25},\"vipDiscount\":{\"title\":\"Trader's Favor Discount\",\"type\":\"number\",\"description\":\"Percentage discount on transaction fees for players with 'STOCK_MARKET_BROKER' permission (50 = 50%)\",\"default\":50,\"minimum\":0,\"maximum\":100},\"priceAlertThreshold\":{\"title\":\"Price Alert Threshold\",\"type\":\"number\",\"description\":\"Percentage change that triggers a market alert (15 = 15%)\",\"default\":15,\"minimum\":5,\"maximum\":50},\"marketNewsChannelId\":{\"title\":\"Discord Channel ID (for Market News)\",\"type\":\"string\",\"description\":\"The ID of the Discord channel where market news messages should be posted. Leave empty to disable.\",\"default\":\"\"}},\"additionalProperties\":false}",
            "uiSchema": "{\"sectors\":{\"items\":{\"ui:order\":[\"id\",\"name\"]}},\"stocks\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"sector\",\"initialPrice\",\"volatility\"]}},\"marketEvents\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"description\",\"sectorImpacts\"],\"sectorImpacts\":{\"items\":{\"ui:order\":[\"sectorId\",\"impact\"]}}}},\"transactionFee\":{\"ui:widget\":\"range\"},\"vipDiscount\":{\"ui:widget\":\"range\"},\"eventFrequency\":{\"ui:help\":\"Set to 0 to disable random events\"},\"priceAlertThreshold\":{\"ui:widget\":\"range\"}}",
            "commands": [
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRIGGER_EVENT')) {\n        throw new TakaroUserError(\"You don't have permission to trigger market events.\");\n    }\n\n    try {\n        // Get current stock data to check market initialization\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Initialize market if needed\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            await player.pm(\"Market was not initialized. Initializing now...\");\n            return;\n        }\n\n        // Get events from module config\n        const marketEvents = mod.userConfig.marketEvents || [];\n\n        if (marketEvents.length === 0) {\n            throw new TakaroUserError(\"No market events configured in this module.\");\n        }\n\n        // Handle case when no event is specified or \"ALL\" is provided\n        if (!args.EventName || args.EventName.toUpperCase() === \"ALL\") {\n            await player.pm(\"=== AVAILABLE MARKET EVENTS ===\\n\");\n\n            // Group events by category or type if possible\n            const eventCategories = {};\n\n            // Create a simple categorization based on positive/negative impact\n            marketEvents.forEach(event => {\n                let category = \"Mixed\";\n                // Calculate net impact across all sectors\n                const netImpact = event.sectorImpacts.reduce((sum, impact) => sum + impact.impact, 0);\n\n                if (netImpact > 0) category = \"Positive\";\n                else if (netImpact < 0) category = \"Negative\";\n\n                if (!eventCategories[category]) {\n                    eventCategories[category] = [];\n                }\n                eventCategories[category].push(event);\n            });\n\n            // Display events by category\n            for (const [category, events] of Object.entries(eventCategories)) {\n                if (events.length > 0) {\n                    await player.pm(`\\n--- ${category.toUpperCase()} EVENTS ---`);\n\n                    let message = \"\";\n                    events.forEach(event => {\n                        // Format primary sectors affected\n                        const primarySectors = event.sectorImpacts\n                            .filter(impact => Math.abs(impact.impact) >= 15)\n                            .map(impact => {\n                                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                                return `${impact.sectorId} ${direction}${Math.abs(impact.impact)}%`;\n                            })\n                            .join(\", \");\n\n                        message += `${event.id}: ${event.name}\\n`;\n                        message += `   ${event.description}\\n`;\n                        if (primarySectors) {\n                            message += `   Major impacts: ${primarySectors}\\n`;\n                        }\n                        message += \"\\n\";\n                    });\n\n                    await player.pm(message);\n                }\n            }\n\n            await player.pm(\"=== HOW TO USE ===\\nUse `/triggerevent <EventName>` to trigger a specific event (e.g., `/triggerevent TECH_BOOM`)\");\n            return;\n        }\n\n        // Find the requested event\n        const eventId = args.EventName.toUpperCase();\n        const event = marketEvents.find(e => e.id === eventId);\n\n        if (!event) {\n            throw new TakaroUserError(`Event \"${eventId}\" not found. Use /triggerevent without parameters to see all available events.`);\n        }\n\n        // Get necessary variables for managing the event\n        const [activeEventVar, eventStartTimeVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_execution_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_cooldown_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['current_event_duration'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Check if there's an active event we need to cancel\n        let activeEventObj = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEventObj = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEventObj && Object.keys(activeEventObj).length > 0) {\n                    await player.pm(`Cancelling active event \"${activeEventObj.name}\" to trigger new event.`);\n                }\n            } catch (e) {\n                // Invalid event data, will be overwritten\n            }\n        }\n\n        // Generate a random duration for the event\n        const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n        // Update or create all event-related variables\n        const updatePromises = [];\n\n        // Save or update the random duration\n        if (eventDurationVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                    value: randomDuration.toString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'current_event_duration',\n                    value: randomDuration.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the event counter to 0\n        if (eventCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the cooldown counter\n        if (cooldownCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update active event\n        if (activeEventVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                    value: JSON.stringify(event)\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: JSON.stringify(event),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update event start time\n        if (eventStartTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update last event time\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (lastEventTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all updates to complete\n        await Promise.all(updatePromises);\n\n        // Check if there are online players to announce the event\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            // Format sector impacts for announcement\n            let impactText = \"\";\n            for (const impact of event.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n            }\n\n            const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${event.name}\\n${event.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /markets to see opportunities!`;\n\n            // Split the message if it's too long\n            const maxLength = 400; // Safe limit for most games\n            for (let i = 0; i < message.length; i += maxLength) {\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message: message.substring(i, i + maxLength)\n                });\n            }\n        }\n\n        await player.pm(`Successfully triggered the \"${event.name}\" market event for ${randomDuration} cycles!`);\n    } catch (error) {\n        // If something goes wrong, log it and let the player know\n        console.log(`Error in triggerEvent: ${error.message}`);\n        throw new TakaroUserError(`Error triggering event: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Store the stocks data\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_data',\n            value: JSON.stringify(stocks),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize last event time to now\n        await takaro.variable.variableControllerCreate({\n            key: 'last_market_event_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize event start time variable\n        await takaro.variable.variableControllerCreate({\n            key: 'event_start_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize active event (empty string means no active event)\n        await takaro.variable.variableControllerCreate({\n            key: 'active_market_event',\n            value: '',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Mark market as initialized\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_initialized',\n            value: 'true',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Announce market initialization to online players\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /markets to see available stocks and /buystock to start investing.\";\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message\n            });\n        }\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "triggerevent",
                    "description": null,
                    "trigger": "triggerevent",
                    "helpText": "Shows all available market events when run without parameters. Use with an event name (e.g., /triggerevent TECH_BOOM) to trigger a specific market event.",
                    "arguments": [
                        {
                            "name": "EventName",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "Event name to trigger a specific market event",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get player's portfolio\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        if (portfolioVar.data.data.length === 0) {\n            throw new TakaroUserError(\"You don't own any stocks to sell.\");\n        }\n\n        const portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        const stockId = args.stock.toUpperCase();\n\n        if (!portfolio[stockId] || portfolio[stockId].shares < amount) {\n            throw new TakaroUserError(`You don't own ${amount} shares of ${stockId}.`);\n        }\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === stockId);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${stockId} not found in current market data. Please contact an admin.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate sale proceeds using Math.round to ensure we work with integers\n        const stockPrice = Math.round(stock.price);\n        const subtotal = stockPrice * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const netProceeds = subtotal - fee;\n\n        // Add money to player - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerAddCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: netProceeds\n            }\n        );\n\n        // Calculate profit/loss\n        const profitPerShare = stockPrice - portfolio[stockId].averagePrice;\n        const totalProfit = Math.round(profitPerShare * amount);\n        const profitText = totalProfit >= 0\n            ? `profit of $${totalProfit}`\n            : `loss of $${Math.abs(totalProfit)}`;\n\n        // Update portfolio\n        portfolio[stockId].shares -= amount;\n        if (portfolio[stockId].shares === 0) {\n            delete portfolio[stockId];\n        }\n\n        // Save updated portfolio\n        await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n            value: JSON.stringify(portfolio)\n        });\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'SELL',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: netProceeds,\n            profit: totalProfit,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully sold ${amount} shares of ${stockId} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Net proceeds: $${netProceeds} (${profitText})`;\n\n        // Add remaining shares info if player still has some\n        if (portfolio[stockId]) {\n            message += `\\nRemaining shares: ${portfolio[stockId].shares}`;\n        } else {\n            message += `\\nYou've sold all your ${stockId} shares.`;\n        }\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in sellstock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your sale. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "sellstock",
                    "description": null,
                    "trigger": "sellstock",
                    "helpText": "Sell shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to sell",
                            "position": 1
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // If a specific stock ticker is provided, show detailed info for that stock\n    const specificTicker = args.ticker ? args.ticker.toUpperCase() : null;\n\n    if (specificTicker && specificTicker !== \"ALL\") {\n        const stock = stocks.find(s => s.id.toUpperCase() === specificTicker);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${specificTicker} not found. Use /stockinfo without parameters to see all available stocks.`);\n        }\n\n        // Get active event to see if this stock's sector is affected\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let activeEvent = null;\n        let sectorImpact = null;\n\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEvent && activeEvent.sectorImpacts) {\n                    sectorImpact = activeEvent.sectorImpacts.find(impact =>\n                        impact.sectorId === stock.sector\n                    );\n                }\n            } catch (e) {\n                // Ignore parsing errors\n            }\n        }\n\n        // Calculate price change indicators\n        let changeText = '';\n        if (stock.lastPrice) {\n            const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n            const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n            changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n        }\n\n        // Add risk assessment based on volatility without showing the raw value\n        let riskLevel;\n        if (stock.volatility <= 0.05) riskLevel = \"Very Low\";\n        else if (stock.volatility <= 0.10) riskLevel = \"Low\";\n        else if (stock.volatility <= 0.15) riskLevel = \"Moderate\";\n        else if (stock.volatility <= 0.20) riskLevel = \"High\";\n        else riskLevel = \"Very High\";\n\n        // Build detailed stock info message\n        let message = `=== ${stock.id}: ${stock.name} ===\\n\\n`;\n        message += `Sector: ${stock.sector}\\n`;\n        message += `Current Price: $${Math.round(stock.price)}${changeText}\\n`;\n        message += `Risk Level: ${riskLevel}\\n`;\n\n        // Add sector trend info if available from event\n        if (activeEvent && sectorImpact) {\n            const direction = sectorImpact.impact >= 0 ? \"Positive\" : \"Negative\";\n            const strength = Math.abs(sectorImpact.impact);\n            let trend;\n\n            if (strength < 10) trend = \"Slight\";\n            else if (strength < 25) trend = \"Moderate\";\n            else trend = \"Strong\";\n\n            message += `\\nCurrent Trend: ${trend} ${direction} (${activeEvent.name})\\n`;\n            message += `Event: ${activeEvent.description}\\n`;\n        }\n\n        // Add trading guidance based on sector and risk, without mentioning volatility\n        message += `\\nTrading Notes:\\n`;\n\n        if (activeEvent && sectorImpact) {\n            if (sectorImpact.impact > 0) {\n                message += `- Currently bullish due to the ${activeEvent.name} event\\n`;\n            } else {\n                message += `- Currently bearish due to the ${activeEvent.name} event\\n`;\n            }\n        }\n\n        if (riskLevel === \"High\" || riskLevel === \"Very High\") {\n            message += `- Expect significant price fluctuations with this stock\\n`;\n        } else if (riskLevel === \"Low\" || riskLevel === \"Very Low\") {\n            message += `- Typically has stable price movement\\n`;\n        }\n\n        message += `\\nUse /buystock ${stock.id} [amount] to purchase shares`;\n\n        await player.pm(message);\n\n    } else {\n        // No specific ticker provided or ALL specified, show summary of all stocks\n        await player.pm(\"=== STOCK MARKET LISTINGS ===\\n\");\n\n        // Group stocks by sector\n        const stocksBySector = {};\n        stocks.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        // MODIFICATION START\n        // Display stocks by sector, chunking them into messages of 3\n        const chunkSize = 3;\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            for (let i = 0; i < sectorStocks.length; i += chunkSize) {\n                const chunk = sectorStocks.slice(i, i + chunkSize);\n\n                // Add the sector header only to the first message for that sector.\n                let sectorMessage = (i === 0) ? `\\n--- ${sector} SECTOR ---\\n` : '';\n\n                chunk.forEach(stock => {\n                    // Add price change indicators\n                    let changeText = '';\n                    if (stock.lastPrice) {\n                        const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                        const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                        changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                    }\n\n                    // Add risk level based on volatility\n                    let riskIndicator;\n                    if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                    else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                    else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                    else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                    else riskIndicator = \"VH\";\n\n                    sectorMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n                });\n\n                await player.pm(sectorMessage);\n            }\n        }\n        // MODIFICATION END\n\n        // Add legend for risk indicators\n        const legend = \"\\n=== LEGEND ===\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\" +\n            \"Use /stockinfo [ticker] for detailed information about a specific stock\";\n\n        await player.pm(legend);\n    }\n}\n\nawait main();",
                    "name": "stockinfo",
                    "description": null,
                    "trigger": "stockinfo",
                    "helpText": "Shows all available stocks in the market. Use with a ticker symbol (e.g., /stockinfo ticker) to see detailed information about a specific stock.",
                    "arguments": [
                        {
                            "name": "ticker",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "stock ticker or ALL to get detailed information about a specific stock",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Handle the industry argument - use \"ALL\" as a special value to show all industries\n    const industryFilter = args.Industry ? args.Industry.toUpperCase() : \"ALL\";\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    // If market data doesn't exist, try to initialize it\n    if (marketDataVar.data.data.length === 0) {\n        const initialized = await initializeMarketIfNeeded(gameServerId, mod);\n        if (!initialized) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        // Get the freshly initialized market data\n        const refreshedMarketData = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (refreshedMarketData.data.data.length === 0) {\n            throw new TakaroUserError(\"There was an issue initializing the stock market. Please try again later.\");\n        }\n\n        // Continue with the refreshed data\n        await displayMarketSummary(player, gameServerId, mod, refreshedMarketData.data.data[0], industryFilter);\n    } else {\n        // Market data exists, display it\n        await displayMarketSummary(player, gameServerId, mod, marketDataVar.data.data[0], industryFilter);\n    }\n}\n\n// Display the market summary to the player\nasync function displayMarketSummary(player, gameServerId, mod, marketDataVariable, industryFilter) {\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Handle empty string or empty object\n            if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (e) {\n            // In case of parsing error\n            activeEvent = null;\n        }\n    }\n\n    const stocks = JSON.parse(marketDataVariable.value);\n\n    // Get all available industries for reference\n    const availableIndustries = [...new Set(stocks.map(stock => stock.sector))];\n\n    // If industry filter is provided and not \"ALL\", check if it's valid\n    if (industryFilter !== \"ALL\") {\n        // Check if the industry exists\n        const industryExists = availableIndustries.includes(industryFilter);\n\n        if (!industryExists) {\n            throw new TakaroUserError(`Industry \"${industryFilter}\" not found. Available industries: ${availableIndustries.join(', ')}\\nUse \"ALL\" to view all industries.`);\n        }\n    }\n\n    // Send header message\n    let headerMessage = \"=== STOCK MARKET SUMMARY ===\\n\";\n\n    // If filtering by industry, mention it in the header\n    if (industryFilter !== \"ALL\") {\n        headerMessage = `=== ${industryFilter} INDUSTRY ===\\n`;\n    }\n\n    // If there's an active event, include it in the header\n    if (activeEvent) {\n        headerMessage += `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n`;\n        headerMessage += `${activeEvent.description}\\n\\n`;\n\n        // If filtering by industry, only show relevant impacts\n        if (industryFilter !== \"ALL\") {\n            const relevantImpact = activeEvent.sectorImpacts.find(\n                impact => impact.sectorId === industryFilter\n            );\n\n            if (relevantImpact) {\n                const direction = relevantImpact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `Industry Impact: ${direction} ${Math.abs(relevantImpact.impact)}%\\n`;\n            } else {\n                headerMessage += \"This industry is not directly affected by the current event.\\n\";\n            }\n        } else {\n            // Show all industry impacts\n            headerMessage += \"Industry Impacts:\\n\";\n            for (const impact of activeEvent.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%\\n`;\n            }\n        }\n    }\n\n    // Send header message first\n    await player.pm(headerMessage);\n\n    // Group stocks by industry\n    const stocksByIndustry = {};\n    stocks.forEach(stock => {\n        if (!stocksByIndustry[stock.sector]) {\n            stocksByIndustry[stock.sector] = [];\n        }\n        stocksByIndustry[stock.sector].push(stock);\n    });\n\n    // If industry filter is not \"ALL\", only show that industry\n    if (industryFilter !== \"ALL\") {\n        const filteredStocks = stocksByIndustry[industryFilter] || [];\n\n        if (filteredStocks.length > 0) {\n            let stockMessage = \"\";\n\n            filteredStocks.forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                stockMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(stockMessage);\n        } else {\n            await player.pm(`No stocks found in the ${industryFilter} industry.`);\n        }\n    } else {\n        // Send each industry as a separate message\n        for (const industryId in stocksByIndustry) {\n            let industryMessage = `=== ${industryId} INDUSTRY ===\\n`;\n\n            stocksByIndustry[industryId].forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                industryMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(industryMessage);\n        }\n    }\n\n    // Add a help message for industry filtering if showing all industries\n    if (industryFilter === \"ALL\") {\n        const allIndustries = Object.keys(stocksByIndustry).join(', ');\n        await player.pm(`\\nTip: Use '/markets [industry]' to view only stocks in a specific industry. Available industries: ${allIndustries}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return false;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            const results = await Promise.allSettled(createPromises);\n            // Check if the critical stock_market_data was created successfully\n            const stockDataPromise = results[0];\n            if (stockDataPromise && stockDataPromise.status === 'rejected') {\n                console.log(`Failed to create stock_market_data: ${stockDataPromise.reason}`);\n                return false;\n            }\n        }\n\n        return true;\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n        return false;\n    }\n}\n\nawait main();",
                    "name": "markets",
                    "description": null,
                    "trigger": "markets",
                    "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. \n",
                    "arguments": [
                        {
                            "name": "Industry",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. ",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // Get player's portfolio\n    const portfolioVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_portfolio'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId],\n            playerId: [player.id]\n        }\n    });\n\n    let portfolio = {};\n    if (portfolioVar.data.data.length > 0) {\n        portfolio = JSON.parse(portfolioVar.data.data[0].value);\n    }\n\n    // Send header\n    await player.pm(\"=== YOUR STOCK PORTFOLIO ===\");\n\n    let hasStocks = false;\n    let totalValue = 0;\n    let totalInvestment = 0;\n\n    // If no stocks, send a simple message\n    if (Object.keys(portfolio).length === 0) {\n        await player.pm(\"You don't own any stocks yet.\\n\" +\n            \"Use /markets to see available stocks and prices.\\n\" +\n            \"Use /buy <stock> <amount> to purchase stocks.\");\n        return;\n    }\n\n    // Helper function to format numbers with commas and a dollar sign\n    const formatNumber = (num) => {\n        return `$${Math.round(num).toLocaleString()}`;\n    };\n\n    // Send each stock as a separate message to avoid length issues\n    for (const [stockId, data] of Object.entries(portfolio)) {\n        hasStocks = true;\n        const stock = stocks.find(s => s.id === stockId);\n        if (!stock) continue; // Stock might have been removed from config\n\n        const currentValue = stock.price * data.shares;\n        const investmentValue = data.averagePrice * data.shares;\n        totalValue += currentValue;\n        totalInvestment += investmentValue;\n        const profit = currentValue - investmentValue;\n        const profitPercent = ((profit / investmentValue) * 100).toFixed(1);\n\n        let stockMessage = `--- ${stockId} (${stock.sector}) ---\\n`;\n        stockMessage += `Shares: ${data.shares}\\n`;\n        stockMessage += `Avg buy: ${formatNumber(data.averagePrice)}\\n`;\n        stockMessage += `Current price: ${formatNumber(stock.price)}\\n`;\n        stockMessage += `Total value: ${formatNumber(currentValue)}\\n`;\n\n        if (profit >= 0) {\n            stockMessage += `Profit: +${formatNumber(profit)} (+${profitPercent}%)\\n`;\n        } else {\n            stockMessage += `Loss: -${formatNumber(Math.abs(profit))} (${profitPercent}%)\\n`;\n        }\n\n        await player.pm(stockMessage);\n    }\n\n    if (hasStocks) {\n        const totalProfit = totalValue - totalInvestment;\n        const totalProfitPercent = ((totalProfit / totalInvestment) * 100).toFixed(1);\n\n        let summaryMessage = \"=== PORTFOLIO SUMMARY ===\\n\";\n        summaryMessage += `Total investment: ${formatNumber(totalInvestment)}\\n`;\n        summaryMessage += `Current value: ${formatNumber(totalValue)}\\n`;\n\n        if (totalProfit >= 0) {\n            summaryMessage += `Overall profit: +${formatNumber(totalProfit)} (+${totalProfitPercent}%)\\n`;\n        } else {\n            summaryMessage += `Overall loss: -${formatNumber(Math.abs(totalProfit))} (${totalProfitPercent}%)\\n`;\n        }\n\n        // Get transaction history count\n        try {\n            const historyVar = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: ['stock_transaction_history'],\n                    gameServerId: [gameServerId],\n                    moduleId: [mod.moduleId],\n                    playerId: [player.id]\n                }\n            });\n\n            if (historyVar.data.data.length > 0) {\n                const history = JSON.parse(historyVar.data.data[0].value);\n                const buyCount = history.filter(t => t.type === 'BUY').length;\n                const sellCount = history.filter(t => t.type === 'SELL').length;\n\n                summaryMessage += `\\nTransactions: ${history.length} (${buyCount} buys, ${sellCount} sells)\\n`;\n            }\n        } catch (error) {\n            // Just ignore history errors\n        }\n\n        await player.pm(summaryMessage);\n    }\n}\n\nawait main();",
                    "name": "stockportfolio",
                    "description": null,
                    "trigger": "stockportfolio",
                    "helpText": "No help text available",
                    "arguments": []
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === args.stock.toUpperCase());\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${args.stock} not found. Use /market to see available stocks.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate costs using Math.round to ensure we work with integers\n        const subtotal = Math.round(stock.price) * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const totalCost = subtotal + fee;\n\n        // Check if player has enough currency\n        const playerData = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, player.id);\n        const currentBalance = playerData.data.data.currency;\n\n        if (currentBalance < totalCost) {\n            throw new TakaroUserError(`You don't have enough currency. Cost: $${subtotal} + $${fee} fee = $${totalCost}. Your balance: $${currentBalance}`);\n        }\n\n        // Deduct the currency - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerDeductCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: totalCost\n            }\n        );\n\n        // Get player's portfolio or create new one\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        let portfolio;\n        if (portfolioVar.data.data.length === 0) {\n            portfolio = {};\n        } else {\n            portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        }\n\n        // Update portfolio using rounded values for consistency\n        const stockPrice = Math.round(stock.price);\n        if (!portfolio[stock.id]) {\n            portfolio[stock.id] = {\n                shares: amount,\n                averagePrice: stockPrice\n            };\n        } else {\n            const totalShares = portfolio[stock.id].shares + amount;\n            const totalValue = (portfolio[stock.id].shares * portfolio[stock.id].averagePrice) + (amount * stockPrice);\n            portfolio[stock.id].shares = totalShares;\n            portfolio[stock.id].averagePrice = Math.round(totalValue / totalShares);\n        }\n\n        // Save updated portfolio\n        if (portfolioVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_portfolio',\n                value: JSON.stringify(portfolio),\n                gameServerId,\n                moduleId: mod.moduleId,\n                playerId: player.id\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n                value: JSON.stringify(portfolio)\n            });\n        }\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'BUY',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: totalCost,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully bought ${amount} shares of ${stock.id} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Total cost: $${totalCost}\\n`;\n        message += `Current portfolio: ${portfolio[stock.id].shares} shares of ${stock.id}`;\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in buystock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your purchase. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "buystock",
                    "description": null,
                    "trigger": "buystock",
                    "helpText": "Buy shares of a stock",
                    "arguments": [
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to buy",
                            "position": 1
                        },
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol ",
                            "position": 0
                        }
                    ]
                }
            ],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n\n    const discordChannelId = mod.userConfig.marketNewsChannelId;\n\n    if (!discordChannelId) {\n        takaro.log.info('Market news Discord channel ID (marketNewsChannelId) not configured in module settings. Skipping Discord messages.');\n    }\n\n    const currentPlayers = (await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    })).data.meta;\n\n    if (currentPlayers.total === 0) {\n        takaro.log.info('Skipping daily market report: No players online.');\n        return;\n    }\n\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        takaro.log.warn('Skipping daily market report: Market data variable not found.');\n        return;\n    }\n\n    let stocks;\n    try {\n        stocks = JSON.parse(marketDataVar.data.data[0].value);\n        if (!Array.isArray(stocks)) {\n            throw new Error('Parsed market data is not an array.');\n        }\n    } catch (error) {\n        takaro.log.error(`Failed to parse stock_market_data: ${error}`);\n        return;\n    }\n\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            if (typeof activeEvent !== 'object' || activeEvent === null || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (error) {\n            takaro.log.warn(`Failed to parse active_market_event: ${error}`);\n            activeEvent = null;\n        }\n    }\n\n    let gameMessage1 = \"==== DAILY MARKET REPORT ====\\n\";\n\n    if (activeEvent && activeEvent.name && activeEvent.description) {\n        const eventText = `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n${activeEvent.description}\\n`;\n        gameMessage1 += eventText;\n    } else {\n        const noEventText = '\\nNo active market events today.\\n';\n        gameMessage1 += noEventText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage1\n    }).catch(err => takaro.log.error(`Failed to send game message 1: ${err}`));\n\n    const stocksWithPerformance = stocks.map(stock => {\n        let change = 0;\n        let percentChange = 0;\n        let changeSymbol = 'â†’';\n\n        if (typeof stock.price === 'number' && typeof stock.lastPrice === 'number' && stock.lastPrice !== 0) {\n            change = stock.price - stock.lastPrice;\n            percentChange = (change / stock.lastPrice) * 100;\n            if (percentChange > 0.05) {\n                changeSymbol = 'â†‘';\n            } else if (percentChange < -0.05) {\n                changeSymbol = 'â†“';\n            }\n        } else if (typeof stock.price === 'number' && stock.lastPrice === undefined) {\n            changeSymbol = 'ðŸ†•';\n            percentChange = 0;\n        }\n        return {\n            ...stock,\n            change,\n            percentChange,\n            changeSymbol\n        };\n    });\n\n    const sectorPerformance = {};\n    // Define the desired display order and mapping for sorting\n    const riskOrder = {\n        \"Very High Risk\": 5,\n        \"High Risk\": 4,\n        \"Medium Risk\": 3,\n        \"Low Risk\": 2,\n        \"Very Low Risk\": 1,\n        \"Uncategorized\": 0 // Fallback for any stock without a defined sector\n    };\n\n    stocksWithPerformance.forEach(stock => {\n        const sectorName = stock.sector || 'Uncategorized'; // Use the sector name directly\n        if (!sectorPerformance[sectorName]) {\n            sectorPerformance[sectorName] = {\n                stocks: [],\n                totalPercentChange: 0,\n                count: 0\n            };\n        }\n        sectorPerformance[sectorName].stocks.push(stock);\n        if (typeof stock.percentChange === 'number' && isFinite(stock.percentChange)) {\n            sectorPerformance[sectorName].totalPercentChange += stock.percentChange;\n            sectorPerformance[sectorName].count++;\n        }\n    });\n\n    for (const sectorName in sectorPerformance) {\n        const sectorData = sectorPerformance[sectorName];\n        if (sectorData.count > 0) {\n            sectorData.avgPerformance = sectorData.totalPercentChange / sectorData.count;\n        } else {\n            sectorData.avgPerformance = 0;\n        }\n    }\n\n    // Sort sector performance by risk order (VH to VL)\n    const sortedSectors = Object.entries(sectorPerformance)\n        .sort(([sectorNameA], [sectorNameB]) => riskOrder[sectorNameB] - riskOrder[sectorNameA]);\n\n    let gameMessage2 = \"\\n=== SECTOR PERFORMANCE ===\\n\";\n\n    if (sortedSectors.length > 0) {\n        sortedSectors.forEach(([sectorName, sectorData]) => { // Use sectorName directly\n            const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n            let line = `${sectorName}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n\n            if (sectorData.avgPerformance > 0.05) {\n                line = `[70FE02]${sectorName}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%[-]\\n`;\n            } else if (sectorData.avgPerformance < -0.05) {\n                line = `[FF0001]${sectorName}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%[-]\\n`;\n            }\n            gameMessage2 += line;\n        });\n    } else {\n        const noDataText = \"No sector performance data available.\\n\";\n        gameMessage2 += noDataText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage2\n    }).catch(err => takaro.log.error(`Failed to send game message 2: ${err}`));\n\n    const validPerformers = stocksWithPerformance.filter(s => typeof s.percentChange === 'number' && isFinite(s.percentChange));\n    validPerformers.sort((a, b) => b.percentChange - a.percentChange);\n\n    let gameMessage3 = \"\";\n\n    const topPerformersTitleGame = \"\\nðŸ”¥ TOP PERFORMERS ðŸ”¥\\n\";\n    gameMessage3 += topPerformersTitleGame;\n\n    if (validPerformers.length > 0) {\n        for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n            const stock = validPerformers[i];\n            gameMessage3 += `[70FE02]${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%[-]\\n`;\n        }\n    } else {\n        gameMessage3 += \"No top performers today.\\n\";\n    }\n\n    const worstPerformersTitleGame = \"\\nðŸ“‰ WORST PERFORMERS ðŸ“‰\\n\";\n    gameMessage3 += worstPerformersTitleGame;\n\n    if (validPerformers.length > 0) {\n        const worstStartIndex = Math.max(0, validPerformers.length - 3);\n        for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n            const stock = validPerformers[i];\n            gameMessage3 += `[FF0001]${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%[-]\\n`;\n        }\n    } else {\n        gameMessage3 += \"No worst performers today.\\n\";\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage3\n    }).catch(err => takaro.log.error(`Failed to send game message 3: ${err}`));\n\n    function hslToRgb(h, s, l) { let a = s * Math.min(l, 1 - l); let f = n => { let k = (n + h / 30) % 12; return l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1)); }; return [Math.round(255 * f(0)), Math.round(255 * f(8)), Math.round(255 * f(4))]; }\n    function rgbToHex(r, g, b) { return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase(); }\n    function stringToHexColor(str) { let hash = 0; for (let i = 0; i < str.length; i++) { hash = str.charCodeAt(i) + ((hash << 5) - hash); } hash = Math.abs(hash); const hue = (hash * 137.508) % 360; const [r, g, b] = hslToRgb(hue, 0.9, 0.7); return rgbToHex(r, g, b); }\n\n    const stockColors = {};\n    stocksWithPerformance.forEach(stock => {\n        stockColors[stock.id] = stringToHexColor(stock.name);\n    });\n\n    const stocksBySectorGame = {};\n    stocksWithPerformance.forEach(stock => {\n        const sector = stock.sector || 'Uncategorized'; // Use the sector name directly\n        if (!stocksBySectorGame[sector]) {\n            stocksBySectorGame[sector] = [];\n        }\n        stocksBySectorGame[sector].push(stock);\n    });\n\n    // Sort the sector names for display in the desired order (VH, H, M, L, VL)\n    const sortedSectorNamesGame = Object.keys(stocksBySectorGame).sort((sectorNameA, sectorNameB) => riskOrder[sectorNameB] - riskOrder[sectorNameA]);\n\n\n    for (const sectorName of sortedSectorNamesGame) { // Iterate through sorted sector names\n        const sectorStocks = stocksBySectorGame[sectorName];\n        const chunkSize = 3;\n        for (let i = 0; i < sectorStocks.length; i += chunkSize) {\n            const chunk = sectorStocks.slice(i, i + chunkSize);\n            // Use sectorName directly for the header\n            let sectorMessage = (i === 0) ? `\\n--- ${sectorName} SECTOR ---\\n` : '';\n\n            chunk.forEach(stock => {\n                let changeText = '';\n                let priceColorPrefix = '', priceColorSuffix = '';\n\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeText = ` ${stock.changeSymbol} ${Math.abs(percentChange).toFixed(1)}%`;\n                    if (percentChange > 0) {\n                        priceColorPrefix = '[70FE02]';\n                        priceColorSuffix = '[-]';\n                    } else if (percentChange < 0) {\n                        priceColorPrefix = '[FF0001]';\n                        priceColorSuffix = '[-]';\n                    }\n                }\n\n                const stockNameColorPrefix = stockColors[stock.id] ? `[${stockColors[stock.id]}]` : '';\n                const stockNameColorSuffix = stockColors[stock.id] ? '[-]' : '';\n\n                let riskIndicator; // This is derived from volatility, not directly from sector ID\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.25) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                sectorMessage += `${stockNameColorPrefix}${stock.name} (${stock.id})${stockNameColorSuffix} (${riskIndicator}): ${priceColorPrefix}$${Math.round(stock.price)}${changeText}${priceColorSuffix}\\n`;\n            });\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message: sectorMessage\n            }).catch(err => takaro.log.error(`Failed to send game message for sector ${sectorName}: ${err}`));\n        }\n    }\n\n    const legendMessage = \"\\n=== LEGEND ===\\n\" +\n        \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\";\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: legendMessage\n    }).catch(err => takaro.log.error(`Failed to send game legend message: ${err}`));\n\n    if (discordChannelId) {\n        // --- MESSAGE 1: The Summary ---\n        let discordMessageSummary = \"**==== DAILY MARKET REPORT ====**\\n\\n\";\n\n        if (activeEvent && activeEvent.name && activeEvent.description) {\n            discordMessageSummary += `ðŸŒ **ACTIVE EVENT: ${activeEvent.name}** ðŸŒ\\n${activeEvent.description}\\n\\n`;\n        } else {\n            discordMessageSummary += 'No active market events today.\\n\\n';\n        }\n\n        discordMessageSummary += \"**=== SECTOR PERFORMANCE ===**\\n\";\n        if (sortedSectors.length > 0) {\n            sortedSectors.forEach(([sectorName, sectorData]) => { // Use sectorName directly\n                const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n                discordMessageSummary += `${sectorName}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n            });\n        } else {\n            discordMessageSummary += \"No sector performance data available.\\n\";\n        }\n        discordMessageSummary += \"\\n\";\n\n        discordMessageSummary += \"**ðŸ”¥ TOP PERFORMERS ðŸ”¥**\\n\";\n        if (validPerformers.length > 0) {\n            for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n                const stock = validPerformers[i];\n                discordMessageSummary += `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            }\n        } else {\n            discordMessageSummary += \"No top performers today.\\n\";\n        }\n        discordMessageSummary += \"\\n\";\n\n        discordMessageSummary += \"**ðŸ“‰ WORST PERFORMERS ðŸ“‰**\\n\";\n        if (validPerformers.length > 0) {\n            const worstStartIndex = Math.max(0, validPerformers.length - 3);\n            for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n                const stock = validPerformers[i];\n                discordMessageSummary += `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            }\n        } else {\n            discordMessageSummary += \"No worst performers today.\\n\";\n        }\n\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessageSummary\n        }).catch(err => takaro.log.error(`Failed to send summary Discord message: ${err.message || err}`));\n\n        // --- MESSAGE 2: All Stock Listings ---\n        let discordMessageDetails = \"**=== ALL STOCK LISTINGS ===**\\n\";\n        const stocksBySector = {};\n        stocksWithPerformance.forEach(stock => {\n            const sector = stock.sector || 'Uncategorized'; // Use the sector name directly\n            if (!stocksBySector[sector]) {\n                stocksBySector[sector] = [];\n            }\n            stocksBySector[sector].push(stock);\n        });\n\n        // Sort the sector names for display in the desired order (VH, H, M, L, VL)\n        const sortedSectorNamesDiscord = Object.keys(stocksBySector).sort((sectorNameA, sectorNameB) => riskOrder[sectorNameB] - riskOrder[sectorNameA]);\n\n\n        for (const sectorName of sortedSectorNamesDiscord) { // Iterate through sorted sector names\n            const sectorStocks = stocksBySector[sectorName];\n            discordMessageDetails += `\\n--- **${sectorName} SECTOR** ---\\n`; // Use sectorName directly\n            sectorStocks.forEach(stock => {\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeText = ` ${stock.changeSymbol} ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.25) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                discordMessageDetails += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n        }\n\n        discordMessageDetails += \"\\n**=== LEGEND ===**\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\";\n\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessageDetails\n        }).catch(err => takaro.log.error(`Failed to send details Discord message: ${err.message || err}`));\n    }\n\n    takaro.log.info('Daily market report sent successfully.');\n}\n\nawait main();",
                    "name": "marketnews",
                    "description": null,
                    "temporalValue": "1 */1 * * *"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    try {\n        const { gameServerId, module: mod } = data;\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Check if market is initialized\n        if (marketDataVar.data.data.length === 0) {\n            console.log(\"Market data not found, initializing...\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return; // Exit after initialization\n        }\n\n        // Get active market event\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event start time\n        const eventStartTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_start_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event execution counter\n        const eventCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_execution_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event cooldown counter\n        const cooldownCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_cooldown_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let eventCounter = 0;\n        if (eventCounterVar.data.data.length > 0) {\n            eventCounter = parseInt(eventCounterVar.data.data[0].value, 10);\n            console.log(`Event counter: ${eventCounter}`);\n        }\n\n        let cooldownCounter = 0;\n        if (cooldownCounterVar.data.data.length > 0) {\n            cooldownCounter = parseInt(cooldownCounterVar.data.data[0].value, 10);\n            console.log(`Cooldown counter: ${cooldownCounter}`);\n        }\n\n        // Get event duration\n        const eventDurationVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['current_event_duration'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Use stored random duration if available, otherwise use defaultEventDuration\n        let eventDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        if (eventDurationVar.data.data.length > 0) {\n            eventDuration = parseInt(eventDurationVar.data.data[0].value, 10);\n            console.log(`Event duration: ${eventDuration}`);\n        }\n\n        let activeEvent = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                // If it's an empty string, treat as no active event\n                if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                    activeEvent = null;\n                }\n                console.log(`Active event: ${activeEvent ? activeEvent.name : 'None'}`);\n            } catch (e) {\n                // In case of parsing error, consider no active event\n                activeEvent = null;\n                console.log(`Error parsing active event: ${e.message}`);\n            }\n        }\n\n        // Check if the current event should end and increment counter\n        if (activeEvent) {\n            eventCounter++;\n            console.log(`Incremented event counter to: ${eventCounter}`);\n\n            if (eventCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: eventCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: eventCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n\n            if (eventCounter >= eventDuration) {\n                console.log(\"Event duration reached, ending event.\");\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: ''\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_cooldown_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    const message = `ðŸ“ˆ MARKET UPDATE ðŸ“‰\\n\\nThe \"${activeEvent.name}\" event has ended. Markets are returning to normal conditions.`;\n\n                    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                        message: message\n                    });\n                }\n\n                activeEvent = null;\n            }\n        } else {\n            cooldownCounter++;\n            console.log(`Incremented cooldown counter to: ${cooldownCounter}`);\n\n            if (cooldownCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: cooldownCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: cooldownCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n        }\n\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        const eventFrequency = (mod.userConfig && mod.userConfig.eventFrequency) || 10;\n        let shouldTriggerEvent = false;\n\n        if (!activeEvent && cooldownCounter >= eventFrequency) {\n            shouldTriggerEvent = Math.random() < 0.5;\n            if (cooldownCounter >= eventFrequency * 2) {\n                shouldTriggerEvent = true;\n            }\n            console.log(`Should trigger new event: ${shouldTriggerEvent}`);\n        }\n\n        if (shouldTriggerEvent) {\n            const events = (mod.userConfig && mod.userConfig.marketEvents) || [];\n            if (events.length > 0) {\n                const randomEvent = events[Math.floor(Math.random() * events.length)];\n                activeEvent = randomEvent;\n                console.log(`New event triggered: ${activeEvent.name}`);\n\n                const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n                const randomDuration = Math.floor(Math.random() * maxDuration) + 1;\n\n                if (eventDurationVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                        value: randomDuration.toString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'current_event_duration',\n                        value: randomDuration.toString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: JSON.stringify(activeEvent)\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'active_market_event',\n                        value: JSON.stringify(activeEvent),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventStartTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_start_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (lastEventTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'last_market_event_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    let impactText = \"\";\n                    for (const impact of activeEvent.sectorImpacts) {\n                        const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                        impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n                    }\n\n                    const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${activeEvent.name}\\n${activeEvent.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /market to see opportunities!`;\n\n                    const maxLength = 400;\n                    for (let i = 0; i < message.length; i += maxLength) {\n                        await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                            message: message.substring(i, i + maxLength)\n                        });\n                    }\n                }\n            }\n        }\n\n        // Get stocks\n        if (!marketDataVar.data.data[0] || !marketDataVar.data.data[0].value) {\n            console.log(\"Market data is empty or invalid after initial check, re-initializing.\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        let stocks;\n        try {\n            stocks = JSON.parse(marketDataVar.data.data[0].value);\n            if (!Array.isArray(stocks)) {\n                throw new Error(\"Parsed stocks data is not an array\");\n            }\n            // CRITICAL FIX: Ensure each stock has valid numerical price properties\n            stocks = stocks.map(s => {\n                const sanitizedPrice = typeof s.price === 'number' && s.price > 0 ? s.price : 1;\n                const sanitizedLastPrice = typeof s.lastPrice === 'number' && s.lastPrice > 0 ? s.lastPrice : sanitizedPrice;\n                return {\n                    ...s,\n                    price: sanitizedPrice,\n                    lastPrice: sanitizedLastPrice\n                };\n            });\n            console.log(\"Stocks loaded and sanitized successfully.\");\n            console.log(\"Initial stocks for this cycle:\");\n            stocks.forEach(s => console.log(`  ${s.id}: Price ${s.price}, LastPrice ${s.lastPrice}`));\n\n        } catch (e) {\n            console.log(`Error parsing or sanitizing stock data: ${e.message}`);\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        const significantChanges = [];\n\n        // Update each stock price\n        stocks.forEach(stock => {\n            // Always capture oldPrice at the very beginning of the iteration\n            const oldPrice = stock.price;\n            // Set lastPrice to the value before this current update cycle for accurate change tracking\n            stock.lastPrice = oldPrice;\n\n            console.log(`Processing stock: ${stock.id}, Old Price: ${oldPrice}`);\n\n            // Define the threshold for \"penny stock\" and the chance/magnitude of a breakout\n            const pennyStockThreshold = 1.9;\n            const breakoutChance = 0.6; // Chance for a penny stock to hit a \"breakout\" swing\n\n            let calculatedNewPrice;\n\n            // Check if it's a penny stock and qualifies for a breakout\n            if (oldPrice <= pennyStockThreshold && Math.random() < breakoutChance) {\n                console.log(`${stock.id} is a penny stock (${oldPrice}) and hit breakout chance!`);\n                // **MODIFIED:** Removed guaranteed increase. Now it's a larger, random swing.\n                const randomFactor = Math.random() * 2 - 1; // Can be positive or negative (-1 to 1)\n                const increasedVolatility = stock.volatility * 2; // Make breakout swings more pronounced\n                calculatedNewPrice = oldPrice * (1 + randomFactor * increasedVolatility);\n                console.log(`${stock.id} calculated breakout price: ${calculatedNewPrice} (Breakout Change: ${(randomFactor * increasedVolatility * 100).toFixed(2)}%)`);\n            } else {\n                const randomFactor = Math.random() * 2 - 1; // Generates a number between -1 and 1\n                const totalChangePercent = randomFactor * stock.volatility;\n                calculatedNewPrice = oldPrice * (1 + totalChangePercent);\n                console.log(`${stock.id} calculated normal price: ${calculatedNewPrice} (Change: ${totalChangePercent * 100}%)`);\n            }\n\n            let finalPrice = calculatedNewPrice;\n            if (activeEvent) {\n                const sectorImpact = activeEvent.sectorImpacts.find(impact => impact.sectorId === stock.sector);\n                if (sectorImpact) {\n                    const eventImpactPercentage = sectorImpact.impact;\n                    const eventImpactDecimal = eventImpactPercentage / 100;\n                    // randomImpactFactor is currently 0.5 to 1.5. If positive events are too common/strong,\n                    // this will still bias upwards. For now, we'll keep it as is, but consider balancing\n                    // the event definitions themselves if needed.\n                    const randomImpactFactor = 0.5 + Math.random();\n                    const eventImpact = eventImpactDecimal * randomImpactFactor;\n\n                    finalPrice = calculatedNewPrice * (1 + eventImpact);\n                    console.log(`${stock.id} final price after event impact: ${finalPrice} (Event impact: ${eventImpact * 100}%)`);\n                }\n            }\n\n            // **NEW LOGIC:** Introduce a \"rebound\" chance for very low-priced stocks (after all other calculations)\n            const lowPriceReboundThreshold = 2.0; // Define a threshold, e.g., $2\n            const reboundBoostFactor = 0.05; // e.g., a 5% potential positive boost\n            const reboundChancePercentage = 0.3; // 30% chance for a rebound when below threshold\n\n            if (finalPrice > 0 && finalPrice < lowPriceReboundThreshold && Math.random() < reboundChancePercentage) {\n                finalPrice += finalPrice * reboundBoostFactor * Math.random(); // Add a small, random positive percentage\n                console.log(`${stock.id} at $${oldPrice} (calculated to $${calculatedNewPrice}) got a low-price rebound bump to $${finalPrice}`);\n            }\n\n            stock.price = finalPrice;\n\n            if (stock.price < 1) {\n                console.log(`${stock.id} price fell below 1, setting to 1.`);\n                stock.price = 1;\n            }\n\n            const actualPercentChange = ((stock.price - oldPrice) / oldPrice) * 100;\n            console.log(`${stock.id} - Final Price: ${stock.price.toFixed(2)}, Actual Change: ${actualPercentChange.toFixed(2)}%`);\n\n            const changeThreshold = ((mod.userConfig && mod.userConfig.priceAlertThreshold) || 10) / 100;\n            if (Math.abs(actualPercentChange) > changeThreshold * 100) {\n                significantChanges.push({\n                    ...stock,\n                    changePercent: actualPercentChange\n                });\n            }\n        });\n\n        console.log(\"All stocks processed, saving updated prices...\");\n        await takaro.variable.variableControllerUpdate(marketDataVar.data.data[0].id, {\n            value: JSON.stringify(stocks)\n        });\n        console.log(\"Updated prices saved.\");\n\n        if (significantChanges.length > 0) {\n            console.log(\"Significant changes detected, sending alert.\");\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                significantChanges.sort((a, b) => Math.abs(b.changePercent) - Math.abs(a.changePercent));\n                const topChanges = significantChanges.slice(0, Math.min(3, significantChanges.length));\n\n                let message = \"ðŸ“Š STOCK MARKET ALERT ðŸ“Š\\n\";\n                topChanges.forEach(stock => {\n                    const changeDir = stock.changePercent > 0 ? \"up\" : \"down\";\n                    const displayPrice = stock.price.toFixed(2);\n                    const changePercent = Math.abs(Math.round(stock.changePercent));\n\n                    message += `${stock.id} (${stock.sector}): ${changeDir} ${changePercent}% to $${displayPrice}!\\n`;\n                });\n\n                if (activeEvent) {\n                    message += `\\nCurrent market event: ${activeEvent.name}`;\n                }\n\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            } else {\n                console.log(\"No online players to send alert to.\");\n            }\n        } else {\n            console.log(\"No significant changes to alert players about.\");\n        }\n    } catch (error) {\n        console.log(`FATAL Error in updateStockPrices: ${error.message}`);\n        // Optionally, send an admin message if a fatal error occurs\n        // await takaro.gameserver.gameServerControllerSendMessage(data.gameServerId, {\n        //     message: `ðŸš¨ Market Error: An error occurred during stock update: ${error.message}`\n        // });\n    }\n}\n\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        console.log(\"Initializing market if needed...\");\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in module configuration for initialization.\");\n            return;\n        }\n\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_data'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['last_market_event_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_start_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['active_market_event'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_initialized'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_execution_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_cooldown_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['current_event_duration'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } })\n            ]);\n\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n        console.log(\"Mapped initial stocks from config.\");\n\n        const createPromises = [];\n\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_data', value: JSON.stringify(stocks), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'last_market_event_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_start_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'active_market_event', value: '', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_execution_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (cooldownCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_cooldown_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventDurationVar.data.data.length === 0) {\n            const defaultDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'current_event_duration', value: defaultDuration.toString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_initialized', value: 'true', gameServerId, moduleId: mod.moduleId }));\n        }\n\n        if (createPromises.length > 0) {\n            console.log(`Creating ${createPromises.length} initial market variables.`);\n            await Promise.allSettled(createPromises);\n        } else {\n            console.log(\"All market variables already exist, no new initialization needed.\");\n        }\n\n        if (marketDataVar.data.data.length === 0) { // Only announce if we actually created the stock_market_data variable\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /market to see available stocks and /buy to start investing.\";\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, { message });\n            }\n        }\n        console.log(\"Market initialization process complete.\");\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();\n",
                    "name": "updatestockprices",
                    "description": null,
                    "temporalValue": "0 */1 * * *"
                }
            ],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Allows the player to view market prices and their portfolio",
                    "permission": "STOCK_MARKET_USE",
                    "friendlyName": "Use Stock Market"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows the player to buy and sell stocks",
                    "permission": "STOCK_MARKET_TRADE",
                    "friendlyName": "Trade Stocks"
                },
                {
                    "canHaveCount": false,
                    "description": "VIP status that reduces transaction fees",
                    "permission": "STOCK_MARKET_BROKER",
                    "friendlyName": "Stock Broker"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows admins to manually trigger market events",
                    "permission": "STOCK_MARKET_TRIGGER_EVENT",
                    "friendlyName": "Trigger Market Events"
                }
            ]
        },
        {
            "tag": "0.1.10",
            "description": "**Stock Market: A Dynamic Virtual Trading System**\n\nCreate an immersive economic experience with this comprehensive stock market module that lets players invest, trade, and react to market events.\n\n**Market Features:**\n\n![Market Summary](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stocks.png)\n\n* **Multiple Economic Sectors:** Configure various industry sectors (Resource Extraction, Manufacturing, Defense, etc.) each with their own market dynamics.\n* **Realistic Stock Behavior:** Stocks have configurable volatility, sector-based pricing, and react differently to market events.\n* **Dynamic Market Events:** Random or admin-triggered events like \"Horde Night Approaching\" or \"Societal Collapse Setback\" impact different sectors in realistic ways.\n\n![Market Events](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_events.png)\n\n**Trading System:**\n\n* **Buy & Sell Shares:** Players can purchase stocks and sell them later for profit or loss.\n* **Transaction Fees:** Configurable fee percentage on all trades creates a realistic market economy.\n* **VIP Benefits:** Special permissions for designated \"Stock Brokers\" who receive fee discounts.\n\n![Buy Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_buy.png)\n\nPlayers can track price changes and sell at the right moment to maximize profits or minimize losses.\n\n![Sell Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sell.png)\n\n**Player Portfolio:**\n\n* **Portfolio Tracking:** Players can view their holdings, average purchase prices, and current profit/loss.\n* **Transaction History:** System tracks all buy/sell transactions for each player.\n* **Summary Statistics:** See overall portfolio performance and value across all holdings.\n\n![Portfolio View](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockportfolio.png)\n\n**Market Information:**\n\n* **Detailed Stock Info:** Players can research specific stocks, including risk levels and sector trends.\n* **Industry Filters:** View stocks by specific sectors to better understand market segments.\n* **Market Alerts:** Server-wide notifications for significant price changes keep players engaged.\n\n![Market Alerts](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockpricechange.png)\n\n**Configuration Options:**\n\n* **Sectors & Stocks:** Define your own market sectors and individual stocks with customizable starting prices and volatility.\n* **Market Events:** Create unique events with specific sector impacts to drive market dynamics.\n* **Transaction Settings:** Configure fee percentages, VIP discounts, and alert thresholds.\n* **Event Frequency:** Control how often random market events occur and how long they last.\n\n![Configuration](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_config.png)\n![Sectors](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sectors.png)\n\n**Commands:**\n\n* `/markets [industry]` - View all stocks or filter by industry\n* `/stockinfo [ticker]` - Get detailed information about a specific stock\n* `/buystock <ticker> <amount>` - Purchase shares of a stock\n* `/sellstock <ticker> <amount>` - Sell shares from your portfolio\n* `/stockportfolio` - View your current holdings and performance\n* `/triggerevent [event]` - Admin command to trigger specific market events\n\nWho says the apocalypse can't have a thriving economy? Now players can stress about both zombie hordes AND their Duke's Casino Tokens dropping 40% after a market event! As one trader put it: \"I used to check my 401K daily, and now I check my AMMO stock before every Blood Moon. Some habits die harder than zombies.\"",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sectors\":{\"type\":\"array\",\"title\":\"Wasteland Economic Sectors\",\"description\":\"Define economic sectors relevant to survival in Navezgane\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Sector ID (e.g., RESOURCES)\"},\"name\":{\"type\":\"string\",\"description\":\"Sector name (e.g., Resource Extraction)\"}}},\"default\":[{\"id\":\"RESOURCES\",\"name\":\"Resource Extraction\"},{\"id\":\"FOSSIL_FUELS\",\"name\":\"Fossil Fuel Extraction (High Volatility)\"},{\"id\":\"MANUFACTURING\",\"name\":\"Manufacturing & Crafting\"},{\"id\":\"VOLATILE_CHEMICALS\",\"name\":\"Volatile Chemicals (High Volatility)\"},{\"id\":\"DEFENSE\",\"name\":\"Defense & Fortifications\"},{\"id\":\"ADVANCED_WEAPONRY\",\"name\":\"Advanced Weaponry (High Volatility)\"},{\"id\":\"SURVIVAL\",\"name\":\"Survival Goods\"},{\"id\":\"PHARMACEUTICALS\",\"name\":\"Pharmaceuticals (High Volatility)\"},{\"id\":\"TRADE\",\"name\":\"Trade & Currency\"},{\"id\":\"GUILD_OPERATIONS\",\"name\":\"Trader Guild Operations (High Volatility)\"}]},\"stocks\":{\"type\":\"array\",\"title\":\"Wasteland Stocks\",\"description\":\"List of stocks representing Navezgane entities and resources\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Stock ticker symbol (e.g., NMC)\"},\"name\":{\"type\":\"string\",\"description\":\"Entity/Resource name\"},\"sector\":{\"type\":\"string\",\"description\":\"Sector ID this stock belongs to\"},\"initialPrice\":{\"type\":\"number\",\"description\":\"Starting price in Dukes\",\"minimum\":1},\"volatility\":{\"type\":\"number\",\"description\":\"Base volatility percentage (5 = 5%)\",\"minimum\":1,\"maximum\":60}}},\"default\":[{\"id\":\"NMC\",\"name\":\"Navezgane Mining Co.\",\"sector\":\"RESOURCES\",\"initialPrice\":50,\"volatility\":15},{\"id\":\"NIOM\",\"name\":\"Navezgane Iron Ore Mining Co.\",\"sector\":\"RESOURCES\",\"initialPrice\":55,\"volatility\":16},{\"id\":\"NLMC\",\"name\":\"Navezgane Lead Mining Co.\",\"sector\":\"RESOURCES\",\"initialPrice\":45,\"volatility\":14},{\"id\":\"WOOD\",\"name\":\"Wasteland Lumberjacks\",\"sector\":\"RESOURCES\",\"initialPrice\":20,\"volatility\":8},{\"id\":\"SHALE\",\"name\":\"Oil Shale Extractors\",\"sector\":\"FOSSIL_FUELS\",\"initialPrice\":40,\"volatility\":45},{\"id\":\"FORGE\",\"name\":\"Forge Ahead Metals\",\"sector\":\"MANUFACTURING\",\"initialPrice\":75,\"volatility\":12},{\"id\":\"TOOLS\",\"name\":\"Working Stiff Tools\",\"sector\":\"MANUFACTURING\",\"initialPrice\":60,\"volatility\":10},{\"id\":\"AIA\",\"name\":\"A1 Auto\",\"sector\":\"MANUFACTURING\",\"initialPrice\":40,\"volatility\":14},{\"id\":\"AMC\",\"name\":\"Atlas Metal Company\",\"sector\":\"MANUFACTURING\",\"initialPrice\":65,\"volatility\":13},{\"id\":\"COC\",\"name\":\"COC Chemicals\",\"sector\":\"VOLATILE_CHEMICALS\",\"initialPrice\":55,\"volatility\":50},{\"id\":\"MECH\",\"name\":\"JunkTech Robotics\",\"sector\":\"MANUFACTURING\",\"initialPrice\":110,\"volatility\":25},{\"id\":\"BUILD\",\"name\":\"Barricade Builders\",\"sector\":\"DEFENSE\",\"initialPrice\":45,\"volatility\":9},{\"id\":\"ZBI\",\"name\":\"Zombie Bashers Inc.\",\"sector\":\"DEFENSE\",\"initialPrice\":85,\"volatility\":17},{\"id\":\"TTC\",\"name\":\"Turret Tracker Co.\",\"sector\":\"ADVANCED_WEAPONRY\",\"initialPrice\":125,\"volatility\":60},{\"id\":\"AMMO\",\"name\":\"AmmoNation Surplus\",\"sector\":\"DEFENSE\",\"initialPrice\":90,\"volatility\":18},{\"id\":\"SHM\",\"name\":\"Shotgun Messiah\",\"sector\":\"DEFENSE\",\"initialPrice\":120,\"volatility\":30},{\"id\":\"SHAM\",\"name\":\"Shamway Foods\",\"sector\":\"SURVIVAL\",\"initialPrice\":30,\"volatility\":5},{\"id\":\"SSHM\",\"name\":\"Super Shamway\",\"sector\":\"SURVIVAL\",\"initialPrice\":32,\"volatility\":4},{\"id\":\"MEDS\",\"name\":\"Pop-N-Pills Medical\",\"sector\":\"PHARMACEUTICALS\",\"initialPrice\":100,\"volatility\":48},{\"id\":\"SAVG\",\"name\":\"Savage Country\",\"sector\":\"SURVIVAL\",\"initialPrice\":35,\"volatility\":6},{\"id\":\"CRKB\",\"name\":\"Crack-A-Book\",\"sector\":\"SURVIVAL\",\"initialPrice\":80,\"volatility\":16},{\"id\":\"TRADE\",\"name\":\"Trader Guild Network\",\"sector\":\"GUILD_OPERATIONS\",\"initialPrice\":150,\"volatility\":40},{\"id\":\"PNG\",\"name\":\"Pass-N-Gas\",\"sector\":\"TRADE\",\"initialPrice\":50,\"volatility\":11},{\"id\":\"BOB\",\"name\":\"Trader Bob's\",\"sector\":\"TRADE\",\"initialPrice\":160,\"volatility\":9},{\"id\":\"HUGH\",\"name\":\"Trader Hugh's\",\"sector\":\"TRADE\",\"initialPrice\":170,\"volatility\":12},{\"id\":\"JEN\",\"name\":\"Trader Jen's\",\"sector\":\"TRADE\",\"initialPrice\":180,\"volatility\":10},{\"id\":\"JOEL\",\"name\":\"Trader Joel's\",\"sector\":\"TRADE\",\"initialPrice\":175,\"volatility\":11},{\"id\":\"REKT\",\"name\":\"Trader Rekt's\",\"sector\":\"TRADE\",\"initialPrice\":165,\"volatility\":6},{\"id\":\"DUKES\",\"name\":\"Duke's Casino Tokens\",\"sector\":\"TRADE\",\"initialPrice\":1,\"volatility\":3}]},\"marketEvents\":{\"type\":\"array\",\"title\":\"Wasteland Events\",\"description\":\"Events impacting the Navezgane economy\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Unique event ID\"},\"name\":{\"type\":\"string\",\"description\":\"Name of the event\"},\"description\":{\"type\":\"string\",\"description\":\"Description of the event's market effect\"},\"sectorImpacts\":{\"type\":\"array\",\"description\":\"How each sector is affected\",\"items\":{\"type\":\"object\",\"properties\":{\"sectorId\":{\"type\":\"string\",\"description\":\"Sector ID\"},\"impact\":{\"type\":\"number\",\"description\":\"Percentage impact (-99 = -99%)\",\"minimum\":-99,\"maximum\":75}}}}}},\"default\":[{\"id\":\"HORDE_INCOMING\",\"name\":\"Horde Night Approaching\",\"description\":\"Increased Zed activity signals the Blood Moon. General defense and manufacturing stocks are up.\",\"sectorImpacts\":[{\"sectorId\":\"DEFENSE\",\"impact\":20},{\"sectorId\":\"MANUFACTURING\",\"impact\":10},{\"sectorId\":\"SURVIVAL\",\"impact\":10},{\"sectorId\":\"TRADE\",\"impact\":-15}]},{\"id\":\"STABLE_ECONOMY\",\"name\":\"Period of Stability\",\"description\":\"A rare period of peace has settled over the wasteland. Low-risk assets and basic trade are flourishing.\",\"sectorImpacts\":[{\"sectorId\":\"TRADE\",\"impact\":25},{\"sectorId\":\"SURVIVAL\",\"impact\":20},{\"sectorId\":\"MANUFACTURING\",\"impact\":5},{\"sectorId\":\"RESOURCES\",\"impact\":5}]},{\"id\":\"GENERAL_PANIC\",\"name\":\"General Market Panic\",\"description\":\"A major setback reminds everyone how fragile survival is. Fear grips the entire market, causing a broad downturn.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-25},{\"sectorId\":\"MANUFACTURING\",\"impact\":-30},{\"sectorId\":\"DEFENSE\",\"impact\":-30},{\"sectorId\":\"SURVIVAL\",\"impact\":-20},{\"sectorId\":\"TRADE\",\"impact\":-40},{\"sectorId\":\"FOSSIL_FUELS\",\"impact\":-35},{\"sectorId\":\"VOLATILE_CHEMICALS\",\"impact\":-45},{\"sectorId\":\"ADVANCED_WEAPONRY\",\"impact\":-50},{\"sectorId\":\"PHARMACEUTICALS\",\"impact\":-25},{\"sectorId\":\"GUILD_OPERATIONS\",\"impact\":-40}]},{\"id\":\"ADVANCED_WEAPONRY_COLLAPSE\",\"name\":\"Turret AI Virus\",\"description\":\"A malicious code is spreading through advanced turret systems, causing them to malfunction violently. TTC's stock has been obliterated.\",\"sectorImpacts\":[{\"sectorId\":\"ADVANCED_WEAPONRY\",\"impact\":-99},{\"sectorId\":\"DEFENSE\",\"impact\":-10}]},{\"id\":\"VOLATILE_CHEMICALS_COLLAPSE\",\"name\":\"Irreversible Contamination\",\"description\":\"The COC chemical disaster is worse than imagined. The company is bankrupt and its assets are worthless.\",\"sectorImpacts\":[{\"sectorId\":\"VOLATILE_CHEMICALS\",\"impact\":-99},{\"sectorId\":\"MANUFACTURING\",\"impact\":-20}]},{\"id\":\"FOSSIL_FUELS_COLLAPSE\",\"name\":\"Clean Energy Breakthrough\",\"description\":\"A scavenger has replicated a pre-collapse fusion generator. The demand for oil shale has evaporated overnight.\",\"sectorImpacts\":[{\"sectorId\":\"FOSSIL_FUELS\",\"impact\":-99},{\"sectorId\":\"MANUFACTURING\",\"impact\":25}]},{\"id\":\"PHARMACEUTICALS_COLLAPSE\",\"name\":\"The Cure is Real\",\"description\":\"A cure for the zombie infection is real and easily replicated. The panic is over, and with it, the market for Pop-N-Pills.\",\"sectorImpacts\":[{\"sectorId\":\"PHARMACEUTICALS\",\"impact\":-99},{\"sectorId\":\"SURVIVAL\",\"impact\":-50}]},{\"id\":\"GUILD_OPERATIONS_COLLAPSE\",\"name\":\"Trader Guild Dissolved\",\"description\":\"The Trader's Guild has been formally dissolved. Its centralized network is gone, and its stock is now worthless paper.\",\"sectorImpacts\":[{\"sectorId\":\"GUILD_OPERATIONS\",\"impact\":-99},{\"sectorId\":\"TRADE\",\"impact\":-30}]}]},\"eventFrequency\":{\"title\":\"Event Frequency\",\"type\":\"number\",\"description\":\"Average number of update cycles between market events (0 to disable). Depends on mod's update frequency (e.g., per in-game hour?).\",\"default\":8,\"minimum\":1},\"defaultEventDuration\":{\"title\":\"Default Event Duration\",\"type\":\"number\",\"description\":\"Default number of update cycles an event lasts.\",\"default\":3,\"minimum\":1,\"maximum\":96},\"transactionFee\":{\"title\":\"Transaction Fee (Dukes Tax)\",\"type\":\"number\",\"description\":\"Percentage fee charged on all buy/sell transactions (5 = 5%)\",\"default\":3,\"minimum\":0,\"maximum\":25},\"vipDiscount\":{\"title\":\"Trader's Favor Discount\",\"type\":\"number\",\"description\":\"Percentage discount on transaction fees for players with 'STOCK_MARKET_BROKER' permission (50 = 50%)\",\"default\":50,\"minimum\":0,\"maximum\":100},\"priceAlertThreshold\":{\"title\":\"Price Alert Threshold\",\"type\":\"number\",\"description\":\"Percentage change that triggers a market alert (15 = 15%)\",\"default\":15,\"minimum\":5,\"maximum\":50},\"marketNewsChannelId\":{\"title\":\"Discord Channel ID (for Market News)\",\"type\":\"string\",\"description\":\"The ID of the Discord channel where market news messages should be posted. Leave empty to disable.\",\"default\":\"\"}},\"additionalProperties\":false}",
            "uiSchema": "{\"sectors\":{\"items\":{\"ui:order\":[\"id\",\"name\"]}},\"stocks\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"sector\",\"initialPrice\",\"volatility\"]}},\"marketEvents\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"description\",\"sectorImpacts\"],\"sectorImpacts\":{\"items\":{\"ui:order\":[\"sectorId\",\"impact\"]}}}},\"transactionFee\":{\"ui:widget\":\"range\"},\"vipDiscount\":{\"ui:widget\":\"range\"},\"eventFrequency\":{\"ui:help\":\"Set to 0 to disable random events\"},\"priceAlertThreshold\":{\"ui:widget\":\"range\"}}",
            "commands": [
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get player's portfolio\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        if (portfolioVar.data.data.length === 0) {\n            throw new TakaroUserError(\"You don't own any stocks to sell.\");\n        }\n\n        const portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        const stockId = args.stock.toUpperCase();\n\n        if (!portfolio[stockId] || portfolio[stockId].shares < amount) {\n            throw new TakaroUserError(`You don't own ${amount} shares of ${stockId}.`);\n        }\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === stockId);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${stockId} not found in current market data. Please contact an admin.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate sale proceeds using Math.round to ensure we work with integers\n        const stockPrice = Math.round(stock.price);\n        const subtotal = stockPrice * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const netProceeds = subtotal - fee;\n\n        // Add money to player - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerAddCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: netProceeds\n            }\n        );\n\n        // Calculate profit/loss\n        const profitPerShare = stockPrice - portfolio[stockId].averagePrice;\n        const totalProfit = Math.round(profitPerShare * amount);\n        const profitText = totalProfit >= 0\n            ? `profit of $${totalProfit}`\n            : `loss of $${Math.abs(totalProfit)}`;\n\n        // Update portfolio\n        portfolio[stockId].shares -= amount;\n        if (portfolio[stockId].shares === 0) {\n            delete portfolio[stockId];\n        }\n\n        // Save updated portfolio\n        await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n            value: JSON.stringify(portfolio)\n        });\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'SELL',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: netProceeds,\n            profit: totalProfit,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully sold ${amount} shares of ${stockId} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Net proceeds: $${netProceeds} (${profitText})`;\n\n        // Add remaining shares info if player still has some\n        if (portfolio[stockId]) {\n            message += `\\nRemaining shares: ${portfolio[stockId].shares}`;\n        } else {\n            message += `\\nYou've sold all your ${stockId} shares.`;\n        }\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in sellstock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your sale. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "sellstock",
                    "description": null,
                    "trigger": "sellstock",
                    "helpText": "Sell shares of a stock",
                    "arguments": [
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to sell",
                            "position": 1
                        },
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // If a specific stock ticker is provided, show detailed info for that stock\n    const specificTicker = args.ticker ? args.ticker.toUpperCase() : null;\n\n    if (specificTicker && specificTicker !== \"ALL\") {\n        const stock = stocks.find(s => s.id.toUpperCase() === specificTicker);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${specificTicker} not found. Use /stockinfo without parameters to see all available stocks.`);\n        }\n\n        // Get active event to see if this stock's sector is affected\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let activeEvent = null;\n        let sectorImpact = null;\n\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEvent && activeEvent.sectorImpacts) {\n                    sectorImpact = activeEvent.sectorImpacts.find(impact =>\n                        impact.sectorId === stock.sector\n                    );\n                }\n            } catch (e) {\n                // Ignore parsing errors\n            }\n        }\n\n        // Calculate price change indicators\n        let changeText = '';\n        if (stock.lastPrice) {\n            const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n            const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n            changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n        }\n\n        // Add risk assessment based on volatility without showing the raw value\n        let riskLevel;\n        if (stock.volatility <= 0.05) riskLevel = \"Very Low\";\n        else if (stock.volatility <= 0.10) riskLevel = \"Low\";\n        else if (stock.volatility <= 0.15) riskLevel = \"Moderate\";\n        else if (stock.volatility <= 0.20) riskLevel = \"High\";\n        else riskLevel = \"Very High\";\n\n        // Build detailed stock info message\n        let message = `=== ${stock.id}: ${stock.name} ===\\n\\n`;\n        message += `Sector: ${stock.sector}\\n`;\n        message += `Current Price: $${Math.round(stock.price)}${changeText}\\n`;\n        message += `Risk Level: ${riskLevel}\\n`;\n\n        // Add sector trend info if available from event\n        if (activeEvent && sectorImpact) {\n            const direction = sectorImpact.impact >= 0 ? \"Positive\" : \"Negative\";\n            const strength = Math.abs(sectorImpact.impact);\n            let trend;\n\n            if (strength < 10) trend = \"Slight\";\n            else if (strength < 25) trend = \"Moderate\";\n            else trend = \"Strong\";\n\n            message += `\\nCurrent Trend: ${trend} ${direction} (${activeEvent.name})\\n`;\n            message += `Event: ${activeEvent.description}\\n`;\n        }\n\n        // Add trading guidance based on sector and risk, without mentioning volatility\n        message += `\\nTrading Notes:\\n`;\n\n        if (activeEvent && sectorImpact) {\n            if (sectorImpact.impact > 0) {\n                message += `- Currently bullish due to the ${activeEvent.name} event\\n`;\n            } else {\n                message += `- Currently bearish due to the ${activeEvent.name} event\\n`;\n            }\n        }\n\n        if (riskLevel === \"High\" || riskLevel === \"Very High\") {\n            message += `- Expect significant price fluctuations with this stock\\n`;\n        } else if (riskLevel === \"Low\" || riskLevel === \"Very Low\") {\n            message += `- Typically has stable price movement\\n`;\n        }\n\n        message += `\\nUse /buystock ${stock.id} [amount] to purchase shares`;\n\n        await player.pm(message);\n\n    } else {\n        // No specific ticker provided or ALL specified, show summary of all stocks\n        await player.pm(\"=== STOCK MARKET LISTINGS ===\\n\");\n\n        // Group stocks by sector\n        const stocksBySector = {};\n        stocks.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        // MODIFICATION START\n        // Display stocks by sector, chunking them into messages of 3\n        const chunkSize = 3;\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            for (let i = 0; i < sectorStocks.length; i += chunkSize) {\n                const chunk = sectorStocks.slice(i, i + chunkSize);\n\n                // Add the sector header only to the first message for that sector.\n                let sectorMessage = (i === 0) ? `\\n--- ${sector} SECTOR ---\\n` : '';\n\n                chunk.forEach(stock => {\n                    // Add price change indicators\n                    let changeText = '';\n                    if (stock.lastPrice) {\n                        const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                        const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                        changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                    }\n\n                    // Add risk level based on volatility\n                    let riskIndicator;\n                    if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                    else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                    else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                    else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                    else riskIndicator = \"VH\";\n\n                    sectorMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n                });\n\n                await player.pm(sectorMessage);\n            }\n        }\n        // MODIFICATION END\n\n        // Add legend for risk indicators\n        const legend = \"\\n=== LEGEND ===\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\" +\n            \"Use /stockinfo [ticker] for detailed information about a specific stock\";\n\n        await player.pm(legend);\n    }\n}\n\nawait main();",
                    "name": "stockinfo",
                    "description": null,
                    "trigger": "stockinfo",
                    "helpText": "Shows all available stocks in the market. Use with a ticker symbol (e.g., /stockinfo ticker) to see detailed information about a specific stock.",
                    "arguments": [
                        {
                            "name": "ticker",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "stock ticker or ALL to get detailed information about a specific stock",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // Get player's portfolio\n    const portfolioVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_portfolio'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId],\n            playerId: [player.id]\n        }\n    });\n\n    let portfolio = {};\n    if (portfolioVar.data.data.length > 0) {\n        portfolio = JSON.parse(portfolioVar.data.data[0].value);\n    }\n\n    // Send header\n    await player.pm(\"=== YOUR STOCK PORTFOLIO ===\");\n\n    let hasStocks = false;\n    let totalValue = 0;\n    let totalInvestment = 0;\n\n    // If no stocks, send a simple message\n    if (Object.keys(portfolio).length === 0) {\n        await player.pm(\"You don't own any stocks yet.\\n\" +\n            \"Use /markets to see available stocks and prices.\\n\" +\n            \"Use /buy <stock> <amount> to purchase stocks.\");\n        return;\n    }\n\n    // Helper function to format numbers with commas\n    const formatNumber = (num) => {\n        return Math.round(num).toLocaleString();\n    };\n\n    // Send each stock as a separate message to avoid length issues\n    for (const [stockId, data] of Object.entries(portfolio)) {\n        hasStocks = true;\n        const stock = stocks.find(s => s.id === stockId);\n        if (!stock) continue; // Stock might have been removed from config\n\n        const currentValue = stock.price * data.shares;\n        const investmentValue = data.averagePrice * data.shares;\n        totalValue += currentValue;\n        totalInvestment += investmentValue;\n        const profit = currentValue - investmentValue;\n        const profitPercent = ((profit / investmentValue) * 100).toFixed(1);\n\n        let stockMessage = `--- ${stockId} (${stock.sector}) ---\\n`;\n        stockMessage += `Shares: ${data.shares}\\n`;\n        stockMessage += `Avg buy: $${formatNumber(data.averagePrice)}\\n`;\n        stockMessage += `Current price: $${formatNumber(stock.price)}\\n`;\n        stockMessage += `Total value: $${formatNumber(currentValue)}\\n`;\n\n        if (profit >= 0) {\n            stockMessage += `Profit: +$${formatNumber(profit)} (+${profitPercent}%)\\n`;\n        } else {\n            stockMessage += `Loss: -$${formatNumber(Math.abs(profit))} (${profitPercent}%)\\n`;\n        }\n\n        await player.pm(stockMessage);\n    }\n\n    if (hasStocks) {\n        const totalProfit = totalValue - totalInvestment;\n        const totalProfitPercent = ((totalProfit / totalInvestment) * 100).toFixed(1);\n\n        let summaryMessage = \"=== PORTFOLIO SUMMARY ===\\n\";\n        summaryMessage += `Total investment: $${formatNumber(totalInvestment)}\\n`;\n        summaryMessage += `Current value: $${formatNumber(totalValue)}\\n`;\n\n        if (totalProfit >= 0) {\n            summaryMessage += `Overall profit: +$${formatNumber(totalProfit)} (+${totalProfitPercent}%)\\n`;\n        } else {\n            summaryMessage += `Overall loss: -$${formatNumber(Math.abs(totalProfit))} (${totalProfitPercent}%)\\n`;\n        }\n\n        // Get transaction history count\n        try {\n            const historyVar = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: ['stock_transaction_history'],\n                    gameServerId: [gameServerId],\n                    moduleId: [mod.moduleId],\n                    playerId: [player.id]\n                }\n            });\n\n            if (historyVar.data.data.length > 0) {\n                const history = JSON.parse(historyVar.data.data[0].value);\n                const buyCount = history.filter(t => t.type === 'BUY').length;\n                const sellCount = history.filter(t => t.type === 'SELL').length;\n\n                summaryMessage += `\\nTransactions: ${history.length} (${buyCount} buys, ${sellCount} sells)\\n`;\n            }\n        } catch (error) {\n            // Just ignore history errors\n        }\n\n        await player.pm(summaryMessage);\n    }\n}\n\nawait main();",
                    "name": "stockportfolio",
                    "description": null,
                    "trigger": "stockportfolio",
                    "helpText": "No help text available",
                    "arguments": []
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRIGGER_EVENT')) {\n        throw new TakaroUserError(\"You don't have permission to trigger market events.\");\n    }\n\n    try {\n        // Get current stock data to check market initialization\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Initialize market if needed\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            await player.pm(\"Market was not initialized. Initializing now...\");\n            return;\n        }\n\n        // Get events from module config\n        const marketEvents = mod.userConfig.marketEvents || [];\n\n        if (marketEvents.length === 0) {\n            throw new TakaroUserError(\"No market events configured in this module.\");\n        }\n\n        // Handle case when no event is specified or \"ALL\" is provided\n        if (!args.EventName || args.EventName.toUpperCase() === \"ALL\") {\n            await player.pm(\"=== AVAILABLE MARKET EVENTS ===\\n\");\n\n            // Group events by category or type if possible\n            const eventCategories = {};\n\n            // Create a simple categorization based on positive/negative impact\n            marketEvents.forEach(event => {\n                let category = \"Mixed\";\n                // Calculate net impact across all sectors\n                const netImpact = event.sectorImpacts.reduce((sum, impact) => sum + impact.impact, 0);\n\n                if (netImpact > 0) category = \"Positive\";\n                else if (netImpact < 0) category = \"Negative\";\n\n                if (!eventCategories[category]) {\n                    eventCategories[category] = [];\n                }\n                eventCategories[category].push(event);\n            });\n\n            // Display events by category\n            for (const [category, events] of Object.entries(eventCategories)) {\n                if (events.length > 0) {\n                    await player.pm(`\\n--- ${category.toUpperCase()} EVENTS ---`);\n\n                    let message = \"\";\n                    events.forEach(event => {\n                        // Format primary sectors affected\n                        const primarySectors = event.sectorImpacts\n                            .filter(impact => Math.abs(impact.impact) >= 15)\n                            .map(impact => {\n                                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                                return `${impact.sectorId} ${direction}${Math.abs(impact.impact)}%`;\n                            })\n                            .join(\", \");\n\n                        message += `${event.id}: ${event.name}\\n`;\n                        message += `   ${event.description}\\n`;\n                        if (primarySectors) {\n                            message += `   Major impacts: ${primarySectors}\\n`;\n                        }\n                        message += \"\\n\";\n                    });\n\n                    await player.pm(message);\n                }\n            }\n\n            await player.pm(\"=== HOW TO USE ===\\nUse `/triggerevent <EventName>` to trigger a specific event (e.g., `/triggerevent TECH_BOOM`)\");\n            return;\n        }\n\n        // Find the requested event\n        const eventId = args.EventName.toUpperCase();\n        const event = marketEvents.find(e => e.id === eventId);\n\n        if (!event) {\n            throw new TakaroUserError(`Event \"${eventId}\" not found. Use /triggerevent without parameters to see all available events.`);\n        }\n\n        // Get necessary variables for managing the event\n        const [activeEventVar, eventStartTimeVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_execution_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_cooldown_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['current_event_duration'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Check if there's an active event we need to cancel\n        let activeEventObj = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEventObj = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEventObj && Object.keys(activeEventObj).length > 0) {\n                    await player.pm(`Cancelling active event \"${activeEventObj.name}\" to trigger new event.`);\n                }\n            } catch (e) {\n                // Invalid event data, will be overwritten\n            }\n        }\n\n        // Generate a random duration for the event\n        const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n        // Update or create all event-related variables\n        const updatePromises = [];\n\n        // Save or update the random duration\n        if (eventDurationVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                    value: randomDuration.toString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'current_event_duration',\n                    value: randomDuration.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the event counter to 0\n        if (eventCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the cooldown counter\n        if (cooldownCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update active event\n        if (activeEventVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                    value: JSON.stringify(event)\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: JSON.stringify(event),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update event start time\n        if (eventStartTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update last event time\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (lastEventTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all updates to complete\n        await Promise.all(updatePromises);\n\n        // Check if there are online players to announce the event\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            // Format sector impacts for announcement\n            let impactText = \"\";\n            for (const impact of event.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n            }\n\n            const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${event.name}\\n${event.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /markets to see opportunities!`;\n\n            // Split the message if it's too long\n            const maxLength = 400; // Safe limit for most games\n            for (let i = 0; i < message.length; i += maxLength) {\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message: message.substring(i, i + maxLength)\n                });\n            }\n        }\n\n        await player.pm(`Successfully triggered the \"${event.name}\" market event for ${randomDuration} cycles!`);\n    } catch (error) {\n        // If something goes wrong, log it and let the player know\n        console.log(`Error in triggerEvent: ${error.message}`);\n        throw new TakaroUserError(`Error triggering event: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Store the stocks data\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_data',\n            value: JSON.stringify(stocks),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize last event time to now\n        await takaro.variable.variableControllerCreate({\n            key: 'last_market_event_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize event start time variable\n        await takaro.variable.variableControllerCreate({\n            key: 'event_start_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize active event (empty string means no active event)\n        await takaro.variable.variableControllerCreate({\n            key: 'active_market_event',\n            value: '',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Mark market as initialized\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_initialized',\n            value: 'true',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Announce market initialization to online players\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /markets to see available stocks and /buystock to start investing.\";\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message\n            });\n        }\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "triggerevent",
                    "description": null,
                    "trigger": "triggerevent",
                    "helpText": "Shows all available market events when run without parameters. Use with an event name (e.g., /triggerevent TECH_BOOM) to trigger a specific market event.",
                    "arguments": [
                        {
                            "name": "EventName",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "Event name to trigger a specific market event",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === args.stock.toUpperCase());\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${args.stock} not found. Use /market to see available stocks.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate costs using Math.round to ensure we work with integers\n        const subtotal = Math.round(stock.price) * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const totalCost = subtotal + fee;\n\n        // Check if player has enough currency\n        const playerData = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, player.id);\n        const currentBalance = playerData.data.data.currency;\n\n        if (currentBalance < totalCost) {\n            throw new TakaroUserError(`You don't have enough currency. Cost: $${subtotal} + $${fee} fee = $${totalCost}. Your balance: $${currentBalance}`);\n        }\n\n        // Deduct the currency - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerDeductCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: totalCost\n            }\n        );\n\n        // Get player's portfolio or create new one\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        let portfolio;\n        if (portfolioVar.data.data.length === 0) {\n            portfolio = {};\n        } else {\n            portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        }\n\n        // Update portfolio using rounded values for consistency\n        const stockPrice = Math.round(stock.price);\n        if (!portfolio[stock.id]) {\n            portfolio[stock.id] = {\n                shares: amount,\n                averagePrice: stockPrice\n            };\n        } else {\n            const totalShares = portfolio[stock.id].shares + amount;\n            const totalValue = (portfolio[stock.id].shares * portfolio[stock.id].averagePrice) + (amount * stockPrice);\n            portfolio[stock.id].shares = totalShares;\n            portfolio[stock.id].averagePrice = Math.round(totalValue / totalShares);\n        }\n\n        // Save updated portfolio\n        if (portfolioVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_portfolio',\n                value: JSON.stringify(portfolio),\n                gameServerId,\n                moduleId: mod.moduleId,\n                playerId: player.id\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n                value: JSON.stringify(portfolio)\n            });\n        }\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'BUY',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: totalCost,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully bought ${amount} shares of ${stock.id} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Total cost: $${totalCost}\\n`;\n        message += `Current portfolio: ${portfolio[stock.id].shares} shares of ${stock.id}`;\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in buystock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your purchase. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "buystock",
                    "description": null,
                    "trigger": "buystock",
                    "helpText": "Buy shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol ",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to buy",
                            "position": 1
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Handle the industry argument - use \"ALL\" as a special value to show all industries\n    const industryFilter = args.Industry ? args.Industry.toUpperCase() : \"ALL\";\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    // If market data doesn't exist, try to initialize it\n    if (marketDataVar.data.data.length === 0) {\n        const initialized = await initializeMarketIfNeeded(gameServerId, mod);\n        if (!initialized) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        // Get the freshly initialized market data\n        const refreshedMarketData = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (refreshedMarketData.data.data.length === 0) {\n            throw new TakaroUserError(\"There was an issue initializing the stock market. Please try again later.\");\n        }\n\n        // Continue with the refreshed data\n        await displayMarketSummary(player, gameServerId, mod, refreshedMarketData.data.data[0], industryFilter);\n    } else {\n        // Market data exists, display it\n        await displayMarketSummary(player, gameServerId, mod, marketDataVar.data.data[0], industryFilter);\n    }\n}\n\n// Display the market summary to the player\nasync function displayMarketSummary(player, gameServerId, mod, marketDataVariable, industryFilter) {\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Handle empty string or empty object\n            if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (e) {\n            // In case of parsing error\n            activeEvent = null;\n        }\n    }\n\n    const stocks = JSON.parse(marketDataVariable.value);\n\n    // Get all available industries for reference\n    const availableIndustries = [...new Set(stocks.map(stock => stock.sector))];\n\n    // If industry filter is provided and not \"ALL\", check if it's valid\n    if (industryFilter !== \"ALL\") {\n        // Check if the industry exists\n        const industryExists = availableIndustries.includes(industryFilter);\n\n        if (!industryExists) {\n            throw new TakaroUserError(`Industry \"${industryFilter}\" not found. Available industries: ${availableIndustries.join(', ')}\\nUse \"ALL\" to view all industries.`);\n        }\n    }\n\n    // Send header message\n    let headerMessage = \"=== STOCK MARKET SUMMARY ===\\n\";\n\n    // If filtering by industry, mention it in the header\n    if (industryFilter !== \"ALL\") {\n        headerMessage = `=== ${industryFilter} INDUSTRY ===\\n`;\n    }\n\n    // If there's an active event, include it in the header\n    if (activeEvent) {\n        headerMessage += `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n`;\n        headerMessage += `${activeEvent.description}\\n\\n`;\n\n        // If filtering by industry, only show relevant impacts\n        if (industryFilter !== \"ALL\") {\n            const relevantImpact = activeEvent.sectorImpacts.find(\n                impact => impact.sectorId === industryFilter\n            );\n\n            if (relevantImpact) {\n                const direction = relevantImpact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `Industry Impact: ${direction} ${Math.abs(relevantImpact.impact)}%\\n`;\n            } else {\n                headerMessage += \"This industry is not directly affected by the current event.\\n\";\n            }\n        } else {\n            // Show all industry impacts\n            headerMessage += \"Industry Impacts:\\n\";\n            for (const impact of activeEvent.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%\\n`;\n            }\n        }\n    }\n\n    // Send header message first\n    await player.pm(headerMessage);\n\n    // Group stocks by industry\n    const stocksByIndustry = {};\n    stocks.forEach(stock => {\n        if (!stocksByIndustry[stock.sector]) {\n            stocksByIndustry[stock.sector] = [];\n        }\n        stocksByIndustry[stock.sector].push(stock);\n    });\n\n    // If industry filter is not \"ALL\", only show that industry\n    if (industryFilter !== \"ALL\") {\n        const filteredStocks = stocksByIndustry[industryFilter] || [];\n\n        if (filteredStocks.length > 0) {\n            let stockMessage = \"\";\n\n            filteredStocks.forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                stockMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(stockMessage);\n        } else {\n            await player.pm(`No stocks found in the ${industryFilter} industry.`);\n        }\n    } else {\n        // Send each industry as a separate message\n        for (const industryId in stocksByIndustry) {\n            let industryMessage = `=== ${industryId} INDUSTRY ===\\n`;\n\n            stocksByIndustry[industryId].forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                industryMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(industryMessage);\n        }\n    }\n\n    // Add a help message for industry filtering if showing all industries\n    if (industryFilter === \"ALL\") {\n        const allIndustries = Object.keys(stocksByIndustry).join(', ');\n        await player.pm(`\\nTip: Use '/markets [industry]' to view only stocks in a specific industry. Available industries: ${allIndustries}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return false;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            const results = await Promise.allSettled(createPromises);\n            // Check if the critical stock_market_data was created successfully\n            const stockDataPromise = results[0];\n            if (stockDataPromise && stockDataPromise.status === 'rejected') {\n                console.log(`Failed to create stock_market_data: ${stockDataPromise.reason}`);\n                return false;\n            }\n        }\n\n        return true;\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n        return false;\n    }\n}\n\nawait main();",
                    "name": "markets",
                    "description": null,
                    "trigger": "markets",
                    "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. \n",
                    "arguments": [
                        {
                            "name": "Industry",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. ",
                            "position": 0
                        }
                    ]
                }
            ],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    try {\n        const { gameServerId, module: mod } = data;\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Check if market is initialized\n        if (marketDataVar.data.data.length === 0) {\n            console.log(\"Market data not found, initializing...\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return; // Exit after initialization\n        }\n\n        // Get active market event\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event start time\n        const eventStartTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_start_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event execution counter\n        const eventCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_execution_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event cooldown counter\n        const cooldownCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_cooldown_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let eventCounter = 0;\n        if (eventCounterVar.data.data.length > 0) {\n            eventCounter = parseInt(eventCounterVar.data.data[0].value, 10);\n            console.log(`Event counter: ${eventCounter}`);\n        }\n\n        let cooldownCounter = 0;\n        if (cooldownCounterVar.data.data.length > 0) {\n            cooldownCounter = parseInt(cooldownCounterVar.data.data[0].value, 10);\n            console.log(`Cooldown counter: ${cooldownCounter}`);\n        }\n\n        // Get event duration\n        const eventDurationVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['current_event_duration'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Use stored random duration if available, otherwise use defaultEventDuration\n        let eventDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        if (eventDurationVar.data.data.length > 0) {\n            eventDuration = parseInt(eventDurationVar.data.data[0].value, 10);\n            console.log(`Event duration: ${eventDuration}`);\n        }\n\n        let activeEvent = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                // If it's an empty string, treat as no active event\n                if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                    activeEvent = null;\n                }\n                console.log(`Active event: ${activeEvent ? activeEvent.name : 'None'}`);\n            } catch (e) {\n                // In case of parsing error, consider no active event\n                activeEvent = null;\n                console.log(`Error parsing active event: ${e.message}`);\n            }\n        }\n\n        // Check if the current event should end and increment counter\n        if (activeEvent) {\n            eventCounter++;\n            console.log(`Incremented event counter to: ${eventCounter}`);\n\n            if (eventCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: eventCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: eventCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n\n            if (eventCounter >= eventDuration) {\n                console.log(\"Event duration reached, ending event.\");\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: ''\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_cooldown_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    const message = `ðŸ“ˆ MARKET UPDATE ðŸ“‰\\n\\nThe \"${activeEvent.name}\" event has ended. Markets are returning to normal conditions.`;\n\n                    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                        message: message\n                    });\n                }\n\n                activeEvent = null;\n            }\n        } else {\n            cooldownCounter++;\n            console.log(`Incremented cooldown counter to: ${cooldownCounter}`);\n\n            if (cooldownCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: cooldownCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: cooldownCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n        }\n\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        const eventFrequency = (mod.userConfig && mod.userConfig.eventFrequency) || 10;\n        let shouldTriggerEvent = false;\n\n        if (!activeEvent && cooldownCounter >= eventFrequency) {\n            shouldTriggerEvent = Math.random() < 0.5;\n            if (cooldownCounter >= eventFrequency * 2) {\n                shouldTriggerEvent = true;\n            }\n            console.log(`Should trigger new event: ${shouldTriggerEvent}`);\n        }\n\n        if (shouldTriggerEvent) {\n            const events = (mod.userConfig && mod.userConfig.marketEvents) || [];\n            if (events.length > 0) {\n                const randomEvent = events[Math.floor(Math.random() * events.length)];\n                activeEvent = randomEvent;\n                console.log(`New event triggered: ${activeEvent.name}`);\n\n                const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n                const randomDuration = Math.floor(Math.random() * maxDuration) + 1;\n\n                if (eventDurationVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                        value: randomDuration.toString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'current_event_duration',\n                        value: randomDuration.toString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: JSON.stringify(activeEvent)\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'active_market_event',\n                        value: JSON.stringify(activeEvent),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventStartTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_start_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (lastEventTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'last_market_event_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    let impactText = \"\";\n                    for (const impact of activeEvent.sectorImpacts) {\n                        const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                        impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n                    }\n\n                    const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${activeEvent.name}\\n${activeEvent.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /market to see opportunities!`;\n\n                    const maxLength = 400;\n                    for (let i = 0; i < message.length; i += maxLength) {\n                        await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                            message: message.substring(i, i + maxLength)\n                        });\n                    }\n                }\n            }\n        }\n\n        // Get stocks\n        if (!marketDataVar.data.data[0] || !marketDataVar.data.data[0].value) {\n            console.log(\"Market data is empty or invalid after initial check, re-initializing.\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        let stocks;\n        try {\n            stocks = JSON.parse(marketDataVar.data.data[0].value);\n            if (!Array.isArray(stocks)) {\n                throw new Error(\"Parsed stocks data is not an array\");\n            }\n            // CRITICAL FIX: Ensure each stock has valid numerical price properties\n            stocks = stocks.map(s => {\n                const sanitizedPrice = typeof s.price === 'number' && s.price > 0 ? s.price : 1;\n                const sanitizedLastPrice = typeof s.lastPrice === 'number' && s.lastPrice > 0 ? s.lastPrice : sanitizedPrice;\n                return {\n                    ...s,\n                    price: sanitizedPrice,\n                    lastPrice: sanitizedLastPrice\n                };\n            });\n            console.log(\"Stocks loaded and sanitized successfully.\");\n            console.log(\"Initial stocks for this cycle:\");\n            stocks.forEach(s => console.log(`  ${s.id}: Price ${s.price}, LastPrice ${s.lastPrice}`));\n\n        } catch (e) {\n            console.log(`Error parsing or sanitizing stock data: ${e.message}`);\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        const significantChanges = [];\n\n        // Update each stock price\n        stocks.forEach(stock => {\n            // Always capture oldPrice at the very beginning of the iteration\n            const oldPrice = stock.price;\n            // Set lastPrice to the value before this current update cycle for accurate change tracking\n            stock.lastPrice = oldPrice;\n\n            console.log(`Processing stock: ${stock.id}, Old Price: ${oldPrice}`);\n\n            // Define the threshold for \"penny stock\" and the chance/magnitude of a breakout\n            const pennyStockThreshold = 1.9;\n            const breakoutChance = 0.6;\n\n            const targetMinPrice = 2.0;\n            const targetMaxPrice = 10.0;\n\n            let calculatedNewPrice;\n\n            // Check if it's a penny stock and qualifies for a breakout\n            if (oldPrice <= pennyStockThreshold && Math.random() < breakoutChance) {\n                console.log(`${stock.id} is a penny stock (${oldPrice}) and hit breakout chance!`);\n                calculatedNewPrice = targetMinPrice + Math.random() * (targetMaxPrice - targetMinPrice);\n                calculatedNewPrice = Math.max(calculatedNewPrice, oldPrice + 0.01); // Ensure at least a penny increase\n                console.log(`${stock.id} calculated breakout price: ${calculatedNewPrice}`);\n            } else {\n                const randomFactor = Math.random() * 2 - 1;\n                const totalChangePercent = randomFactor * stock.volatility;\n                calculatedNewPrice = oldPrice * (1 + totalChangePercent);\n                console.log(`${stock.id} calculated normal price: ${calculatedNewPrice} (Change: ${totalChangePercent * 100}%)`);\n            }\n\n            let finalPrice = calculatedNewPrice;\n            if (activeEvent) {\n                const sectorImpact = activeEvent.sectorImpacts.find(impact => impact.sectorId === stock.sector);\n                if (sectorImpact) {\n                    const eventImpactPercentage = sectorImpact.impact;\n                    const eventImpactDecimal = eventImpactPercentage / 100;\n                    const randomImpactFactor = 0.5 + Math.random();\n                    const eventImpact = eventImpactDecimal * randomImpactFactor;\n\n                    finalPrice = calculatedNewPrice * (1 + eventImpact);\n                    console.log(`${stock.id} final price after event impact: ${finalPrice} (Event impact: ${eventImpact * 100}%)`);\n                }\n            }\n\n            stock.price = finalPrice;\n\n            if (stock.price < 1) {\n                console.log(`${stock.id} price fell below 1, setting to 1.`);\n                stock.price = 1;\n            }\n\n            const actualPercentChange = ((stock.price - oldPrice) / oldPrice) * 100;\n            console.log(`${stock.id} - Final Price: ${stock.price.toFixed(2)}, Actual Change: ${actualPercentChange.toFixed(2)}%`);\n\n            const changeThreshold = ((mod.userConfig && mod.userConfig.priceAlertThreshold) || 10) / 100;\n            if (Math.abs(actualPercentChange) > changeThreshold * 100) {\n                significantChanges.push({\n                    ...stock,\n                    changePercent: actualPercentChange\n                });\n            }\n        });\n\n        console.log(\"All stocks processed, saving updated prices...\");\n        await takaro.variable.variableControllerUpdate(marketDataVar.data.data[0].id, {\n            value: JSON.stringify(stocks)\n        });\n        console.log(\"Updated prices saved.\");\n\n        if (significantChanges.length > 0) {\n            console.log(\"Significant changes detected, sending alert.\");\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                significantChanges.sort((a, b) => Math.abs(b.changePercent) - Math.abs(a.changePercent));\n                const topChanges = significantChanges.slice(0, Math.min(3, significantChanges.length));\n\n                let message = \"ðŸ“Š STOCK MARKET ALERT ðŸ“Š\\n\";\n                topChanges.forEach(stock => {\n                    const changeDir = stock.changePercent > 0 ? \"up\" : \"down\";\n                    const displayPrice = stock.price.toFixed(2);\n                    const changePercent = Math.abs(Math.round(stock.changePercent));\n\n                    message += `${stock.id} (${stock.sector}): ${changeDir} ${changePercent}% to $${displayPrice}!\\n`;\n                });\n\n                if (activeEvent) {\n                    message += `\\nCurrent market event: ${activeEvent.name}`;\n                }\n\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            } else {\n                console.log(\"No online players to send alert to.\");\n            }\n        } else {\n            console.log(\"No significant changes to alert players about.\");\n        }\n    } catch (error) {\n        console.log(`FATAL Error in updateStockPrices: ${error.message}`);\n        // Optionally, send an admin message if a fatal error occurs\n        // await takaro.gameserver.gameServerControllerSendMessage(data.gameServerId, {\n        //     message: `ðŸš¨ Market Error: An error occurred during stock update: ${error.message}`\n        // });\n    }\n}\n\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        console.log(\"Initializing market if needed...\");\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in module configuration for initialization.\");\n            return;\n        }\n\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_data'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['last_market_event_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_start_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['active_market_event'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_initialized'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_execution_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_cooldown_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['current_event_duration'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } })\n            ]);\n\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n        console.log(\"Mapped initial stocks from config.\");\n\n        const createPromises = [];\n\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_data', value: JSON.stringify(stocks), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'last_market_event_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_start_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'active_market_event', value: '', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_execution_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (cooldownCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_cooldown_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventDurationVar.data.data.length === 0) {\n            const defaultDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'current_event_duration', value: defaultDuration.toString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_initialized', value: 'true', gameServerId, moduleId: mod.moduleId }));\n        }\n\n        if (createPromises.length > 0) {\n            console.log(`Creating ${createPromises.length} initial market variables.`);\n            await Promise.allSettled(createPromises);\n        } else {\n            console.log(\"All market variables already exist, no new initialization needed.\");\n        }\n\n        if (marketDataVar.data.data.length === 0) { // Only announce if we actually created the stock_market_data variable\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /market to see available stocks and /buy to start investing.\";\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, { message });\n            }\n        }\n        console.log(\"Market initialization process complete.\");\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "updatestockprices",
                    "description": null,
                    "temporalValue": "0 */1 * * *"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n\n    const discordChannelId = mod.userConfig.marketNewsChannelId;\n\n    if (!discordChannelId) {\n        takaro.log.info('Market news Discord channel ID (marketNewsChannelId) not configured in module settings. Skipping Discord messages.');\n    }\n\n    const currentPlayers = (await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    })).data.meta;\n\n    if (currentPlayers.total === 0) {\n        takaro.log.info('Skipping daily market report: No players online.');\n        return;\n    }\n\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        takaro.log.warn('Skipping daily market report: Market data variable not found.');\n        return;\n    }\n\n    let stocks;\n    try {\n        stocks = JSON.parse(marketDataVar.data.data[0].value);\n        if (!Array.isArray(stocks)) {\n            throw new Error('Parsed market data is not an array.');\n        }\n    } catch (error) {\n        takaro.log.error(`Failed to parse stock_market_data: ${error}`);\n        return;\n    }\n\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            if (typeof activeEvent !== 'object' || activeEvent === null || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (error) {\n            takaro.log.warn(`Failed to parse active_market_event: ${error}`);\n            activeEvent = null;\n        }\n    }\n\n    let gameMessage1 = \"==== DAILY MARKET REPORT ====\\n\";\n\n    if (activeEvent && activeEvent.name && activeEvent.description) {\n        const eventText = `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n${activeEvent.description}\\n`;\n        gameMessage1 += eventText;\n    } else {\n        const noEventText = '\\nNo active market events today.\\n';\n        gameMessage1 += noEventText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage1\n    }).catch(err => takaro.log.error(`Failed to send game message 1: ${err}`));\n\n    const stocksWithPerformance = stocks.map(stock => {\n        let change = 0;\n        let percentChange = 0;\n        let changeSymbol = 'â†’';\n\n        if (typeof stock.price === 'number' && typeof stock.lastPrice === 'number' && stock.lastPrice !== 0) {\n            change = stock.price - stock.lastPrice;\n            percentChange = (change / stock.lastPrice) * 100;\n            if (percentChange > 0.05) {\n                changeSymbol = 'â†‘';\n            } else if (percentChange < -0.05) {\n                changeSymbol = 'â†“';\n            }\n        } else if (typeof stock.price === 'number' && stock.lastPrice === undefined) {\n            changeSymbol = 'ðŸ†•';\n            percentChange = 0;\n        }\n        return {\n            ...stock,\n            change,\n            percentChange,\n            changeSymbol\n        };\n    });\n\n    const sectorPerformance = {};\n    stocksWithPerformance.forEach(stock => {\n        const sectorId = stock.sector || 'Uncategorized';\n        if (!sectorPerformance[sectorId]) {\n            sectorPerformance[sectorId] = {\n                stocks: [],\n                totalPercentChange: 0,\n                count: 0\n            };\n        }\n        sectorPerformance[sectorId].stocks.push(stock);\n        if (typeof stock.percentChange === 'number' && isFinite(stock.percentChange)) {\n            sectorPerformance[sectorId].totalPercentChange += stock.percentChange;\n            sectorPerformance[sectorId].count++;\n        }\n    });\n\n    for (const sectorId in sectorPerformance) {\n        const sectorData = sectorPerformance[sectorId];\n        if (sectorData.count > 0) {\n            sectorData.avgPerformance = sectorData.totalPercentChange / sectorData.count;\n        } else {\n            sectorData.avgPerformance = 0;\n        }\n    }\n\n    const sortedSectors = Object.entries(sectorPerformance)\n        .sort(([, a], [, b]) => b.avgPerformance - a.avgPerformance);\n\n    let gameMessage2 = \"\\n=== SECTOR PERFORMANCE ===\\n\";\n\n    if (sortedSectors.length > 0) {\n        sortedSectors.forEach(([sectorId, sectorData]) => {\n            const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n            let line = `${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n\n            if (sectorData.avgPerformance > 0.05) {\n                line = `[70FE02]${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%[-]\\n`;\n            } else if (sectorData.avgPerformance < -0.05) {\n                line = `[FF0001]${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%[-]\\n`;\n            }\n            gameMessage2 += line;\n        });\n    } else {\n        const noDataText = \"No sector performance data available.\\n\";\n        gameMessage2 += noDataText;\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage2\n    }).catch(err => takaro.log.error(`Failed to send game message 2: ${err}`));\n\n    const validPerformers = stocksWithPerformance.filter(s => typeof s.percentChange === 'number' && isFinite(s.percentChange));\n    validPerformers.sort((a, b) => b.percentChange - a.percentChange);\n\n    let gameMessage3 = \"\";\n\n    const topPerformersTitleGame = \"\\nðŸ”¥ TOP PERFORMERS ðŸ”¥\\n\";\n    gameMessage3 += topPerformersTitleGame;\n\n    if (validPerformers.length > 0) {\n        for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n            const stock = validPerformers[i];\n            gameMessage3 += `[70FE02]${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%[-]\\n`;\n        }\n    } else {\n        gameMessage3 += \"No top performers today.\\n\";\n    }\n\n    const worstPerformersTitleGame = \"\\nðŸ“‰ WORST PERFORMERS ðŸ“‰\\n\";\n    gameMessage3 += worstPerformersTitleGame;\n\n    if (validPerformers.length > 0) {\n        const worstStartIndex = Math.max(0, validPerformers.length - 3);\n        for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n            const stock = validPerformers[i];\n            gameMessage3 += `[FF0001]${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%[-]\\n`;\n        }\n    } else {\n        gameMessage3 += \"No worst performers today.\\n\";\n    }\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage3\n    }).catch(err => takaro.log.error(`Failed to send game message 3: ${err}`));\n\n    // Helper functions (omitted for brevity, they are unchanged)\n    function hslToRgb(h, s, l) { let a = s * Math.min(l, 1 - l); let f = n => { let k = (n + h / 30) % 12; return l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1)); }; return [Math.round(255 * f(0)), Math.round(255 * f(8)), Math.round(255 * f(4))]; }\n    function rgbToHex(r, g, b) { return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase(); }\n    function stringToHexColor(str) { let hash = 0; for (let i = 0; i < str.length; i++) { hash = str.charCodeAt(i) + ((hash << 5) - hash); } hash = Math.abs(hash); const hue = (hash * 137.508) % 360; const [r, g, b] = hslToRgb(hue, 0.9, 0.7); return rgbToHex(r, g, b); }\n\n    const stockColors = {};\n    stocksWithPerformance.forEach(stock => {\n        stockColors[stock.id] = stringToHexColor(stock.name);\n    });\n\n    // --- MODIFICATION START: Send each sector's stock listings in CHUNKED messages (Game Server Only) ---\n    const stocksBySectorGame = {};\n    stocksWithPerformance.forEach(stock => {\n        const sector = stock.sector || 'Uncategorized';\n        if (!stocksBySectorGame[sector]) {\n            stocksBySectorGame[sector] = [];\n        }\n        stocksBySectorGame[sector].push(stock);\n    });\n\n    const chunkSize = 3;\n    for (const [sector, sectorStocks] of Object.entries(stocksBySectorGame)) {\n        for (let i = 0; i < sectorStocks.length; i += chunkSize) {\n            const chunk = sectorStocks.slice(i, i + chunkSize);\n            // Add the sector header only to the first message for that sector.\n            let sectorMessage = (i === 0) ? `\\n--- ${sector} SECTOR ---\\n` : '';\n\n            chunk.forEach(stock => {\n                let changeText = '';\n                let priceColorPrefix = '', priceColorSuffix = '';\n\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeText = ` ${stock.changeSymbol} ${Math.abs(percentChange).toFixed(1)}%`;\n                    if (percentChange > 0) {\n                        priceColorPrefix = '[70FE02]';\n                        priceColorSuffix = '[-]';\n                    } else if (percentChange < 0) {\n                        priceColorPrefix = '[FF0001]';\n                        priceColorSuffix = '[-]';\n                    }\n                }\n\n                const stockNameColorPrefix = stockColors[stock.id] ? `[${stockColors[stock.id]}]` : '';\n                const stockNameColorSuffix = stockColors[stock.id] ? '[-]' : '';\n\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                sectorMessage += `${stockNameColorPrefix}${stock.name} (${stock.id})${stockNameColorSuffix} (${riskIndicator}): ${priceColorPrefix}$${Math.round(stock.price)}${changeText}${priceColorSuffix}\\n`;\n            });\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message: sectorMessage\n            }).catch(err => takaro.log.error(`Failed to send game message for sector ${sector}: ${err}`));\n        }\n    }\n    // --- MODIFICATION END ---\n\n    // Send the legend for risk indicators as a separate message\n    const legendMessage = \"\\n=== LEGEND ===\\n\" +\n        \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\";\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: legendMessage\n    }).catch(err => takaro.log.error(`Failed to send game legend message: ${err}`));\n\n\n    // --- UNCHANGED Discord Message: Consolidated Market Report ---\n    if (discordChannelId) {\n        let discordMessage = \"**==== DAILY MARKET REPORT ====**\\n\\n\";\n\n        if (activeEvent && activeEvent.name && activeEvent.description) {\n            discordMessage += `ðŸŒ **ACTIVE EVENT: ${activeEvent.name}** ðŸŒ\\n${activeEvent.description}\\n\\n`;\n        } else {\n            discordMessage += 'No active market events today.\\n\\n';\n        }\n\n        discordMessage += \"**=== SECTOR PERFORMANCE ===**\\n\";\n        if (sortedSectors.length > 0) {\n            sortedSectors.forEach(([sectorId, sectorData]) => {\n                const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n                discordMessage += `${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n            });\n        } else {\n            discordMessage += \"No sector performance data available.\\n\";\n        }\n        discordMessage += \"\\n\";\n\n        discordMessage += \"**ðŸ”¥ TOP PERFORMERS ðŸ”¥**\\n\";\n        if (validPerformers.length > 0) {\n            for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n                const stock = validPerformers[i];\n                const line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n                discordMessage += line;\n            }\n        } else {\n            discordMessage += \"No top performers today.\\n\";\n        }\n        discordMessage += \"\\n\";\n\n        discordMessage += \"**ðŸ“‰ WORST PERFORMERS ðŸ“‰**\\n\";\n        if (validPerformers.length > 0) {\n            const worstStartIndex = Math.max(0, validPerformers.length - 3);\n            for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n                const stock = validPerformers[i];\n                const line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n                discordMessage += line;\n            }\n        } else {\n            discordMessage += \"No worst performers today.\\n\";\n        }\n        discordMessage += \"\\n\";\n\n        discordMessage += \"**=== ALL STOCK LISTINGS ===**\\n\";\n        const stocksBySector = {};\n        stocksWithPerformance.forEach(stock => {\n            const sector = stock.sector || 'Uncategorized';\n            if (!stocksBySector[sector]) {\n                stocksBySector[sector] = [];\n            }\n            stocksBySector[sector].push(stock);\n        });\n\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            discordMessage += `\\n--- **${sector} SECTOR** ---\\n`;\n            sectorStocks.forEach(stock => {\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeText = ` ${stock.changeSymbol} ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                discordMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n        }\n\n        discordMessage += \"\\n**=== LEGEND ===**\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\";\n\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessage\n        }).catch(err => takaro.log.error(`Failed to send consolidated Discord message: ${err.message || err}`));\n    }\n\n    takaro.log.info('Daily market report sent successfully (game server and potentially Discord).');\n}\n\nawait main();",
                    "name": "marketnews",
                    "description": null,
                    "temporalValue": "1 */1 * * *"
                }
            ],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Allows the player to view market prices and their portfolio",
                    "permission": "STOCK_MARKET_USE",
                    "friendlyName": "Use Stock Market"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows the player to buy and sell stocks",
                    "permission": "STOCK_MARKET_TRADE",
                    "friendlyName": "Trade Stocks"
                },
                {
                    "canHaveCount": false,
                    "description": "VIP status that reduces transaction fees",
                    "permission": "STOCK_MARKET_BROKER",
                    "friendlyName": "Stock Broker"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows admins to manually trigger market events",
                    "permission": "STOCK_MARKET_TRIGGER_EVENT",
                    "friendlyName": "Trigger Market Events"
                }
            ]
        },
        {
            "tag": "0.1.0",
            "description": "**Stock Market: A Dynamic Virtual Trading System**\n\nCreate an immersive economic experience with this comprehensive stock market module that lets players invest, trade, and react to market events.\n\n**Market Features:**\n\n![Market Summary](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stocks.png)\n\n* **Multiple Economic Sectors:** Configure various industry sectors (Resource Extraction, Manufacturing, Defense, etc.) each with their own market dynamics.\n* **Realistic Stock Behavior:** Stocks have configurable volatility, sector-based pricing, and react differently to market events.\n* **Dynamic Market Events:** Random or admin-triggered events like \"Horde Night Approaching\" or \"Societal Collapse Setback\" impact different sectors in realistic ways.\n\n![Market Events](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_events.png)\n\n**Trading System:**\n\n* **Buy & Sell Shares:** Players can purchase stocks and sell them later for profit or loss.\n* **Transaction Fees:** Configurable fee percentage on all trades creates a realistic market economy.\n* **VIP Benefits:** Special permissions for designated \"Stock Brokers\" who receive fee discounts.\n\n![Buy Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_buy.png)\n\nPlayers can track price changes and sell at the right moment to maximize profits or minimize losses.\n\n![Sell Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sell.png)\n\n**Player Portfolio:**\n\n* **Portfolio Tracking:** Players can view their holdings, average purchase prices, and current profit/loss.\n* **Transaction History:** System tracks all buy/sell transactions for each player.\n* **Summary Statistics:** See overall portfolio performance and value across all holdings.\n\n![Portfolio View](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockportfolio.png)\n\n**Market Information:**\n\n* **Detailed Stock Info:** Players can research specific stocks, including risk levels and sector trends.\n* **Industry Filters:** View stocks by specific sectors to better understand market segments.\n* **Market Alerts:** Server-wide notifications for significant price changes keep players engaged.\n\n![Market Alerts](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockpricechange.png)\n\n**Configuration Options:**\n\n* **Sectors & Stocks:** Define your own market sectors and individual stocks with customizable starting prices and volatility.\n* **Market Events:** Create unique events with specific sector impacts to drive market dynamics.\n* **Transaction Settings:** Configure fee percentages, VIP discounts, and alert thresholds.\n* **Event Frequency:** Control how often random market events occur and how long they last.\n\n![Configuration](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_config.png)\n![Sectors](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sectors.png)\n\n**Commands:**\n\n* `/markets [industry]` - View all stocks or filter by industry\n* `/stockinfo [ticker]` - Get detailed information about a specific stock\n* `/buystock <ticker> <amount>` - Purchase shares of a stock\n* `/sellstock <ticker> <amount>` - Sell shares from your portfolio\n* `/stockportfolio` - View your current holdings and performance\n* `/triggerevent [event]` - Admin command to trigger specific market events\n\nWho says the apocalypse can't have a thriving economy? Now players can stress about both zombie hordes AND their Duke's Casino Tokens dropping 40% after a market event! As one trader put it: \"I used to check my 401K daily, and now I check my AMMO stock before every Blood Moon. Some habits die harder than zombies.\"",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sectors\":{\"type\":\"array\",\"title\":\"Wasteland Economic Sectors\",\"description\":\"Define economic sectors relevant to survival in Navezgane\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Sector ID (e.g., RESOURCES)\"},\"name\":{\"type\":\"string\",\"description\":\"Sector name (e.g., Resource Extraction)\"}}},\"default\":[{\"id\":\"RESOURCES\",\"name\":\"Resource Extraction\"},{\"id\":\"MANUFACTURING\",\"name\":\"Manufacturing & Crafting\"},{\"id\":\"DEFENSE\",\"name\":\"Defense & Fortifications\"},{\"id\":\"SURVIVAL\",\"name\":\"Survival Goods\"},{\"id\":\"TRADE\",\"name\":\"Trade & Currency\"}]},\"stocks\":{\"type\":\"array\",\"title\":\"Wasteland Stocks\",\"description\":\"List of stocks representing Navezgane entities and resources\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Stock ticker symbol (e.g., NMC)\"},\"name\":{\"type\":\"string\",\"description\":\"Entity/Resource name\"},\"sector\":{\"type\":\"string\",\"description\":\"Sector ID this stock belongs to\"},\"initialPrice\":{\"type\":\"number\",\"description\":\"Starting price in Dukes\",\"minimum\":1},\"volatility\":{\"type\":\"number\",\"description\":\"Base volatility percentage (5 = 5%)\",\"minimum\":1,\"maximum\":35}}},\"default\":[{\"id\":\"NMC\",\"name\":\"Navezgane Mining Co.\",\"sector\":\"RESOURCES\",\"initialPrice\":50,\"volatility\":15},{\"id\":\"WOOD\",\"name\":\"Wasteland Lumberjacks\",\"sector\":\"RESOURCES\",\"initialPrice\":20,\"volatility\":8},{\"id\":\"SHALE\",\"name\":\"Oil Shale Extractors\",\"sector\":\"RESOURCES\",\"initialPrice\":40,\"volatility\":18},{\"id\":\"FORGE\",\"name\":\"Forge Ahead Metals\",\"sector\":\"MANUFACTURING\",\"initialPrice\":75,\"volatility\":12},{\"id\":\"TOOLS\",\"name\":\"Working Stiff Tools\",\"sector\":\"MANUFACTURING\",\"initialPrice\":60,\"volatility\":10},{\"id\":\"MECH\",\"name\":\"JunkTech Robotics\",\"sector\":\"MANUFACTURING\",\"initialPrice\":110,\"volatility\":20},{\"id\":\"BUILD\",\"name\":\"Barricade Builders\",\"sector\":\"DEFENSE\",\"initialPrice\":45,\"volatility\":9},{\"id\":\"AMMO\",\"name\":\"AmmoNation Surplus\",\"sector\":\"DEFENSE\",\"initialPrice\":90,\"volatility\":25},{\"id\":\"SHAM\",\"name\":\"Shamway Foods\",\"sector\":\"SURVIVAL\",\"initialPrice\":30,\"volatility\":5},{\"id\":\"MEDS\",\"name\":\"Pop-N-Pills Medical\",\"sector\":\"SURVIVAL\",\"initialPrice\":100,\"volatility\":18},{\"id\":\"TRADE\",\"name\":\"Trader Guild Network\",\"sector\":\"TRADE\",\"initialPrice\":150,\"volatility\":10},{\"id\":\"DUKES\",\"name\":\"Duke's Casino Tokens\",\"sector\":\"TRADE\",\"initialPrice\":1,\"volatility\":3}]},\"marketEvents\":{\"type\":\"array\",\"title\":\"Wasteland Events\",\"description\":\"Events impacting the Navezgane economy\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Unique event ID\"},\"name\":{\"type\":\"string\",\"description\":\"Name of the event\"},\"description\":{\"type\":\"string\",\"description\":\"Description of the event's market effect\"},\"sectorImpacts\":{\"type\":\"array\",\"description\":\"How each sector is affected\",\"items\":{\"type\":\"object\",\"properties\":{\"sectorId\":{\"type\":\"string\",\"description\":\"Sector ID\"},\"impact\":{\"type\":\"number\",\"description\":\"Percentage impact (-30 = -30%)\",\"minimum\":-75,\"maximum\":75}}}}}},\"default\":[{\"id\":\"HORDE_INCOMING\",\"name\":\"Horde Night Approaching\",\"description\":\"Increased Zed activity signals the Blood Moon. Survivors prepare defenses.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-15},{\"sectorId\":\"MANUFACTURING\",\"impact\":20},{\"sectorId\":\"DEFENSE\",\"impact\":35},{\"sectorId\":\"SURVIVAL\",\"impact\":5},{\"sectorId\":\"TRADE\",\"impact\":-10}]},{\"id\":\"RESOURCE_SCARCITY\",\"name\":\"Resource Scarcity\",\"description\":\"Key resource veins are depleted, making raw materials harder to find.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-40},{\"sectorId\":\"MANUFACTURING\",\"impact\":-25},{\"sectorId\":\"DEFENSE\",\"impact\":-10},{\"sectorId\":\"SURVIVAL\",\"impact\":0},{\"sectorId\":\"TRADE\",\"impact\":5}]},{\"id\":\"ZED_OUTBREAK\",\"name\":\"Severe Zed Outbreak\",\"description\":\"An unusual concentration of Zed activity makes scavenging and travel extremely dangerous.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-30},{\"sectorId\":\"MANUFACTURING\",\"impact\":-10},{\"sectorId\":\"DEFENSE\",\"impact\":15},{\"sectorId\":\"SURVIVAL\",\"impact\":25},{\"sectorId\":\"TRADE\",\"impact\":-20}]},{\"id\":\"TRADE_ROUTE_SECURED\",\"name\":\"Trade Route Secured\",\"description\":\"Traders have established a safer passage, improving the flow of goods.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":5},{\"sectorId\":\"MANUFACTURING\",\"impact\":10},{\"sectorId\":\"DEFENSE\",\"impact\":0},{\"sectorId\":\"SURVIVAL\",\"impact\":15},{\"sectorId\":\"TRADE\",\"impact\":30}]},{\"id\":\"GENERAL_COLLAPSE\",\"name\":\"Societal Collapse Setback\",\"description\":\"A major setback reminds everyone how fragile survival is. Fear grips the market.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-25},{\"sectorId\":\"MANUFACTURING\",\"impact\":-30},{\"sectorId\":\"DEFENSE\",\"impact\":-15},{\"sectorId\":\"SURVIVAL\",\"impact\":-10},{\"sectorId\":\"TRADE\",\"impact\":-40}]}]},\"eventFrequency\":{\"title\":\"Event Frequency\",\"type\":\"number\",\"description\":\"Average number of update cycles between market events (0 to disable). Depends on mod's update frequency (e.g., per in-game hour?).\",\"default\":8,\"minimum\":1},\"defaultEventDuration\":{\"title\":\"Default Event Duration\",\"type\":\"number\",\"description\":\"Default number of update cycles an event lasts.\",\"default\":3,\"minimum\":1,\"maximum\":96},\"transactionFee\":{\"title\":\"Transaction Fee (Dukes Tax)\",\"type\":\"number\",\"description\":\"Percentage fee charged on all buy/sell transactions (5 = 5%)\",\"default\":3,\"minimum\":0,\"maximum\":25},\"vipDiscount\":{\"title\":\"Trader's Favor Discount\",\"type\":\"number\",\"description\":\"Percentage discount on transaction fees for players with 'STOCK_MARKET_BROKER' permission (50 = 50%)\",\"default\":50,\"minimum\":0,\"maximum\":100},\"priceAlertThreshold\":{\"title\":\"Price Alert Threshold\",\"type\":\"number\",\"description\":\"Percentage change that triggers a market alert (15 = 15%)\",\"default\":15,\"minimum\":5,\"maximum\":50}},\"additionalProperties\":false}",
            "uiSchema": "{\"sectors\":{\"items\":{\"ui:order\":[\"id\",\"name\"]}},\"stocks\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"sector\",\"initialPrice\",\"volatility\"]}},\"marketEvents\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"description\",\"sectorImpacts\"],\"sectorImpacts\":{\"items\":{\"ui:order\":[\"sectorId\",\"impact\"]}}}},\"transactionFee\":{\"ui:widget\":\"range\"},\"vipDiscount\":{\"ui:widget\":\"range\"},\"eventFrequency\":{\"ui:help\":\"Set to 0 to disable random events\"},\"priceAlertThreshold\":{\"ui:widget\":\"range\"}}",
            "commands": [
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get player's portfolio\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        if (portfolioVar.data.data.length === 0) {\n            throw new TakaroUserError(\"You don't own any stocks to sell.\");\n        }\n\n        const portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        const stockId = args.stock.toUpperCase();\n\n        if (!portfolio[stockId] || portfolio[stockId].shares < amount) {\n            throw new TakaroUserError(`You don't own ${amount} shares of ${stockId}.`);\n        }\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === stockId);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${stockId} not found in current market data. Please contact an admin.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate sale proceeds using Math.round to ensure we work with integers\n        const stockPrice = Math.round(stock.price);\n        const subtotal = stockPrice * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const netProceeds = subtotal - fee;\n\n        // Add money to player - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerAddCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: netProceeds\n            }\n        );\n\n        // Calculate profit/loss\n        const profitPerShare = stockPrice - portfolio[stockId].averagePrice;\n        const totalProfit = Math.round(profitPerShare * amount);\n        const profitText = totalProfit >= 0\n            ? `profit of $${totalProfit}`\n            : `loss of $${Math.abs(totalProfit)}`;\n\n        // Update portfolio\n        portfolio[stockId].shares -= amount;\n        if (portfolio[stockId].shares === 0) {\n            delete portfolio[stockId];\n        }\n\n        // Save updated portfolio\n        await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n            value: JSON.stringify(portfolio)\n        });\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'SELL',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: netProceeds,\n            profit: totalProfit,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully sold ${amount} shares of ${stockId} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Net proceeds: $${netProceeds} (${profitText})`;\n\n        // Add remaining shares info if player still has some\n        if (portfolio[stockId]) {\n            message += `\\nRemaining shares: ${portfolio[stockId].shares}`;\n        } else {\n            message += `\\nYou've sold all your ${stockId} shares.`;\n        }\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in sellstock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your sale. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "sellstock",
                    "description": null,
                    "trigger": "sellstock",
                    "helpText": "Sell shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to sell",
                            "position": 1
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === args.stock.toUpperCase());\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${args.stock} not found. Use /market to see available stocks.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate costs using Math.round to ensure we work with integers\n        const subtotal = Math.round(stock.price) * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const totalCost = subtotal + fee;\n\n        // Check if player has enough currency\n        const playerData = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, player.id);\n        const currentBalance = playerData.data.data.currency;\n\n        if (currentBalance < totalCost) {\n            throw new TakaroUserError(`You don't have enough currency. Cost: $${subtotal} + $${fee} fee = $${totalCost}. Your balance: $${currentBalance}`);\n        }\n\n        // Deduct the currency - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerDeductCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: totalCost\n            }\n        );\n\n        // Get player's portfolio or create new one\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        let portfolio;\n        if (portfolioVar.data.data.length === 0) {\n            portfolio = {};\n        } else {\n            portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        }\n\n        // Update portfolio using rounded values for consistency\n        const stockPrice = Math.round(stock.price);\n        if (!portfolio[stock.id]) {\n            portfolio[stock.id] = {\n                shares: amount,\n                averagePrice: stockPrice\n            };\n        } else {\n            const totalShares = portfolio[stock.id].shares + amount;\n            const totalValue = (portfolio[stock.id].shares * portfolio[stock.id].averagePrice) + (amount * stockPrice);\n            portfolio[stock.id].shares = totalShares;\n            portfolio[stock.id].averagePrice = Math.round(totalValue / totalShares);\n        }\n\n        // Save updated portfolio\n        if (portfolioVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_portfolio',\n                value: JSON.stringify(portfolio),\n                gameServerId,\n                moduleId: mod.moduleId,\n                playerId: player.id\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n                value: JSON.stringify(portfolio)\n            });\n        }\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'BUY',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: totalCost,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully bought ${amount} shares of ${stock.id} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Total cost: $${totalCost}\\n`;\n        message += `Current portfolio: ${portfolio[stock.id].shares} shares of ${stock.id}`;\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in buystock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your purchase. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "buystock",
                    "description": null,
                    "trigger": "buystock",
                    "helpText": "Buy shares of a stock",
                    "arguments": [
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to buy",
                            "position": 1
                        },
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol ",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // Get player's portfolio\n    const portfolioVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_portfolio'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId],\n            playerId: [player.id]\n        }\n    });\n\n    let portfolio = {};\n    if (portfolioVar.data.data.length > 0) {\n        portfolio = JSON.parse(portfolioVar.data.data[0].value);\n    }\n\n    // Send header\n    await player.pm(\"=== YOUR STOCK PORTFOLIO ===\");\n\n    let hasStocks = false;\n    let totalValue = 0;\n    let totalInvestment = 0;\n\n    // If no stocks, send a simple message\n    if (Object.keys(portfolio).length === 0) {\n        await player.pm(\"You don't own any stocks yet.\\n\" +\n            \"Use /markets to see available stocks and prices.\\n\" +\n            \"Use /buy <stock> <amount> to purchase stocks.\");\n        return;\n    }\n\n    // Send each stock as a separate message to avoid length issues\n    for (const [stockId, data] of Object.entries(portfolio)) {\n        hasStocks = true;\n        const stock = stocks.find(s => s.id === stockId);\n        if (!stock) continue; // Stock might have been removed from config\n\n        const currentValue = stock.price * data.shares;\n        const investmentValue = data.averagePrice * data.shares;\n        totalValue += currentValue;\n        totalInvestment += investmentValue;\n        const profit = currentValue - investmentValue;\n        const profitPercent = ((profit / investmentValue) * 100).toFixed(1);\n\n        let stockMessage = `--- ${stockId} (${stock.sector}) ---\\n`;\n        stockMessage += `Shares: ${data.shares}\\n`;\n        stockMessage += `Avg buy: $${Math.round(data.averagePrice)}\\n`;\n        stockMessage += `Current price: $${Math.round(stock.price)}\\n`;\n        stockMessage += `Total value: $${Math.round(currentValue)}\\n`;\n\n        if (profit >= 0) {\n            stockMessage += `Profit: +$${Math.round(profit)} (+${profitPercent}%)\\n`;\n        } else {\n            stockMessage += `Loss: -$${Math.abs(Math.round(profit))} (${profitPercent}%)\\n`;\n        }\n\n        await player.pm(stockMessage);\n    }\n\n    if (hasStocks) {\n        const totalProfit = totalValue - totalInvestment;\n        const totalProfitPercent = ((totalProfit / totalInvestment) * 100).toFixed(1);\n\n        let summaryMessage = \"=== PORTFOLIO SUMMARY ===\\n\";\n        summaryMessage += `Total investment: $${Math.round(totalInvestment)}\\n`;\n        summaryMessage += `Current value: $${Math.round(totalValue)}\\n`;\n\n        if (totalProfit >= 0) {\n            summaryMessage += `Overall profit: +$${Math.round(totalProfit)} (+${totalProfitPercent}%)\\n`;\n        } else {\n            summaryMessage += `Overall loss: -$${Math.abs(Math.round(totalProfit))} (${totalProfitPercent}%)\\n`;\n        }\n\n        // Get transaction history count\n        try {\n            const historyVar = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: ['stock_transaction_history'],\n                    gameServerId: [gameServerId],\n                    moduleId: [mod.moduleId],\n                    playerId: [player.id]\n                }\n            });\n\n            if (historyVar.data.data.length > 0) {\n                const history = JSON.parse(historyVar.data.data[0].value);\n                const buyCount = history.filter(t => t.type === 'BUY').length;\n                const sellCount = history.filter(t => t.type === 'SELL').length;\n\n                summaryMessage += `\\nTransactions: ${history.length} (${buyCount} buys, ${sellCount} sells)\\n`;\n            }\n        } catch (error) {\n            // Just ignore history errors\n        }\n\n        await player.pm(summaryMessage);\n\n    }\n}\n\nawait main();",
                    "name": "stockportfolio",
                    "description": null,
                    "trigger": "stockportfolio",
                    "helpText": "No help text available",
                    "arguments": []
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Handle the industry argument - use \"ALL\" as a special value to show all industries\n    const industryFilter = args.Industry ? args.Industry.toUpperCase() : \"ALL\";\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    // If market data doesn't exist, try to initialize it\n    if (marketDataVar.data.data.length === 0) {\n        const initialized = await initializeMarketIfNeeded(gameServerId, mod);\n        if (!initialized) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        // Get the freshly initialized market data\n        const refreshedMarketData = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (refreshedMarketData.data.data.length === 0) {\n            throw new TakaroUserError(\"There was an issue initializing the stock market. Please try again later.\");\n        }\n\n        // Continue with the refreshed data\n        await displayMarketSummary(player, gameServerId, mod, refreshedMarketData.data.data[0], industryFilter);\n    } else {\n        // Market data exists, display it\n        await displayMarketSummary(player, gameServerId, mod, marketDataVar.data.data[0], industryFilter);\n    }\n}\n\n// Display the market summary to the player\nasync function displayMarketSummary(player, gameServerId, mod, marketDataVariable, industryFilter) {\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Handle empty string or empty object\n            if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (e) {\n            // In case of parsing error\n            activeEvent = null;\n        }\n    }\n\n    const stocks = JSON.parse(marketDataVariable.value);\n\n    // Get all available industries for reference\n    const availableIndustries = [...new Set(stocks.map(stock => stock.sector))];\n\n    // If industry filter is provided and not \"ALL\", check if it's valid\n    if (industryFilter !== \"ALL\") {\n        // Check if the industry exists\n        const industryExists = availableIndustries.includes(industryFilter);\n\n        if (!industryExists) {\n            throw new TakaroUserError(`Industry \"${industryFilter}\" not found. Available industries: ${availableIndustries.join(', ')}\\nUse \"ALL\" to view all industries.`);\n        }\n    }\n\n    // Send header message\n    let headerMessage = \"=== STOCK MARKET SUMMARY ===\\n\";\n\n    // If filtering by industry, mention it in the header\n    if (industryFilter !== \"ALL\") {\n        headerMessage = `=== ${industryFilter} INDUSTRY ===\\n`;\n    }\n\n    // If there's an active event, include it in the header\n    if (activeEvent) {\n        headerMessage += `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n`;\n        headerMessage += `${activeEvent.description}\\n\\n`;\n\n        // If filtering by industry, only show relevant impacts\n        if (industryFilter !== \"ALL\") {\n            const relevantImpact = activeEvent.sectorImpacts.find(\n                impact => impact.sectorId === industryFilter\n            );\n\n            if (relevantImpact) {\n                const direction = relevantImpact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `Industry Impact: ${direction} ${Math.abs(relevantImpact.impact)}%\\n`;\n            } else {\n                headerMessage += \"This industry is not directly affected by the current event.\\n\";\n            }\n        } else {\n            // Show all industry impacts\n            headerMessage += \"Industry Impacts:\\n\";\n            for (const impact of activeEvent.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%\\n`;\n            }\n        }\n    }\n\n    // Send header message first\n    await player.pm(headerMessage);\n\n    // Group stocks by industry\n    const stocksByIndustry = {};\n    stocks.forEach(stock => {\n        if (!stocksByIndustry[stock.sector]) {\n            stocksByIndustry[stock.sector] = [];\n        }\n        stocksByIndustry[stock.sector].push(stock);\n    });\n\n    // If industry filter is not \"ALL\", only show that industry\n    if (industryFilter !== \"ALL\") {\n        const filteredStocks = stocksByIndustry[industryFilter] || [];\n\n        if (filteredStocks.length > 0) {\n            let stockMessage = \"\";\n\n            filteredStocks.forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                stockMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(stockMessage);\n        } else {\n            await player.pm(`No stocks found in the ${industryFilter} industry.`);\n        }\n    } else {\n        // Send each industry as a separate message\n        for (const industryId in stocksByIndustry) {\n            let industryMessage = `=== ${industryId} INDUSTRY ===\\n`;\n\n            stocksByIndustry[industryId].forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                industryMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(industryMessage);\n        }\n    }\n\n    // Add a help message for industry filtering if showing all industries\n    if (industryFilter === \"ALL\") {\n        const allIndustries = Object.keys(stocksByIndustry).join(', ');\n        await player.pm(`\\nTip: Use '/markets [industry]' to view only stocks in a specific industry. Available industries: ${allIndustries}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return false;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            const results = await Promise.allSettled(createPromises);\n            // Check if the critical stock_market_data was created successfully\n            const stockDataPromise = results[0];\n            if (stockDataPromise && stockDataPromise.status === 'rejected') {\n                console.log(`Failed to create stock_market_data: ${stockDataPromise.reason}`);\n                return false;\n            }\n        }\n\n        return true;\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n        return false;\n    }\n}\n\nawait main();",
                    "name": "markets",
                    "description": null,
                    "trigger": "markets",
                    "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. \n",
                    "arguments": [
                        {
                            "name": "Industry",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. ",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // If a specific stock ticker is provided, show detailed info for that stock\n    const specificTicker = args.ticker ? args.ticker.toUpperCase() : null;\n\n    if (specificTicker && specificTicker !== \"ALL\") {\n        const stock = stocks.find(s => s.id.toUpperCase() === specificTicker);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${specificTicker} not found. Use /stockinfo without parameters to see all available stocks.`);\n        }\n\n        // Get active event to see if this stock's sector is affected\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let activeEvent = null;\n        let sectorImpact = null;\n\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEvent && activeEvent.sectorImpacts) {\n                    sectorImpact = activeEvent.sectorImpacts.find(impact =>\n                        impact.sectorId === stock.sector\n                    );\n                }\n            } catch (e) {\n                // Ignore parsing errors\n            }\n        }\n\n        // Calculate price change indicators\n        let changeText = '';\n        if (stock.lastPrice) {\n            const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n            const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n            changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n        }\n\n        // Add risk assessment based on volatility without showing the raw value\n        let riskLevel;\n        if (stock.volatility <= 0.05) riskLevel = \"Very Low\";\n        else if (stock.volatility <= 0.10) riskLevel = \"Low\";\n        else if (stock.volatility <= 0.15) riskLevel = \"Moderate\";\n        else if (stock.volatility <= 0.20) riskLevel = \"High\";\n        else riskLevel = \"Very High\";\n\n        // Build detailed stock info message\n        let message = `=== ${stock.id}: ${stock.name} ===\\n\\n`;\n        message += `Sector: ${stock.sector}\\n`;\n        message += `Current Price: $${Math.round(stock.price)}${changeText}\\n`;\n        message += `Risk Level: ${riskLevel}\\n`;\n\n        // Add sector trend info if available from event\n        if (activeEvent && sectorImpact) {\n            const direction = sectorImpact.impact >= 0 ? \"Positive\" : \"Negative\";\n            const strength = Math.abs(sectorImpact.impact);\n            let trend;\n\n            if (strength < 10) trend = \"Slight\";\n            else if (strength < 25) trend = \"Moderate\";\n            else trend = \"Strong\";\n\n            message += `\\nCurrent Trend: ${trend} ${direction} (${activeEvent.name})\\n`;\n            message += `Event: ${activeEvent.description}\\n`;\n        }\n\n        // Add trading guidance based on sector and risk, without mentioning volatility\n        message += `\\nTrading Notes:\\n`;\n\n        if (activeEvent && sectorImpact) {\n            if (sectorImpact.impact > 0) {\n                message += `- Currently bullish due to the ${activeEvent.name} event\\n`;\n            } else {\n                message += `- Currently bearish due to the ${activeEvent.name} event\\n`;\n            }\n        }\n\n        if (riskLevel === \"High\" || riskLevel === \"Very High\") {\n            message += `- Expect significant price fluctuations with this stock\\n`;\n        } else if (riskLevel === \"Low\" || riskLevel === \"Very Low\") {\n            message += `- Typically has stable price movement\\n`;\n        }\n\n        message += `\\nUse /buystock ${stock.id} [amount] to purchase shares`;\n\n        await player.pm(message);\n\n    } else {\n        // No specific ticker provided or ALL specified, show summary of all stocks\n        await player.pm(\"=== STOCK MARKET LISTINGS ===\\n\");\n\n        // Group stocks by sector\n        const stocksBySector = {};\n        stocks.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        // Display stocks by sector\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            let sectorMessage = `\\n--- ${sector} SECTOR ---\\n`;\n\n            sectorStocks.forEach(stock => {\n                // Add price change indicators\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                    changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                // Add risk level based on volatility\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                sectorMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n\n            await player.pm(sectorMessage);\n        }\n\n        // Add legend for risk indicators\n        const legend = \"\\n=== LEGEND ===\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\" +\n            \"Use /stockinfo [ticker] for detailed information about a specific stock\";\n\n        await player.pm(legend);\n    }\n}\n\nawait main();",
                    "name": "stockinfo",
                    "description": null,
                    "trigger": "stockinfo",
                    "helpText": "Shows all available stocks in the market. Use with a ticker symbol (e.g., /stockinfo ticker) to see detailed information about a specific stock.",
                    "arguments": [
                        {
                            "name": "ticker",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "stock ticker or ALL to get detailed information about a specific stock",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRIGGER_EVENT')) {\n        throw new TakaroUserError(\"You don't have permission to trigger market events.\");\n    }\n\n    try {\n        // Get current stock data to check market initialization\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Initialize market if needed\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            await player.pm(\"Market was not initialized. Initializing now...\");\n            return;\n        }\n\n        // Get events from module config\n        const marketEvents = mod.userConfig.marketEvents || [];\n\n        if (marketEvents.length === 0) {\n            throw new TakaroUserError(\"No market events configured in this module.\");\n        }\n\n        // Handle case when no event is specified or \"ALL\" is provided\n        if (!args.EventName || args.EventName.toUpperCase() === \"ALL\") {\n            await player.pm(\"=== AVAILABLE MARKET EVENTS ===\\n\");\n\n            // Group events by category or type if possible\n            const eventCategories = {};\n\n            // Create a simple categorization based on positive/negative impact\n            marketEvents.forEach(event => {\n                let category = \"Mixed\";\n                // Calculate net impact across all sectors\n                const netImpact = event.sectorImpacts.reduce((sum, impact) => sum + impact.impact, 0);\n\n                if (netImpact > 0) category = \"Positive\";\n                else if (netImpact < 0) category = \"Negative\";\n\n                if (!eventCategories[category]) {\n                    eventCategories[category] = [];\n                }\n                eventCategories[category].push(event);\n            });\n\n            // Display events by category\n            for (const [category, events] of Object.entries(eventCategories)) {\n                if (events.length > 0) {\n                    await player.pm(`\\n--- ${category.toUpperCase()} EVENTS ---`);\n\n                    let message = \"\";\n                    events.forEach(event => {\n                        // Format primary sectors affected\n                        const primarySectors = event.sectorImpacts\n                            .filter(impact => Math.abs(impact.impact) >= 15)\n                            .map(impact => {\n                                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                                return `${impact.sectorId} ${direction}${Math.abs(impact.impact)}%`;\n                            })\n                            .join(\", \");\n\n                        message += `${event.id}: ${event.name}\\n`;\n                        message += `   ${event.description}\\n`;\n                        if (primarySectors) {\n                            message += `   Major impacts: ${primarySectors}\\n`;\n                        }\n                        message += \"\\n\";\n                    });\n\n                    await player.pm(message);\n                }\n            }\n\n            await player.pm(\"=== HOW TO USE ===\\nUse `/triggerevent <EventName>` to trigger a specific event (e.g., `/triggerevent TECH_BOOM`)\");\n            return;\n        }\n\n        // Find the requested event\n        const eventId = args.EventName.toUpperCase();\n        const event = marketEvents.find(e => e.id === eventId);\n\n        if (!event) {\n            throw new TakaroUserError(`Event \"${eventId}\" not found. Use /triggerevent without parameters to see all available events.`);\n        }\n\n        // Get necessary variables for managing the event\n        const [activeEventVar, eventStartTimeVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_execution_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_cooldown_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['current_event_duration'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Check if there's an active event we need to cancel\n        let activeEventObj = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEventObj = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEventObj && Object.keys(activeEventObj).length > 0) {\n                    await player.pm(`Cancelling active event \"${activeEventObj.name}\" to trigger new event.`);\n                }\n            } catch (e) {\n                // Invalid event data, will be overwritten\n            }\n        }\n\n        // Generate a random duration for the event\n        const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n        // Update or create all event-related variables\n        const updatePromises = [];\n\n        // Save or update the random duration\n        if (eventDurationVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                    value: randomDuration.toString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'current_event_duration',\n                    value: randomDuration.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the event counter to 0\n        if (eventCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the cooldown counter\n        if (cooldownCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update active event\n        if (activeEventVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                    value: JSON.stringify(event)\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: JSON.stringify(event),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update event start time\n        if (eventStartTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update last event time\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (lastEventTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all updates to complete\n        await Promise.all(updatePromises);\n\n        // Check if there are online players to announce the event\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            // Format sector impacts for announcement\n            let impactText = \"\";\n            for (const impact of event.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n            }\n\n            const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${event.name}\\n${event.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /markets to see opportunities!`;\n\n            // Split the message if it's too long\n            const maxLength = 400; // Safe limit for most games\n            for (let i = 0; i < message.length; i += maxLength) {\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message: message.substring(i, i + maxLength)\n                });\n            }\n        }\n\n        await player.pm(`Successfully triggered the \"${event.name}\" market event for ${randomDuration} cycles!`);\n    } catch (error) {\n        // If something goes wrong, log it and let the player know\n        console.log(`Error in triggerEvent: ${error.message}`);\n        throw new TakaroUserError(`Error triggering event: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Store the stocks data\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_data',\n            value: JSON.stringify(stocks),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize last event time to now\n        await takaro.variable.variableControllerCreate({\n            key: 'last_market_event_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize event start time variable\n        await takaro.variable.variableControllerCreate({\n            key: 'event_start_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize active event (empty string means no active event)\n        await takaro.variable.variableControllerCreate({\n            key: 'active_market_event',\n            value: '',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Mark market as initialized\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_initialized',\n            value: 'true',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Announce market initialization to online players\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /markets to see available stocks and /buystock to start investing.\";\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message\n            });\n        }\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "triggerevent",
                    "description": null,
                    "trigger": "triggerevent",
                    "helpText": "Shows all available market events when run without parameters. Use with an event name (e.g., /triggerevent TECH_BOOM) to trigger a specific market event.",
                    "arguments": [
                        {
                            "name": "EventName",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "Event name to trigger a specific market event",
                            "position": 0
                        }
                    ]
                }
            ],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    try {\n        const { gameServerId, module: mod } = data;\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Check if market is initialized\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return; // Exit after initialization\n        }\n\n        // Get active market event\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event start time\n        const eventStartTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_start_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event execution counter\n        const eventCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_execution_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event cooldown counter\n        const cooldownCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_cooldown_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let eventCounter = 0;\n        if (eventCounterVar.data.data.length > 0) {\n            eventCounter = parseInt(eventCounterVar.data.data[0].value, 10);\n        }\n\n        let cooldownCounter = 0;\n        if (cooldownCounterVar.data.data.length > 0) {\n            cooldownCounter = parseInt(cooldownCounterVar.data.data[0].value, 10);\n        }\n\n        // Get event duration\n        const eventDurationVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['current_event_duration'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Use stored random duration if available, otherwise use defaultEventDuration\n        let eventDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        if (eventDurationVar.data.data.length > 0) {\n            eventDuration = parseInt(eventDurationVar.data.data[0].value, 10);\n        }\n\n        let activeEvent = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                // If it's an empty string, treat as no active event\n                if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                    activeEvent = null;\n                }\n            } catch (e) {\n                // In case of parsing error, consider no active event\n                activeEvent = null;\n            }\n        }\n\n        // Check if the current event should end and increment counter\n        if (activeEvent) {\n            // Increment the event execution counter\n            eventCounter++;\n\n            // Update or create the counter\n            if (eventCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: eventCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: eventCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n\n            // End the event if counter reached duration\n            if (eventCounter >= eventDuration) {\n                // Clear the active event\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: ''\n                    });\n                }\n\n                // Reset counter to 0\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                // Reset cooldown counter to 0 to begin cooldown period\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_cooldown_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Announce the end of the event to all online players\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    const message = `ðŸ“ˆ MARKET UPDATE ðŸ“‰\\n\\nThe \"${activeEvent.name}\" event has ended. Markets are returning to normal conditions.`;\n\n                    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                        message: message\n                    });\n                }\n\n                // Reset active event\n                activeEvent = null;\n            }\n        } else {\n            // No active event, increment cooldown counter\n            cooldownCounter++;\n\n            // Update or create the cooldown counter\n            if (cooldownCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: cooldownCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: cooldownCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n        }\n\n        // Get last event time for event frequency calculation\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        const eventFrequency = (mod.userConfig && mod.userConfig.eventFrequency) || 10;\n        let shouldTriggerEvent = false;\n\n        // Only trigger a new event if:\n        // 1. There's no active event \n        // 2. We have passed the cooldown period (cooldownCounter >= eventFrequency)\n        if (!activeEvent && cooldownCounter >= eventFrequency) {\n            // Base chance to trigger an event\n            shouldTriggerEvent = Math.random() < 0.5; // 50% chance\n\n            // Force an event if we're well past the cooldown period (2x frequency)\n            if (cooldownCounter >= eventFrequency * 2) {\n                shouldTriggerEvent = true;\n            }\n        }\n\n        // If we should trigger a new event, select a random one\n        if (shouldTriggerEvent) {\n            const events = (mod.userConfig && mod.userConfig.marketEvents) || [];\n            if (events.length > 0) {\n                const randomEvent = events[Math.floor(Math.random() * events.length)];\n                activeEvent = randomEvent;\n\n                // Generate a random duration between 1 and defaultEventDuration\n                const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n                const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n                // Save the random duration\n                if (eventDurationVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                        value: randomDuration.toString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'current_event_duration',\n                        value: randomDuration.toString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Reset the event counter to 0\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Reset the cooldown counter\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                // Update active event\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: JSON.stringify(activeEvent)\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'active_market_event',\n                        value: JSON.stringify(activeEvent),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Update event start time\n                if (eventStartTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_start_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Update last event time\n                if (lastEventTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'last_market_event_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                // Announce the event to all online players\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    // Format sector impacts for announcement\n                    let impactText = \"\";\n                    for (const impact of activeEvent.sectorImpacts) {\n                        const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                        impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n                    }\n\n                    const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${activeEvent.name}\\n${activeEvent.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /market to see opportunities!`;\n\n                    // Split the message if it's too long\n                    const maxLength = 400; // Safe limit for most games\n                    for (let i = 0; i < message.length; i += maxLength) {\n                        await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                            message: message.substring(i, i + maxLength)\n                        });\n                    }\n                }\n            }\n        }\n\n        // Get stocks\n        if (!marketDataVar.data.data[0] || !marketDataVar.data.data[0].value) {\n            // Re-initialize market if value is missing\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        let stocks;\n        try {\n            stocks = JSON.parse(marketDataVar.data.data[0].value);\n            if (!Array.isArray(stocks)) {\n                throw new Error(\"Parsed stocks data is not an array\");\n            }\n        } catch (e) {\n            // Re-initialize market if data is corrupt\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        const significantChanges = [];\n\n        // Update each stock price\n        stocks.forEach(stock => {\n            // Save the current price as lastPrice for change tracking\n            if (!stock.lastPrice) {\n                stock.lastPrice = stock.price;\n            } else {\n                stock.lastPrice = stock.price;\n            }\n\n            // Calculate base price change based on volatility\n            // Using a more normalized random approach\n            // Math.random() * 2 - 1 gives a value between -1 and 1\n            const randomFactor = Math.random() * 2 - 1;\n            const baseChangePercent = randomFactor * stock.volatility;\n            let totalChangePercent = baseChangePercent;\n\n            // Apply active event effects if any\n            if (activeEvent) {\n                const sectorImpact = activeEvent.sectorImpacts.find(impact => impact.sectorId === stock.sector);\n                if (sectorImpact) {\n                    // Convert impact percentage to decimal and apply a random factor\n                    // to create varied effects within each sector\n                    const eventImpactPercentage = sectorImpact.impact; // This is already a percentage\n                    const eventImpactDecimal = eventImpactPercentage / 100; // Convert to decimal\n                    const randomImpactFactor = 0.5 + Math.random(); // Between 0.5 and 1.5\n                    const eventImpact = eventImpactDecimal * randomImpactFactor;\n\n                    // Add the event impact to the total change percent\n                    totalChangePercent += eventImpact;\n                }\n            }\n\n            // Apply the price change\n            const oldPrice = stock.price;\n            const priceChange = stock.price * totalChangePercent;\n            stock.price = Math.max(1, stock.price + priceChange);\n\n            // Check if this is a significant change\n            const changeThreshold = ((mod.userConfig && mod.userConfig.priceAlertThreshold) || 10) / 100;\n            const percentChange = (stock.price - stock.lastPrice) / stock.lastPrice;\n\n            if (Math.abs(percentChange) > changeThreshold) {\n                significantChanges.push({\n                    ...stock,\n                    changePercent: percentChange * 100\n                });\n            }\n        });\n\n        // Save updated prices\n        await takaro.variable.variableControllerUpdate(marketDataVar.data.data[0].id, {\n            value: JSON.stringify(stocks)\n        });\n\n        // Broadcast major changes to all players\n        if (significantChanges.length > 0) {\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                // Sort by absolute change percentage\n                significantChanges.sort((a, b) => Math.abs(b.changePercent) - Math.abs(a.changePercent));\n\n                // Take top 3 most significant changes\n                const topChanges = significantChanges.slice(0, Math.min(3, significantChanges.length));\n\n                // Formulate message about big market changes\n                let message = \"ðŸ“Š STOCK MARKET ALERT ðŸ“Š\\n\";\n                topChanges.forEach(stock => {\n                    const changeDir = stock.changePercent > 0 ? \"up\" : \"down\";\n                    const changePercent = Math.abs(Math.round(stock.changePercent));\n\n                    message += `${stock.id} (${stock.sector}): ${changeDir} ${changePercent}% to $${Math.round(stock.price)}!\\n`;\n                });\n\n                if (activeEvent) {\n                    message += `\\nCurrent market event: ${activeEvent.name}`;\n                }\n\n                // Send the message\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            }\n        }\n    } catch (error) {\n        // If something goes wrong, log it\n        console.log(`Error in updateStockPrices: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            await Promise.allSettled(createPromises);\n        }\n\n        // Only announce if we had to create at least the stock data (indicating a new market)\n        if (marketDataVar.data.data.length === 0) {\n            // Announce market initialization to online players\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /market to see available stocks and /buy to start investing.\";\n\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            }\n        }\n    } catch (error) {\n        // Log the error but don't throw, so the cronjob can continue\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "updatestockprices",
                    "description": null,
                    "temporalValue": "5 4 * * *"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n\n    // Check for online players\n    const currentPlayers = (await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    })).data.meta;\n\n    if (currentPlayers.total === 0) {\n        takaro.log.info('Skipping daily market report: No players online.');\n        return; // No players online, skip the market news\n    }\n\n    // Get current stock data (which should include lastPrice)\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        takaro.log.warn('Skipping daily market report: Market data variable not found.');\n        return; // Market not initialized yet\n    }\n\n    let stocks;\n    try {\n        stocks = JSON.parse(marketDataVar.data.data[0].value);\n        if (!Array.isArray(stocks)) {\n            throw new Error('Parsed market data is not an array.');\n        }\n    } catch (error) {\n        takaro.log.error(`Failed to parse stock_market_data: ${error}`);\n        return; // Invalid market data\n    }\n\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n        } catch (error) {\n            takaro.log.warn(`Failed to parse active_market_event: ${error}`);\n            // Continue without event info if parsing fails\n        }\n    }\n\n    // --- Message 1: Header and active event ---\n    let message1 = \"==== DAILY MARKET REPORT ====\\n\";\n    if (activeEvent && activeEvent.name && activeEvent.description) {\n        message1 += `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n${activeEvent.description}\\n`;\n    } else {\n        message1 += '\\nNo active market events today.\\n';\n    }\n\n    // Send first part of the report\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: message1\n    }).catch(err => takaro.log.error(`Failed to send message 1: ${err}`));\n\n    // --- Calculate stock performance using stock.price and stock.lastPrice ---\n    const stocksWithPerformance = stocks.map(stock => {\n        let change = 0;\n        let percentChange = 0;\n        let changeSymbol = 'â†’'; // Default: No change or insufficient data\n\n        // Ensure required fields exist and lastPrice is a valid number > 0 for percentage calculation\n        if (typeof stock.price === 'number' && typeof stock.lastPrice === 'number' && stock.lastPrice !== 0) {\n            change = stock.price - stock.lastPrice;\n            percentChange = (change / stock.lastPrice) * 100;\n            if (percentChange > 0.05) { // Use a small threshold to avoid 'noise'\n                changeSymbol = 'â†‘';\n            } else if (percentChange < -0.05) {\n                changeSymbol = 'â†“';\n            }\n        } else if (typeof stock.price === 'number' && stock.lastPrice === undefined) {\n            // Handle case where lastPrice might not exist (e.g., new stock)\n            changeSymbol = 'ðŸ†•'; // Indicate 'New' or similar\n            percentChange = 0; // Or handle as needed\n        }\n        // If lastPrice is 0, or types are wrong, change/percentChange remain 0, symbol remains 'â†’'\n\n        return {\n            ...stock,\n            change,         // Absolute change\n            percentChange,  // Percentage change\n            changeSymbol    // Visual indicator\n        };\n    });\n\n    // --- Group by sector ---\n    const sectorPerformance = {};\n    stocksWithPerformance.forEach(stock => {\n        const sectorId = stock.sector || 'Uncategorized'; // Default sector if missing\n        if (!sectorPerformance[sectorId]) {\n            sectorPerformance[sectorId] = {\n                stocks: [],\n                totalPercentChange: 0, // Sum percentages for averaging\n                count: 0\n            };\n        }\n        sectorPerformance[sectorId].stocks.push(stock);\n        // Only include stocks with valid percentage change in the average\n        if (typeof stock.percentChange === 'number' && isFinite(stock.percentChange)) {\n            sectorPerformance[sectorId].totalPercentChange += stock.percentChange;\n            sectorPerformance[sectorId].count++;\n        }\n    });\n\n    // --- Calculate average sector performance ---\n    for (const sectorId in sectorPerformance) {\n        const sectorData = sectorPerformance[sectorId];\n        if (sectorData.count > 0) {\n            sectorData.avgPerformance = sectorData.totalPercentChange / sectorData.count;\n        } else {\n            sectorData.avgPerformance = 0; // Avoid division by zero if no stocks had valid changes\n        }\n    }\n\n    // Sort sectors by average performance\n    const sortedSectors = Object.entries(sectorPerformance)\n        .sort(([, a], [, b]) => b.avgPerformance - a.avgPerformance);\n\n    // --- Message 2: Sector performance ---\n    let message2 = \"\\n=== SECTOR PERFORMANCE ===\\n\";\n    if (sortedSectors.length > 0) {\n        sortedSectors.forEach(([sectorId, data]) => {\n            const avgSymbol = data.avgPerformance > 0.05 ? 'â†‘' : data.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n            message2 += `${sectorId}: ${avgSymbol} ${Math.abs(data.avgPerformance).toFixed(1)}%\\n`; // Use toFixed(1) like command\n        });\n    } else {\n        message2 += \"No sector performance data available.\\n\";\n    }\n\n    // Send sector performance report\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: message2\n    }).catch(err => takaro.log.error(`Failed to send message 2: ${err}`));\n\n\n    // --- Message 3: Top and Worst performers ---\n    // Filter out stocks where percentChange couldn't be calculated properly before sorting\n    const validPerformers = stocksWithPerformance.filter(s => typeof s.percentChange === 'number' && isFinite(s.percentChange));\n\n    // Sort valid performers\n    validPerformers.sort((a, b) => b.percentChange - a.percentChange);\n\n    let message3 = \"\\nðŸ”¥ TOP PERFORMERS ðŸ”¥\\n\";\n    if (validPerformers.length > 0) {\n        for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n            const stock = validPerformers[i];\n            // Use the pre-calculated changeSymbol based on percentChange\n            message3 += `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n        }\n    } else {\n        message3 += \"No top performers today.\\n\";\n    }\n\n\n    message3 += \"\\nðŸ“‰ WORST PERFORMERS ðŸ“‰\\n\";\n    if (validPerformers.length > 0) {\n        // Sort for worst (ascending order) - no need to create a new sorted array if we just reverse iteration\n        const worstStartIndex = Math.max(0, validPerformers.length - 3);\n        for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n            const stock = validPerformers[i];\n            // Use the pre-calculated changeSymbol based on percentChange\n            message3 += `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n        }\n    } else {\n        message3 += \"No worst performers today.\\n\";\n    }\n\n\n    // Send top/worst performers report\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: message3\n    }).catch(err => takaro.log.error(`Failed to send message 3: ${err}`));\n\n    // --- IMPORTANT: REMOVED the update of 'stock_market_yesterday' ---\n    // This script now assumes 'stock_market_data' contains 'lastPrice'.\n    // The responsibility of updating 'lastPrice' and the new 'price'\n    // must lie in another script/process that runs *before* this report.\n\n    takaro.log.info('Daily market report sent successfully.');\n}\n\nawait main();",
                    "name": "marketnews",
                    "description": null,
                    "temporalValue": "0 */1 * * *"
                }
            ],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Allows the player to view market prices and their portfolio",
                    "permission": "STOCK_MARKET_USE",
                    "friendlyName": "Use Stock Market"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows the player to buy and sell stocks",
                    "permission": "STOCK_MARKET_TRADE",
                    "friendlyName": "Trade Stocks"
                },
                {
                    "canHaveCount": false,
                    "description": "VIP status that reduces transaction fees",
                    "permission": "STOCK_MARKET_BROKER",
                    "friendlyName": "Stock Broker"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows admins to manually trigger market events",
                    "permission": "STOCK_MARKET_TRIGGER_EVENT",
                    "friendlyName": "Trigger Market Events"
                }
            ]
        },
        {
            "tag": "0.1.6",
            "description": "**Stock Market: A Dynamic Virtual Trading System**\n\nCreate an immersive economic experience with this comprehensive stock market module that lets players invest, trade, and react to market events.\n\n**Market Features:**\n\n![Market Summary](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stocks.png)\n\n* **Multiple Economic Sectors:** Configure various industry sectors (Resource Extraction, Manufacturing, Defense, etc.) each with their own market dynamics.\n* **Realistic Stock Behavior:** Stocks have configurable volatility, sector-based pricing, and react differently to market events.\n* **Dynamic Market Events:** Random or admin-triggered events like \"Horde Night Approaching\" or \"Societal Collapse Setback\" impact different sectors in realistic ways.\n\n![Market Events](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_events.png)\n\n**Trading System:**\n\n* **Buy & Sell Shares:** Players can purchase stocks and sell them later for profit or loss.\n* **Transaction Fees:** Configurable fee percentage on all trades creates a realistic market economy.\n* **VIP Benefits:** Special permissions for designated \"Stock Brokers\" who receive fee discounts.\n\n![Buy Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_buy.png)\n\nPlayers can track price changes and sell at the right moment to maximize profits or minimize losses.\n\n![Sell Stock Example](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sell.png)\n\n**Player Portfolio:**\n\n* **Portfolio Tracking:** Players can view their holdings, average purchase prices, and current profit/loss.\n* **Transaction History:** System tracks all buy/sell transactions for each player.\n* **Summary Statistics:** See overall portfolio performance and value across all holdings.\n\n![Portfolio View](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockportfolio.png)\n\n**Market Information:**\n\n* **Detailed Stock Info:** Players can research specific stocks, including risk levels and sector trends.\n* **Industry Filters:** View stocks by specific sectors to better understand market segments.\n* **Market Alerts:** Server-wide notifications for significant price changes keep players engaged.\n\n![Market Alerts](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_stockpricechange.png)\n\n**Configuration Options:**\n\n* **Sectors & Stocks:** Define your own market sectors and individual stocks with customizable starting prices and volatility.\n* **Market Events:** Create unique events with specific sector impacts to drive market dynamics.\n* **Transaction Settings:** Configure fee percentages, VIP discounts, and alert thresholds.\n* **Event Frequency:** Control how often random market events occur and how long they last.\n\n![Configuration](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_config.png)\n![Sectors](https://raw.githubusercontent.com/gettakaro/community-modules-viewer/refs/heads/main/images/stockmarket_7dtd_sectors.png)\n\n**Commands:**\n\n* `/markets [industry]` - View all stocks or filter by industry\n* `/stockinfo [ticker]` - Get detailed information about a specific stock\n* `/buystock <ticker> <amount>` - Purchase shares of a stock\n* `/sellstock <ticker> <amount>` - Sell shares from your portfolio\n* `/stockportfolio` - View your current holdings and performance\n* `/triggerevent [event]` - Admin command to trigger specific market events\n\nWho says the apocalypse can't have a thriving economy? Now players can stress about both zombie hordes AND their Duke's Casino Tokens dropping 40% after a market event! As one trader put it: \"I used to check my 401K daily, and now I check my AMMO stock before every Blood Moon. Some habits die harder than zombies.\"",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sectors\":{\"type\":\"array\",\"title\":\"Wasteland Economic Sectors\",\"description\":\"Define economic sectors relevant to survival in Navezgane\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Sector ID (e.g., RESOURCES)\"},\"name\":{\"type\":\"string\",\"description\":\"Sector name (e.g., Resource Extraction)\"}}},\"default\":[{\"id\":\"RESOURCES\",\"name\":\"Resource Extraction\"},{\"id\":\"MANUFACTURING\",\"name\":\"Manufacturing & Crafting\"},{\"id\":\"DEFENSE\",\"name\":\"Defense & Fortifications\"},{\"id\":\"SURVIVAL\",\"name\":\"Survival Goods\"},{\"id\":\"TRADE\",\"name\":\"Trade & Currency\"}]},\"stocks\":{\"type\":\"array\",\"title\":\"Wasteland Stocks\",\"description\":\"List of stocks representing Navezgane entities and resources\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Stock ticker symbol (e.g., NMC)\"},\"name\":{\"type\":\"string\",\"description\":\"Entity/Resource name\"},\"sector\":{\"type\":\"string\",\"description\":\"Sector ID this stock belongs to\"},\"initialPrice\":{\"type\":\"number\",\"description\":\"Starting price in Dukes\",\"minimum\":1},\"volatility\":{\"type\":\"number\",\"description\":\"Base volatility percentage (5 = 5%)\",\"minimum\":1,\"maximum\":35}}},\"default\":[{\"id\":\"NMC\",\"name\":\"Navezgane Mining Co.\",\"sector\":\"RESOURCES\",\"initialPrice\":50,\"volatility\":15},{\"id\":\"WOOD\",\"name\":\"Wasteland Lumberjacks\",\"sector\":\"RESOURCES\",\"initialPrice\":20,\"volatility\":8},{\"id\":\"SHALE\",\"name\":\"Oil Shale Extractors\",\"sector\":\"RESOURCES\",\"initialPrice\":40,\"volatility\":18},{\"id\":\"FORGE\",\"name\":\"Forge Ahead Metals\",\"sector\":\"MANUFACTURING\",\"initialPrice\":75,\"volatility\":12},{\"id\":\"TOOLS\",\"name\":\"Working Stiff Tools\",\"sector\":\"MANUFACTURING\",\"initialPrice\":60,\"volatility\":10},{\"id\":\"MECH\",\"name\":\"JunkTech Robotics\",\"sector\":\"MANUFACTURING\",\"initialPrice\":110,\"volatility\":20},{\"id\":\"BUILD\",\"name\":\"Barricade Builders\",\"sector\":\"DEFENSE\",\"initialPrice\":45,\"volatility\":9},{\"id\":\"AMMO\",\"name\":\"AmmoNation Surplus\",\"sector\":\"DEFENSE\",\"initialPrice\":90,\"volatility\":18},{\"id\":\"SHAM\",\"name\":\"Shamway Foods\",\"sector\":\"SURVIVAL\",\"initialPrice\":30,\"volatility\":5},{\"id\":\"MEDS\",\"name\":\"Pop-N-Pills Medical\",\"sector\":\"SURVIVAL\",\"initialPrice\":100,\"volatility\":18},{\"id\":\"TRADE\",\"name\":\"Trader Guild Network\",\"sector\":\"TRADE\",\"initialPrice\":150,\"volatility\":10},{\"id\":\"DUKES\",\"name\":\"Duke's Casino Tokens\",\"sector\":\"TRADE\",\"initialPrice\":1,\"volatility\":3}]},\"marketEvents\":{\"type\":\"array\",\"title\":\"Wasteland Events\",\"description\":\"Events impacting the Navezgane economy\",\"items\":{\"type\":\"object\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Unique event ID\"},\"name\":{\"type\":\"string\",\"description\":\"Name of the event\"},\"description\":{\"type\":\"string\",\"description\":\"Description of the event's market effect\"},\"sectorImpacts\":{\"type\":\"array\",\"description\":\"How each sector is affected\",\"items\":{\"type\":\"object\",\"properties\":{\"sectorId\":{\"type\":\"string\",\"description\":\"Sector ID\"},\"impact\":{\"type\":\"number\",\"description\":\"Percentage impact (-30 = -30%)\",\"minimum\":-75,\"maximum\":75}}}}}},\"default\":[{\"id\":\"HORDE_INCOMING\",\"name\":\"Horde Night Approaching\",\"description\":\"Increased Zed activity signals the Blood Moon. Survivors prepare defenses.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-5},{\"sectorId\":\"MANUFACTURING\",\"impact\":15},{\"sectorId\":\"DEFENSE\",\"impact\":25},{\"sectorId\":\"SURVIVAL\",\"impact\":10},{\"sectorId\":\"TRADE\",\"impact\":-10}]},{\"id\":\"RESOURCE_SHOCK\",\"name\":\"Resource Shock\",\"description\":\"Key resource veins are depleted, making raw materials expensive and driving up the price of finished goods.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-30},{\"sectorId\":\"MANUFACTURING\",\"impact\":15},{\"sectorId\":\"DEFENSE\",\"impact\":10},{\"sectorId\":\"SURVIVAL\",\"impact\":5},{\"sectorId\":\"TRADE\",\"impact\":5}]},{\"id\":\"ZED_OUTBREAK\",\"name\":\"Severe Zed Outbreak\",\"description\":\"An unusual concentration of Zed activity makes scavenging dangerous. Demand for medical supplies and defenses skyrockets.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-20},{\"sectorId\":\"MANUFACTURING\",\"impact\":-5},{\"sectorId\":\"DEFENSE\",\"impact\":25},{\"sectorId\":\"SURVIVAL\",\"impact\":25},{\"sectorId\":\"TRADE\",\"impact\":-15}]},{\"id\":\"TECH_BREAKTHROUGH\",\"name\":\"Technological Breakthrough\",\"description\":\"A discovery of pre-collapse schematics has revolutionized crafting and manufacturing.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":10},{\"sectorId\":\"MANUFACTURING\",\"impact\":30},{\"sectorId\":\"DEFENSE\",\"impact\":15},{\"sectorId\":\"SURVIVAL\",\"impact\":5},{\"sectorId\":\"TRADE\",\"impact\":15}]},{\"id\":\"TRADE_ROUTE_SECURED\",\"name\":\"Trade Route Secured\",\"description\":\"Traders have established a safer passage, improving the flow of all goods and services.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":20},{\"sectorId\":\"MANUFACTURING\",\"impact\":10},{\"sectorId\":\"DEFENSE\",\"impact\":5},{\"sectorId\":\"SURVIVAL\",\"impact\":15},{\"sectorId\":\"TRADE\",\"impact\":30}]},{\"id\":\"GENERAL_COLLAPSE\",\"name\":\"Societal Collapse Setback\",\"description\":\"A major setback reminds everyone how fragile survival is. Fear grips the market.\",\"sectorImpacts\":[{\"sectorId\":\"RESOURCES\",\"impact\":-15},{\"sectorId\":\"MANUFACTURING\",\"impact\":-20},{\"sectorId\":\"DEFENSE\",\"impact\":-15},{\"sectorId\":\"SURVIVAL\",\"impact\":0},{\"sectorId\":\"TRADE\",\"impact\":-25}]}]},\"eventFrequency\":{\"title\":\"Event Frequency\",\"type\":\"number\",\"description\":\"Average number of update cycles between market events (0 to disable). Depends on mod's update frequency (e.g., per in-game hour?).\",\"default\":8,\"minimum\":1},\"defaultEventDuration\":{\"title\":\"Default Event Duration\",\"type\":\"number\",\"description\":\"Default number of update cycles an event lasts.\",\"default\":3,\"minimum\":1,\"maximum\":96},\"transactionFee\":{\"title\":\"Transaction Fee (Dukes Tax)\",\"type\":\"number\",\"description\":\"Percentage fee charged on all buy/sell transactions (5 = 5%)\",\"default\":3,\"minimum\":0,\"maximum\":25},\"vipDiscount\":{\"title\":\"Trader's Favor Discount\",\"type\":\"number\",\"description\":\"Percentage discount on transaction fees for players with 'STOCK_MARKET_BROKER' permission (50 = 50%)\",\"default\":50,\"minimum\":0,\"maximum\":100},\"priceAlertThreshold\":{\"title\":\"Price Alert Threshold\",\"type\":\"number\",\"description\":\"Percentage change that triggers a market alert (15 = 15%)\",\"default\":15,\"minimum\":5,\"maximum\":50},\"marketNewsChannelId\":{\"title\":\"Discord Channel ID (for Market News)\",\"type\":\"string\",\"description\":\"The ID of the Discord channel where market news messages should be posted. Leave empty to disable.\",\"default\":\"\"}},\"additionalProperties\":false}",
            "uiSchema": "{\"sectors\":{\"items\":{\"ui:order\":[\"id\",\"name\"]}},\"stocks\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"sector\",\"initialPrice\",\"volatility\"]}},\"marketEvents\":{\"items\":{\"ui:order\":[\"id\",\"name\",\"description\",\"sectorImpacts\"],\"sectorImpacts\":{\"items\":{\"ui:order\":[\"sectorId\",\"impact\"]}}}},\"transactionFee\":{\"ui:widget\":\"range\"},\"vipDiscount\":{\"ui:widget\":\"range\"},\"eventFrequency\":{\"ui:help\":\"Set to 0 to disable random events\"},\"priceAlertThreshold\":{\"ui:widget\":\"range\"}}",
            "commands": [
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // Get player's portfolio\n    const portfolioVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_portfolio'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId],\n            playerId: [player.id]\n        }\n    });\n\n    let portfolio = {};\n    if (portfolioVar.data.data.length > 0) {\n        portfolio = JSON.parse(portfolioVar.data.data[0].value);\n    }\n\n    // Send header\n    await player.pm(\"=== YOUR STOCK PORTFOLIO ===\");\n\n    let hasStocks = false;\n    let totalValue = 0;\n    let totalInvestment = 0;\n\n    // If no stocks, send a simple message\n    if (Object.keys(portfolio).length === 0) {\n        await player.pm(\"You don't own any stocks yet.\\n\" +\n            \"Use /markets to see available stocks and prices.\\n\" +\n            \"Use /buy <stock> <amount> to purchase stocks.\");\n        return;\n    }\n\n    // Helper function to format numbers with commas\n    const formatNumber = (num) => {\n        return Math.round(num).toLocaleString();\n    };\n\n    // Send each stock as a separate message to avoid length issues\n    for (const [stockId, data] of Object.entries(portfolio)) {\n        hasStocks = true;\n        const stock = stocks.find(s => s.id === stockId);\n        if (!stock) continue; // Stock might have been removed from config\n\n        const currentValue = stock.price * data.shares;\n        const investmentValue = data.averagePrice * data.shares;\n        totalValue += currentValue;\n        totalInvestment += investmentValue;\n        const profit = currentValue - investmentValue;\n        const profitPercent = ((profit / investmentValue) * 100).toFixed(1);\n\n        let stockMessage = `--- ${stockId} (${stock.sector}) ---\\n`;\n        stockMessage += `Shares: ${data.shares}\\n`;\n        stockMessage += `Avg buy: $${formatNumber(data.averagePrice)}\\n`;\n        stockMessage += `Current price: $${formatNumber(stock.price)}\\n`;\n        stockMessage += `Total value: $${formatNumber(currentValue)}\\n`;\n\n        if (profit >= 0) {\n            stockMessage += `Profit: +$${formatNumber(profit)} (+${profitPercent}%)\\n`;\n        } else {\n            stockMessage += `Loss: -$${formatNumber(Math.abs(profit))} (${profitPercent}%)\\n`;\n        }\n\n        await player.pm(stockMessage);\n    }\n\n    if (hasStocks) {\n        const totalProfit = totalValue - totalInvestment;\n        const totalProfitPercent = ((totalProfit / totalInvestment) * 100).toFixed(1);\n\n        let summaryMessage = \"=== PORTFOLIO SUMMARY ===\\n\";\n        summaryMessage += `Total investment: $${formatNumber(totalInvestment)}\\n`;\n        summaryMessage += `Current value: $${formatNumber(totalValue)}\\n`;\n\n        if (totalProfit >= 0) {\n            summaryMessage += `Overall profit: +$${formatNumber(totalProfit)} (+${totalProfitPercent}%)\\n`;\n        } else {\n            summaryMessage += `Overall loss: -$${formatNumber(Math.abs(totalProfit))} (${totalProfitPercent}%)\\n`;\n        }\n\n        // Get transaction history count\n        try {\n            const historyVar = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: ['stock_transaction_history'],\n                    gameServerId: [gameServerId],\n                    moduleId: [mod.moduleId],\n                    playerId: [player.id]\n                }\n            });\n\n            if (historyVar.data.data.length > 0) {\n                const history = JSON.parse(historyVar.data.data[0].value);\n                const buyCount = history.filter(t => t.type === 'BUY').length;\n                const sellCount = history.filter(t => t.type === 'SELL').length;\n\n                summaryMessage += `\\nTransactions: ${history.length} (${buyCount} buys, ${sellCount} sells)\\n`;\n            }\n        } catch (error) {\n            // Just ignore history errors\n        }\n\n        await player.pm(summaryMessage);\n    }\n}\n\nawait main();",
                    "name": "stockportfolio",
                    "description": null,
                    "trigger": "stockportfolio",
                    "helpText": "No help text available",
                    "arguments": []
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /buystock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === args.stock.toUpperCase());\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${args.stock} not found. Use /market to see available stocks.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate costs using Math.round to ensure we work with integers\n        const subtotal = Math.round(stock.price) * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const totalCost = subtotal + fee;\n\n        // Check if player has enough currency\n        const playerData = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, player.id);\n        const currentBalance = playerData.data.data.currency;\n\n        if (currentBalance < totalCost) {\n            throw new TakaroUserError(`You don't have enough currency. Cost: $${subtotal} + $${fee} fee = $${totalCost}. Your balance: $${currentBalance}`);\n        }\n\n        // Deduct the currency - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerDeductCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: totalCost\n            }\n        );\n\n        // Get player's portfolio or create new one\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        let portfolio;\n        if (portfolioVar.data.data.length === 0) {\n            portfolio = {};\n        } else {\n            portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        }\n\n        // Update portfolio using rounded values for consistency\n        const stockPrice = Math.round(stock.price);\n        if (!portfolio[stock.id]) {\n            portfolio[stock.id] = {\n                shares: amount,\n                averagePrice: stockPrice\n            };\n        } else {\n            const totalShares = portfolio[stock.id].shares + amount;\n            const totalValue = (portfolio[stock.id].shares * portfolio[stock.id].averagePrice) + (amount * stockPrice);\n            portfolio[stock.id].shares = totalShares;\n            portfolio[stock.id].averagePrice = Math.round(totalValue / totalShares);\n        }\n\n        // Save updated portfolio\n        if (portfolioVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_portfolio',\n                value: JSON.stringify(portfolio),\n                gameServerId,\n                moduleId: mod.moduleId,\n                playerId: player.id\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n                value: JSON.stringify(portfolio)\n            });\n        }\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'BUY',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: totalCost,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully bought ${amount} shares of ${stock.id} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Total cost: $${totalCost}\\n`;\n        message += `Current portfolio: ${portfolio[stock.id].shares} shares of ${stock.id}`;\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in buystock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your purchase. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "buystock",
                    "description": null,
                    "trigger": "buystock",
                    "helpText": "Buy shares of a stock",
                    "arguments": [
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to buy",
                            "position": 1
                        },
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol ",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Handle the industry argument - use \"ALL\" as a special value to show all industries\n    const industryFilter = args.Industry ? args.Industry.toUpperCase() : \"ALL\";\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    // If market data doesn't exist, try to initialize it\n    if (marketDataVar.data.data.length === 0) {\n        const initialized = await initializeMarketIfNeeded(gameServerId, mod);\n        if (!initialized) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        // Get the freshly initialized market data\n        const refreshedMarketData = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (refreshedMarketData.data.data.length === 0) {\n            throw new TakaroUserError(\"There was an issue initializing the stock market. Please try again later.\");\n        }\n\n        // Continue with the refreshed data\n        await displayMarketSummary(player, gameServerId, mod, refreshedMarketData.data.data[0], industryFilter);\n    } else {\n        // Market data exists, display it\n        await displayMarketSummary(player, gameServerId, mod, marketDataVar.data.data[0], industryFilter);\n    }\n}\n\n// Display the market summary to the player\nasync function displayMarketSummary(player, gameServerId, mod, marketDataVariable, industryFilter) {\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Handle empty string or empty object\n            if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (e) {\n            // In case of parsing error\n            activeEvent = null;\n        }\n    }\n\n    const stocks = JSON.parse(marketDataVariable.value);\n\n    // Get all available industries for reference\n    const availableIndustries = [...new Set(stocks.map(stock => stock.sector))];\n\n    // If industry filter is provided and not \"ALL\", check if it's valid\n    if (industryFilter !== \"ALL\") {\n        // Check if the industry exists\n        const industryExists = availableIndustries.includes(industryFilter);\n\n        if (!industryExists) {\n            throw new TakaroUserError(`Industry \"${industryFilter}\" not found. Available industries: ${availableIndustries.join(', ')}\\nUse \"ALL\" to view all industries.`);\n        }\n    }\n\n    // Send header message\n    let headerMessage = \"=== STOCK MARKET SUMMARY ===\\n\";\n\n    // If filtering by industry, mention it in the header\n    if (industryFilter !== \"ALL\") {\n        headerMessage = `=== ${industryFilter} INDUSTRY ===\\n`;\n    }\n\n    // If there's an active event, include it in the header\n    if (activeEvent) {\n        headerMessage += `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n`;\n        headerMessage += `${activeEvent.description}\\n\\n`;\n\n        // If filtering by industry, only show relevant impacts\n        if (industryFilter !== \"ALL\") {\n            const relevantImpact = activeEvent.sectorImpacts.find(\n                impact => impact.sectorId === industryFilter\n            );\n\n            if (relevantImpact) {\n                const direction = relevantImpact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `Industry Impact: ${direction} ${Math.abs(relevantImpact.impact)}%\\n`;\n            } else {\n                headerMessage += \"This industry is not directly affected by the current event.\\n\";\n            }\n        } else {\n            // Show all industry impacts\n            headerMessage += \"Industry Impacts:\\n\";\n            for (const impact of activeEvent.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                headerMessage += `${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%\\n`;\n            }\n        }\n    }\n\n    // Send header message first\n    await player.pm(headerMessage);\n\n    // Group stocks by industry\n    const stocksByIndustry = {};\n    stocks.forEach(stock => {\n        if (!stocksByIndustry[stock.sector]) {\n            stocksByIndustry[stock.sector] = [];\n        }\n        stocksByIndustry[stock.sector].push(stock);\n    });\n\n    // If industry filter is not \"ALL\", only show that industry\n    if (industryFilter !== \"ALL\") {\n        const filteredStocks = stocksByIndustry[industryFilter] || [];\n\n        if (filteredStocks.length > 0) {\n            let stockMessage = \"\";\n\n            filteredStocks.forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                stockMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(stockMessage);\n        } else {\n            await player.pm(`No stocks found in the ${industryFilter} industry.`);\n        }\n    } else {\n        // Send each industry as a separate message\n        for (const industryId in stocksByIndustry) {\n            let industryMessage = `=== ${industryId} INDUSTRY ===\\n`;\n\n            stocksByIndustry[industryId].forEach(stock => {\n                let changeIcon = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    changeIcon = percentChange > 0 ? `â†‘ ${percentChange.toFixed(1)}%` :\n                        percentChange < 0 ? `â†“ ${Math.abs(percentChange).toFixed(1)}%` : 'â†’';\n                }\n\n                industryMessage += `${stock.id}: $${Math.round(stock.price)} ${changeIcon}\\n`;\n            });\n\n            await player.pm(industryMessage);\n        }\n    }\n\n    // Add a help message for industry filtering if showing all industries\n    if (industryFilter === \"ALL\") {\n        const allIndustries = Object.keys(stocksByIndustry).join(', ');\n        await player.pm(`\\nTip: Use '/markets [industry]' to view only stocks in a specific industry. Available industries: ${allIndustries}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return false;\n        }\n\n        // Check for each required variable first\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_data'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['last_market_event_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['stock_market_initialized'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Create each variable only if it doesn't exist already\n        const createPromises = [];\n\n        // Store the stocks data if it doesn't exist\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_data',\n                    value: JSON.stringify(stocks),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize last event time if it doesn't exist\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize event start time variable if it doesn't exist\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Initialize active event if it doesn't exist\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: '',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Mark market as initialized if not already marked\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'stock_market_initialized',\n                    value: 'true',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all creation promises to complete\n        if (createPromises.length > 0) {\n            const results = await Promise.allSettled(createPromises);\n            // Check if the critical stock_market_data was created successfully\n            const stockDataPromise = results[0];\n            if (stockDataPromise && stockDataPromise.status === 'rejected') {\n                console.log(`Failed to create stock_market_data: ${stockDataPromise.reason}`);\n                return false;\n            }\n        }\n\n        return true;\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n        return false;\n    }\n}\n\nawait main();",
                    "name": "markets",
                    "description": null,
                    "trigger": "markets",
                    "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. \n",
                    "arguments": [
                        {
                            "name": "Industry",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "View stock market prices and activity. Use '/markets ALL' to see all industries, or specify an industry name (e.g., '/markets TECH') to see stocks in that industry only. ",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_USE')) {\n        throw new TakaroUserError(\"You don't have permission to use the stock market.\");\n    }\n\n    // Get current stock data\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n    }\n\n    const stocks = JSON.parse(marketDataVar.data.data[0].value);\n\n    // If a specific stock ticker is provided, show detailed info for that stock\n    const specificTicker = args.ticker ? args.ticker.toUpperCase() : null;\n\n    if (specificTicker && specificTicker !== \"ALL\") {\n        const stock = stocks.find(s => s.id.toUpperCase() === specificTicker);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${specificTicker} not found. Use /stockinfo without parameters to see all available stocks.`);\n        }\n\n        // Get active event to see if this stock's sector is affected\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let activeEvent = null;\n        let sectorImpact = null;\n\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEvent && activeEvent.sectorImpacts) {\n                    sectorImpact = activeEvent.sectorImpacts.find(impact =>\n                        impact.sectorId === stock.sector\n                    );\n                }\n            } catch (e) {\n                // Ignore parsing errors\n            }\n        }\n\n        // Calculate price change indicators\n        let changeText = '';\n        if (stock.lastPrice) {\n            const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n            const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n            changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n        }\n\n        // Add risk assessment based on volatility without showing the raw value\n        let riskLevel;\n        if (stock.volatility <= 0.05) riskLevel = \"Very Low\";\n        else if (stock.volatility <= 0.10) riskLevel = \"Low\";\n        else if (stock.volatility <= 0.15) riskLevel = \"Moderate\";\n        else if (stock.volatility <= 0.20) riskLevel = \"High\";\n        else riskLevel = \"Very High\";\n\n        // Build detailed stock info message\n        let message = `=== ${stock.id}: ${stock.name} ===\\n\\n`;\n        message += `Sector: ${stock.sector}\\n`;\n        message += `Current Price: $${Math.round(stock.price)}${changeText}\\n`;\n        message += `Risk Level: ${riskLevel}\\n`;\n\n        // Add sector trend info if available from event\n        if (activeEvent && sectorImpact) {\n            const direction = sectorImpact.impact >= 0 ? \"Positive\" : \"Negative\";\n            const strength = Math.abs(sectorImpact.impact);\n            let trend;\n\n            if (strength < 10) trend = \"Slight\";\n            else if (strength < 25) trend = \"Moderate\";\n            else trend = \"Strong\";\n\n            message += `\\nCurrent Trend: ${trend} ${direction} (${activeEvent.name})\\n`;\n            message += `Event: ${activeEvent.description}\\n`;\n        }\n\n        // Add trading guidance based on sector and risk, without mentioning volatility\n        message += `\\nTrading Notes:\\n`;\n\n        if (activeEvent && sectorImpact) {\n            if (sectorImpact.impact > 0) {\n                message += `- Currently bullish due to the ${activeEvent.name} event\\n`;\n            } else {\n                message += `- Currently bearish due to the ${activeEvent.name} event\\n`;\n            }\n        }\n\n        if (riskLevel === \"High\" || riskLevel === \"Very High\") {\n            message += `- Expect significant price fluctuations with this stock\\n`;\n        } else if (riskLevel === \"Low\" || riskLevel === \"Very Low\") {\n            message += `- Typically has stable price movement\\n`;\n        }\n\n        message += `\\nUse /buystock ${stock.id} [amount] to purchase shares`;\n\n        await player.pm(message);\n\n    } else {\n        // No specific ticker provided or ALL specified, show summary of all stocks\n        await player.pm(\"=== STOCK MARKET LISTINGS ===\\n\");\n\n        // Group stocks by sector\n        const stocksBySector = {};\n        stocks.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        // Display stocks by sector\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            let sectorMessage = `\\n--- ${sector} SECTOR ---\\n`;\n\n            sectorStocks.forEach(stock => {\n                // Add price change indicators\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                    changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                // Add risk level based on volatility\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                sectorMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n\n            await player.pm(sectorMessage);\n        }\n\n        // Add legend for risk indicators\n        const legend = \"\\n=== LEGEND ===\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\" +\n            \"Use /stockinfo [ticker] for detailed information about a specific stock\";\n\n        await player.pm(legend);\n    }\n}\n\nawait main();",
                    "name": "stockinfo",
                    "description": null,
                    "trigger": "stockinfo",
                    "helpText": "Shows all available stocks in the market. Use with a ticker symbol (e.g., /stockinfo ticker) to see detailed information about a specific stock.",
                    "arguments": [
                        {
                            "name": "ticker",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "stock ticker or ALL to get detailed information about a specific stock",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRADE')) {\n        throw new TakaroUserError(\"You don't have permission to trade stocks.\");\n    }\n\n    // Validate input parameters\n    if (!args.stock) {\n        throw new TakaroUserError(\"Please specify a stock ticker. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    // Convert amount to integer and validate\n    const amount = parseInt(args.amount);\n    if (isNaN(amount) || amount <= 0) {\n        throw new TakaroUserError(\"Amount must be a positive whole number. Usage: /sellstock STOCK AMOUNT\");\n    }\n\n    try {\n        // Get player's portfolio\n        const portfolioVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_portfolio'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId],\n                playerId: [player.id]\n            }\n        });\n\n        if (portfolioVar.data.data.length === 0) {\n            throw new TakaroUserError(\"You don't own any stocks to sell.\");\n        }\n\n        const portfolio = JSON.parse(portfolioVar.data.data[0].value);\n        const stockId = args.stock.toUpperCase();\n\n        if (!portfolio[stockId] || portfolio[stockId].shares < amount) {\n            throw new TakaroUserError(`You don't own ${amount} shares of ${stockId}.`);\n        }\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (marketDataVar.data.data.length === 0) {\n            throw new TakaroUserError(\"The stock market isn't available right now. Please try again later.\");\n        }\n\n        const stocks = JSON.parse(marketDataVar.data.data[0].value);\n        const stock = stocks.find(s => s.id.toUpperCase() === stockId);\n\n        if (!stock) {\n            throw new TakaroUserError(`Stock ${stockId} not found in current market data. Please contact an admin.`);\n        }\n\n        // Calculate transaction fee - using integers to avoid floating point issues\n        let feePercentage = mod.userConfig.transactionFee || 5;\n\n        // Check for VIP discount\n        if (checkPermission(data.pog, 'STOCK_MARKET_BROKER')) {\n            const discount = (mod.userConfig.vipDiscount || 50) / 100; // Convert to decimal\n            feePercentage = feePercentage * (1 - discount);\n        }\n\n        // Calculate sale proceeds using Math.round to ensure we work with integers\n        const stockPrice = Math.round(stock.price);\n        const subtotal = stockPrice * amount;\n        const fee = Math.round((subtotal * feePercentage) / 100);\n        const netProceeds = subtotal - fee;\n\n        // Add money to player - using integer value to avoid precision errors\n        await takaro.playerOnGameserver.playerOnGameServerControllerAddCurrency(\n            gameServerId,\n            player.id,\n            {\n                currency: netProceeds\n            }\n        );\n\n        // Calculate profit/loss\n        const profitPerShare = stockPrice - portfolio[stockId].averagePrice;\n        const totalProfit = Math.round(profitPerShare * amount);\n        const profitText = totalProfit >= 0\n            ? `profit of $${totalProfit}`\n            : `loss of $${Math.abs(totalProfit)}`;\n\n        // Update portfolio\n        portfolio[stockId].shares -= amount;\n        if (portfolio[stockId].shares === 0) {\n            delete portfolio[stockId];\n        }\n\n        // Save updated portfolio\n        await takaro.variable.variableControllerUpdate(portfolioVar.data.data[0].id, {\n            value: JSON.stringify(portfolio)\n        });\n\n        // Track this transaction in transaction history\n        await recordTransaction(gameServerId, mod.moduleId, player.id, {\n            type: 'SELL',\n            stockId: stock.id,\n            shares: amount,\n            pricePerShare: stockPrice,\n            subtotal: subtotal,\n            fee: fee,\n            total: netProceeds,\n            profit: totalProfit,\n            timestamp: new Date().toISOString()\n        });\n\n        let message = `Successfully sold ${amount} shares of ${stockId} at $${stockPrice} each.\\n`;\n        message += `Subtotal: $${subtotal}\\n`;\n        message += `Transaction fee: $${fee}\\n`;\n        message += `Net proceeds: $${netProceeds} (${profitText})`;\n\n        // Add remaining shares info if player still has some\n        if (portfolio[stockId]) {\n            message += `\\nRemaining shares: ${portfolio[stockId].shares}`;\n        } else {\n            message += `\\nYou've sold all your ${stockId} shares.`;\n        }\n\n        await player.pm(message);\n\n    } catch (error) {\n        // If it's our custom error, just pass it through\n        if (error instanceof TakaroUserError) {\n            throw error;\n        }\n\n        // For unexpected errors, log them and provide a friendlier message\n        console.error(\"Error in sellstock command:\", error);\n        throw new TakaroUserError(\"An error occurred while processing your sale. Please try again later.\");\n    }\n}\n\n// Record transaction history for reporting and analytics\nasync function recordTransaction(gameServerId, moduleId, playerId, transaction) {\n    try {\n        const historyVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_transaction_history'],\n                gameServerId: [gameServerId],\n                moduleId: [moduleId],\n                playerId: [playerId]\n            }\n        });\n\n        let history = [];\n        if (historyVar.data.data.length > 0) {\n            history = JSON.parse(historyVar.data.data[0].value);\n        }\n\n        // Add new transaction to history\n        history.push(transaction);\n\n        // Keep only the last 50 transactions to avoid variable size limits\n        if (history.length > 50) {\n            history = history.slice(history.length - 50);\n        }\n\n        if (historyVar.data.data.length === 0) {\n            await takaro.variable.variableControllerCreate({\n                key: 'stock_transaction_history',\n                value: JSON.stringify(history),\n                gameServerId,\n                moduleId,\n                playerId\n            });\n        } else {\n            await takaro.variable.variableControllerUpdate(historyVar.data.data[0].id, {\n                value: JSON.stringify(history)\n            });\n        }\n    } catch (error) {\n        // Don't let transaction history errors prevent the main operation\n        console.error(\"Error recording transaction history:\", error);\n    }\n}\n\nawait main();",
                    "name": "sellstock",
                    "description": null,
                    "trigger": "sellstock",
                    "helpText": "Sell shares of a stock",
                    "arguments": [
                        {
                            "name": "stock",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "The stock ticker symbol",
                            "position": 0
                        },
                        {
                            "name": "amount",
                            "type": "number",
                            "defaultValue": "",
                            "helpText": "Number of shares to sell",
                            "position": 1
                        }
                    ]
                },
                {
                    "function": "import { takaro, data, TakaroUserError, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { player, gameServerId, module: mod, arguments: args } = data;\n\n    // Check permission\n    if (!checkPermission(data.pog, 'STOCK_MARKET_TRIGGER_EVENT')) {\n        throw new TakaroUserError(\"You don't have permission to trigger market events.\");\n    }\n\n    try {\n        // Get current stock data to check market initialization\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Initialize market if needed\n        if (marketDataVar.data.data.length === 0) {\n            await initializeMarketIfNeeded(gameServerId, mod);\n            await player.pm(\"Market was not initialized. Initializing now...\");\n            return;\n        }\n\n        // Get events from module config\n        const marketEvents = mod.userConfig.marketEvents || [];\n\n        if (marketEvents.length === 0) {\n            throw new TakaroUserError(\"No market events configured in this module.\");\n        }\n\n        // Handle case when no event is specified or \"ALL\" is provided\n        if (!args.EventName || args.EventName.toUpperCase() === \"ALL\") {\n            await player.pm(\"=== AVAILABLE MARKET EVENTS ===\\n\");\n\n            // Group events by category or type if possible\n            const eventCategories = {};\n\n            // Create a simple categorization based on positive/negative impact\n            marketEvents.forEach(event => {\n                let category = \"Mixed\";\n                // Calculate net impact across all sectors\n                const netImpact = event.sectorImpacts.reduce((sum, impact) => sum + impact.impact, 0);\n\n                if (netImpact > 0) category = \"Positive\";\n                else if (netImpact < 0) category = \"Negative\";\n\n                if (!eventCategories[category]) {\n                    eventCategories[category] = [];\n                }\n                eventCategories[category].push(event);\n            });\n\n            // Display events by category\n            for (const [category, events] of Object.entries(eventCategories)) {\n                if (events.length > 0) {\n                    await player.pm(`\\n--- ${category.toUpperCase()} EVENTS ---`);\n\n                    let message = \"\";\n                    events.forEach(event => {\n                        // Format primary sectors affected\n                        const primarySectors = event.sectorImpacts\n                            .filter(impact => Math.abs(impact.impact) >= 15)\n                            .map(impact => {\n                                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                                return `${impact.sectorId} ${direction}${Math.abs(impact.impact)}%`;\n                            })\n                            .join(\", \");\n\n                        message += `${event.id}: ${event.name}\\n`;\n                        message += `   ${event.description}\\n`;\n                        if (primarySectors) {\n                            message += `   Major impacts: ${primarySectors}\\n`;\n                        }\n                        message += \"\\n\";\n                    });\n\n                    await player.pm(message);\n                }\n            }\n\n            await player.pm(\"=== HOW TO USE ===\\nUse `/triggerevent <EventName>` to trigger a specific event (e.g., `/triggerevent TECH_BOOM`)\");\n            return;\n        }\n\n        // Find the requested event\n        const eventId = args.EventName.toUpperCase();\n        const event = marketEvents.find(e => e.id === eventId);\n\n        if (!event) {\n            throw new TakaroUserError(`Event \"${eventId}\" not found. Use /triggerevent without parameters to see all available events.`);\n        }\n\n        // Get necessary variables for managing the event\n        const [activeEventVar, eventStartTimeVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['active_market_event'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_start_time'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_execution_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['event_cooldown_counter'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                }),\n                takaro.variable.variableControllerSearch({\n                    filters: {\n                        key: ['current_event_duration'],\n                        gameServerId: [gameServerId],\n                        moduleId: [mod.moduleId]\n                    }\n                })\n            ]);\n\n        // Check if there's an active event we need to cancel\n        let activeEventObj = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEventObj = JSON.parse(activeEventVar.data.data[0].value);\n                if (activeEventObj && Object.keys(activeEventObj).length > 0) {\n                    await player.pm(`Cancelling active event \"${activeEventObj.name}\" to trigger new event.`);\n                }\n            } catch (e) {\n                // Invalid event data, will be overwritten\n            }\n        }\n\n        // Generate a random duration for the event\n        const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        const randomDuration = Math.floor(Math.random() * maxDuration) + 1; // 1 to maxDuration\n\n        // Update or create all event-related variables\n        const updatePromises = [];\n\n        // Save or update the random duration\n        if (eventDurationVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                    value: randomDuration.toString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'current_event_duration',\n                    value: randomDuration.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the event counter to 0\n        if (eventCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Reset the cooldown counter\n        if (cooldownCounterVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: '0'\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: '0',\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update active event\n        if (activeEventVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                    value: JSON.stringify(event)\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'active_market_event',\n                    value: JSON.stringify(event),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update event start time\n        if (eventStartTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'event_start_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Update last event time\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        if (lastEventTimeVar.data.data.length > 0) {\n            updatePromises.push(\n                takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                    value: new Date().toISOString()\n                })\n            );\n        } else {\n            updatePromises.push(\n                takaro.variable.variableControllerCreate({\n                    key: 'last_market_event_time',\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                })\n            );\n        }\n\n        // Wait for all updates to complete\n        await Promise.all(updatePromises);\n\n        // Check if there are online players to announce the event\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            // Format sector impacts for announcement\n            let impactText = \"\";\n            for (const impact of event.sectorImpacts) {\n                const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n            }\n\n            const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${event.name}\\n${event.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /markets to see opportunities!`;\n\n            // Split the message if it's too long\n            const maxLength = 400; // Safe limit for most games\n            for (let i = 0; i < message.length; i += maxLength) {\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message: message.substring(i, i + maxLength)\n                });\n            }\n        }\n\n        await player.pm(`Successfully triggered the \"${event.name}\" market event for ${randomDuration} cycles!`);\n    } catch (error) {\n        // If something goes wrong, log it and let the player know\n        console.log(`Error in triggerEvent: ${error.message}`);\n        throw new TakaroUserError(`Error triggering event: ${error.message}`);\n    }\n}\n\n// Initialize the market with stocks from the configuration\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        // Get stocks from config\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in configuration\");\n            return;\n        }\n\n        // Map config stocks to our internal format\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n\n        // Store the stocks data\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_data',\n            value: JSON.stringify(stocks),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize last event time to now\n        await takaro.variable.variableControllerCreate({\n            key: 'last_market_event_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize event start time variable\n        await takaro.variable.variableControllerCreate({\n            key: 'event_start_time',\n            value: new Date().toISOString(),\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Initialize active event (empty string means no active event)\n        await takaro.variable.variableControllerCreate({\n            key: 'active_market_event',\n            value: '',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Mark market as initialized\n        await takaro.variable.variableControllerCreate({\n            key: 'stock_market_initialized',\n            value: 'true',\n            gameServerId,\n            moduleId: mod.moduleId\n        });\n\n        // Announce market initialization to online players\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        if (onlinePlayers.data.meta.total > 0) {\n            const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /markets to see available stocks and /buystock to start investing.\";\n\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message\n            });\n        }\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "triggerevent",
                    "description": null,
                    "trigger": "triggerevent",
                    "helpText": "Shows all available market events when run without parameters. Use with an event name (e.g., /triggerevent TECH_BOOM) to trigger a specific market event.",
                    "arguments": [
                        {
                            "name": "EventName",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "Event name to trigger a specific market event",
                            "position": 0
                        }
                    ]
                }
            ],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n\n    // Get the Discord channel ID from module configuration\n    // IMPORTANT: You need to add 'marketNewsChannelId' to your module's configSchema and set its value.\n    const discordChannelId = mod.userConfig.marketNewsChannelId;\n\n    if (!discordChannelId) {\n        takaro.log.info('Market news Discord channel ID (marketNewsChannelId) not configured in module settings. Skipping Discord messages.');\n    }\n\n    // Check for online players\n    const currentPlayers = (await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    })).data.meta;\n\n    if (currentPlayers.total === 0) {\n        takaro.log.info('Skipping daily market report: No players online.');\n        return; // No players online, skip the market news\n    }\n\n    // Get current stock data (which should include lastPrice)\n    const marketDataVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['stock_market_data'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    if (marketDataVar.data.data.length === 0) {\n        takaro.log.warn('Skipping daily market report: Market data variable not found.');\n        return; // Market not initialized yet\n    }\n\n    let stocks;\n    try {\n        stocks = JSON.parse(marketDataVar.data.data[0].value);\n        if (!Array.isArray(stocks)) {\n            throw new Error('Parsed market data is not an array.');\n        }\n    } catch (error) {\n        takaro.log.error(`Failed to parse stock_market_data: ${error}`);\n        return; // Invalid market data\n    }\n\n    // Get active market event\n    const activeEventVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['active_market_event'],\n            gameServerId: [gameServerId],\n            moduleId: [mod.moduleId]\n        }\n    });\n\n    let activeEvent = null;\n    if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n        try {\n            activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n            // Ensure activeEvent is an object with data, not an empty string or empty object\n            if (typeof activeEvent !== 'object' || activeEvent === null || Object.keys(activeEvent).length === 0) {\n                activeEvent = null;\n            }\n        } catch (error) {\n            takaro.log.warn(`Failed to parse active_market_event: ${error}`);\n            activeEvent = null; // Continue without event info if parsing fails\n        }\n    }\n\n    // --- Message 1: Header and active event (Game Server Only) ---\n    let gameMessage1 = \"==== DAILY MARKET REPORT ====\\n\";\n\n    if (activeEvent && activeEvent.name && activeEvent.description) {\n        const eventText = `\\nðŸŒ ACTIVE EVENT: ${activeEvent.name} ðŸŒ\\n${activeEvent.description}\\n`;\n        gameMessage1 += eventText;\n    } else {\n        const noEventText = '\\nNo active market events today.\\n';\n        gameMessage1 += noEventText;\n    }\n\n    // Send first part of the report to game server\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage1\n    }).catch(err => takaro.log.error(`Failed to send game message 1: ${err}`));\n\n\n    // --- Calculate stock performance using stock.price and stock.lastPrice ---\n    const stocksWithPerformance = stocks.map(stock => {\n        let change = 0;\n        let percentChange = 0;\n        let changeSymbol = 'â†’'; // Default: No change or insufficient data\n\n        if (typeof stock.price === 'number' && typeof stock.lastPrice === 'number' && stock.lastPrice !== 0) {\n            change = stock.price - stock.lastPrice;\n            percentChange = (change / stock.lastPrice) * 100;\n            if (percentChange > 0.05) {\n                changeSymbol = 'â†‘';\n            } else if (percentChange < -0.05) {\n                changeSymbol = 'â†“';\n            }\n        } else if (typeof stock.price === 'number' && stock.lastPrice === undefined) {\n            changeSymbol = 'ðŸ†•';\n            percentChange = 0;\n        }\n        return {\n            ...stock,\n            change,\n            percentChange,\n            changeSymbol\n        };\n    });\n\n    // --- Group by sector ---\n    const sectorPerformance = {};\n    stocksWithPerformance.forEach(stock => {\n        const sectorId = stock.sector || 'Uncategorized';\n        if (!sectorPerformance[sectorId]) {\n            sectorPerformance[sectorId] = {\n                stocks: [],\n                totalPercentChange: 0,\n                count: 0\n            };\n        }\n        sectorPerformance[sectorId].stocks.push(stock);\n        if (typeof stock.percentChange === 'number' && isFinite(stock.percentChange)) {\n            sectorPerformance[sectorId].totalPercentChange += stock.percentChange;\n            sectorPerformance[sectorId].count++;\n        }\n    });\n\n    // --- Calculate average sector performance ---\n    for (const sectorId in sectorPerformance) {\n        const sectorData = sectorPerformance[sectorId];\n        if (sectorData.count > 0) {\n            sectorData.avgPerformance = sectorData.totalPercentChange / sectorData.count;\n        } else {\n            sectorData.avgPerformance = 0;\n        }\n    }\n\n    const sortedSectors = Object.entries(sectorPerformance)\n        .sort(([, a], [, b]) => b.avgPerformance - a.avgPerformance);\n\n    // --- Message 2: Sector performance (Game Server Only) ---\n    let gameMessage2 = \"\\n=== SECTOR PERFORMANCE ===\\n\";\n\n    if (sortedSectors.length > 0) {\n        sortedSectors.forEach(([sectorId, sectorData]) => {\n            const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n            const line = `${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n            gameMessage2 += line;\n        });\n    } else {\n        const noDataText = \"No sector performance data available.\\n\";\n        gameMessage2 += noDataText;\n    }\n\n    // Send sector performance report to game server\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage2\n    }).catch(err => takaro.log.error(`Failed to send game message 2: ${err}`));\n\n    // --- Message 3: Top and Worst performers (Game Server Only) ---\n    const validPerformers = stocksWithPerformance.filter(s => typeof s.percentChange === 'number' && isFinite(s.percentChange));\n    validPerformers.sort((a, b) => b.percentChange - a.percentChange);\n\n    let gameMessage3 = \"\";\n\n    const topPerformersTitleGame = \"\\nðŸ”¥ TOP PERFORMERS ðŸ”¥\\n\";\n    gameMessage3 += topPerformersTitleGame;\n\n    if (validPerformers.length > 0) {\n        for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n            const stock = validPerformers[i];\n            const line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            gameMessage3 += line;\n        }\n    } else {\n        const noTopText = \"No top performers today.\\n\";\n        gameMessage3 += noTopText;\n    }\n\n    const worstPerformersTitleGame = \"\\nðŸ“‰ WORST PERFORMERS ðŸ“‰\\n\";\n    gameMessage3 += worstPerformersTitleGame;\n\n    if (validPerformers.length > 0) {\n        const worstStartIndex = Math.max(0, validPerformers.length - 3);\n        for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n            const stock = validPerformers[i];\n            const line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n            gameMessage3 += line;\n        }\n    } else {\n        const noWorstText = \"No worst performers today.\\n\";\n        gameMessage3 += noWorstText;\n    }\n\n    // Send top/worst performers report to game server\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: gameMessage3\n    }).catch(err => takaro.log.error(`Failed to send game message 3: ${err}`));\n\n\n    // --- Discord Message: Consolidated Market Report ---\n    if (discordChannelId) {\n        let discordMessage = \"**==== DAILY MARKET REPORT ====**\\n\\n\";\n\n        // Add active event\n        if (activeEvent && activeEvent.name && activeEvent.description) {\n            discordMessage += `ðŸŒ **ACTIVE EVENT: ${activeEvent.name}** ðŸŒ\\n${activeEvent.description}\\n\\n`;\n        } else {\n            discordMessage += 'No active market events today.\\n\\n';\n        }\n\n        // Add sector performance\n        discordMessage += \"**=== SECTOR PERFORMANCE ===**\\n\";\n        if (sortedSectors.length > 0) {\n            sortedSectors.forEach(([sectorId, sectorData]) => {\n                const avgSymbol = sectorData.avgPerformance > 0.05 ? 'â†‘' : sectorData.avgPerformance < -0.05 ? 'â†“' : 'â†’';\n                discordMessage += `${sectorId}: ${avgSymbol} ${Math.abs(sectorData.avgPerformance).toFixed(1)}%\\n`;\n            });\n        } else {\n            discordMessage += \"No sector performance data available.\\n\";\n        }\n        discordMessage += \"\\n\"; // Add a newline for spacing\n\n        // Add Top Performers for Discord\n        discordMessage += \"**ðŸ”¥ TOP PERFORMERS ðŸ”¥**\\n\";\n        if (validPerformers.length > 0) {\n            for (let i = 0; i < Math.min(3, validPerformers.length); i++) {\n                const stock = validPerformers[i];\n                const line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n                discordMessage += line;\n            }\n        } else {\n            discordMessage += \"No top performers today.\\n\";\n        }\n        discordMessage += \"\\n\"; // Add a newline for spacing\n\n        // Add Worst Performers for Discord\n        discordMessage += \"**ðŸ“‰ WORST PERFORMERS ðŸ“‰**\\n\";\n        if (validPerformers.length > 0) {\n            const worstStartIndex = Math.max(0, validPerformers.length - 3);\n            for (let i = validPerformers.length - 1; i >= worstStartIndex; i--) {\n                const stock = validPerformers[i];\n                const line = `${stock.id}: $${Math.round(stock.price)} ${stock.changeSymbol} ${Math.abs(stock.percentChange).toFixed(1)}%\\n`;\n                discordMessage += line;\n            }\n        } else {\n            discordMessage += \"No worst performers today.\\n\";\n        }\n        discordMessage += \"\\n\"; // Add a newline for spacing\n\n        // Add all stock listings\n        discordMessage += \"**=== ALL STOCK LISTINGS ===**\\n\";\n        const stocksBySector = {};\n        stocksWithPerformance.forEach(stock => {\n            if (!stocksBySector[stock.sector]) {\n                stocksBySector[stock.sector] = [];\n            }\n            stocksBySector[stock.sector].push(stock);\n        });\n\n        for (const [sector, sectorStocks] of Object.entries(stocksBySector)) {\n            discordMessage += `\\n--- **${sector} SECTOR** ---\\n`;\n            sectorStocks.forEach(stock => {\n                let changeText = '';\n                if (stock.lastPrice) {\n                    const percentChange = ((stock.price - stock.lastPrice) / stock.lastPrice) * 100;\n                    const changeIcon = percentChange > 0 ? 'â†‘' : percentChange < 0 ? 'â†“' : 'â†’';\n                    changeText = ` ${changeIcon} ${Math.abs(percentChange).toFixed(1)}%`;\n                }\n\n                let riskIndicator;\n                if (stock.volatility <= 0.05) riskIndicator = \"VL\";\n                else if (stock.volatility <= 0.10) riskIndicator = \"L\";\n                else if (stock.volatility <= 0.15) riskIndicator = \"M\";\n                else if (stock.volatility <= 0.20) riskIndicator = \"H\";\n                else riskIndicator = \"VH\";\n\n                discordMessage += `${stock.id} (${riskIndicator}): ${stock.name} - $${Math.round(stock.price)}${changeText}\\n`;\n            });\n        }\n\n        // Add legend for risk indicators\n        discordMessage += \"\\n**=== LEGEND ===**\\n\" +\n            \"Risk Levels: VL=Very Low, L=Low, M=Moderate, H=High, VH=Very High\\n\";\n\n        // Send the consolidated Discord message\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: discordMessage\n        }).catch(err => takaro.log.error(`Failed to send consolidated Discord message: ${err.message || err}`));\n    }\n\n    takaro.log.info('Daily market report sent successfully (game server and potentially Discord).');\n}\n\nawait main();",
                    "name": "marketnews",
                    "description": null,
                    "temporalValue": "1 */1 * * *"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    try {\n        const { gameServerId, module: mod } = data;\n\n        // Get current stock data\n        const marketDataVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['stock_market_data'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Check if market is initialized\n        if (marketDataVar.data.data.length === 0) {\n            console.log(\"Market data not found, initializing...\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return; // Exit after initialization\n        }\n\n        // Get active market event\n        const activeEventVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['active_market_event'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event start time\n        const eventStartTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_start_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event execution counter\n        const eventCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_execution_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get event cooldown counter\n        const cooldownCounterVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['event_cooldown_counter'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let eventCounter = 0;\n        if (eventCounterVar.data.data.length > 0) {\n            eventCounter = parseInt(eventCounterVar.data.data[0].value, 10);\n            console.log(`Event counter: ${eventCounter}`);\n        }\n\n        let cooldownCounter = 0;\n        if (cooldownCounterVar.data.data.length > 0) {\n            cooldownCounter = parseInt(cooldownCounterVar.data.data[0].value, 10);\n            console.log(`Cooldown counter: ${cooldownCounter}`);\n        }\n\n        // Get event duration\n        const eventDurationVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['current_event_duration'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Use stored random duration if available, otherwise use defaultEventDuration\n        let eventDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n        if (eventDurationVar.data.data.length > 0) {\n            eventDuration = parseInt(eventDurationVar.data.data[0].value, 10);\n            console.log(`Event duration: ${eventDuration}`);\n        }\n\n        let activeEvent = null;\n        if (activeEventVar.data.data.length > 0 && activeEventVar.data.data[0].value) {\n            try {\n                activeEvent = JSON.parse(activeEventVar.data.data[0].value);\n                // If it's an empty string, treat as no active event\n                if (!activeEvent || Object.keys(activeEvent).length === 0) {\n                    activeEvent = null;\n                }\n                console.log(`Active event: ${activeEvent ? activeEvent.name : 'None'}`);\n            } catch (e) {\n                // In case of parsing error, consider no active event\n                activeEvent = null;\n                console.log(`Error parsing active event: ${e.message}`);\n            }\n        }\n\n        // Check if the current event should end and increment counter\n        if (activeEvent) {\n            eventCounter++;\n            console.log(`Incremented event counter to: ${eventCounter}`);\n\n            if (eventCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                    value: eventCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_execution_counter',\n                    value: eventCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n\n            if (eventCounter >= eventDuration) {\n                console.log(\"Event duration reached, ending event.\");\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: ''\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_cooldown_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    const message = `ðŸ“ˆ MARKET UPDATE ðŸ“‰\\n\\nThe \"${activeEvent.name}\" event has ended. Markets are returning to normal conditions.`;\n\n                    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                        message: message\n                    });\n                }\n\n                activeEvent = null;\n            }\n        } else {\n            cooldownCounter++;\n            console.log(`Incremented cooldown counter to: ${cooldownCounter}`);\n\n            if (cooldownCounterVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                    value: cooldownCounter.toString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: 'event_cooldown_counter',\n                    value: cooldownCounter.toString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n        }\n\n        const lastEventTimeVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['last_market_event_time'],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        const eventFrequency = (mod.userConfig && mod.userConfig.eventFrequency) || 10;\n        let shouldTriggerEvent = false;\n\n        if (!activeEvent && cooldownCounter >= eventFrequency) {\n            shouldTriggerEvent = Math.random() < 0.5;\n            if (cooldownCounter >= eventFrequency * 2) {\n                shouldTriggerEvent = true;\n            }\n            console.log(`Should trigger new event: ${shouldTriggerEvent}`);\n        }\n\n        if (shouldTriggerEvent) {\n            const events = (mod.userConfig && mod.userConfig.marketEvents) || [];\n            if (events.length > 0) {\n                const randomEvent = events[Math.floor(Math.random() * events.length)];\n                activeEvent = randomEvent;\n                console.log(`New event triggered: ${activeEvent.name}`);\n\n                const maxDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n                const randomDuration = Math.floor(Math.random() * maxDuration) + 1;\n\n                if (eventDurationVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventDurationVar.data.data[0].id, {\n                        value: randomDuration.toString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'current_event_duration',\n                        value: randomDuration.toString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_execution_counter',\n                        value: '0',\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (cooldownCounterVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(cooldownCounterVar.data.data[0].id, {\n                        value: '0'\n                    });\n                }\n\n                if (activeEventVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(activeEventVar.data.data[0].id, {\n                        value: JSON.stringify(activeEvent)\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'active_market_event',\n                        value: JSON.stringify(activeEvent),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (eventStartTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(eventStartTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'event_start_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                if (lastEventTimeVar.data.data.length > 0) {\n                    await takaro.variable.variableControllerUpdate(lastEventTimeVar.data.data[0].id, {\n                        value: new Date().toISOString()\n                    });\n                } else {\n                    await takaro.variable.variableControllerCreate({\n                        key: 'last_market_event_time',\n                        value: new Date().toISOString(),\n                        gameServerId,\n                        moduleId: mod.moduleId\n                    });\n                }\n\n                const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        online: [true]\n                    }\n                });\n\n                if (onlinePlayers.data.meta.total > 0) {\n                    let impactText = \"\";\n                    for (const impact of activeEvent.sectorImpacts) {\n                        const direction = impact.impact >= 0 ? \"â†‘\" : \"â†“\";\n                        impactText += `\\n${impact.sectorId}: ${direction} ${Math.abs(impact.impact)}%`;\n                    }\n\n                    const message = `ðŸŒ BREAKING MARKET NEWS ðŸŒ\\n\\n${activeEvent.name}\\n${activeEvent.description}\\n\\nSector Impacts:${impactText}\\n\\nThis event will influence stock prices! Use /market to see opportunities!`;\n\n                    const maxLength = 400;\n                    for (let i = 0; i < message.length; i += maxLength) {\n                        await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                            message: message.substring(i, i + maxLength)\n                        });\n                    }\n                }\n            }\n        }\n\n        // Get stocks\n        if (!marketDataVar.data.data[0] || !marketDataVar.data.data[0].value) {\n            console.log(\"Market data is empty or invalid after initial check, re-initializing.\");\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        let stocks;\n        try {\n            stocks = JSON.parse(marketDataVar.data.data[0].value);\n            if (!Array.isArray(stocks)) {\n                throw new Error(\"Parsed stocks data is not an array\");\n            }\n            // CRITICAL FIX: Ensure each stock has valid numerical price properties\n            stocks = stocks.map(s => {\n                const sanitizedPrice = typeof s.price === 'number' && s.price > 0 ? s.price : 1;\n                const sanitizedLastPrice = typeof s.lastPrice === 'number' && s.lastPrice > 0 ? s.lastPrice : sanitizedPrice;\n                return {\n                    ...s,\n                    price: sanitizedPrice,\n                    lastPrice: sanitizedLastPrice\n                };\n            });\n            console.log(\"Stocks loaded and sanitized successfully.\");\n            console.log(\"Initial stocks for this cycle:\");\n            stocks.forEach(s => console.log(`  ${s.id}: Price ${s.price}, LastPrice ${s.lastPrice}`));\n\n        } catch (e) {\n            console.log(`Error parsing or sanitizing stock data: ${e.message}`);\n            await initializeMarketIfNeeded(gameServerId, mod);\n            return;\n        }\n\n        const significantChanges = [];\n\n        // Update each stock price\n        stocks.forEach(stock => {\n            // Always capture oldPrice at the very beginning of the iteration\n            const oldPrice = stock.price;\n            // Set lastPrice to the value before this current update cycle for accurate change tracking\n            stock.lastPrice = oldPrice;\n\n            console.log(`Processing stock: ${stock.id}, Old Price: ${oldPrice}`);\n\n            // Define the threshold for \"penny stock\" and the chance/magnitude of a breakout\n            const pennyStockThreshold = 1.9;\n            const breakoutChance = 0.6;\n\n            const targetMinPrice = 2.0;\n            const targetMaxPrice = 10.0;\n\n            let calculatedNewPrice;\n\n            // Check if it's a penny stock and qualifies for a breakout\n            if (oldPrice <= pennyStockThreshold && Math.random() < breakoutChance) {\n                console.log(`${stock.id} is a penny stock (${oldPrice}) and hit breakout chance!`);\n                calculatedNewPrice = targetMinPrice + Math.random() * (targetMaxPrice - targetMinPrice);\n                calculatedNewPrice = Math.max(calculatedNewPrice, oldPrice + 0.01); // Ensure at least a penny increase\n                console.log(`${stock.id} calculated breakout price: ${calculatedNewPrice}`);\n            } else {\n                const randomFactor = Math.random() * 2 - 1;\n                const totalChangePercent = randomFactor * stock.volatility;\n                calculatedNewPrice = oldPrice * (1 + totalChangePercent);\n                console.log(`${stock.id} calculated normal price: ${calculatedNewPrice} (Change: ${totalChangePercent * 100}%)`);\n            }\n\n            let finalPrice = calculatedNewPrice;\n            if (activeEvent) {\n                const sectorImpact = activeEvent.sectorImpacts.find(impact => impact.sectorId === stock.sector);\n                if (sectorImpact) {\n                    const eventImpactPercentage = sectorImpact.impact;\n                    const eventImpactDecimal = eventImpactPercentage / 100;\n                    const randomImpactFactor = 0.5 + Math.random();\n                    const eventImpact = eventImpactDecimal * randomImpactFactor;\n\n                    finalPrice = calculatedNewPrice * (1 + eventImpact);\n                    console.log(`${stock.id} final price after event impact: ${finalPrice} (Event impact: ${eventImpact * 100}%)`);\n                }\n            }\n\n            stock.price = finalPrice;\n\n            if (stock.price < 1) {\n                console.log(`${stock.id} price fell below 1, setting to 1.`);\n                stock.price = 1;\n            }\n\n            const actualPercentChange = ((stock.price - oldPrice) / oldPrice) * 100;\n            console.log(`${stock.id} - Final Price: ${stock.price.toFixed(2)}, Actual Change: ${actualPercentChange.toFixed(2)}%`);\n\n            const changeThreshold = ((mod.userConfig && mod.userConfig.priceAlertThreshold) || 10) / 100;\n            if (Math.abs(actualPercentChange) > changeThreshold * 100) {\n                significantChanges.push({\n                    ...stock,\n                    changePercent: actualPercentChange\n                });\n            }\n        });\n\n        console.log(\"All stocks processed, saving updated prices...\");\n        await takaro.variable.variableControllerUpdate(marketDataVar.data.data[0].id, {\n            value: JSON.stringify(stocks)\n        });\n        console.log(\"Updated prices saved.\");\n\n        if (significantChanges.length > 0) {\n            console.log(\"Significant changes detected, sending alert.\");\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                significantChanges.sort((a, b) => Math.abs(b.changePercent) - Math.abs(a.changePercent));\n                const topChanges = significantChanges.slice(0, Math.min(3, significantChanges.length));\n\n                let message = \"ðŸ“Š STOCK MARKET ALERT ðŸ“Š\\n\";\n                topChanges.forEach(stock => {\n                    const changeDir = stock.changePercent > 0 ? \"up\" : \"down\";\n                    const displayPrice = stock.price.toFixed(2);\n                    const changePercent = Math.abs(Math.round(stock.changePercent));\n\n                    message += `${stock.id} (${stock.sector}): ${changeDir} ${changePercent}% to $${displayPrice}!\\n`;\n                });\n\n                if (activeEvent) {\n                    message += `\\nCurrent market event: ${activeEvent.name}`;\n                }\n\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message\n                });\n            } else {\n                console.log(\"No online players to send alert to.\");\n            }\n        } else {\n            console.log(\"No significant changes to alert players about.\");\n        }\n    } catch (error) {\n        console.log(`FATAL Error in updateStockPrices: ${error.message}`);\n        // Optionally, send an admin message if a fatal error occurs\n        // await takaro.gameserver.gameServerControllerSendMessage(data.gameServerId, {\n        //     message: `ðŸš¨ Market Error: An error occurred during stock update: ${error.message}`\n        // });\n    }\n}\n\nasync function initializeMarketIfNeeded(gameServerId, mod) {\n    try {\n        console.log(\"Initializing market if needed...\");\n        const configStocks = (mod.userConfig && mod.userConfig.stocks) || [];\n\n        if (!configStocks || configStocks.length === 0) {\n            console.log(\"Error: No stocks defined in module configuration for initialization.\");\n            return;\n        }\n\n        const [marketDataVar, lastEventTimeVar, eventStartTimeVar, activeEventVar, marketInitVar, eventCounterVar, cooldownCounterVar, eventDurationVar] =\n            await Promise.all([\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_data'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['last_market_event_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_start_time'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['active_market_event'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['stock_market_initialized'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_execution_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['event_cooldown_counter'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } }),\n                takaro.variable.variableControllerSearch({ filters: { key: ['current_event_duration'], gameServerId: [gameServerId], moduleId: [mod.moduleId] } })\n            ]);\n\n        const stocks = configStocks.map(stock => ({\n            id: stock.id,\n            name: stock.name,\n            sector: stock.sector,\n            price: stock.initialPrice,\n            volatility: stock.volatility / 100, // Convert percentage to decimal\n            lastPrice: stock.initialPrice\n        }));\n        console.log(\"Mapped initial stocks from config.\");\n\n        const createPromises = [];\n\n        if (marketDataVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_data', value: JSON.stringify(stocks), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (lastEventTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'last_market_event_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventStartTimeVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_start_time', value: new Date().toISOString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (activeEventVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'active_market_event', value: '', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_execution_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (cooldownCounterVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'event_cooldown_counter', value: '0', gameServerId, moduleId: mod.moduleId }));\n        }\n        if (eventDurationVar.data.data.length === 0) {\n            const defaultDuration = (mod.userConfig && mod.userConfig.defaultEventDuration) || 5;\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'current_event_duration', value: defaultDuration.toString(), gameServerId, moduleId: mod.moduleId }));\n        }\n        if (marketInitVar.data.data.length === 0) {\n            createPromises.push(takaro.variable.variableControllerCreate({ key: 'stock_market_initialized', value: 'true', gameServerId, moduleId: mod.moduleId }));\n        }\n\n        if (createPromises.length > 0) {\n            console.log(`Creating ${createPromises.length} initial market variables.`);\n            await Promise.allSettled(createPromises);\n        } else {\n            console.log(\"All market variables already exist, no new initialization needed.\");\n        }\n\n        if (marketDataVar.data.data.length === 0) { // Only announce if we actually created the stock_market_data variable\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    online: [true]\n                }\n            });\n\n            if (onlinePlayers.data.meta.total > 0) {\n                const message = \"ðŸ“ˆ STOCK MARKET INITIALIZED ðŸ“ˆ\\n\\nThe stock market is now open for trading! Use /market to see available stocks and /buy to start investing.\";\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, { message });\n            }\n        }\n        console.log(\"Market initialization process complete.\");\n    } catch (error) {\n        console.log(`Error in initializeMarketIfNeeded: ${error.message}`);\n    }\n}\n\nawait main();",
                    "name": "updatestockprices",
                    "description": null,
                    "temporalValue": "0 */1 * * *"
                }
            ],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Allows the player to view market prices and their portfolio",
                    "permission": "STOCK_MARKET_USE",
                    "friendlyName": "Use Stock Market"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows the player to buy and sell stocks",
                    "permission": "STOCK_MARKET_TRADE",
                    "friendlyName": "Trade Stocks"
                },
                {
                    "canHaveCount": false,
                    "description": "VIP status that reduces transaction fees",
                    "permission": "STOCK_MARKET_BROKER",
                    "friendlyName": "Stock Broker"
                },
                {
                    "canHaveCount": false,
                    "description": "Allows admins to manually trigger market events",
                    "permission": "STOCK_MARKET_TRIGGER_EVENT",
                    "friendlyName": "Trigger Market Events"
                }
            ]
        }
    ],
    "takaroVersion": "v0.3.3"
}