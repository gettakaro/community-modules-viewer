{
    "name": "Mad_serverWipe",
    "versions": [
        {
            "tag": "latest",
            "description": "The ServerWipe module provides administrators with a powerful tool to reset server data. It allows selective wiping of player currency, teleport locations, and waypoints with a single command.",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[],\"additionalProperties\":false,\"properties\":{\"wipeCurrency\":{\"title\":\"wipeCurrency\",\"description\":\"Whether to reset all player currency during wipe\",\"default\":false,\"type\":\"boolean\"},\"wipeTeleports\":{\"title\":\"wipeTeleports\",\"description\":\"Whether to delete all teleport locations during wipe.\",\"default\":false,\"type\":\"boolean\"},\"wipeStarterKitClaims\":{\"title\":\"wipeStarterKitClaims\",\"description\":\"wipeStarterKitClaims\",\"default\":false,\"type\":\"boolean\"},\"globalAnnouncement\":{\"title\":\"globalAnnouncement\",\"description\":\"Message to broadcast to all players after the wipe\",\"default\":\"\",\"type\":\"string\"}}}",
            "uiSchema": "{}",
            "commands": [
                {
                    "function": "// commands/wipe_start_batch.js\nimport { takaro, data, checkPermission, TakaroUserError } from '@takaro/helpers';\n\n// --- Configuration ---\nconst PAGE_LIMIT = 100; // Items per fetch\nconst BATCH_SIZE = 100; // Items per concurrent processing batch (Adjust lower if timeouts persist)\nconst PAGES_PER_RUN = 4; // Number of pages to process per command execution (4 * 100 = 400 items)\n\n// --- State Variable Keys ---\nconst STATE_KEYS = {\n    currencyPage: 'wipe_cont_currency_page',\n    teleportsPage: 'wipe_cont_teleports_page',\n    starterKitsPage: 'wipe_cont_starterkits_page',\n    teleportsModuleId: 'wipe_cont_teleports_module_id',\n    waypointsModuleId: 'wipe_cont_waypoints_module_id'\n};\n\n// --- State Management Helpers (defined within this command) ---\n// It's highly recommended to use the import from wipeHelpers.js instead of duplicating these.\nasync function getStateVariable(key, gameServerId, moduleId) {\n    const existingVar = await takaro.variable.variableControllerSearch({\n        filters: { key: [key], gameServerId: [gameServerId], moduleId: [moduleId] },\n        limit: 1\n    });\n    if (existingVar.data.data.length > 0) {\n        try { return JSON.parse(existingVar.data.data[0].value) ?? 0; }\n        catch (e) { console.error(`State Error (Get: ${key}): ${e}`); return 0; }\n    }\n    return 0;\n}\n\nasync function setStateVariable(key, value, gameServerId, moduleId) {\n    const existingVar = await takaro.variable.variableControllerSearch({\n        filters: { key: [key], gameServerId: [gameServerId], moduleId: [moduleId] },\n        limit: 1\n    });\n    const valueString = JSON.stringify(value);\n    if (existingVar.data.data.length > 0) {\n        if (existingVar.data.data[0].value !== valueString) {\n            console.log(`State Set: ${key} = ${valueString}`);\n            await takaro.variable.variableControllerUpdate(existingVar.data.data[0].id, { value: valueString });\n        }\n    } else {\n        console.log(`State Create: ${key} = ${valueString}`);\n        await takaro.variable.variableControllerCreate({ key, value: valueString, gameServerId, moduleId });\n    }\n}\n// --- End State Helpers ---\n\n\n// --- Main Function ---\nasync function main() {\n    const { player, module: mod, gameServerId, arguments: args, pog } = data;\n    const wipeType = args.target?.toLowerCase();\n    const wipeAll = wipeType === 'all';\n\n    // --- Initial Checks ---\n    if (!checkPermission(pog, 'SERVER_WIPE')) throw new TakaroUserError('Permission denied.');\n    if (!args.confirm || args.confirm.toString().toLowerCase() !== 'true') throw new TakaroUserError('Please confirm with `true`. Usage: /wipe_start_batch {type|all} true');\n    if (!wipeType) throw new TakaroUserError('Specify target: all, currency, teleports, or starterkits.');\n\n    await player.pm(`Starting initial wipe batch (~${PAGES_PER_RUN * PAGE_LIMIT} items) for: ${wipeType}...`);\n\n    // --- Reset State & Find Module IDs ---\n    console.log('Wipe Start: Resetting state variables...');\n    await setStateVariable(STATE_KEYS.currencyPage, 0, gameServerId, mod.moduleId);\n    await setStateVariable(STATE_KEYS.teleportsPage, 0, gameServerId, mod.moduleId);\n    await setStateVariable(STATE_KEYS.starterKitsPage, 0, gameServerId, mod.moduleId);\n\n    const teleportsModule = await takaro.module.moduleControllerSearch({ filters: { name: ['teleports'] } });\n    const teleportsModuleId = teleportsModule.data.data.length > 0 ? teleportsModule.data.data[0].id : null;\n    await setStateVariable(STATE_KEYS.teleportsModuleId, teleportsModuleId, gameServerId, mod.moduleId);\n\n    const waypointsModule = await takaro.module.moduleControllerSearch({ filters: { name: ['Waypoints'] } });\n    const waypointsModuleId = waypointsModule.data.data.length > 0 ? waypointsModule.data.data[0].id : null;\n    await setStateVariable(STATE_KEYS.waypointsModuleId, waypointsModuleId, gameServerId, mod.moduleId);\n    console.log('Wipe Start: State reset complete.');\n\n    // --- Determine Types ---\n    const typesToProcess = [];\n    if (wipeAll || wipeType === 'currency') typesToProcess.push('currency');\n    if (wipeAll || wipeType === 'teleports') typesToProcess.push('teleports');\n    if (wipeAll || wipeType === 'starterkits') typesToProcess.push('starterkits');\n\n    let overallHasMore = false;\n\n    // --- Process Each Type ---\n    for (const currentType of typesToProcess) {\n        await player.pm(`Processing initial ${PAGES_PER_RUN} pages for ${currentType}...`);\n        console.log(`Wipe Start: Processing type ${currentType}`);\n\n        let currentPageForType = 0;\n        let itemsProcessedThisType = 0;\n        let errorsThisType = 0;\n        let typeHasMore = false;\n        let pagesProcessedThisTypeRun = 0;\n\n        for (let pageIndex = 0; pageIndex < PAGES_PER_RUN; pageIndex++) {\n            currentPageForType = await getStateVariable(STATE_KEYS[`${currentType}Page`], gameServerId, mod.moduleId);\n\n            if (currentPageForType === 0 && pageIndex > 0) {\n                typeHasMore = false;\n                break;\n            }\n\n            console.log(`Wipe Start (${currentType}): Attempting page ${currentPageForType}`);\n            let pageResult = { itemsProcessed: 0, errorCount: 0, hasMore: false };\n\n            try {\n                // *** Page Processing Logic (Duplicated for each type) ***\n                if (currentType === 'currency') {\n                    const pogsResponse = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                        filters: { gameServerId: [gameServerId] }, limit: PAGE_LIMIT, page: currentPageForType\n                    });\n                    const pogs = pogsResponse.data.data; const countOnPage = pogs.length;\n                    if (!pogs || countOnPage === 0) { pageResult.hasMore = false; }\n                    else {\n                        pageResult.hasMore = countOnPage === PAGE_LIMIT;\n                        for (let i = 0; i < countOnPage; i += BATCH_SIZE) {\n                            const batch = pogs.slice(i, i + BATCH_SIZE);\n                            const results = await Promise.allSettled(batch.map(p => takaro.playerOnGameserver.playerOnGameServerControllerSetCurrency(gameServerId, p.playerId, { currency: 0 }).catch(err => ({ status: 'rejected', reason: err }))));\n                            results.forEach(r => { if (r.status === 'fulfilled') pageResult.itemsProcessed++; else pageResult.errorCount++; });\n                        }\n                    }\n                } else if (currentType === 'teleports') {\n                    const tpModuleId = await getStateVariable(STATE_KEYS.teleportsModuleId, gameServerId, mod.moduleId);\n                    if (!tpModuleId) { await player.pm('Skipping teleports: Module ID not found.'); break; }\n                    const varsResponse = await takaro.variable.variableControllerSearch({\n                        filters: { gameServerId: [gameServerId], moduleId: [tpModuleId] }, limit: PAGE_LIMIT, page: currentPageForType\n                    });\n                    const variables = varsResponse.data.data; const countOnPage = variables.length;\n                    if (!variables || countOnPage === 0) { pageResult.hasMore = false; }\n                    else {\n                        pageResult.hasMore = countOnPage === PAGE_LIMIT;\n                        for (let i = 0; i < countOnPage; i += BATCH_SIZE) {\n                            const batch = variables.slice(i, i + BATCH_SIZE);\n                            const results = await Promise.allSettled(batch.map(v => takaro.variable.variableControllerDelete(v.id).catch(err => ({ status: 'rejected', reason: err }))));\n                            results.forEach(r => { if (r.status === 'fulfilled') pageResult.itemsProcessed++; else pageResult.errorCount++; });\n                        }\n                    }\n                } else if (currentType === 'starterkits') {\n                    const varsResponse = await takaro.variable.variableControllerSearch({\n                        filters: { gameServerId: [gameServerId], key: ['t_starterkit_lock'], moduleId: [mod.moduleId] }, limit: PAGE_LIMIT, page: currentPageForType\n                    });\n                    const variables = varsResponse.data.data; const countOnPage = variables.length;\n                    if (!variables || countOnPage === 0) { pageResult.hasMore = false; }\n                    else {\n                        pageResult.hasMore = countOnPage === PAGE_LIMIT;\n                        for (let i = 0; i < countOnPage; i += BATCH_SIZE) {\n                            const batch = variables.slice(i, i + BATCH_SIZE);\n                            const results = await Promise.allSettled(batch.map(v => takaro.variable.variableControllerDelete(v.id).catch(err => ({ status: 'rejected', reason: err }))));\n                            results.forEach(r => { if (r.status === 'fulfilled') pageResult.itemsProcessed++; else pageResult.errorCount++; });\n                        }\n                    }\n                }\n                // *** End Duplicated Logic ***\n\n                itemsProcessedThisType += pageResult.itemsProcessed;\n                errorsThisType += pageResult.errorCount;\n                typeHasMore = pageResult.hasMore;\n                pagesProcessedThisTypeRun++;\n\n                if (!typeHasMore) {\n                    console.log(`Wipe Start (${currentType}): Reached end at page ${currentPageForType}`);\n                    await setStateVariable(STATE_KEYS[`${currentType}Page`], 0, gameServerId, mod.moduleId);\n                    break;\n                } else {\n                    await setStateVariable(STATE_KEYS[`${currentType}Page`], currentPageForType + 1, gameServerId, mod.moduleId);\n                }\n\n            } catch (error) {\n                console.error(`Wipe Start (${currentType}): Error processing page ${currentPageForType}: ${error}`);\n                await player.pm(`Error during ${currentType} wipe on page ${currentPageForType + 1}. Use continue command to retry.`);\n                await setStateVariable(STATE_KEYS[`${currentType}Page`], currentPageForType, gameServerId, mod.moduleId);\n                typeHasMore = true;\n                break;\n            }\n        } // End page loop (PAGES_PER_RUN)\n\n        await player.pm(`Initial batch for ${currentType}: Processed ${itemsProcessedThisType} items across ${pagesProcessedThisTypeRun} pages with ${errorsThisType} errors.`);\n        if (typeHasMore) {\n            await player.pm(`More ${currentType} items remain. Use /wipe_continue_batch ${currentType}`);\n            overallHasMore = true;\n        } else {\n            await player.pm(`${currentType} wipe completed.`);\n        }\n    } // End loop over types\n\n    // --- Final Message & Announcement ---\n    if (!overallHasMore) {\n        await player.pm(\"Initial wipe batch finished, and all targeted items completed.\");\n        if (wipeAll && mod.userConfig.globalAnnouncement?.length > 0) {\n            try { await takaro.gameserver.gameServerControllerSendMessage(gameServerId, { message: mod.userConfig.globalAnnouncement }); }\n            catch (error) { console.error(`Announcement Error: ${error}`); await player.pm(\"Error sending final announcement.\"); }\n        }\n    } else {\n        await player.pm(\"Initial wipe batch finished. Use /wipe_continue_batch {type} for remaining items.\");\n    }\n    console.log('Wipe Start: Finished.');\n\n    // *** ADD EXPLICIT RETURN HERE ***\n    return { success: true };\n}\n\nawait main();",
                    "name": "wipe",
                    "description": "Careful, this command can wipe your server's currency and teleports/waypoints.",
                    "trigger": "wipe",
                    "helpText": "Wipe server data according to configuration",
                    "arguments": [
                        {
                            "name": "confirm",
                            "type": "boolean",
                            "defaultValue": "false",
                            "helpText": "Confirm wipe operation (must be true to execute)",
                            "position": 1
                        },
                        {
                            "name": "target",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "What to wipe: all, currency, teleports, waypoints, or starterkits",
                            "position": 0
                        }
                    ]
                },
                {
                    "function": "// commands/wipe_continue_batch.js\nimport { takaro, data, checkPermission, TakaroUserError } from '@takaro/helpers';\n\n// --- Configuration ---\nconst PAGE_LIMIT = 100; // Items per fetch\nconst BATCH_SIZE = 100; // Items per concurrent processing batch (Adjust lower if timeouts persist)\nconst PAGES_PER_RUN = 4; // Number of pages to process per command execution (4 * 100 = 400 items)\n\n// --- State Variable Keys ---\nconst STATE_KEYS = {\n    currencyPage: 'wipe_cont_currency_page',\n    teleportsPage: 'wipe_cont_teleports_page',\n    starterKitsPage: 'wipe_cont_starterkits_page',\n    teleportsModuleId: 'wipe_cont_teleports_module_id',\n    waypointsModuleId: 'wipe_cont_waypoints_module_id'\n};\n\n// --- State Management Helpers (defined within this command) ---\n// It's highly recommended to use the import from wipeHelpers.js instead of duplicating these.\nasync function getStateVariable(key, gameServerId, moduleId) {\n    const existingVar = await takaro.variable.variableControllerSearch({\n        filters: { key: [key], gameServerId: [gameServerId], moduleId: [moduleId] },\n        limit: 1\n    });\n    if (existingVar.data.data.length > 0) {\n        try { return JSON.parse(existingVar.data.data[0].value) ?? 0; }\n        catch (e) { console.error(`State Error (Get: ${key}): ${e}`); return 0; }\n    }\n    return 0;\n}\n\nasync function setStateVariable(key, value, gameServerId, moduleId) {\n    const existingVar = await takaro.variable.variableControllerSearch({\n        filters: { key: [key], gameServerId: [gameServerId], moduleId: [moduleId] },\n        limit: 1\n    });\n    const valueString = JSON.stringify(value);\n    if (existingVar.data.data.length > 0) {\n        if (existingVar.data.data[0].value !== valueString) {\n            console.log(`State Set: ${key} = ${valueString}`);\n            await takaro.variable.variableControllerUpdate(existingVar.data.data[0].id, { value: valueString });\n        }\n    } else {\n        console.log(`State Create: ${key} = ${valueString}`);\n        await takaro.variable.variableControllerCreate({ key, value: valueString, gameServerId, moduleId });\n    }\n}\n// --- End State Helpers ---\n\n\n// --- Main Function ---\nasync function main() {\n    const { player, module: mod, gameServerId, arguments: args, pog } = data;\n    const wipeType = args.type?.toLowerCase();\n\n    // --- Initial Checks ---\n    if (!checkPermission(pog, 'SERVER_WIPE')) throw new TakaroUserError('Permission denied.');\n    if (!wipeType || !['currency', 'teleports', 'starterkits'].includes(wipeType)) throw new TakaroUserError('Specify type: currency, teleports, or starterkits.');\n\n    await player.pm(`Continuing wipe (~${PAGES_PER_RUN * PAGE_LIMIT} items) for: ${wipeType}...`);\n    console.log(`Wipe Continue: Starting run for ${wipeType}`);\n\n    // --- Determine State Key & Function ---\n    let stateKeyPage = '';\n    let processingFunction = null;\n    let functionArgs = []; // Arguments for the processing function, page added dynamically\n\n    switch (wipeType) {\n        case 'currency':\n            stateKeyPage = STATE_KEYS.currencyPage;\n            // Define inline processing function for currency\n            processingFunction = async (page, gameServerId) => {\n                let itemsProcessed = 0, errorCount = 0, hasMore = false;\n                const pogsResponse = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({ filters: { gameServerId: [gameServerId] }, limit: PAGE_LIMIT, page: page });\n                const pogs = pogsResponse.data.data; const countOnPage = pogs.length;\n                if (!pogs || countOnPage === 0) return { itemsProcessed: 0, errorCount: 0, hasMore: false };\n                hasMore = countOnPage === PAGE_LIMIT;\n                for (let i = 0; i < countOnPage; i += BATCH_SIZE) {\n                    const batch = pogs.slice(i, i + BATCH_SIZE);\n                    const results = await Promise.allSettled(batch.map(p => takaro.playerOnGameserver.playerOnGameServerControllerSetCurrency(gameServerId, p.playerId, { currency: 0 }).catch(err => ({ status: 'rejected', reason: err }))));\n                    results.forEach(r => { if (r.status === 'fulfilled') itemsProcessed++; else errorCount++; });\n                }\n                return { itemsProcessed, errorCount, hasMore };\n            };\n            functionArgs = [gameServerId]; // Arguments excluding page\n            break;\n        case 'teleports':\n        case 'starterkits': // Combine logic as they both use processVariablePage\n            stateKeyPage = (wipeType === 'teleports') ? STATE_KEYS.teleportsPage : STATE_KEYS.starterKitsPage;\n            let identifier, typeName;\n            if (wipeType === 'teleports') {\n                identifier = await getStateVariable(STATE_KEYS.teleportsModuleId, gameServerId, mod.moduleId);\n                typeName = 'Teleport';\n                if (!identifier) throw new TakaroUserError(`Cannot continue ${wipeType}: Module ID not found in state.`);\n                // TODO: Handle Waypoints logic here if needed\n            } else { // starterkits\n                identifier = 'var_key_t_starterkit_lock';\n                typeName = 'Starter Kit';\n            }\n            // Define inline processing function for variables\n            processingFunction = async (page, gameServerId, moduleId, varKeyOrModId, typeNameArg) => {\n                let itemsProcessed = 0, errorCount = 0, hasMore = false;\n                const filters = { gameServerId: [gameServerId] };\n                if (varKeyOrModId.startsWith('var_key_')) { filters.key = [varKeyOrModId.substring(8)]; filters.moduleId = [moduleId]; }\n                else { filters.moduleId = [varKeyOrModId]; }\n                const varsResponse = await takaro.variable.variableControllerSearch({ filters, limit: PAGE_LIMIT, page });\n                const variables = varsResponse.data.data; const countOnPage = variables.length;\n                if (!variables || countOnPage === 0) return { itemsProcessed: 0, errorCount: 0, hasMore: false };\n                hasMore = countOnPage === PAGE_LIMIT;\n                for (let i = 0; i < countOnPage; i += BATCH_SIZE) {\n                    const batch = variables.slice(i, i + BATCH_SIZE);\n                    const results = await Promise.allSettled(batch.map(v => takaro.variable.variableControllerDelete(v.id).catch(err => ({ status: 'rejected', reason: err }))));\n                    results.forEach(r => { if (r.status === 'fulfilled') itemsProcessed++; else errorCount++; });\n                }\n                return { itemsProcessed, errorCount, hasMore };\n            };\n            functionArgs = [gameServerId, mod.moduleId, identifier, typeName]; // Arguments excluding page\n            break;\n        default:\n            throw new TakaroUserError(`Internal error: Unhandled wipe type \"${wipeType}\"`);\n    }\n\n\n    // --- Process Continuation Batches ---\n    let itemsProcessedThisRun = 0;\n    let errorsThisRun = 0;\n    let continueProcessing = true;\n    let pagesProcessedThisRun = 0;\n\n    try {\n        for (let i = 0; i < PAGES_PER_RUN; i++) {\n            const currentPage = await getStateVariable(stateKeyPage, gameServerId, mod.moduleId);\n\n            if (currentPage === 0) {\n                console.log(`Wipe Continue (${wipeType}): Page is 0, indicating completion.`);\n                continueProcessing = false;\n                break;\n            }\n\n            console.log(`Wipe Continue (${wipeType}): Attempting page ${currentPage}`);\n            await player.pm(`Attempting page ${currentPage + 1} for ${wipeType}...`);\n            let pageResult = { itemsProcessed: 0, errorCount: 0, hasMore: false };\n\n            try {\n                // Call the processing function with current page prepended to args\n                pageResult = await processingFunction(currentPage, ...functionArgs);\n                pagesProcessedThisRun++;\n            } catch (pageError) {\n                console.error(`Wipe Continue (${wipeType}): Error processing page ${currentPage}: ${pageError}`);\n                await player.pm(`Error during ${wipeType} wipe on page ${currentPage + 1}. Use continue command again to retry.`);\n                continueProcessing = true;\n                break;\n            }\n\n            itemsProcessedThisRun += pageResult.itemsProcessed;\n            errorsThisRun += pageResult.errorCount;\n            continueProcessing = pageResult.hasMore;\n\n            if (!continueProcessing) {\n                console.log(`Wipe Continue (${wipeType}): Reached end at page ${currentPage}.`);\n                await setStateVariable(stateKeyPage, 0, gameServerId, mod.moduleId);\n                break;\n            } else {\n                await setStateVariable(stateKeyPage, currentPage + 1, gameServerId, mod.moduleId);\n            }\n        } // End page loop\n\n        // --- Report Results ---\n        let summaryMsg = `Continuation batch for ${wipeType} finished.\\nProcessed ${itemsProcessedThisRun} items across ${pagesProcessedThisRun} pages this run with ${errorsThisRun} errors.`;\n\n        if (continueProcessing) {\n            const nextPage = await getStateVariable(stateKeyPage, gameServerId, mod.moduleId);\n            summaryMsg += `\\nMore items remain. Next page to process: ${nextPage}. Run the command again.`;\n        } else {\n            summaryMsg += `\\nAll items for ${wipeType} complete. Page counter reset.`;\n            const currencyPg = await getStateVariable(STATE_KEYS.currencyPage, gameServerId, mod.moduleId);\n            const teleportsPg = await getStateVariable(STATE_KEYS.teleportsPage, gameServerId, mod.moduleId);\n            const starterKitsPg = await getStateVariable(STATE_KEYS.starterKitsPage, gameServerId, mod.moduleId);\n            if (currencyPg === 0 && teleportsPg === 0 && starterKitsPg === 0) {\n                summaryMsg += \"\\n\\nAll wipe tasks appear complete!\";\n                if (mod.userConfig.globalAnnouncement?.length > 0) {\n                    try { await takaro.gameserver.gameServerControllerSendMessage(gameServerId, { message: mod.userConfig.globalAnnouncement }); }\n                    catch (error) { console.error(`Announcement Error: ${error}`); await player.pm(\"Error sending final announcement.\"); }\n                }\n            }\n        }\n        await player.pm(summaryMsg);\n\n    } catch (error) {\n        console.error(`Wipe Continue: Error during setup or loop for ${wipeType}: ${error.stack || error.message}`);\n        throw new TakaroUserError(`Failed processing continuation batch for ${wipeType}: ${error.message}`);\n    }\n    console.log(`Wipe Continue: Finished run for type: ${wipeType}`);\n\n    // *** ADD EXPLICIT RETURN HERE ***\n    return { success: true };\n}\n\nawait main();",
                    "name": "wipecontinue",
                    "description": "Careful, this command can wipe your server's currency and teleports/waypoints. ",
                    "trigger": "wipecontinue",
                    "helpText": "No help text available",
                    "arguments": [
                        {
                            "name": "type",
                            "type": "string",
                            "defaultValue": "",
                            "helpText": "help",
                            "position": 0
                        },
                        {
                            "name": "confirm",
                            "type": "boolean",
                            "defaultValue": "false",
                            "helpText": "help",
                            "position": 1
                        }
                    ]
                }
            ],
            "hooks": [],
            "cronJobs": [],
            "functions": [
                {
                    "function": "// functions/wipeHelpers.js (or define these inside each command if needed)\nimport { takaro } from '@takaro/helpers';\n\nexport const PAGE_LIMIT = 100; // How many items to FETCH per page\nexport const BATCH_SIZE = 100; // How many items to PROCESS concurrently within a page (Adjust if needed)\n\n// --- State Variable Keys ---\nexport const STATE_KEYS = {\n    currencyPage: 'wipe_cont_currency_page',\n    teleportsPage: 'wipe_cont_teleports_page',\n    starterKitsPage: 'wipe_cont_starterkits_page',\n    // We also need to store the module IDs found by the start command\n    teleportsModuleId: 'wipe_cont_teleports_module_id',\n    waypointsModuleId: 'wipe_cont_waypoints_module_id'\n};\n\n// --- Get/Set State ---\nexport async function getStateVariable(key, gameServerId, moduleId) {\n    const existingVar = await takaro.variable.variableControllerSearch({\n        filters: { key: [key], gameServerId: [gameServerId], moduleId: [moduleId] },\n        limit: 1\n    });\n    if (existingVar.data.data.length > 0) {\n        try {\n            const parsed = JSON.parse(existingVar.data.data[0].value);\n            return parsed ?? 0; // Default to 0 if null/undefined after parsing\n        } catch (e) {\n            console.error(`Wipe Helpers: Error parsing state variable ${key}: ${e}. Defaulting to 0.`);\n            return 0;\n        }\n    }\n    console.log(`Wipe Helpers: State variable ${key} not found, defaulting to 0.`);\n    return 0; // Default to 0 if variable doesn't exist\n}\n\nexport async function setStateVariable(key, value, gameServerId, moduleId) {\n    const existingVar = await takaro.variable.variableControllerSearch({\n        filters: { key: [key], gameServerId: [gameServerId], moduleId: [moduleId] },\n        limit: 1\n    });\n    const valueString = JSON.stringify(value);\n    if (existingVar.data.data.length > 0) {\n        if (existingVar.data.data[0].value !== valueString) {\n            console.log(`Wipe Helpers: Updating state variable ${key} to ${valueString}`);\n            await takaro.variable.variableControllerUpdate(existingVar.data.data[0].id, { value: valueString });\n        }\n    } else {\n        console.log(`Wipe Helpers: Creating state variable ${key} with value ${valueString}`);\n        await takaro.variable.variableControllerCreate({\n            key: key, value: valueString, gameServerId, moduleId\n        });\n    }\n}\n\n// --- Process One Page of Currency ---\nexport async function processCurrencyPage(page, gameServerId) {\n    let itemsProcessed = 0;\n    let errorCount = 0;\n    let hasMore = false;\n\n    console.log(`Wipe Helpers: Processing currency page ${page}`);\n\n    const pogsResponse = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: { gameServerId: [gameServerId] },\n        limit: PAGE_LIMIT,\n        page: page\n    });\n\n    const pogs = pogsResponse.data.data;\n    const countOnPage = pogs.length;\n    console.log(`Wipe Helpers: Currency page ${page} fetched ${countOnPage} items.`);\n\n    if (!pogs || countOnPage === 0) {\n        console.log(`Wipe Helpers: Currency page ${page} - No items found.`);\n        return { itemsProcessed: 0, errorCount: 0, hasMore: false };\n    }\n\n    hasMore = countOnPage === PAGE_LIMIT;\n\n    for (let i = 0; i < countOnPage; i += BATCH_SIZE) {\n        const batch = pogs.slice(i, i + BATCH_SIZE);\n        // console.log(`Wipe Helpers: Currency page ${page}, processing batch index ${i} (size ${batch.length})`); // Optional detailed log\n        const results = await Promise.allSettled(\n            batch.map(pogEntry =>\n                takaro.playerOnGameserver.playerOnGameServerControllerSetCurrency(\n                    gameServerId, pogEntry.playerId, { currency: 0 }\n                ).catch(err => ({ status: 'rejected', reason: err, playerId: pogEntry.playerId }))\n            )\n        );\n        results.forEach(result => {\n            if (result.status === 'fulfilled') { itemsProcessed++; }\n            else { errorCount++; console.error(`Currency Error: ${result.reason?.message || result.reason}`); }\n        });\n    }\n    console.log(`Wipe Helpers: Currency page ${page} finished. Processed: ${itemsProcessed}, Errors: ${errorCount}, HasMore: ${hasMore}`);\n    return { itemsProcessed, errorCount, hasMore };\n}\n\n// --- Process One Page of Variables ---\nexport async function processVariablePage(page, gameServerId, moduleId, variableKeyOrModuleId, typeName) {\n    let itemsProcessed = 0;\n    let errorCount = 0;\n    let hasMore = false;\n\n    console.log(`Wipe Helpers: Processing ${typeName} variable page ${page}`);\n\n    const filters = { gameServerId: [gameServerId] };\n    if (variableKeyOrModuleId.startsWith('var_key_')) {\n        filters.key = [variableKeyOrModuleId.substring(8)];\n        filters.moduleId = [moduleId]; // Scope to this module when searching by key\n    } else if (variableKeyOrModuleId) { // Check if module ID is provided and not null/empty\n        filters.moduleId = [variableKeyOrModuleId]; // Use specific module ID\n    } else {\n        console.error(`Wipe Helpers: Invalid variableKeyOrModuleId for ${typeName}`);\n        return { itemsProcessed: 0, errorCount: 0, hasMore: false }; // Cannot process without key/moduleID\n    }\n\n\n    const varsResponse = await takaro.variable.variableControllerSearch({\n        filters: filters, limit: PAGE_LIMIT, page: page\n    });\n\n    const variables = varsResponse.data.data;\n    const countOnPage = variables.length;\n    console.log(`Wipe Helpers: ${typeName} page ${page} fetched ${countOnPage} items.`);\n\n    if (!variables || countOnPage === 0) {\n        console.log(`Wipe Helpers: ${typeName} page ${page} - No items found.`);\n        return { itemsProcessed: 0, errorCount: 0, hasMore: false };\n    }\n\n    hasMore = countOnPage === PAGE_LIMIT;\n\n    for (let i = 0; i < countOnPage; i += BATCH_SIZE) {\n        const batch = variables.slice(i, i + batchSize);\n        // console.log(`Wipe Helpers: ${typeName} page ${page}, processing batch index ${i} (size ${batch.length})`); // Optional detailed log\n        const results = await Promise.allSettled(\n            batch.map(variable =>\n                takaro.variable.variableControllerDelete(variable.id)\n                    .catch(err => ({ status: 'rejected', reason: err, variableId: variable.id }))\n            )\n        );\n        results.forEach(result => {\n            if (result.status === 'fulfilled') { itemsProcessed++; }\n            else { errorCount++; console.error(`${typeName} Delete Error: ${result.reason?.message || result.reason}`); }\n        });\n    }\n    console.log(`Wipe Helpers: ${typeName} page ${page} finished. Processed: ${itemsProcessed}, Errors: ${errorCount}, HasMore: ${hasMore}`);\n    return { itemsProcessed, errorCount, hasMore };\n}",
                    "name": "wipeHelpers.js",
                    "description": null
                }
            ],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Permission to wipe server",
                    "permission": "SERVER_WIPE",
                    "friendlyName": "SERVER_WIPE"
                }
            ]
        },
        {
            "tag": "1.0.0",
            "description": "The ServerWipe module provides administrators with a powerful tool to reset server data. It allows selective wiping of player currency, teleport locations, and waypoints with a single command.",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[],\"additionalProperties\":false,\"properties\":{\"wipeCurrency\":{\"title\":\"wipeCurrency\",\"description\":\"Whether to reset all player currency during wipe\",\"default\":false,\"type\":\"boolean\"},\"wipeTeleports\":{\"title\":\"wipeTeleports\",\"description\":\"Whether to delete all teleport locations during wipe.\",\"default\":false,\"type\":\"boolean\"},\"wipeStarterKitClaims\":{\"title\":\"wipeStarterKitClaims\",\"description\":\"wipeStarterKitClaims\",\"default\":false,\"type\":\"boolean\"},\"globalAnnouncement\":{\"title\":\"globalAnnouncement\",\"description\":\"Message to broadcast to all players after the wipe\",\"default\":\"\",\"type\":\"string\"}}}",
            "uiSchema": "{}",
            "commands": [
                {
                    "function": "import { takaro, data, checkPermission, TakaroUserError } from '@takaro/helpers';\n\nasync function main() {\n    const { player, module: mod, gameServerId, arguments: args } = data;\n\n    // Check permissions\n    if (!checkPermission(data.pog, 'SERVER_WIPE')) {\n        throw new TakaroUserError('You do not have permission to wipe server data.');\n    }\n\n    // Check if confirmation is provided\n    if (!args.confirm) {\n        throw new TakaroUserError(`\nThis will wipe server data! To confirm, use one of:\n/wipe all true - Wipe everything (respects config settings)\n/wipe currency true - Wipe only currency\n/wipe teleports true - Wipe all teleports (including waypoints)\n/wipe starterkits true - Wipe only starter kit claims`);\n    }\n\n    // Start the wipe process\n    await player.pm('Server wipe initiated. This might take a moment...');\n\n    const wipeAll = args.target === 'all';\n\n    // 1. Wipe currency if specified and enabled in config\n    if ((wipeAll && mod.userConfig.wipeCurrency) || args.target === 'currency') {\n        try {\n            await player.pm(\"Resetting all player currency...\");\n\n            // First get all PlayerOnGameServer records\n            const pogsResponse = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId]\n                },\n                limit: 100\n            });\n\n            const pogs = pogsResponse.data.data;\n\n            if (!pogs || pogs.length === 0) {\n                await player.pm('No players found on this server.');\n                return;\n            }\n\n            // Process players in batches of 10 using Promise.all\n            const batchSize = 10;\n            let resetCount = 0;\n            let errorCount = 0;\n\n            for (let i = 0; i < pogs.length; i += batchSize) {\n                const batch = pogs.slice(i, i + batchSize);\n\n                const results = await Promise.all(\n                    batch.map(pog => {\n                        return takaro.playerOnGameserver.playerOnGameServerControllerSetCurrency(\n                            gameServerId,\n                            pog.playerId,\n                            { currency: 0 }\n                        )\n                            .then(() => ({ success: true }))\n                            .catch(err => ({\n                                success: false,\n                                error: err,\n                                playerId: pog.playerId\n                            }));\n                    })\n                );\n\n                // Count successes and failures\n                results.forEach(result => {\n                    if (result.success) {\n                        resetCount++;\n                    } else {\n                        errorCount++;\n                        console.error(`Failed to reset currency for player ${result.playerId}: ${result.error}`);\n                    }\n                });\n            }\n\n            await player.pm(`Currency reset complete.`);\n\n        } catch (error) {\n            if (error instanceof TakaroUserError) {\n                throw error;\n            }\n            throw new TakaroUserError(`Failed to reset currency: ${error.message}`);\n        }\n    }\n    // 2. Delete teleport AND waypoint variables (treating them as one system)\n    if ((wipeAll && mod.userConfig.wipeTeleports) || args.target === 'teleports') {\n        try {\n            await player.pm(\"Wiping teleports and waypoints data...\");\n\n            let totalDeleted = 0;\n\n            // Find teleports module\n            const teleportsModule = await takaro.module.moduleControllerSearch({\n                filters: {\n                    name: ['teleports']\n                }\n            });\n            const teleportsModuleId = teleportsModule.data.data.length > 0 ? teleportsModule.data.data[0].id : null;\n\n            // Find waypoints module (if it exists as a separate module)\n            const waypointsModule = await takaro.module.moduleControllerSearch({\n                filters: {\n                    name: ['Waypoints']\n                }\n            });\n            const waypointsModuleId = waypointsModule.data.data.length > 0 ? waypointsModule.data.data[0].id : null;\n\n            // Handle teleport variables\n            if (teleportsModuleId) {\n                const teleportVars = await takaro.variable.variableControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        moduleId: [teleportsModuleId]\n                    },\n                    limit: 500\n                });\n\n                // Delete variables in batches\n                const batchSize = 10;\n                for (let i = 0; i < teleportVars.data.data.length; i += batchSize) {\n                    const batch = teleportVars.data.data.slice(i, i + batchSize);\n                    await Promise.all(\n                        batch.map(variable =>\n                            takaro.variable.variableControllerDelete(variable.id)\n                                .then(() => { totalDeleted++; })\n                                .catch(err => console.error(`Failed to delete variable ${variable.id}: ${err.message}`))\n                        )\n                    );\n                }\n            }\n\n            // Handle waypoint variables if they exist as a separate module\n            if (waypointsModuleId) {\n                const waypointVars = await takaro.variable.variableControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        moduleId: [waypointsModuleId]\n                    },\n                    limit: 500\n                });\n\n                // Delete variables in batches\n                const batchSize = 10;\n                for (let i = 0; i < waypointVars.data.data.length; i += batchSize) {\n                    const batch = waypointVars.data.data.slice(i, i + batchSize);\n                    await Promise.all(\n                        batch.map(variable =>\n                            takaro.variable.variableControllerDelete(variable.id)\n                                .then(() => { totalDeleted++; })\n                                .catch(err => console.error(`Failed to delete variable ${variable.id}: ${err.message}`))\n                        )\n                    );\n                }\n            }\n\n            await player.pm(`Deleted ${totalDeleted} teleport and waypoint variables from the server.`);\n        } catch (error) {\n            await player.pm(`Error wiping teleports and waypoints: ${error.message}`);\n        }\n    }\n\n    // 3. Wipe starter kit claims if specified and enabled in config\n    if ((wipeAll && mod.userConfig.wipeStarterKitClaims) || args.target === 'starterkits') {\n        try {\n            await player.pm(\"Resetting all starter kit claims...\");\n\n            // Search for variables with the exact starterkit lock key\n            const starterKitVars = await takaro.variable.variableControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    key: ['t_starterkit_lock']\n                }\n            });\n\n            const claimCount = starterKitVars.data.data.length;\n\n            // Delete all found starterkit lock variables\n            for (const variable of starterKitVars.data.data) {\n                await takaro.variable.variableControllerDelete(variable.id);\n            }\n\n            await player.pm(`Starter kit claims reset complete. Reset ${claimCount} claims.`);\n        } catch (error) {\n            throw new TakaroUserError(`Failed to reset starter kit claims: ${error.message}`);\n        }\n    }\n\n\n    // 4. Broadcast the wipe announcement to all players if configured\n    if (mod.userConfig.globalAnnouncement && mod.userConfig.globalAnnouncement.length > 0) {\n        try {\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message: mod.userConfig.globalAnnouncement\n            });\n        } catch (error) {\n            await player.pm(`Error sending global announcement: ${error.message}`);\n        }\n    }\n\n    // Confirm completion to the admin\n    await player.pm('Server wipe completed successfully.');\n}\n\nawait main();",
                    "name": "wipe",
                    "description": null,
                    "trigger": "wipe",
                    "helpText": "Wipe server data according to configuration",
                    "arguments": [
                        {
                            "name": "confirm",
                            "type": "boolean",
                            "defaultValue": "false",
                            "helpText": "Confirm wipe operation (must be true to execute)",
                            "position": 1
                        },
                        {
                            "name": "target",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "What to wipe: all, currency, teleports, waypoints, or starterkits",
                            "position": 0
                        }
                    ]
                }
            ],
            "hooks": [],
            "cronJobs": [],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Permission to wipe server",
                    "permission": "SERVER_WIPE",
                    "friendlyName": "SERVER_WIPE"
                }
            ]
        },
        {
            "tag": "0.0.1",
            "description": "The ServerWipe module provides administrators with a powerful tool to reset server data. It allows selective wiping of player currency, teleport locations, and waypoints with a single command.",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[],\"additionalProperties\":false,\"properties\":{\"wipeCurrency\":{\"title\":\"wipeCurrency\",\"description\":\"Whether to reset all player currency during wipe\",\"default\":false,\"type\":\"boolean\"},\"wipeTeleports\":{\"title\":\"wipeTeleports\",\"description\":\"Whether to delete all teleport locations during wipe.\",\"default\":false,\"type\":\"boolean\"},\"wipeStarterKitClaims\":{\"title\":\"wipeStarterKitClaims\",\"description\":\"wipeStarterKitClaims\",\"default\":false,\"type\":\"boolean\"},\"globalAnnouncement\":{\"title\":\"globalAnnouncement\",\"description\":\"Message to broadcast to all players after the wipe\",\"default\":\"\",\"type\":\"string\"}}}",
            "uiSchema": "{}",
            "commands": [
                {
                    "function": "import { takaro, data, checkPermission, TakaroUserError } from '@takaro/helpers';\n\nasync function main() {\n    const { player, module: mod, gameServerId, arguments: args } = data;\n\n    // Check permissions\n    if (!checkPermission(data.pog, 'SERVER_WIPE')) {\n        throw new TakaroUserError('You do not have permission to wipe server data.');\n    }\n\n    // Check if confirmation is provided\n    if (!args.confirm) {\n        throw new TakaroUserError(`\nThis will wipe server data! To confirm, use one of:\n/wipe all true - Wipe everything (respects config settings)\n/wipe currency true - Wipe only currency\n/wipe teleports true - Wipe all teleports (including waypoints)\n/wipe starterkits true - Wipe only starter kit claims`);\n    }\n\n    // Start the wipe process\n    await player.pm('Server wipe initiated. This might take a moment...');\n\n    const wipeAll = args.target === 'all';\n\n    // 1. Wipe currency if specified and enabled in config\n    if ((wipeAll && mod.userConfig.wipeCurrency) || args.target === 'currency') {\n        try {\n            await player.pm(\"Resetting all player currency...\");\n\n            let page = 0; // Or 1, depending on API's pagination start\n            const limit = 100; // How many to fetch per API call\n            let totalPlayersProcessed = 0;\n            let totalPlayersOnServer = Infinity; // Initialize high, will be updated by first API call\n            let errorCount = 0;\n\n            // Loop until we've processed all players\n            while (totalPlayersProcessed < totalPlayersOnServer) {\n                await player.pm(`Workspaceing player page ${page + 1}...`); // Informative message\n\n                const pogsResponse = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId]\n                    },\n                    limit: limit,\n                    page: page // Or potentially 'offset: page * limit' - CHECK TAKARO DOCS\n                    // You might need other params like 'sortBy', 'sortDirection' for consistent pagination\n                });\n\n                // Update total count from the first response (assuming it's in meta)\n                if (page === 0 && pogsResponse.data.meta) {\n                    totalPlayersOnServer = pogsResponse.data.meta.total;\n                    await player.pm(`Found ${totalPlayersOnServer} total players to process.`);\n                } else if (page === 0) {\n                    // Fallback if meta isn't available, process at least the first batch\n                    totalPlayersOnServer = pogsResponse.data.data.length;\n                    if (totalPlayersOnServer < limit) {\n                        await player.pm(`Found ${totalPlayersOnServer} total players to process.`);\n                    } else {\n                        await player.pm(`Processing first batch of ${limit}. Warning: Total player count unknown, pagination might be needed but metadata is missing.`);\n                        // Set total to limit to prevent infinite loop if meta is missing but there are > limit players\n                        totalPlayersOnServer = limit;\n                    }\n                }\n\n\n                const pogs = pogsResponse.data.data;\n\n                if (!pogs || pogs.length === 0) {\n                    if (page === 0) await player.pm('No players found on this server.');\n                    break; // Exit the loop if no players are returned on the current page\n                }\n\n                await player.pm(`Processing ${pogs.length} players from page ${page + 1}...`);\n\n                // Process the current batch of players\n                const batchSize = 10; // How many currency resets to run in parallel\n\n                for (let i = 0; i < pogs.length; i += batchSize) {\n                    const batch = pogs.slice(i, i + batchSize);\n\n                    const results = await Promise.all(\n                        batch.map(pog => {\n                            return takaro.playerOnGameserver.playerOnGameServerControllerSetCurrency(\n                                gameServerId,\n                                pog.playerId,\n                                { currency: 0 }\n                            )\n                                .then(() => ({ success: true }))\n                                .catch(err => ({\n                                    success: false,\n                                    error: err,\n                                    playerId: pog.playerId\n                                }));\n                        })\n                    );\n\n                    // Count successes and failures for this inner batch\n                    results.forEach(result => {\n                        if (result.success) {\n                            totalPlayersProcessed++; // Increment the overall count\n                        } else {\n                            errorCount++;\n                            console.error(`Failed to reset currency for player ${result.playerId}: ${result.error}`);\n                            // We still increment totalPlayersProcessed to avoid infinite loops on persistent errors,\n                            // but the error is logged. Alternatively, implement retry logic or stop on error.\n                            totalPlayersProcessed++;\n                        }\n                    });\n                    await player.pm(`Processed ${totalPlayersProcessed} / ${totalPlayersOnServer} players so far...`);\n                }\n\n                // Prepare for the next page\n                page++;\n\n                // Safety break if something is wrong with total count reporting\n                if (pogs.length < limit) {\n                    break;\n                }\n\n            } // End of while loop\n\n            await player.pm(`Currency reset complete. Processed ${totalPlayersProcessed} players with ${errorCount} errors.`);\n\n        } catch (error) {\n            if (error instanceof TakaroUserError) {\n                throw error;\n            }\n            console.error(`Error during currency wipe: ${error.stack || error.message}`);\n            throw new TakaroUserError(`Failed to reset currency: ${error.message}`);\n        }\n    }\n\n    // --- IMPORTANT ---\n    // Similar pagination logic might be needed for:\n    // 1. Teleport/Waypoint Variable Deletion: It currently has `limit: 500`. If you have more than 500 variables, it won't delete them all.\n    // 2. Starter Kit Variable Deletion: It currently has *no limit specified*. APIs often have a default limit (like 100). If you have more starter kit locks than the default limit, it might not delete them all. You should explicitly add pagination here too for safety.\n    // 2. Delete teleport AND waypoint variables (treating them as one system)\n    if ((wipeAll && mod.userConfig.wipeTeleports) || args.target === 'teleports') {\n        try {\n            await player.pm(\"Wiping teleports and waypoints data...\");\n\n            let totalDeleted = 0;\n\n            // Find teleports module\n            const teleportsModule = await takaro.module.moduleControllerSearch({\n                filters: {\n                    name: ['teleports']\n                }\n            });\n            const teleportsModuleId = teleportsModule.data.data.length > 0 ? teleportsModule.data.data[0].id : null;\n\n            // Find waypoints module (if it exists as a separate module)\n            const waypointsModule = await takaro.module.moduleControllerSearch({\n                filters: {\n                    name: ['Waypoints']\n                }\n            });\n            const waypointsModuleId = waypointsModule.data.data.length > 0 ? waypointsModule.data.data[0].id : null;\n\n            // Handle teleport variables\n            if (teleportsModuleId) {\n                const teleportVars = await takaro.variable.variableControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        moduleId: [teleportsModuleId]\n                    },\n                    limit: 500\n                });\n\n                // Delete variables in batches\n                const batchSize = 10;\n                for (let i = 0; i < teleportVars.data.data.length; i += batchSize) {\n                    const batch = teleportVars.data.data.slice(i, i + batchSize);\n                    await Promise.all(\n                        batch.map(variable =>\n                            takaro.variable.variableControllerDelete(variable.id)\n                                .then(() => { totalDeleted++; })\n                                .catch(err => console.error(`Failed to delete variable ${variable.id}: ${err.message}`))\n                        )\n                    );\n                }\n            }\n\n            // Handle waypoint variables if they exist as a separate module\n            if (waypointsModuleId) {\n                const waypointVars = await takaro.variable.variableControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        moduleId: [waypointsModuleId]\n                    },\n                    limit: 500\n                });\n\n                // Delete variables in batches\n                const batchSize = 10;\n                for (let i = 0; i < waypointVars.data.data.length; i += batchSize) {\n                    const batch = waypointVars.data.data.slice(i, i + batchSize);\n                    await Promise.all(\n                        batch.map(variable =>\n                            takaro.variable.variableControllerDelete(variable.id)\n                                .then(() => { totalDeleted++; })\n                                .catch(err => console.error(`Failed to delete variable ${variable.id}: ${err.message}`))\n                        )\n                    );\n                }\n            }\n\n            await player.pm(`Deleted ${totalDeleted} teleport and waypoint variables from the server.`);\n        } catch (error) {\n            await player.pm(`Error wiping teleports and waypoints: ${error.message}`);\n        }\n    }\n\n    // 3. Wipe starter kit claims if specified and enabled in config\n    if ((wipeAll && mod.userConfig.wipeStarterKitClaims) || args.target === 'starterkits') {\n        try {\n            await player.pm(\"Resetting all starter kit claims...\");\n\n            // Search for variables with the exact starterkit lock key\n            const starterKitVars = await takaro.variable.variableControllerSearch({\n                filters: {\n                    gameServerId: [gameServerId],\n                    key: ['t_starterkit_lock']\n                }\n            });\n\n            const claimCount = starterKitVars.data.data.length;\n\n            // Delete all found starterkit lock variables\n            for (const variable of starterKitVars.data.data) {\n                await takaro.variable.variableControllerDelete(variable.id);\n            }\n\n            await player.pm(`Starter kit claims reset complete. Reset ${claimCount} claims.`);\n        } catch (error) {\n            throw new TakaroUserError(`Failed to reset starter kit claims: ${error.message}`);\n        }\n    }\n\n\n    // 4. Broadcast the wipe announcement to all players if configured\n    if (mod.userConfig.globalAnnouncement && mod.userConfig.globalAnnouncement.length > 0) {\n        try {\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message: mod.userConfig.globalAnnouncement\n            });\n        } catch (error) {\n            await player.pm(`Error sending global announcement: ${error.message}`);\n        }\n    }\n\n    // Confirm completion to the admin\n    await player.pm('Server wipe completed successfully.');\n}\n\nawait main();",
                    "name": "wipe",
                    "description": null,
                    "trigger": "wipe",
                    "helpText": "Wipe server data according to configuration",
                    "arguments": [
                        {
                            "name": "target",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "What to wipe: all, currency, teleports, waypoints, or starterkits",
                            "position": 0
                        },
                        {
                            "name": "confirm",
                            "type": "boolean",
                            "defaultValue": "false",
                            "helpText": "Confirm wipe operation (must be true to execute)",
                            "position": 1
                        }
                    ]
                }
            ],
            "hooks": [],
            "cronJobs": [],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Permission to wipe server",
                    "permission": "SERVER_WIPE",
                    "friendlyName": "SERVER_WIPE"
                }
            ]
        },
        {
            "tag": "0.0.2",
            "description": "The ServerWipe module provides administrators with a powerful tool to reset server data. It allows selective wiping of player currency, teleport locations, and waypoints with a single command.",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[],\"additionalProperties\":false,\"properties\":{\"wipeCurrency\":{\"title\":\"wipeCurrency\",\"description\":\"Whether to reset all player currency during wipe\",\"default\":false,\"type\":\"boolean\"},\"wipeTeleports\":{\"title\":\"wipeTeleports\",\"description\":\"Whether to delete all teleport locations during wipe.\",\"default\":false,\"type\":\"boolean\"},\"wipeStarterKitClaims\":{\"title\":\"wipeStarterKitClaims\",\"description\":\"wipeStarterKitClaims\",\"default\":false,\"type\":\"boolean\"},\"globalAnnouncement\":{\"title\":\"globalAnnouncement\",\"description\":\"Message to broadcast to all players after the wipe\",\"default\":\"\",\"type\":\"string\"}}}",
            "uiSchema": "{}",
            "commands": [
                {
                    "function": "import { takaro, data, checkPermission, TakaroUserError } from '@takaro/helpers';\n\nasync function main() {\n    const { player, module: mod, gameServerId, arguments: args, pog } = data; // Added 'pog' for permission check\n\n    // Check permissions\n    if (!checkPermission(pog, 'SERVER_WIPE')) { // Use 'pog' here\n        throw new TakaroUserError('You do not have permission to wipe server data.');\n    }\n\n    // Check if confirmation is provided\n    // Assuming 'confirm' is the name of your boolean argument for confirmation\n    if (!args.confirm || args.confirm.toString().toLowerCase() !== 'true') {\n        throw new TakaroUserError(`\nThis will wipe server data! To confirm, use one of:\n/wipe all true - Wipe everything (respects config settings)\n/wipe currency true - Wipe only currency\n/wipe teleports true - Wipe all teleports (including waypoints)\n/wipe starterkits true - Wipe only starter kit claims`);\n    }\n\n    // Start the wipe process\n    await player.pm('Server wipe initiated. This might take a moment...');\n\n    // Ensure wipeAll is declared *before* it's used in the if conditions\n    const wipeAll = args.target === 'all';\n\n    // --- 1. Wipe Currency ---\n    if ((wipeAll && mod.userConfig.wipeCurrency) || args.target === 'currency') {\n        try {\n            await player.pm(\"Resetting all player currency...\");\n\n            let page = 0;\n            const limit = 100;\n            let totalPlayersProcessed = 0;\n            let totalPlayersOnServer = Infinity;\n            let errorCount = 0;\n\n            while (totalPlayersProcessed < totalPlayersOnServer) {\n                // Small status update for the user running the command\n                // await player.pm(`Fetching player page ${page + 1}...`);\n\n                const pogsResponse = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId]\n                    },\n                    limit: limit,\n                    page: page\n                });\n\n                if (page === 0 && pogsResponse.data.meta) {\n                    totalPlayersOnServer = pogsResponse.data.meta.total;\n                    await player.pm(`Found ${totalPlayersOnServer} total players to process for currency.`);\n                } else if (page === 0) {\n                    totalPlayersOnServer = pogsResponse.data.data.length;\n                    if (totalPlayersOnServer < limit) {\n                        await player.pm(`Found ${totalPlayersOnServer} total players to process for currency.`);\n                    } else {\n                        await player.pm(`Processing first batch of ${limit} players for currency. Warning: Total player count unknown.`);\n                        totalPlayersOnServer = limit; // Prevent potential infinite loop if meta is missing\n                    }\n                }\n\n                const pogs = pogsResponse.data.data;\n\n                if (!pogs || pogs.length === 0) {\n                    if (page === 0) await player.pm('No players found on this server to reset currency.');\n                    break;\n                }\n\n                // await player.pm(`Processing currency for ${pogs.length} players from page ${page + 1}...`);\n\n                const batchSize = 20; // How many currency resets to run in parallel\n                for (let i = 0; i < pogs.length; i += batchSize) {\n                    const batch = pogs.slice(i, i + batchSize);\n\n                    const results = await Promise.allSettled( // Use allSettled for better error handling\n                        batch.map(pogEntry => { // Renamed inner variable to avoid confusion\n                            return takaro.playerOnGameserver.playerOnGameServerControllerSetCurrency(\n                                gameServerId,\n                                pogEntry.playerId, // Use pogEntry here\n                                { currency: 0 }\n                            )\n                                .catch(err => ({ // Catch errors for individual resets\n                                    status: 'rejected',\n                                    reason: err,\n                                    playerId: pogEntry.playerId\n                                }));\n                        })\n                    );\n\n                    // Count successes and failures for this inner batch\n                    results.forEach(result => {\n                        if (result.status === 'fulfilled') {\n                            totalPlayersProcessed++;\n                        } else {\n                            errorCount++;\n                            console.error(`Failed to reset currency for player ${result.playerId}: ${result.reason?.message || result.reason}`);\n                            totalPlayersProcessed++; // Still increment to avoid infinite loops on persistent errors\n                        }\n                    });\n                    await player.pm(`Currency: Processed ${totalPlayersProcessed} / ${totalPlayersOnServer > limit ? '~' + totalPlayersOnServer : totalPlayersOnServer} players...`);\n                }\n\n                page++;\n                if (pogs.length < limit) {\n                    break; // Last page\n                }\n            } // End of while loop\n\n            await player.pm(`Currency reset complete. Processed ${totalPlayersProcessed} players with ${errorCount} errors.`);\n\n        } catch (error) {\n            if (error instanceof TakaroUserError) {\n                throw error; // Re-throw user errors\n            }\n            console.error(`Error during currency wipe: ${error.stack || error.message}`);\n            throw new TakaroUserError(`Failed to reset currency: ${error.message}`);\n        }\n    }\n\n    // --- 2. Wipe Teleports/Waypoints ---\n    if ((wipeAll && mod.userConfig.wipeTeleports) || args.target === 'teleports') {\n        try {\n            await player.pm(\"Wiping teleports and waypoints data...\");\n\n            // Helper function to delete variables with pagination\n            const deleteVariables = async (moduleId, moduleName) => {\n                let page = 0;\n                const limit = 100; // Process 100 variables per API call\n                let totalProcessed = 0;\n                let totalToDelete = Infinity;\n                let errorCount = 0;\n\n                await player.pm(`Starting ${moduleName} variable wipe...`);\n\n                while (totalProcessed < totalToDelete) {\n                    const varsResponse = await takaro.variable.variableControllerSearch({\n                        filters: {\n                            gameServerId: [gameServerId],\n                            moduleId: [moduleId]\n                        },\n                        limit: limit,\n                        page: page\n                    });\n\n                    if (page === 0 && varsResponse.data.meta) {\n                        totalToDelete = varsResponse.data.meta.total;\n                        await player.pm(`Found ${totalToDelete} ${moduleName} variables to delete.`);\n                    } else if (page === 0) {\n                        totalToDelete = varsResponse.data.data.length; // Fallback\n                        if (totalToDelete < limit) {\n                            await player.pm(`Found ${totalToDelete} ${moduleName} variables to delete.`);\n                        } else {\n                            await player.pm(`Processing first batch of ${limit} ${moduleName} variables. Warning: Total count unknown.`);\n                            totalToDelete = limit; // Prevent potential infinite loop\n                        }\n                    }\n\n                    const variables = varsResponse.data.data;\n\n                    if (!variables || variables.length === 0) {\n                        if (page === 0) await player.pm(`No ${moduleName} variables found.`);\n                        break;\n                    }\n\n                    // await player.pm(`Deleting ${variables.length} ${moduleName} variables from page ${page + 1}...`);\n\n                    const batchSize = 20; // Delete 20 variables concurrently\n                    for (let i = 0; i < variables.length; i += batchSize) {\n                        const batch = variables.slice(i, i + batchSize);\n                        const results = await Promise.allSettled(\n                            batch.map(variable =>\n                                takaro.variable.variableControllerDelete(variable.id)\n                                    .catch(err => ({ // Catch errors for individual deletes\n                                        status: 'rejected',\n                                        reason: err,\n                                        variableId: variable.id\n                                    }))\n                            )\n                        );\n\n                        results.forEach(result => {\n                            if (result.status === 'fulfilled') {\n                                totalProcessed++;\n                            } else {\n                                errorCount++;\n                                console.error(`Failed to delete ${moduleName} variable ${result.variableId}: ${result.reason?.message || result.reason}`);\n                                // Still increment totalProcessed to avoid loops on persistent errors\n                                totalProcessed++;\n                            }\n                        });\n                        await player.pm(`Deleted ${totalProcessed} / ${totalToDelete > limit ? '~' + totalToDelete : totalToDelete} ${moduleName} variables...`);\n                    }\n\n                    page++;\n                    if (variables.length < limit) {\n                        break; // Last page\n                    }\n                }\n                await player.pm(`${moduleName} variable wipe complete. Processed ${totalProcessed} variables with ${errorCount} errors.`);\n                return { totalProcessed, errorCount };\n            };\n\n            // --- Find Module IDs ---\n            const teleportsModule = await takaro.module.moduleControllerSearch({ filters: { name: ['teleports'] } });\n            const teleportsModuleId = teleportsModule.data.data.length > 0 ? teleportsModule.data.data[0].id : null;\n\n            // Adjust 'Waypoints' if your module has a different exact name\n            const waypointsModule = await takaro.module.moduleControllerSearch({ filters: { name: ['Waypoints'] } });\n            const waypointsModuleId = waypointsModule.data.data.length > 0 ? waypointsModule.data.data[0].id : null;\n\n            let totalDeleted = 0;\n            let totalErrors = 0;\n\n            // --- Delete Teleport Variables ---\n            if (teleportsModuleId) {\n                const { totalProcessed: tpProcessed, errorCount: tpErrors } = await deleteVariables(teleportsModuleId, 'Teleport');\n                totalDeleted += tpProcessed;\n                totalErrors += tpErrors;\n            } else {\n                await player.pm('Teleports module not found, skipping variable deletion.');\n            }\n\n            // --- Delete Waypoint Variables ---\n            if (waypointsModuleId) {\n                const { totalProcessed: wpProcessed, errorCount: wpErrors } = await deleteVariables(waypointsModuleId, 'Waypoint');\n                totalDeleted += wpProcessed;\n                totalErrors += wpErrors;\n            } else {\n                // Optional: Inform if waypoints module isn't found/used\n                // await player.pm('Waypoints module not found, skipping variable deletion.');\n            }\n\n            await player.pm(`Finished teleport/waypoint wipe. Deleted approximately ${totalDeleted} variables with ${totalErrors} errors.`);\n\n        } catch (error) {\n            if (error instanceof TakaroUserError) {\n                throw error; // Re-throw user errors\n            }\n            console.error(`Error wiping teleports/waypoints: ${error.stack || error.message}`);\n            await player.pm(`Error wiping teleports and waypoints: ${error.message}`); // Inform admin of failure\n        }\n    }\n\n    // --- 3. Wipe Starter Kit Claims ---\n    if ((wipeAll && mod.userConfig.wipeStarterKitClaims) || args.target === 'starterkits') {\n        try {\n            await player.pm(\"Resetting all starter kit claims...\");\n\n            let page = 0;\n            const limit = 100; // Process 100 variables per API call\n            let totalProcessed = 0;\n            let totalToDelete = Infinity;\n            let errorCount = 0;\n\n            while (totalProcessed < totalToDelete) {\n                const varsResponse = await takaro.variable.variableControllerSearch({\n                    filters: {\n                        gameServerId: [gameServerId],\n                        key: ['t_starterkit_lock'] // Ensure this key is correct for your starter kit module\n                    },\n                    limit: limit,\n                    page: page\n                });\n\n                if (page === 0 && varsResponse.data.meta) {\n                    totalToDelete = varsResponse.data.meta.total;\n                    await player.pm(`Found ${totalToDelete} starter kit claims to reset.`);\n                } else if (page === 0) {\n                    totalToDelete = varsResponse.data.data.length; // Fallback\n                    if (totalToDelete < limit) {\n                        await player.pm(`Found ${totalToDelete} starter kit claims to reset.`);\n                    } else {\n                        await player.pm(`Processing first batch of ${limit} starter kit claims. Warning: Total count unknown.`);\n                        totalToDelete = limit; // Prevent potential infinite loop\n                    }\n                }\n\n                const variables = varsResponse.data.data;\n\n                if (!variables || variables.length === 0) {\n                    if (page === 0) await player.pm('No starter kit claims found.');\n                    break;\n                }\n\n                // await player.pm(`Resetting ${variables.length} starter kit claims from page ${page + 1}...`);\n\n                const batchSize = 20; // Delete 20 variables concurrently\n                for (let i = 0; i < variables.length; i += batchSize) {\n                    const batch = variables.slice(i, i + batchSize);\n                    const results = await Promise.allSettled(\n                        batch.map(variable =>\n                            takaro.variable.variableControllerDelete(variable.id)\n                                .catch(err => ({ // Catch errors for individual deletes\n                                    status: 'rejected',\n                                    reason: err,\n                                    variableId: variable.id\n                                }))\n                        )\n                    );\n\n                    results.forEach(result => {\n                        if (result.status === 'fulfilled') {\n                            totalProcessed++;\n                        } else {\n                            errorCount++;\n                            console.error(`Failed to delete starter kit variable ${result.variableId}: ${result.reason?.message || result.reason}`);\n                            // Still increment totalProcessed to avoid loops on persistent errors\n                            totalProcessed++;\n                        }\n                    });\n                    await player.pm(`Reset ${totalProcessed} / ${totalToDelete > limit ? '~' + totalToDelete : totalToDelete} starter kit claims...`);\n                }\n\n                page++;\n                if (variables.length < limit) {\n                    break; // Last page\n                }\n            }\n\n            await player.pm(`Starter kit claims reset complete. Processed ${totalProcessed} claims with ${errorCount} errors.`);\n\n        } catch (error) {\n            if (error instanceof TakaroUserError) {\n                throw error; // Re-throw user errors\n            }\n            console.error(`Error resetting starter kit claims: ${error.stack || error.message}`);\n            // Throw TakaroUserError for user-facing messages\n            throw new TakaroUserError(`Failed to reset starter kit claims: ${error.message}`);\n        }\n    }\n\n\n    // --- 4. Broadcast Announcement ---\n    if (wipeAll && mod.userConfig.globalAnnouncement && mod.userConfig.globalAnnouncement.length > 0) {\n        try {\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                message: mod.userConfig.globalAnnouncement\n            });\n        } catch (error) {\n            console.error(`Error sending global announcement: ${error.stack || error.message}`);\n            await player.pm(`Error sending global announcement: ${error.message}`); // Inform admin\n        }\n    }\n\n    // --- Confirm Completion ---\n    await player.pm('Server wipe process finished.');\n}\n\n// Execute the main function\nawait main();",
                    "name": "wipe",
                    "description": null,
                    "trigger": "wipe",
                    "helpText": "Wipe server data according to configuration",
                    "arguments": [
                        {
                            "name": "target",
                            "type": "string",
                            "defaultValue": "all",
                            "helpText": "What to wipe: all, currency, teleports, waypoints, or starterkits",
                            "position": 0
                        },
                        {
                            "name": "confirm",
                            "type": "boolean",
                            "defaultValue": "false",
                            "helpText": "Confirm wipe operation (must be true to execute)",
                            "position": 1
                        }
                    ]
                }
            ],
            "hooks": [],
            "cronJobs": [],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Permission to wipe server",
                    "permission": "SERVER_WIPE",
                    "friendlyName": "SERVER_WIPE"
                }
            ]
        }
    ],
    "takaroVersion": "v0.0.24"
}