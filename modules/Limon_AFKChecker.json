{
    "name": "Limon_AFKChecker",
    "versions": [
        {
            "tag": "1.0.0",
            "description": "**Keep your server active by automatically handling AFK players.**\n\nThis module identifies and manages inactive players on your server. It allows you to:\n\n* **Track player movement:** Automatically detect when players haven't moved for a specified period.\n* **Send customized warnings:** Alert players that they've been inactive and will be kicked if they don't move.\n* **Configure AFK timeouts:** Set how long players can remain idle before receiving warnings and eventually being removed.\n* **Provide immunity:** Grant certain roles permission to remain AFK without being kicked.\n* **Make global announcements:** Optionally notify all players when someone is warned or kicked for being AFK.\n* **Define movement threshold:** Fine-tune the amount of movement required to be considered active.\n\n**Key Features:**\n\n![moduleoverview](https://github.com/gettakaro/community-modules-viewer/raw/main/images/afkkicker/afkkickerconfig.png)\n\n* Smart position tracking with configurable tolerance\n* Customizable warning and kick messages\n* Permission-based immunity system\n* Automatic variable cleanup for offline players\n* Progressive warning system before kicking\n* Optional server-wide announcements\n\n**Benefits:**\n\n* Optimizes server resources by removing inactive players\n* Keeps server slots available for active players\n* Prevents players from taking up space while idle\n* Reduces server lag by managing the player count\n* Maintains an engaging, active server environment\n\n![AFKICKER asset](https://github.com/gettakaro/community-modules-viewer/blob/main/images/afkkicker/AFKICKER.png)",
            "uiSchema": "{}",
            "commands": [],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n\n    // Get configuration values directly from userConfig\n    const maxAfkChecks = mod.userConfig.maxAfkChecks;\n    const kickMessage = mod.userConfig.kickMessage;\n    const sendWarning = mod.userConfig.sendWarning;\n    const warningMessage = mod.userConfig.warningMessage;\n    const globalAnnouncement = mod.userConfig.globalAnnouncement;\n    const minutesBetweenChecks = mod.userConfig.minutesBeforeKick;\n\n    // Add a small position tolerance to avoid false AFK positives\n    const positionTolerance = 1.0; // Allow 1 unit of movement without resetting AFK\n\n    // First, let's clean up variables for offline players\n    await cleanupOfflinePlayerVariables(gameServerId, mod.moduleId);\n\n    // Get online players through PlayerOnGameServer search\n    const playersResponse = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    });\n\n    // If no players online, exit early\n    if (playersResponse.data.meta.total === 0) {\n        return;\n    }\n\n    // Process each online player\n    for (const playerData of playersResponse.data.data) {\n        // Get the player's POG data to check permissions\n        const pogResponse = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, playerData.player.id);\n        const pog = pogResponse.data.data;\n\n        // Check if player has immunity\n        let hasImmunity = false;\n        try {\n            // Checking if the player has the permission\n            if (pog) {\n                hasImmunity = checkPermission(pog, 'AFK_IMMUNITY');\n            }\n        } catch (e) {\n            // If there's an error checking permissions, assume no immunity\n            hasImmunity = false;\n        }\n\n        // Skip players with AFK immunity\n        if (hasImmunity) {\n            continue;\n        }\n\n        // Look for the player's last position\n        const lastPositionVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['afk_last_position'],\n                playerId: [playerData.player.id],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get current position from playerData\n        const currentPosition = {\n            x: playerData.positionX,\n            y: playerData.positionY,\n            z: playerData.positionZ\n        };\n\n        if (lastPositionVar.data.data.length === 0) {\n            // First time seeing this player, store their position\n            await takaro.variable.variableControllerCreate({\n                key: 'afk_last_position',\n                value: JSON.stringify(currentPosition),\n                playerId: playerData.player.id,\n                gameServerId: gameServerId,\n                moduleId: mod.moduleId\n            });\n\n            // Also initialize their AFK counter\n            await takaro.variable.variableControllerCreate({\n                key: 'afk_check_count',\n                value: '0',\n                playerId: playerData.player.id,\n                gameServerId: gameServerId,\n                moduleId: mod.moduleId\n            });\n            continue;\n        }\n\n        // Parse the last saved position\n        const lastPosition = JSON.parse(lastPositionVar.data.data[0].value);\n\n        // Get the AFK counter\n        const afkCountVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['afk_check_count'],\n                playerId: [playerData.player.id],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let afkCount = 0;\n        if (afkCountVar.data.data.length > 0) {\n            afkCount = parseInt(afkCountVar.data.data[0].value);\n        }\n\n        // Calculate distance moved\n        const distanceX = Math.abs(currentPosition.x - lastPosition.x);\n        const distanceY = Math.abs(currentPosition.y - lastPosition.y);\n        const distanceZ = Math.abs(currentPosition.z - lastPosition.z);\n\n        // Consider player moved if they moved more than the tolerance in any direction\n        const hasPlayerMoved = (\n            distanceX > positionTolerance ||\n            distanceY > positionTolerance ||\n            distanceZ > positionTolerance\n        );\n\n        if (hasPlayerMoved) {\n            // Player has moved, reset AFK counter\n            if (afkCountVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(afkCountVar.data.data[0].id, {\n                    value: '0'\n                });\n            }\n\n            // Update last position\n            await takaro.variable.variableControllerUpdate(lastPositionVar.data.data[0].id, {\n                value: JSON.stringify(currentPosition)\n            });\n        } else {\n            // Player hasn't moved, increment AFK counter\n            afkCount++;\n\n            await takaro.variable.variableControllerUpdate(afkCountVar.data.data[0].id, {\n                value: afkCount.toString()\n            });\n\n            // Calculate dynamic message values\n            const checksLeft = maxAfkChecks - afkCount;\n            const minutesAfk = afkCount * minutesBetweenChecks;\n            const minutesUntilKick = checksLeft * minutesBetweenChecks;\n\n            // Create dynamic messages with placeholders replaced\n            const personalWarningMsg = warningMessage\n                .replace('{warningsLeft}', checksLeft)\n                .replace('{minutesAfk}', minutesAfk)\n                .replace('{minutesUntilKick}', minutesUntilKick);\n\n            const personalKickMsg = kickMessage\n                .replace('{warningsLeft}', checksLeft)\n                .replace('{minutesAfk}', minutesAfk)\n                .replace('{minutesUntilKick}', minutesUntilKick);\n\n            // Send warning if configured and there are checks left before max\n            if (sendWarning && checksLeft > 0) {\n                // Send personal warning message to the player\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message: personalWarningMsg,\n                    opts: {\n                        recipient: {\n                            gameId: pog.gameId,\n                        }\n                    }\n                });\n\n                // Send global announcement if configured\n                if (globalAnnouncement) {\n                    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                        message: `${playerData.player.name} has been AFK for ${minutesAfk} minutes and will be kicked in ${minutesUntilKick} minutes unless they move!`\n                    });\n                }\n            }\n\n            // If AFK for too long, kick the player\n            if (afkCount >= maxAfkChecks) {\n                // Using the execute command approach which is more reliable\n                await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n                    command: `kick \"${playerData.player.name}\" \"${personalKickMsg}\"`\n                });\n\n                // Send global announcement if configured\n                if (globalAnnouncement) {\n                    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                        message: `${playerData.player.name} has been kicked for being AFK for ${minutesAfk} minutes.`\n                    });\n                }\n\n                // Reset counter after kicking\n                await takaro.variable.variableControllerUpdate(afkCountVar.data.data[0].id, {\n                    value: '0'\n                });\n            }\n\n            // Update last position even if they haven't moved significantly\n            await takaro.variable.variableControllerUpdate(lastPositionVar.data.data[0].id, {\n                value: JSON.stringify(currentPosition)\n            });\n        }\n    }\n}\n\n// Helper function to clean up variables for offline players\nasync function cleanupOfflinePlayerVariables(gameServerId, moduleId) {\n    // Get all variables for this module and gameserver\n    const allVariables = await takaro.variable.variableControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            moduleId: [moduleId]\n        }\n    });\n\n    if (allVariables.data.data.length === 0) {\n        return;\n    }\n\n    // Group variables by player ID\n    const variablesByPlayer = {};\n    for (const variable of allVariables.data.data) {\n        if (variable.playerId) {\n            if (!variablesByPlayer[variable.playerId]) {\n                variablesByPlayer[variable.playerId] = [];\n            }\n            variablesByPlayer[variable.playerId].push(variable);\n        }\n    }\n\n    // Get list of online player IDs for fast lookup\n    const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    });\n\n    const onlinePlayerIds = new Set(onlinePlayers.data.data.map(pog => pog.player.id));\n\n    // Delete variables for offline players\n    for (const playerId in variablesByPlayer) {\n        if (!onlinePlayerIds.has(playerId)) {\n            for (const variable of variablesByPlayer[playerId]) {\n                await takaro.variable.variableControllerDelete(variable.id);\n            }\n        }\n    }\n}\n\nawait main();",
                    "name": "afkChecker",
                    "description": null,
                    "temporalValue": "*/5 * * * *"
                }
            ],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Players with this permission will not be kicked for being AFK.",
                    "permission": "AFK_IMMUNITY",
                    "friendlyName": "AFK Kick Immunity"
                }
            ]
        },
        {
            "tag": "latest",
            "description": "**Keep your server active by automatically handling AFK players.**\n\nThis module identifies and manages inactive players on your server. It allows you to:\n\n* **Track player movement:** Automatically detect when players haven't moved for a specified period.\n* **Send customized warnings:** Alert players that they've been inactive and will be kicked if they don't move.\n* **Configure AFK timeouts:** Set how long players can remain idle before receiving warnings and eventually being removed.\n* **Provide immunity:** Grant certain roles permission to remain AFK without being kicked.\n* **Make global announcements:** Optionally notify all players when someone is warned or kicked for being AFK.\n* **Define movement threshold:** Fine-tune the amount of movement required to be considered active.\n\n**Key Features:**\n\n![moduleoverview](https://github.com/gettakaro/community-modules-viewer/raw/main/images/afkkicker/afkkickerconfig.png)\n\n* Smart position tracking with configurable tolerance\n* Customizable warning and kick messages\n* Permission-based immunity system\n* Automatic variable cleanup for offline players\n* Progressive warning system before kicking\n* Optional server-wide announcements\n\n**Benefits:**\n\n* Optimizes server resources by removing inactive players\n* Keeps server slots available for active players\n* Prevents players from taking up space while idle\n* Reduces server lag by managing the player count\n* Maintains an engaging, active server environment\n\n![AFKICKER asset](https://github.com/gettakaro/community-modules-viewer/blob/main/images/afkkicker/AFKICKER.png)",
            "commands": [],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data, checkPermission } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n\n    // Get configuration values directly from userConfig\n    const maxAfkChecks = mod.userConfig.maxAfkChecks;\n    const kickMessage = mod.userConfig.kickMessage;\n    const sendWarning = mod.userConfig.sendWarning;\n    const warningMessage = mod.userConfig.warningMessage;\n    const globalAnnouncement = mod.userConfig.globalAnnouncement;\n    const minutesBetweenChecks = mod.userConfig.minutesBeforeKick;\n\n    // Add a small position tolerance to avoid false AFK positives\n    const positionTolerance = 1.0; // Allow 1 unit of movement without resetting AFK\n\n    // First, let's clean up variables for offline players\n    await cleanupOfflinePlayerVariables(gameServerId, mod.moduleId);\n\n    // Get online players through PlayerOnGameServer search\n    const playersResponse = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    });\n\n    // If no players online, exit early\n    if (playersResponse.data.meta.total === 0) {\n        return;\n    }\n\n    // Process each online player\n    for (const playerData of playersResponse.data.data) {\n        // Get the player's POG data to check permissions\n        const pogResponse = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, playerData.player.id);\n        const pog = pogResponse.data.data;\n\n        // Check if player has immunity\n        let hasImmunity = false;\n        try {\n            // Checking if the player has the permission\n            if (pog) {\n                hasImmunity = checkPermission(pog, 'AFK_IMMUNITY');\n            }\n        } catch (e) {\n            // If there's an error checking permissions, assume no immunity\n            hasImmunity = false;\n        }\n\n        // Skip players with AFK immunity\n        if (hasImmunity) {\n            continue;\n        }\n\n        // Look for the player's last position\n        const lastPositionVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['afk_last_position'],\n                playerId: [playerData.player.id],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        // Get current position from playerData\n        const currentPosition = {\n            x: playerData.positionX,\n            y: playerData.positionY,\n            z: playerData.positionZ\n        };\n\n        if (lastPositionVar.data.data.length === 0) {\n            // First time seeing this player, store their position\n            await takaro.variable.variableControllerCreate({\n                key: 'afk_last_position',\n                value: JSON.stringify(currentPosition),\n                playerId: playerData.player.id,\n                gameServerId: gameServerId,\n                moduleId: mod.moduleId\n            });\n\n            // Also initialize their AFK counter\n            await takaro.variable.variableControllerCreate({\n                key: 'afk_check_count',\n                value: '0',\n                playerId: playerData.player.id,\n                gameServerId: gameServerId,\n                moduleId: mod.moduleId\n            });\n            continue;\n        }\n\n        // Parse the last saved position\n        const lastPosition = JSON.parse(lastPositionVar.data.data[0].value);\n\n        // Get the AFK counter\n        const afkCountVar = await takaro.variable.variableControllerSearch({\n            filters: {\n                key: ['afk_check_count'],\n                playerId: [playerData.player.id],\n                gameServerId: [gameServerId],\n                moduleId: [mod.moduleId]\n            }\n        });\n\n        let afkCount = 0;\n        if (afkCountVar.data.data.length > 0) {\n            afkCount = parseInt(afkCountVar.data.data[0].value);\n        }\n\n        // Calculate distance moved\n        const distanceX = Math.abs(currentPosition.x - lastPosition.x);\n        const distanceY = Math.abs(currentPosition.y - lastPosition.y);\n        const distanceZ = Math.abs(currentPosition.z - lastPosition.z);\n\n        // Consider player moved if they moved more than the tolerance in any direction\n        const hasPlayerMoved = (\n            distanceX > positionTolerance ||\n            distanceY > positionTolerance ||\n            distanceZ > positionTolerance\n        );\n\n        if (hasPlayerMoved) {\n            // Player has moved, reset AFK counter\n            if (afkCountVar.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(afkCountVar.data.data[0].id, {\n                    value: '0'\n                });\n            }\n\n            // Update last position\n            await takaro.variable.variableControllerUpdate(lastPositionVar.data.data[0].id, {\n                value: JSON.stringify(currentPosition)\n            });\n        } else {\n            // Player hasn't moved, increment AFK counter\n            afkCount++;\n\n            await takaro.variable.variableControllerUpdate(afkCountVar.data.data[0].id, {\n                value: afkCount.toString()\n            });\n\n            // Calculate dynamic message values\n            const checksLeft = maxAfkChecks - afkCount;\n            const minutesAfk = afkCount * minutesBetweenChecks;\n            const minutesUntilKick = checksLeft * minutesBetweenChecks;\n\n            // Create dynamic messages with placeholders replaced\n            const personalWarningMsg = warningMessage\n                .replace('{warningsLeft}', checksLeft)\n                .replace('{minutesAfk}', minutesAfk)\n                .replace('{minutesUntilKick}', minutesUntilKick);\n\n            const personalKickMsg = kickMessage\n                .replace('{warningsLeft}', checksLeft)\n                .replace('{minutesAfk}', minutesAfk)\n                .replace('{minutesUntilKick}', minutesUntilKick);\n\n            // Send warning if configured and there are checks left before max\n            if (sendWarning && checksLeft > 0) {\n                // Send personal warning message to the player\n                await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                    message: personalWarningMsg,\n                    opts: {\n                        recipient: {\n                            gameId: pog.gameId,\n                        }\n                    }\n                });\n\n                // Send global announcement if configured\n                if (globalAnnouncement) {\n                    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                        message: `${playerData.player.name} has been AFK for ${minutesAfk} minutes and will be kicked in ${minutesUntilKick} minutes unless they move!`\n                    });\n                }\n            }\n\n            // If AFK for too long, kick the player\n            if (afkCount >= maxAfkChecks) {\n                // Using the execute command approach which is more reliable\n                await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n                    command: `kick \"${playerData.player.name}\" \"${personalKickMsg}\"`\n                });\n\n                // Send global announcement if configured\n                if (globalAnnouncement) {\n                    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n                        message: `${playerData.player.name} has been kicked for being AFK for ${minutesAfk} minutes.`\n                    });\n                }\n\n                // Reset counter after kicking\n                await takaro.variable.variableControllerUpdate(afkCountVar.data.data[0].id, {\n                    value: '0'\n                });\n            }\n\n            // Update last position even if they haven't moved significantly\n            await takaro.variable.variableControllerUpdate(lastPositionVar.data.data[0].id, {\n                value: JSON.stringify(currentPosition)\n            });\n        }\n    }\n}\n\n// Helper function to clean up variables for offline players\nasync function cleanupOfflinePlayerVariables(gameServerId, moduleId) {\n    // Get all variables for this module and gameserver\n    const allVariables = await takaro.variable.variableControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            moduleId: [moduleId]\n        }\n    });\n\n    if (allVariables.data.data.length === 0) {\n        return;\n    }\n\n    // Group variables by player ID\n    const variablesByPlayer = {};\n    for (const variable of allVariables.data.data) {\n        if (variable.playerId) {\n            if (!variablesByPlayer[variable.playerId]) {\n                variablesByPlayer[variable.playerId] = [];\n            }\n            variablesByPlayer[variable.playerId].push(variable);\n        }\n    }\n\n    // Get list of online player IDs for fast lookup\n    const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    });\n\n    const onlinePlayerIds = new Set(onlinePlayers.data.data.map(pog => pog.player.id));\n\n    // Delete variables for offline players\n    for (const playerId in variablesByPlayer) {\n        if (!onlinePlayerIds.has(playerId)) {\n            for (const variable of variablesByPlayer[playerId]) {\n                await takaro.variable.variableControllerDelete(variable.id);\n            }\n        }\n    }\n}\n\nawait main();",
                    "name": "afkChecker",
                    "description": "checks for afk ",
                    "temporalValue": "*/5 * * * *"
                }
            ],
            "functions": [],
            "permissions": [
                {
                    "canHaveCount": false,
                    "description": "Players with this permission will not be kicked for being AFK.",
                    "permission": "AFK_IMMUNITY",
                    "friendlyName": "AFK Kick Immunity"
                }
            ]
        }
    ],
    "takaroVersion": "main"
}