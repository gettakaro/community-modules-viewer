{
    "name": "Limon_DynamicServerMessages",
    "versions": [
        {
            "tag": "latest",
            "description": "This will send dynamic server messages",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"cronjobs\":{\"type\":\"array\",\"title\":\"Cronjobs\",\"description\":\"List of cronjobs and their schedules\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\",\"description\":\"Optional name for the cronjob\",\"minLength\":1},\"command\":{\"type\":\"string\",\"description\":\"Command to execute\",\"minLength\":1},\"temporalValue\":{\"type\":\"string\",\"description\":\"Cron expression for execution schedule\",\"minLength\":1}},\"required\":[\"command\",\"temporalValue\"]}}},\"additionalProperties\":false}",
            "uiSchema": "{}",
            "commands": [],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n    const cronjobs = mod.userConfig.cronjobs || [];\n\n    // First get existing cronjobs for this module \n    const existingCronjobs = (await takaro.cronjob.cronJobControllerSearch({\n        filters: {\n            versionId: [mod.versionId]\n        }\n    })).data.data;\n\n    // Track what we've processed to handle cleanup later\n    const processedJobs = new Set();\n\n    // Create or update cronjobs from config\n    for (let i = 0; i < cronjobs.length; i++) {\n        const job = cronjobs[i];\n        // Use the provided name if available, otherwise use default number\n        const jobNameSuffix = job.name ? `-${job.name}` : '';\n        const jobName = `sm-${i + 1}${jobNameSuffix}`; // Start counting from 1\n\n        processedJobs.add(jobName);\n\n        const existingJob = existingCronjobs.find(j => j.name === jobName);\n\n        const jobFunction = `\n      import { takaro, data } from '@takaro/helpers';\n      async function main() {\n        const { gameServerId } = data;\n        \n        // Get online players through PlayerOnGameServer search\n        const currentPlayers = (await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        })).data.meta;\n\n        // If no players online, exit early\n        if (currentPlayers.total === 0) {\n            return;\n        }\n        \n        await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n          message: \\`${job.command}\\`,\n        });\n      }\n      await main();\n    `.trim();\n\n        try {\n            if (existingJob) {\n                // Update without versionId\n                await takaro.cronjob.cronJobControllerUpdate(existingJob.id, {\n                    name: jobName,\n                    temporalValue: job.temporalValue,\n                    function: jobFunction\n                });\n            } else {\n                try {\n                    // Create includes versionId\n                    await takaro.cronjob.cronJobControllerCreate({\n                        name: jobName,\n                        temporalValue: job.temporalValue,\n                        versionId: mod.versionId,\n                        function: jobFunction\n                    });\n                } catch (createError) {\n                    if (createError.response?.status === 409) {\n                        const conflictJobSearch = await takaro.cronjob.cronJobControllerSearch({\n                            filters: {\n                                name: [jobName]\n                            }\n                        });\n\n                        if (conflictJobSearch.data.data.length > 0) {\n                            const conflictJob = conflictJobSearch.data.data[0];\n                            // Update without versionId\n                            await takaro.cronjob.cronJobControllerUpdate(conflictJob.id, {\n                                name: jobName,\n                                temporalValue: job.temporalValue,\n                                function: jobFunction\n                            });\n                        } else {\n                            throw createError;\n                        }\n                    } else {\n                        throw createError;\n                    }\n                }\n            }\n        } catch (error) {\n            // Error handling with no logging\n        }\n    }\n\n    // Clean up old cronjobs that are no longer in config\n    for (const existingJob of existingCronjobs) {\n        // Check if the name matches our pattern and if it's not in the processed list\n        if (/^sm-\\d+(-.*)?$/.test(existingJob.name) && !processedJobs.has(existingJob.name)) {\n            try {\n                await takaro.cronjob.cronJobControllerRemove(existingJob.id);\n            } catch (error) {\n                // Error handling with no logging\n            }\n        }\n    }\n}\n\nawait main();",
                    "name": "ServerMessagesGenerator",
                    "temporalValue": "5 4 * * *"
                }
            ],
            "functions": [],
            "permissions": []
        }
    ],
    "takaroVersion": "main"
}