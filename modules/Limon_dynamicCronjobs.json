{
    "name": "Limon_dynamicCronjobs",
    "versions": [
        {
            "tag": "latest",
            "description": "# Dynamic CronJob Manager: Automated Game Server Command Scheduler\n\n---\nðŸŽ¥ **SETUP TUTORIAL**  \n**[â–º Watch the Complete Guide](https://youtu.be/OwxbBxYFZk8?si=7Fu3XVB972in6IvS)**  \n*Learn how to set up and configure dynamic cronjobs*\n---\n\nCreate and manage dynamic cronjobs for executing game server commands based on flexible schedules. Define commands and their cron expressions to automate tasks.  \n\n  -   **Dynamic Updates:** The module's `cronJobGenerator` cronjob automatically checks for and adapts to changes in the user configuration. This ensures that any modifications to commands or schedules are applied dynamically.\n  -   **Cron Syntax Validation:** The module validates the syntax of cron expressions. If an invalid expression is provided, that specific cronjob will be skipped, preventing errors and ensuring only valid schedules are applied.  For assistance with cron syntax, you can use a tool like [crontab.guru](https://crontab.guru/).\n  -   **Command Sequencing:** You can define multiple commands within a single cronjob entry, separated by semicolons. These commands will be executed sequentially according to the defined schedule.\n  -   **Game Server Specificity:** It is crucial to install the latest version of this module and create a **separate copy for each game server**. This ensures that cronjobs are executed on the intended server and avoids unintended cross-server execution.\n  -   **Automated Management:** The module handles the creation, updating, and cleanup of cronjobs. It removes any cronjobs that are no longer present in the configuration, maintaining a clean and accurate schedule.\n  -   **Internal Synchronization:** To ensure proper synchronization of cron schedules, the module may perform internal operations to update its configuration. This process is automated and does not require manual intervention from the user.",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"cronjobs\":{\"type\":\"array\",\"title\":\"Cronjobs\",\"description\":\"List of cronjobs and their schedules\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\",\"description\":\"Optional name for the cronjob\",\"minLength\":1},\"command\":{\"type\":\"string\",\"description\":\"You can enter multiple commands separated by semicolons (;) to create a sequence of scheduled tasks for the same cron expression. \",\"minLength\":1},\"temporalValue\":{\"type\":\"string\",\"description\":\"Cron expression for execution schedule\",\"minLength\":1}},\"required\":[\"command\",\"temporalValue\"]}}},\"additionalProperties\":false}",
            "uiSchema": "{}",
            "commands": [],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n  const { gameServerId, module: mod } = data;\n  const cronjobs = mod.userConfig.cronjobs || [];\n\n  // Create a filtered version of cronjobs that will only include valid ones\n  const validatedCronjobs = [];\n\n  // First get existing cronjobs for this module \n  const existingCronjobs = (await takaro.cronjob.cronJobControllerSearch({\n    filters: {\n      versionId: [mod.versionId]\n    }\n  })).data.data;\n\n  // Track what we've processed to handle cleanup later\n  const processedJobs = new Set();\n  let jobCounter = 1;\n\n  // Improved cron validation function\n  function isValidCronSyntax(cronExpression) {\n    try {\n      // Trim whitespace\n      cronExpression = cronExpression.trim();\n\n      // Check for special expressions like @daily, @hourly, etc.\n      if (/^@(yearly|annually|monthly|weekly|daily|hourly|reboot)$/.test(cronExpression)) {\n        return true;\n      }\n\n      // Split into components\n      const parts = cronExpression.split(/\\s+/);\n      if (parts.length !== 5) {\n        return false;\n      }\n\n      // Valid characters per field (excluding spaces)\n      const validChars = [\n        // Minutes: numbers, commas, hyphens, asterisks, and forward slashes\n        /^[0-9,\\-*\\/]+$/,\n        // Hours: numbers, commas, hyphens, asterisks, and forward slashes\n        /^[0-9,\\-*\\/]+$/,\n        // Day of month: numbers, commas, hyphens, asterisks, question marks, and forward slashes\n        /^[0-9,\\-*\\/?]+$/,\n        // Month: numbers, commas, hyphens, asterisks, and forward slashes\n        /^[0-9,\\-*\\/]+$/,\n        // Day of week: numbers, commas, hyphens, asterisks, question marks, forward slashes, and letters (for day names)\n        /^[0-9,\\-*\\/?a-zA-Z]+$/\n      ];\n\n      // Check each part for valid characters\n      for (let i = 0; i < 5; i++) {\n        if (!validChars[i].test(parts[i])) {\n          return false;\n        }\n      }\n\n      // Additional simple sanity checks\n      // For minutes (0-59)\n      const minutes = parts[0].split(/[,\\-\\/]/).filter(m => m !== '*' && /^\\d+$/.test(m));\n      if (minutes.some(m => parseInt(m) > 59)) {\n        return false;\n      }\n\n      // For hours (0-23)\n      const hours = parts[1].split(/[,\\-\\/]/).filter(h => h !== '*' && /^\\d+$/.test(h));\n      if (hours.some(h => parseInt(h) > 23)) {\n        return false;\n      }\n\n      // For days of month (1-31)\n      const dom = parts[2].split(/[,\\-\\/]/).filter(d => d !== '*' && d !== '?' && /^\\d+$/.test(d));\n      if (dom.some(d => parseInt(d) < 1 || parseInt(d) > 31)) {\n        return false;\n      }\n\n      // For months (1-12)\n      const months = parts[3].split(/[,\\-\\/]/).filter(m => m !== '*' && /^\\d+$/.test(m));\n      if (months.some(m => parseInt(m) < 1 || parseInt(m) > 12)) {\n        return false;\n      }\n\n      // For days of week (0-6)\n      const dow = parts[4].split(/[,\\-\\/]/).filter(d => {\n        // Skip wildcards and step values\n        if (d === '*' || d === '?' || d.includes('/')) return false;\n\n        // Convert named days to numbers\n        if (/^[a-zA-Z]+$/.test(d)) {\n          const dayMap = {\n            sun: 0, mon: 1, tue: 2, wed: 3, thu: 4, fri: 5, sat: 6,\n            sunday: 0, monday: 1, tuesday: 2, wednesday: 3, thursday: 4, friday: 5, saturday: 6\n          };\n          // Return false (not invalid) if it's a recognized day name\n          return dayMap[d.toLowerCase()] === undefined;\n        }\n        // Only filter numeric values\n        return /^\\d+$/.test(d);\n      });\n\n      if (dow.some(d => parseInt(d) > 6)) {\n        return false;\n      }\n\n      return true;\n    } catch (err) {\n      console.log(`Error validating cron syntax: ${err.message}`);\n      return false;\n    }\n  }\n\n  // Create or update cronjobs from config\n  for (let i = 0; i < cronjobs.length; i++) {\n    const job = cronjobs[i];\n\n    // Validate cron syntax before proceeding\n    if (!isValidCronSyntax(job.temporalValue)) {\n      // Log error using console.log which will show in the logs\n      console.log(`Invalid cron syntax in job ${job.name || i + 1}: \"${job.temporalValue}\"`);\n      // Skip this job but continue with others\n      continue;\n    }\n\n    // Add to validated list for reinstallation\n    validatedCronjobs.push({ ...job });\n\n    // Split the command by semicolons and trim each command\n    const commands = job.command.split(';').map(cmd => cmd.trim()).filter(cmd => cmd);\n\n    // Process each command separately to create sequential cronjobs\n    for (let cmdIndex = 0; cmdIndex < commands.length; cmdIndex++) {\n      const command = commands[cmdIndex];\n\n      // Use the provided name if available, otherwise use default number\n      // For multiple commands from one entry, append sequence number\n      const seqSuffix = commands.length > 1 ? `-seq${cmdIndex + 1}` : '';\n      const jobNameSuffix = job.name ? `-${job.name}${seqSuffix}` : seqSuffix;\n      const jobName = `cr-${jobCounter}${jobNameSuffix}`;\n      jobCounter++;\n\n      processedJobs.add(jobName);\n\n      const existingJob = existingCronjobs.find(j => j.name === jobName);\n\n      const jobFunction = `\n        import { takaro, data } from '@takaro/helpers';\n        async function main() {\n          const { gameServerId } = data;\n          await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n            command: \\`${command}\\`,\n          });\n        }\n        await main();\n      `.trim();\n\n      try {\n        if (existingJob) {\n          // Check if the temporal value needs to be updated\n          if (existingJob.temporalValue !== job.temporalValue) {\n            console.log(`Updating cronjob ${jobName} temporal value from ${existingJob.temporalValue} to ${job.temporalValue}`);\n          }\n\n          // Update without versionId, always using the temporalValue from userConfig\n          await takaro.cronjob.cronJobControllerUpdate(existingJob.id, {\n            name: jobName,\n            temporalValue: job.temporalValue,\n            function: jobFunction\n          });\n        } else {\n          try {\n            // Create includes versionId\n            await takaro.cronjob.cronJobControllerCreate({\n              name: jobName,\n              temporalValue: job.temporalValue,\n              versionId: mod.versionId,\n              function: jobFunction\n            });\n          } catch (createError) {\n            if (createError.response?.status === 409) {\n              const conflictJobSearch = await takaro.cronjob.cronJobControllerSearch({\n                filters: {\n                  name: [jobName]\n                }\n              });\n\n              if (conflictJobSearch.data.data.length > 0) {\n                const conflictJob = conflictJobSearch.data.data[0];\n                // Update without versionId\n                await takaro.cronjob.cronJobControllerUpdate(conflictJob.id, {\n                  name: jobName,\n                  temporalValue: job.temporalValue,\n                  function: jobFunction\n                });\n              } else {\n                throw createError;\n              }\n            } else {\n              console.log(`Error creating cronjob \"${jobName}\": ${createError.message || \"Unknown error\"}`);\n            }\n          }\n        }\n      } catch (error) {\n        // Log error but continue with other jobs\n        console.log(`Error with cronjob \"${jobName}\": ${error.message || \"Unknown error\"}`);\n      }\n    }\n  }\n\n  // Clean up old cronjobs that are no longer in config\n  for (const existingJob of existingCronjobs) {\n    // Check if the name matches our pattern and if it's not in the processed list\n    if (/^cr-\\d+(-.*)?$/.test(existingJob.name) && !processedJobs.has(existingJob.name)) {\n      try {\n        await takaro.cronjob.cronJobControllerRemove(existingJob.id);\n      } catch (error) {\n        console.log(`Error removing cronjob \"${existingJob.name}\": ${error.message || \"Unknown error\"}`);\n      }\n    }\n  }\n\n  // Create new userConfig with only validated cronjobs\n  const cleanedUserConfig = { ...mod.userConfig, cronjobs: validatedCronjobs };\n\n  // Create systemConfig with updated temporal values for our cronjobs\n  // This is a bit of a hack since we don't have direct access to systemConfig\n  // We'll try to reconstruct it based on the current userConfig\n  try {\n    // Parse the current systemConfig\n    let systemConfig = {};\n    if (mod.systemConfig) {\n      try {\n        systemConfig = JSON.parse(mod.systemConfig);\n      } catch (e) {\n        console.log('Error parsing systemConfig, will rebuild it');\n        systemConfig = { enabled: true, cronJobs: {} };\n      }\n    } else {\n      systemConfig = { enabled: true, cronJobs: {} };\n    }\n\n    // Make sure cronJobs object exists\n    if (!systemConfig.cronJobs) {\n      systemConfig.cronJobs = {};\n    }\n\n    // Update temporal values for all our cronjobs\n    for (let i = 0; i < validatedCronjobs.length; i++) {\n      const job = validatedCronjobs[i];\n      const jobNameBase = `cr-${i + 1}-${job.name}`;\n\n      // Update the systemConfig for this job\n      systemConfig.cronJobs[jobNameBase] = {\n        enabled: true,\n        temporalValue: job.temporalValue\n      };\n    }\n\n    // Also update the generator cronjob if it exists\n    if (systemConfig.cronJobs.cronJobGenerator) {\n      systemConfig.cronJobs.cronJobGenerator.enabled = true;\n    }\n\n    // After updating all cronjobs, uninstall and reinstall the module with both configs\n    // Uninstall the module\n    await takaro.module.moduleInstallationsControllerUninstallModule(\n      mod.moduleId,\n      gameServerId\n    );\n\n    // Then reinstall it with both cleaned userConfig and updated systemConfig\n    await takaro.module.moduleInstallationsControllerInstallModule({\n      versionId: mod.versionId,\n      gameServerId: gameServerId,\n      userConfig: JSON.stringify(cleanedUserConfig),\n      systemConfig: JSON.stringify(systemConfig)\n    });\n  } catch (error) {\n    console.log(`Error reinstalling module: ${error.message || \"Unknown error\"}`);\n    try {\n      // Fall back to just userConfig if including systemConfig failed\n      await takaro.module.moduleInstallationsControllerInstallModule({\n        versionId: mod.versionId,\n        gameServerId: gameServerId,\n        userConfig: JSON.stringify(cleanedUserConfig)\n      });\n    } catch (retryError) {\n      console.log(`Error in retry installation: ${retryError.message || \"Unknown error\"}`);\n      // If all else fails, try reloading modules\n      try {\n        await takaro.gameserver.gameServerControllerReloadModules(gameServerId);\n      } catch (reloadError) {\n        console.log(`Failed to reload modules: ${reloadError.message || \"Unknown error\"}`);\n      }\n    }\n  }\n}\n\nawait main();",
                    "name": "cronJobGenerator",
                    "description": "check changes in the user config and adapts",
                    "temporalValue": "*/5 * * * *"
                }
            ],
            "functions": [],
            "permissions": []
        }
    ],
    "takaroVersion": "v0.0.21"
}