{
    "name": "Limon_dynamicCronjobs",
    "versions": [
        {
            "tag": "latest",
            "description": "Create and manage dynamic cronjobs for any command",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"cronjobs\":{\"type\":\"array\",\"title\":\"Cronjobs\",\"description\":\"List of cronjobs and their schedules\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\",\"description\":\"Optional name for the cronjob\",\"minLength\":1},\"command\":{\"type\":\"string\",\"description\":\"You can enter multiple commands separated by semicolons (;) to create a sequence of scheduled tasks for the same cron expression. \",\"minLength\":1},\"temporalValue\":{\"type\":\"string\",\"description\":\"Cron expression for execution schedule\",\"minLength\":1}},\"required\":[\"command\",\"temporalValue\"]}}},\"additionalProperties\":false}",
            "uiSchema": "{}",
            "commands": [],
            "hooks": [],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n  const { gameServerId, module: mod } = data;\n  const cronjobs = mod.userConfig.cronjobs || [];\n\n  // First get existing cronjobs for this module \n  const existingCronjobs = (await takaro.cronjob.cronJobControllerSearch({\n    filters: {\n      versionId: [mod.versionId]\n    }\n  })).data.data;\n\n  // Track what we've processed to handle cleanup later\n  const processedJobs = new Set();\n  let jobCounter = 1;\n\n  // Create or update cronjobs from config\n  for (let i = 0; i < cronjobs.length; i++) {\n    const job = cronjobs[i];\n\n    // Split the command by semicolons and trim each command\n    const commands = job.command.split(';').map(cmd => cmd.trim()).filter(cmd => cmd);\n\n    // Process each command separately to create sequential cronjobs\n    for (let cmdIndex = 0; cmdIndex < commands.length; cmdIndex++) {\n      const command = commands[cmdIndex];\n\n      // Use the provided name if available, otherwise use default number\n      // For multiple commands from one entry, append sequence number\n      const seqSuffix = commands.length > 1 ? `-seq${cmdIndex + 1}` : '';\n      const jobNameSuffix = job.name ? `-${job.name}${seqSuffix}` : seqSuffix;\n      const jobName = `cr-${jobCounter}${jobNameSuffix}`;\n      jobCounter++;\n\n      processedJobs.add(jobName);\n\n      const existingJob = existingCronjobs.find(j => j.name === jobName);\n\n      const jobFunction = `\n        import { takaro, data } from '@takaro/helpers';\n        async function main() {\n          const { gameServerId } = data;\n          await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n            command: \\`${command}\\`,\n          });\n        }\n        await main();\n      `.trim();\n\n      try {\n        if (existingJob) {\n          // Update without versionId\n          await takaro.cronjob.cronJobControllerUpdate(existingJob.id, {\n            name: jobName,\n            temporalValue: job.temporalValue,\n            function: jobFunction\n          });\n        } else {\n          try {\n            // Create includes versionId\n            await takaro.cronjob.cronJobControllerCreate({\n              name: jobName,\n              temporalValue: job.temporalValue,\n              versionId: mod.versionId,\n              function: jobFunction\n            });\n          } catch (createError) {\n            if (createError.response?.status === 409) {\n              const conflictJobSearch = await takaro.cronjob.cronJobControllerSearch({\n                filters: {\n                  name: [jobName]\n                }\n              });\n\n              if (conflictJobSearch.data.data.length > 0) {\n                const conflictJob = conflictJobSearch.data.data[0];\n                // Update without versionId\n                await takaro.cronjob.cronJobControllerUpdate(conflictJob.id, {\n                  name: jobName,\n                  temporalValue: job.temporalValue,\n                  function: jobFunction\n                });\n              } else {\n                throw createError;\n              }\n            } else {\n              throw createError;\n            }\n          }\n        }\n      } catch (error) {\n        // Error handling with no logging\n      }\n    }\n  }\n\n  // Clean up old cronjobs that are no longer in config\n  for (const existingJob of existingCronjobs) {\n    // Check if the name matches our pattern and if it's not in the processed list\n    if (/^cr-\\d+(-.*)?$/.test(existingJob.name) && !processedJobs.has(existingJob.name)) {\n      try {\n        await takaro.cronjob.cronJobControllerRemove(existingJob.id);\n      } catch (error) {\n        // Error handling with no logging\n      }\n    }\n  }\n\n  // After updating all cronjobs, uninstall and reinstall the module to apply changes\n  try {\n    // Uninstall the module\n    await takaro.module.moduleInstallationsControllerUninstallModule(\n      mod.moduleId,\n      gameServerId\n    );\n\n    // Then reinstall it with the correct parameters\n    await takaro.module.moduleInstallationsControllerInstallModule({\n      versionId: mod.versionId,\n      gameServerId: gameServerId,\n      userConfig: JSON.stringify(mod.userConfig)\n    });\n  } catch (error) {\n    try {\n      // Try again without userConfig if including it failed\n      await takaro.module.moduleInstallationsControllerInstallModule({\n        versionId: mod.versionId,\n        gameServerId: gameServerId\n      });\n    } catch (retryError) {\n      // If all else fails, try reloading modules\n      try {\n        await takaro.gameserver.gameServerControllerReloadModules(gameServerId);\n      } catch (reloadError) {\n        // Final error handling with no logging\n      }\n    }\n  }\n}\n\nawait main();",
                    "name": "cronJobGenerator",
                    "temporalValue": "5 4 * * *"
                }
            ],
            "functions": [],
            "permissions": []
        }
    ],
    "takaroVersion": "main"
}