{
    "name": "Limon_7dtd_ChatBridge",
    "versions": [
        {
            "tag": "latest",
            "description": "# Limon_chatbridge: Discord Chat Integration for Your Game Server\n\nThis module bridges your game server's chat and a Discord channel, enabling two-way communication with powerful, customizable filtering options.\n\n## Key Features\n\n*   **Two-Way Chat Relay:** Forward messages between your game and Discord in real-time. Improve player interaction and build a stronger community.\n*   **Player Connection/Disconnection Notifications:** Optionally send automated Discord messages when players join or leave your server.\n*   **Advanced Filtering Options:**\n    *   **Global Chat Only:** Restrict messages to your game's global chat channel, excluding team chat and private messages.\n    *   **Command Filtering:** Prevent in-game command messages (e.g., `/ban`) from cluttering your Discord.\n    *   **System Message Filtering:** Keep your Discord clean by blocking system (non-player) messages.\n*   **Dedicated Monitoring Channel (Optional):** Create a separate Discord channel for *all* server activity, including chat, commands, and logs. Ideal for moderation and debugging.\n*   **Easy Configuration:** Customize settings quickly and easily with a straightforward configuration schema.\n\n## Configuration Options\n\n*   `sendPlayerConnected`: (`true`/`false`, default: `true`) Enable player connect notifications.\n*   `sendPlayerDisconnected`: (`true`/`false`, default: `true`) Enable player disconnect notifications.\n*   `onlyGlobalChat`: (`true`/`false`, default: `true`) Restrict to global chat only.\n*   `filterCommands`: (`true`/`false`, default: `false`) Filter out in-game command messages.\n*   `filterSystemMessages`: (`true`/`false`, default: `false`) Filter out system messages.\n*   `useMonitoring`: (`true`/`false`, default: `false`) Enable a dedicated monitoring channel.\n*   `monitoringChannelId`: (string) Discord channel ID for monitoring (required if `useMonitoring` is enabled).\n\n## Hooks\n\n*   `PlayerDisconnected` / `PlayerConnected`: Handles player join/leave notifications.\n*   `DiscordToGame`: Relays messages from your Discord server to the game.\n*   `GameToDiscord`: Relays in-game chat messages to Discord, applying all configured filters.",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sendPlayerConnected\":{\"title\":\"Send player connected\",\"type\":\"boolean\",\"description\":\"Send a message when a player connects.\",\"default\":true},\"sendPlayerDisconnected\":{\"title\":\"Send player disconnected\",\"type\":\"boolean\",\"description\":\"Send a message when a player disconnects.\",\"default\":true},\"onlyGlobalChat\":{\"title\":\"Only global chat\",\"type\":\"boolean\",\"default\":true,\"description\":\"Only relay messages from global chat (no team chat or private messages)\"},\"filterCommands\":{\"title\":\"Filter commands\",\"type\":\"boolean\",\"default\":false,\"description\":\"Don't relay command messages (/command) to Discord\"},\"filterSystemMessages\":{\"title\":\"Filter system messages\",\"type\":\"boolean\",\"default\":false,\"description\":\"Don't relay system messages to Discord\"},\"useMonitoring\":{\"title\":\"Enable monitoring channel\",\"type\":\"boolean\",\"default\":false,\"description\":\"Send commands and system messages to a separate monitoring channel\"},\"monitoringChannelId\":{\"title\":\"Monitoring channel ID\",\"type\":\"string\",\"description\":\"Discord channel ID for monitoring messages (only used if monitoring is enabled)\"}},\"additionalProperties\":false}",
            "uiSchema": "{}",
            "commands": [],
            "hooks": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const config = data.module.userConfig;\n\n    // Get message details\n    const sender = data.player ? data.player.name : 'Non-player';\n    const message = data.eventData.msg;\n    const channel = data.eventData.channel;\n    const isCommand = message.startsWith('/');\n\n    // Check if the message is from Discord (starts with [D])\n    const isDiscordMessage = message.startsWith('[D] ');\n\n    // If this is a Discord echo message, skip it completely to prevent loops\n    if (isDiscordMessage) {\n        return;\n    }\n\n    // Format message based on channel type\n    let formattedMessage;\n    if (channel === \"global\") {\n        formattedMessage = `**${sender}**: ${message}`;\n    } else if (channel === \"team\") {\n        formattedMessage = `[Party] **${sender}**: ${message}`;\n    } else {\n        formattedMessage = `[Friends] **${sender}**: ${message}`;\n    }\n\n    // Always send to monitoring channel if enabled\n    if (config.useMonitoring && config.monitoringChannelId) {\n        await takaro.discord.discordControllerSendMessage(config.monitoringChannelId, {\n            message: formattedMessage\n        });\n    }\n\n    // Apply filters for main channel\n    if (config.onlyGlobalChat && channel !== 'global') return;\n    if (isCommand && config.filterCommands) return;\n    // Only filter system messages that aren't from Discord users (already handled above)\n    if (sender === 'Non-player' && config.filterSystemMessages) return;\n\n    // Send to main channel after filters\n    const mainChannel = data.module.systemConfig.hooks['DiscordToGame'].discordChannelId;\n    await takaro.discord.discordControllerSendMessage(mainChannel, {\n        message: formattedMessage\n    });\n}\n\nawait main();",
                    "name": "GameToDiscord",
                    "description": null,
                    "eventType": "chat-message"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\nimport { getServerStatusMessage } from './utils.js';\n\nasync function main() {\n    try {\n        const config = data.module.userConfig;\n\n        // Skip messages from bots\n        if (data.eventData.author.isBot)\n            return;\n\n        // Get Discord channel from module system config\n        const discordChannelId = data.discordChannelId ||\n            data.module.systemConfig.hooks['DiscordToGame']?.discordChannelId;\n\n        if (!discordChannelId) {\n            console.error(\"Discord channel ID is missing from both data context and module config\");\n            return;\n        }\n\n        // Format the message for monitoring\n        const formattedMessage = `[Discord ‚Üí Game] **${data.eventData.author.displayName}**: ${data.eventData.msg}`;\n\n        // If monitoring is enabled, send to monitoring channel\n        if (config.useMonitoring && config.monitoringChannelId) {\n            await takaro.discord.discordControllerSendMessage(config.monitoringChannelId, {\n                message: formattedMessage\n            });\n        }\n\n        // Check if the message is the serverstatus command\n        if (data.eventData.msg.toLowerCase().endsWith('serverstatus')) {\n            // Use a fixed server start time for demonstration\n            const serverStartTime = new Date(\"2025-04-12T11:54:01.547Z\");\n\n            // Get server status message\n            const message = await getServerStatusMessage(data.gameServerId, serverStartTime);\n\n            // Send to Discord\n            await takaro.discord.discordControllerSendMessage(discordChannelId, {\n                message: message\n            });\n\n            // Return early to avoid forwarding the command to the game\n            return;\n        }\n\n        // Forward regular messages to the game\n        await takaro.gameserver.gameServerControllerSendMessage(data.gameServerId, {\n            message: `[D] ${data.eventData.author.displayName}:  ${data.eventData.msg}`,\n        });\n    }\n    catch (error) {\n        console.error(error);\n\n        // Try to get Discord channel ID if we haven't already\n        const discordChannelId = data.discordChannelId ||\n            data.module.systemConfig.hooks['DiscordToGame']?.discordChannelId;\n\n        if (discordChannelId) {\n            await takaro.discord.discordControllerSendMessage(discordChannelId, {\n                message: 'Failed to forward your message to the game. Please try again later.',\n            });\n        } else {\n            console.error(\"Could not send error message because Discord channel ID is missing\");\n        }\n    }\n}\n\nawait main();",
                    "name": "DiscordToGame",
                    "description": null,
                    "eventType": "discord-message"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { player } = data;\n    const discordChannel = data.module.systemConfig.hooks['DiscordToGame'].discordChannelId;\n\n    await takaro.discord.discordControllerSendMessage(discordChannel, {\n        message: `**[üëã Disconnected]**: ${player.name} has left the server\\n` +\n            `Steam: https://steamcommunity.com/profiles/${player.steamId}\\n` +\n            `Takaro: https://dashboard.takaro.io/player/${player.id}/info`\n    });\n}\n\nawait main();",
                    "name": "PlayerDisconnected",
                    "description": null,
                    "eventType": "player-disconnected"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { player } = data;\n    const discordChannel = data.module.systemConfig.hooks['DiscordToGame'].discordChannelId;\n\n    await takaro.discord.discordControllerSendMessage(discordChannel, {\n        message: `**[‚ö° Connected]**: ${player.name} has joined the server\\n` +\n            `Steam: https://steamcommunity.com/profiles/${player.steamId}\\n` +\n            `Takaro: https://dashboard.takaro.io/player/${player.id}/info`\n    });\n}\n\nawait main();",
                    "name": "PlayerConnected",
                    "description": null,
                    "eventType": "player-connected"
                }
            ],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\nimport { getServerStatusMessage } from './utils.js';\n\nasync function main() {\n    try {\n        const { gameServerId, module: mod } = data;\n        const discordChannel = mod.systemConfig.hooks['DiscordToGame']?.discordChannelId;\n\n        if (!discordChannel) {\n            console.error(\"Discord channel ID not configured\");\n            return { success: false, reason: \"Discord channel ID not configured\" };\n        }\n\n        // Use a fixed server start time for demonstration\n        const serverStartTime = new Date(\"2025-04-12T11:54:01.547Z\");\n\n        // Get the complete server status message\n        const message = await getServerStatusMessage(gameServerId, serverStartTime);\n\n        // Send the message to Discord\n        await takaro.discord.discordControllerSendMessage(discordChannel, {\n            message: message\n        });\n\n        // Return success result\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error in serverStatus cronjob:\", error);\n        return {\n            success: false,\n            reason: error.message || \"Unknown error in serverStatus cronjob\"\n        };\n    }\n}\n\nawait main();",
                    "name": "serverStatus",
                    "description": "the server status cronjob",
                    "temporalValue": "*/30 * * * *"
                }
            ],
            "functions": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\n/**\n * Gets the server start time from the latest server-status-changed event with status \"online\"\n * @param {string} gameServerId - The ID of the game server\n * @returns {Promise<Date>} The server start time\n */\nexport async function getServerStartTime(gameServerId) {\n    try {\n        // First try to get server-status-changed events\n        const statusEvents = await takaro.event.eventControllerSearch({\n            filters: {\n                eventName: ['server-status-changed'],\n                gameserverId: [gameServerId]\n            }\n        });\n\n        // Filter for online events and find the most recent one\n        if (statusEvents.data.data.length > 0) {\n            const onlineEvents = statusEvents.data.data.filter(event =>\n                event.meta && event.meta.status === 'online'\n            );\n\n            if (onlineEvents.length > 0) {\n                // Sort by timestamp (newest first)\n                onlineEvents.sort((a, b) =>\n                    new Date(b.meta.timestamp).getTime() - new Date(a.meta.timestamp).getTime()\n                );\n\n                return new Date(onlineEvents[0].meta.timestamp);\n            }\n        }\n\n        // If no server-status-changed events found, try gameserver-created as fallback\n        const creationEvents = await takaro.event.eventControllerSearch({\n            filters: {\n                eventName: ['gameserver-created'],\n                gameserverId: [gameServerId]\n            }\n        });\n\n        if (creationEvents.data.data.length > 0) {\n            // Just use the first one since we're not sorting\n            return new Date(creationEvents.data.data[0].meta.timestamp);\n        }\n\n        // Final fallback - use server creation time from the gameServer object\n        const serverInfo = await takaro.gameserver.gameServerControllerGetOne(gameServerId);\n        if (serverInfo && serverInfo.data && serverInfo.data.data) {\n            return new Date(serverInfo.data.data.createdAt);\n        }\n\n        // If all else fails, use 1 day ago as fallback\n        const fallbackTime = new Date();\n        fallbackTime.setDate(fallbackTime.getDate() - 1);\n        return fallbackTime;\n    } catch (error) {\n        console.error(\"Error getting server start time:\", error);\n        // Return a fallback value if there's an error\n        const fallbackTime = new Date();\n        fallbackTime.setDate(fallbackTime.getDate() - 1);\n        return fallbackTime;\n    }\n}\n\n/**\n * Gets the server creation time from gameserver-created event\n * @param {string} gameServerId - The ID of the game server\n * @returns {Promise<Date>} The server creation time\n */\nexport async function getServerCreationTime(gameServerId) {\n    try {\n        // Get gameserver-created events\n        const creationEvents = await takaro.event.eventControllerSearch({\n            filters: {\n                eventName: ['gameserver-created'],\n                gameserverId: [gameServerId]\n            }\n        });\n\n        if (creationEvents.data.data.length > 0) {\n            // Sort by timestamp (oldest first) to get the original creation time\n            creationEvents.data.data.sort((a, b) =>\n                new Date(a.meta.timestamp).getTime() - new Date(b.meta.timestamp).getTime()\n            );\n\n            return new Date(creationEvents.data.data[0].meta.timestamp);\n        }\n\n        // Fallback to the server's creation time in the database\n        const serverInfo = await takaro.gameserver.gameServerControllerGetOne(gameServerId);\n        if (serverInfo && serverInfo.data && serverInfo.data.data) {\n            return new Date(serverInfo.data.data.createdAt);\n        }\n\n        // If all else fails, use today as fallback\n        return new Date();\n    } catch (error) {\n        console.error(\"Error getting server creation time:\", error);\n        return new Date(); // Return current time as fallback\n    }\n}\n\n/**\n * Calculates server uptime from a given start time\n * @param {Date} serverStartTime - The time when the server started\n * @returns {string} Formatted uptime string (e.g. \"2d 5h 30m\")\n */\nexport function calculateUptime(serverStartTime) {\n    try {\n        const currentTime = new Date();\n        const uptimeMs = currentTime.getTime() - serverStartTime.getTime();\n        const uptimeSeconds = Math.floor(uptimeMs / 1000);\n        const days = Math.floor(uptimeSeconds / 86400);\n        const hours = Math.floor((uptimeSeconds % 86400) / 3600);\n        const minutes = Math.floor((uptimeSeconds % 3600) / 60);\n\n        let serverUptime = \"\";\n        if (days > 0) serverUptime += `${days}d `;\n        if (hours > 0 || days > 0) serverUptime += `${hours}h `;\n        serverUptime += `${minutes}m`;\n\n        return serverUptime;\n    } catch (error) {\n        console.error(\"Error calculating server uptime:\", error);\n        return \"Unknown\";\n    }\n}\n\n/**\n * Gets a list of online players\n * @param {string} gameServerId - The ID of the game server\n * @returns {Promise<Object>} Object containing player count and formatted player list\n */\nexport async function getOnlinePlayers(gameServerId) {\n    try {\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        let playerList = \"No players online\";\n        const playerCount = onlinePlayers.data.meta.total;\n\n        if (playerCount > 0) {\n            const playerNamePromises = onlinePlayers.data.data.map(async (pog) => {\n                const playerData = await takaro.player.playerControllerGetOne(pog.playerId);\n                return playerData.data.data.name;\n            });\n\n            const playerNames = await Promise.all(playerNamePromises);\n            playerList = playerNames.join(\", \");\n        }\n\n        return {\n            count: playerCount,\n            list: playerList\n        };\n    } catch (error) {\n        console.error(\"Error getting online players:\", error);\n        return {\n            count: 0,\n            list: \"Error retrieving player information\"\n        };\n    }\n}\n\n/**\n * Gets bloodmoon information for 7 Days to Die\n * @param {string} gameServerId - The ID of the game server\n * @returns {Promise<string>} Formatted bloodmoon information\n */\nexport async function getBloodmoonInfo(gameServerId) {\n    try {\n        // Get game time using gettime command\n        const getTimeCommand = await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n            command: \"gettime\"\n        });\n\n        // Get bloodmoon frequency\n        const bmFreqCommand = await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n            command: \"getgamepref BloodMoonFrequency\"\n        });\n\n        // Parse the current day and time\n        let currentDay = 0;\n        let currentTime = \"\";\n\n        // Try to parse from gettime command (e.g. \"Day 5, 02:02\")\n        const dayTimeMatch = getTimeCommand.data.data.rawResult?.match(/Day (\\d+),\\s+(\\d+:\\d+)/i);\n        if (dayTimeMatch) {\n            currentDay = parseInt(dayTimeMatch[1]);\n            currentTime = dayTimeMatch[2];\n        }\n\n        // Parse bloodmoon frequency\n        let bloodMoonFrequency = 7; // Default value\n        const freqMatch = bmFreqCommand.data.data.rawResult?.match(/BloodMoonFrequency\\s*=\\s*(\\d+)/i);\n        if (freqMatch) {\n            bloodMoonFrequency = parseInt(freqMatch[1]);\n        }\n\n        // Calculate days until bloodmoon\n        if (currentDay > 0) {\n            // Calculate next bloodmoon day\n            const daysUntilBloodmoon = bloodMoonFrequency - (currentDay % bloodMoonFrequency);\n            const nextBloodmoonDay = currentDay + daysUntilBloodmoon;\n\n            // Special case: if today is bloodmoon day\n            if (daysUntilBloodmoon === bloodMoonFrequency) {\n                return `üìÖ Day ${currentDay} (${currentTime}) | üî¥ **Bloodmoon: TONIGHT!** üî¥`;\n            } else if (daysUntilBloodmoon === 1) {\n                return `üìÖ Day ${currentDay} (${currentTime}) | üî¥ Next Bloodmoon: Day ${nextBloodmoonDay} | ‚ö†Ô∏è **TOMORROW!** ‚ö†Ô∏è`;\n            } else {\n                return `üìÖ Day ${currentDay} (${currentTime}) | üî¥ Next Bloodmoon: Day ${nextBloodmoonDay} | ${daysUntilBloodmoon} days until bloodmoon`;\n            }\n        }\n\n        // Fall back to old method if gettime doesn't work\n        const bmDayCommand = await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n            command: \"ggs BloodMoonDay\"\n        });\n\n        let nextBloodmoonDay = 0;\n        const bloodmoonMatch = bmDayCommand.data.data.rawResult?.match(/BloodMoonDay\\s*=\\s*(\\d+)/i);\n        if (bloodmoonMatch) {\n            nextBloodmoonDay = parseInt(bloodmoonMatch[1]);\n            return `üî¥ Next Bloodmoon: Day ${nextBloodmoonDay}`;\n        }\n\n        return \"Unknown\";\n    } catch (error) {\n        console.error(\"Error getting bloodmoon information:\", error);\n        return \"Error getting bloodmoon information\";\n    }\n}\n\n/**\n * Formats a date as a relative time string (e.g., \"2 days ago\")\n * @param {Date} date - The date to format\n * @returns {string} Formatted relative time string\n */\nexport function formatRelativeTime(date) {\n    const now = new Date();\n    const diffMs = now.getTime() - date.getTime();\n    const diffSeconds = Math.floor(diffMs / 1000);\n    const diffMinutes = Math.floor(diffSeconds / 60);\n    const diffHours = Math.floor(diffMinutes / 60);\n    const diffDays = Math.floor(diffHours / 24);\n\n    if (diffDays > 0) {\n        return `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;\n    } else if (diffHours > 0) {\n        return `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;\n    } else if (diffMinutes > 0) {\n        return `${diffMinutes} minute${diffMinutes !== 1 ? 's' : ''} ago`;\n    } else {\n        return 'just now';\n    }\n}\n\n/**\n * Generates a complete server status message\n * @param {string} gameServerId - The ID of the game server\n * @param {Object} config - User configuration options\n * @returns {Promise<string>} Formatted server status message for Discord\n */\nexport async function getServerStatusMessage(gameServerId, config = {}) {\n    try {\n        let message = \"**Server Status**\\n\";\n\n        // Get uptime if enabled in config\n        if (config.showUptime !== false) {\n            const serverStartTime = await getServerStartTime(gameServerId);\n            const uptime = calculateUptime(serverStartTime);\n            message += `‚è±Ô∏è Uptime: ${uptime}\\n`;\n        }\n\n        // Get server creation time if enabled in config\n        if (config.showCreationTime !== false) {\n            const serverCreationTime = await getServerCreationTime(gameServerId);\n            const createdRelative = formatRelativeTime(serverCreationTime);\n            message += `üÜï Server created: ${createdRelative}\\n`;\n        }\n\n        // Get bloodmoon info if enabled in config\n        if (config.showBloodmoon !== false) {\n            const bloodmoonInfo = await getBloodmoonInfo(gameServerId);\n            message += `${bloodmoonInfo}\\n`;\n        }\n\n        // Always show player info\n        const players = await getOnlinePlayers(gameServerId);\n        message += `üë• Players online (${players.count}): ${players.list}`;\n\n        return message;\n    } catch (error) {\n        console.error(\"Error generating server status message:\", error);\n        return `**Server Status**\\nError: Could not retrieve server information`;\n    }\n}",
                    "name": "utils",
                    "description": null
                }
            ],
            "permissions": []
        }
    ],
    "takaroVersion": "v0.0.24"
}