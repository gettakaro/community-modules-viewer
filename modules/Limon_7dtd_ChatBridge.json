{
    "name": "Limon_7dtd_ChatBridge",
    "versions": [
        {
            "tag": "2.0.0",
"description": "Enables two-way chat communication between your 7 Days to Die game server and a Discord channel, enhancing community interaction and providing server monitoring tools.\n\n  **Key Functionality:**\n\n  * **Two-Way Chat Relay:** Seamlessly forwards messages between the game server and the designated Discord channel, allowing players in-game and on Discord to communicate with each other.\n  * **Player Connection/Disconnection Notifications:** Automatically sends messages to Discord when players join or leave the server, with links to their Steam and Takaro profiles for easy access.\n  * **Advanced Filtering Options:** Offers robust filtering options to control which messages are relayed to Discord:\n      * `Only Global Chat:` Relays only messages from the game's global chat, excluding private or team messages.\n      * `Filter Commands:` Prevents in-game commands (e.g., `/ban`, `/kick`) from cluttering your Discord channel.\n      * `Filter System Messages:` Excludes non-player system messages from being forwarded to Discord.\n  * **Monitoring Channel Support:** Set up a separate Discord channel that receives *all* server activity, including filtered messages, for comprehensive moderation and debugging.\n  * **Server Status Features:** Includes a Discord command for checking server uptime, player count, and in-game day information. For 7 Days to Die servers, it provides Blood Moon tracking with automatic countdown and warnings.\n\n  **How to Use:**\n\n  1.  **Configuration:** Configure the module in your Takaro dashboard by entering your Discord channel IDs and selecting your preferred filtering options.\n  2.  **Discord Setup:** Ensure your Discord bot has permissions to send and receive messages in the configured channels.\n  3.  **Installation:** Install and enable the module on your Takaro instance for your 7 Days to Die server.\n  4.  **Using Features:** Type \"serverstatus\" in your configured Discord channel to get current server information, or use the scheduled updates for regular status reports.\n\n  **Important Considerations:**\n\n  * This module enhances community engagement by bridging the gap between players in-game and those on Discord.\n  * The server status features provide valuable information for players without needing to log into the game.\n  * For optimal performance, configure the filtering options based on your community's specific needs and server activity level.\n  * Regular status updates can be configured to run at customized intervals via the module's cronjob settings.\n",            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sendPlayerConnected\":{\"title\":\"Send player connected\",\"type\":\"boolean\",\"description\":\"Send a message when a player connects.\",\"default\":true},\"sendPlayerDisconnected\":{\"title\":\"Send player disconnected\",\"type\":\"boolean\",\"description\":\"Send a message when a player disconnects.\",\"default\":true},\"onlyGlobalChat\":{\"title\":\"Only global chat\",\"type\":\"boolean\",\"default\":true,\"description\":\"Only relay messages from global chat (no team chat or private messages)\"},\"filterCommands\":{\"title\":\"Filter commands\",\"type\":\"boolean\",\"default\":false,\"description\":\"Don't relay command messages (/command) to Discord\"},\"filterSystemMessages\":{\"title\":\"Filter system messages\",\"type\":\"boolean\",\"default\":false,\"description\":\"Don't relay system messages to Discord\"},\"useMonitoring\":{\"title\":\"Enable monitoring channel\",\"type\":\"boolean\",\"default\":false,\"description\":\"Send commands and system messages to a separate monitoring channel\"},\"monitoringChannelId\":{\"title\":\"Monitoring channel ID\",\"type\":\"string\",\"description\":\"Discord channel ID for monitoring messages (only used if monitoring is enabled)\"}},\"additionalProperties\":false}",
            "uiSchema": "{}",
            "commands": [],
            "hooks": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const config = data.module.userConfig;\n\n    // Get message details\n    const sender = data.player ? data.player.name : 'Non-player';\n    const message = data.eventData.msg;\n    const channel = data.eventData.channel;\n    const isCommand = message.startsWith('/');\n\n    // Format message based on channel type\n    let formattedMessage;\n    if (channel === \"global\") {\n        formattedMessage = `**${sender}**: ${message}`;\n    } else if (channel === \"team\") {\n        formattedMessage = `[Party] **${sender}**: ${message}`;\n    } else {\n        formattedMessage = `[Friends] **${sender}**: ${message}`;\n    }\n\n    // Always send to monitoring channel if enabled\n    if (config.useMonitoring && config.monitoringChannelId) {\n        await takaro.discord.discordControllerSendMessage(config.monitoringChannelId, {\n            message: formattedMessage\n        });\n    }\n\n    // Apply filters for main channel\n    if (config.onlyGlobalChat && channel !== 'global') return;\n    if (isCommand && config.filterCommands) return;\n    if (sender === 'Non-player' && config.filterSystemMessages) return;\n\n    // Send to main channel after filters\n    const mainChannel = data.module.systemConfig.hooks['DiscordToGame'].discordChannelId;\n    await takaro.discord.discordControllerSendMessage(mainChannel, {\n        message: formattedMessage\n    });\n}\n\nawait main();",
                    "name": "GameToDiscord",
                    "description": null,
                    "eventType": "chat-message"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\nasync function main() {\n    const discordChannel = data.module.systemConfig.hooks['DiscordToGame'].discordChannelId;\n    await takaro.discord.discordControllerSendMessage(discordChannel, {\n        message: `[⚡ Connected]: ${data.player.name}`,\n    });\n}\nawait main();\n//# sourceMappingURL=PlayerConnected.js.map",
                    "name": "PlayerConnected",
                    "description": null,
                    "eventType": "player-connected"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\nimport { getServerStatusMessage } from './utils.js';\n\nasync function main() {\n    try {\n        // Skip messages from bots\n        if (data.eventData.author.isBot)\n            return;\n\n        // Get Discord channel from module system config\n        const discordChannelId = data.discordChannelId ||\n            data.module.systemConfig.hooks['DiscordToGame']?.discordChannelId;\n\n        if (!discordChannelId) {\n            console.error(\"Discord channel ID is missing from both data context and module config\");\n            return;\n        }\n\n        // Check if the message is the serverstatus command\n        if (data.eventData.msg.toLowerCase().endsWith('serverstatus')) {\n            // Use a fixed server start time for demonstration\n            const serverStartTime = new Date(\"2025-04-12T11:54:01.547Z\");\n\n            // Get server status message\n            const message = await getServerStatusMessage(data.gameServerId, serverStartTime);\n\n            // Send to Discord\n            await takaro.discord.discordControllerSendMessage(discordChannelId, {\n                message: message\n            });\n\n            // Return early to avoid forwarding the command to the game\n            return;\n        }\n\n        // Forward regular messages to the game\n        await takaro.gameserver.gameServerControllerSendMessage(data.gameServerId, {\n            message: `[D] ${data.eventData.author.displayName}:  ${data.eventData.msg}`,\n        });\n    }\n    catch (error) {\n        console.error(error);\n\n        // Try to get Discord channel ID if we haven't already\n        const discordChannelId = data.discordChannelId ||\n            data.module.systemConfig.hooks['DiscordToGame']?.discordChannelId;\n\n        if (discordChannelId) {\n            await takaro.discord.discordControllerSendMessage(discordChannelId, {\n                message: 'Failed to forward your message to the game. Please try again later.',\n            });\n        } else {\n            console.error(\"Could not send error message because Discord channel ID is missing\");\n        }\n    }\n}\n\nawait main();",
                    "name": "DiscordToGame",
                    "description": null,
                    "eventType": "discord-message"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\nasync function main() {\n    const discordChannel = data.module.systemConfig.hooks['DiscordToGame'].discordChannelId;\n    await takaro.discord.discordControllerSendMessage(discordChannel, {\n        message: `[👋 Disconnected]: ${data.player.name}`,\n    });\n}\nawait main();\n//# sourceMappingURL=PlayerDisconnected.js.map",
                    "name": "PlayerDisconnected",
                    "description": null,
                    "eventType": "player-disconnected"
                }
            ],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\nimport { getServerStatusMessage } from './utils.js';\n\nasync function main() {\n    try {\n        const { gameServerId, module: mod } = data;\n        const discordChannel = mod.systemConfig.hooks['DiscordToGame']?.discordChannelId;\n\n        if (!discordChannel) {\n            console.error(\"Discord channel ID not configured\");\n            return { success: false, reason: \"Discord channel ID not configured\" };\n        }\n\n        // Use a fixed server start time for demonstration\n        const serverStartTime = new Date(\"2025-04-12T11:54:01.547Z\");\n\n        // Get the complete server status message\n        const message = await getServerStatusMessage(gameServerId, serverStartTime);\n\n        // Send the message to Discord\n        await takaro.discord.discordControllerSendMessage(discordChannel, {\n            message: message\n        });\n\n        // Return success result\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error in serverStatus cronjob:\", error);\n        return {\n            success: false,\n            reason: error.message || \"Unknown error in serverStatus cronjob\"\n        };\n    }\n}\n\nawait main();",
                    "name": "serverStatus",
                    "description": null,
                    "temporalValue": "0 0 * * *"
                }
            ],
            "functions": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\n/**\n * Gets the server start time from the latest server-status-changed event with status \"online\"\n * @param {string} gameServerId - The ID of the game server\n * @returns {Promise<Date>} The server start time\n */\nexport async function getServerStartTime(gameServerId) {\n    try {\n        // First try to get server-status-changed events\n        const statusEvents = await takaro.event.eventControllerSearch({\n            filters: {\n                eventName: ['server-status-changed'],\n                gameserverId: [gameServerId]\n            }\n        });\n\n        // Filter for online events and find the most recent one\n        if (statusEvents.data.data.length > 0) {\n            const onlineEvents = statusEvents.data.data.filter(event =>\n                event.meta && event.meta.status === 'online'\n            );\n\n            if (onlineEvents.length > 0) {\n                // Sort by timestamp (newest first)\n                onlineEvents.sort((a, b) =>\n                    new Date(b.meta.timestamp).getTime() - new Date(a.meta.timestamp).getTime()\n                );\n\n                return new Date(onlineEvents[0].meta.timestamp);\n            }\n        }\n\n        // If no server-status-changed events found, try gameserver-created as fallback\n        const creationEvents = await takaro.event.eventControllerSearch({\n            filters: {\n                eventName: ['gameserver-created'],\n                gameserverId: [gameServerId]\n            }\n        });\n\n        if (creationEvents.data.data.length > 0) {\n            // Just use the first one since we're not sorting\n            return new Date(creationEvents.data.data[0].meta.timestamp);\n        }\n\n        // Final fallback - use server creation time from the gameServer object\n        const serverInfo = await takaro.gameserver.gameServerControllerGetOne(gameServerId);\n        if (serverInfo && serverInfo.data && serverInfo.data.data) {\n            return new Date(serverInfo.data.data.createdAt);\n        }\n\n        // If all else fails, use 1 day ago as fallback\n        const fallbackTime = new Date();\n        fallbackTime.setDate(fallbackTime.getDate() - 1);\n        return fallbackTime;\n    } catch (error) {\n        console.error(\"Error getting server start time:\", error);\n        // Return a fallback value if there's an error\n        const fallbackTime = new Date();\n        fallbackTime.setDate(fallbackTime.getDate() - 1);\n        return fallbackTime;\n    }\n}\n\n/**\n * Gets the server creation time from gameserver-created event\n * @param {string} gameServerId - The ID of the game server\n * @returns {Promise<Date>} The server creation time\n */\nexport async function getServerCreationTime(gameServerId) {\n    try {\n        // Get gameserver-created events\n        const creationEvents = await takaro.event.eventControllerSearch({\n            filters: {\n                eventName: ['gameserver-created'],\n                gameserverId: [gameServerId]\n            }\n        });\n\n        if (creationEvents.data.data.length > 0) {\n            // Sort by timestamp (oldest first) to get the original creation time\n            creationEvents.data.data.sort((a, b) =>\n                new Date(a.meta.timestamp).getTime() - new Date(b.meta.timestamp).getTime()\n            );\n\n            return new Date(creationEvents.data.data[0].meta.timestamp);\n        }\n\n        // Fallback to the server's creation time in the database\n        const serverInfo = await takaro.gameserver.gameServerControllerGetOne(gameServerId);\n        if (serverInfo && serverInfo.data && serverInfo.data.data) {\n            return new Date(serverInfo.data.data.createdAt);\n        }\n\n        // If all else fails, use today as fallback\n        return new Date();\n    } catch (error) {\n        console.error(\"Error getting server creation time:\", error);\n        return new Date(); // Return current time as fallback\n    }\n}\n\n/**\n * Calculates server uptime from a given start time\n * @param {Date} serverStartTime - The time when the server started\n * @returns {string} Formatted uptime string (e.g. \"2d 5h 30m\")\n */\nexport function calculateUptime(serverStartTime) {\n    try {\n        const currentTime = new Date();\n        const uptimeMs = currentTime.getTime() - serverStartTime.getTime();\n        const uptimeSeconds = Math.floor(uptimeMs / 1000);\n        const days = Math.floor(uptimeSeconds / 86400);\n        const hours = Math.floor((uptimeSeconds % 86400) / 3600);\n        const minutes = Math.floor((uptimeSeconds % 3600) / 60);\n\n        let serverUptime = \"\";\n        if (days > 0) serverUptime += `${days}d `;\n        if (hours > 0 || days > 0) serverUptime += `${hours}h `;\n        serverUptime += `${minutes}m`;\n\n        return serverUptime;\n    } catch (error) {\n        console.error(\"Error calculating server uptime:\", error);\n        return \"Unknown\";\n    }\n}\n\n/**\n * Gets a list of online players\n * @param {string} gameServerId - The ID of the game server\n * @returns {Promise<Object>} Object containing player count and formatted player list\n */\nexport async function getOnlinePlayers(gameServerId) {\n    try {\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        let playerList = \"No players online\";\n        const playerCount = onlinePlayers.data.meta.total;\n\n        if (playerCount > 0) {\n            const playerNamePromises = onlinePlayers.data.data.map(async (pog) => {\n                const playerData = await takaro.player.playerControllerGetOne(pog.playerId);\n                return playerData.data.data.name;\n            });\n\n            const playerNames = await Promise.all(playerNamePromises);\n            playerList = playerNames.join(\", \");\n        }\n\n        return {\n            count: playerCount,\n            list: playerList\n        };\n    } catch (error) {\n        console.error(\"Error getting online players:\", error);\n        return {\n            count: 0,\n            list: \"Error retrieving player information\"\n        };\n    }\n}\n\n/**\n * Gets bloodmoon information for 7 Days to Die\n * @param {string} gameServerId - The ID of the game server\n * @returns {Promise<string>} Formatted bloodmoon information\n */\nexport async function getBloodmoonInfo(gameServerId) {\n    try {\n        // Get game time using gettime command\n        const getTimeCommand = await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n            command: \"gettime\"\n        });\n\n        // Get bloodmoon frequency\n        const bmFreqCommand = await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n            command: \"getgamepref BloodMoonFrequency\"\n        });\n\n        // Parse the current day and time\n        let currentDay = 0;\n        let currentTime = \"\";\n\n        // Try to parse from gettime command (e.g. \"Day 5, 02:02\")\n        const dayTimeMatch = getTimeCommand.data.data.rawResult?.match(/Day (\\d+),\\s+(\\d+:\\d+)/i);\n        if (dayTimeMatch) {\n            currentDay = parseInt(dayTimeMatch[1]);\n            currentTime = dayTimeMatch[2];\n        }\n\n        // Parse bloodmoon frequency\n        let bloodMoonFrequency = 7; // Default value\n        const freqMatch = bmFreqCommand.data.data.rawResult?.match(/BloodMoonFrequency\\s*=\\s*(\\d+)/i);\n        if (freqMatch) {\n            bloodMoonFrequency = parseInt(freqMatch[1]);\n        }\n\n        // Calculate days until bloodmoon\n        if (currentDay > 0) {\n            // Calculate next bloodmoon day\n            const daysUntilBloodmoon = bloodMoonFrequency - (currentDay % bloodMoonFrequency);\n            const nextBloodmoonDay = currentDay + daysUntilBloodmoon;\n\n            // Special case: if today is bloodmoon day\n            if (daysUntilBloodmoon === bloodMoonFrequency) {\n                return `📅 Day ${currentDay} (${currentTime}) | 🔴 **Bloodmoon: TONIGHT!** 🔴`;\n            } else if (daysUntilBloodmoon === 1) {\n                return `📅 Day ${currentDay} (${currentTime}) | 🔴 Next Bloodmoon: Day ${nextBloodmoonDay} | ⚠️ **TOMORROW!** ⚠️`;\n            } else {\n                return `📅 Day ${currentDay} (${currentTime}) | 🔴 Next Bloodmoon: Day ${nextBloodmoonDay} | ${daysUntilBloodmoon} days until bloodmoon`;\n            }\n        }\n\n        // Fall back to old method if gettime doesn't work\n        const bmDayCommand = await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n            command: \"ggs BloodMoonDay\"\n        });\n\n        let nextBloodmoonDay = 0;\n        const bloodmoonMatch = bmDayCommand.data.data.rawResult?.match(/BloodMoonDay\\s*=\\s*(\\d+)/i);\n        if (bloodmoonMatch) {\n            nextBloodmoonDay = parseInt(bloodmoonMatch[1]);\n            return `🔴 Next Bloodmoon: Day ${nextBloodmoonDay}`;\n        }\n\n        return \"Unknown\";\n    } catch (error) {\n        console.error(\"Error getting bloodmoon information:\", error);\n        return \"Error getting bloodmoon information\";\n    }\n}\n\n/**\n * Formats a date as a relative time string (e.g., \"2 days ago\")\n * @param {Date} date - The date to format\n * @returns {string} Formatted relative time string\n */\nexport function formatRelativeTime(date) {\n    const now = new Date();\n    const diffMs = now.getTime() - date.getTime();\n    const diffSeconds = Math.floor(diffMs / 1000);\n    const diffMinutes = Math.floor(diffSeconds / 60);\n    const diffHours = Math.floor(diffMinutes / 60);\n    const diffDays = Math.floor(diffHours / 24);\n\n    if (diffDays > 0) {\n        return `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;\n    } else if (diffHours > 0) {\n        return `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;\n    } else if (diffMinutes > 0) {\n        return `${diffMinutes} minute${diffMinutes !== 1 ? 's' : ''} ago`;\n    } else {\n        return 'just now';\n    }\n}\n\n/**\n * Generates a complete server status message\n * @param {string} gameServerId - The ID of the game server\n * @returns {Promise<string>} Formatted server status message for Discord\n */\nexport async function getServerStatusMessage(gameServerId) {\n    try {\n        // Get server start time and creation time\n        const serverStartTime = await getServerStartTime(gameServerId);\n        const serverCreationTime = await getServerCreationTime(gameServerId);\n\n        const uptime = calculateUptime(serverStartTime);\n        const createdRelative = formatRelativeTime(serverCreationTime);\n        const players = await getOnlinePlayers(gameServerId);\n        const bloodmoonInfo = await getBloodmoonInfo(gameServerId);\n\n        return `**Server Status**\\n` +\n            `⏱️ Uptime: ${uptime}\\n` +\n            `🆕 Server created: ${createdRelative}\\n` +\n            `${bloodmoonInfo}\\n` +\n            `👥 Players online (${players.count}): ${players.list}`;\n    } catch (error) {\n        console.error(\"Error generating server status message:\", error);\n        return `**Server Status**\\nError: Could not retrieve server information`;\n    }\n}",
                    "name": "utils",
                    "description": null
                }
            ],
            "permissions": []
        },
        {
            "tag": "latest",
"description": "Enables two-way chat communication between your 7 Days to Die game server and a Discord channel, enhancing community interaction and providing server monitoring tools.\n\n  **Key Functionality:**\n\n  * **Two-Way Chat Relay:** Seamlessly forwards messages between the game server and the designated Discord channel, allowing players in-game and on Discord to communicate with each other.\n  * **Player Connection/Disconnection Notifications:** Automatically sends messages to Discord when players join or leave the server, with links to their Steam and Takaro profiles for easy access.\n  * **Advanced Filtering Options:** Offers robust filtering options to control which messages are relayed to Discord:\n      * `Only Global Chat:` Relays only messages from the game's global chat, excluding private or team messages.\n      * `Filter Commands:` Prevents in-game commands (e.g., `/ban`, `/kick`) from cluttering your Discord channel.\n      * `Filter System Messages:` Excludes non-player system messages from being forwarded to Discord.\n  * **Monitoring Channel Support:** Set up a separate Discord channel that receives *all* server activity, including filtered messages, for comprehensive moderation and debugging.\n  * **Server Status Features:** Includes a Discord command for checking server uptime, player count, and in-game day information. For 7 Days to Die servers, it provides Blood Moon tracking with automatic countdown and warnings.\n\n  **How to Use:**\n\n  1.  **Configuration:** Configure the module in your Takaro dashboard by entering your Discord channel IDs and selecting your preferred filtering options.\n  2.  **Discord Setup:** Ensure your Discord bot has permissions to send and receive messages in the configured channels.\n  3.  **Installation:** Install and enable the module on your Takaro instance for your 7 Days to Die server.\n  4.  **Using Features:** Type \"serverstatus\" in your configured Discord channel to get current server information, or use the scheduled updates for regular status reports.\n\n  **Important Considerations:**\n\n  * This module enhances community engagement by bridging the gap between players in-game and those on Discord.\n  * The server status features provide valuable information for players without needing to log into the game.\n  * For optimal performance, configure the filtering options based on your community's specific needs and server activity level.\n  * Regular status updates can be configured to run at customized intervals via the module's cronjob settings.\n",            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sendPlayerConnected\":{\"title\":\"Send player connected\",\"type\":\"boolean\",\"description\":\"Send a message when a player connects.\",\"default\":true},\"sendPlayerDisconnected\":{\"title\":\"Send player disconnected\",\"type\":\"boolean\",\"description\":\"Send a message when a player disconnects.\",\"default\":true},\"onlyGlobalChat\":{\"title\":\"Only global chat\",\"type\":\"boolean\",\"default\":true,\"description\":\"Only relay messages from global chat (no team chat or private messages)\"},\"filterCommands\":{\"title\":\"Filter commands\",\"type\":\"boolean\",\"default\":false,\"description\":\"Don't relay command messages (/command) to Discord\"},\"filterSystemMessages\":{\"title\":\"Filter system messages\",\"type\":\"boolean\",\"default\":false,\"description\":\"Don't relay system messages to Discord\"},\"useMonitoring\":{\"title\":\"Enable monitoring channel\",\"type\":\"boolean\",\"default\":false,\"description\":\"Send commands and system messages to a separate monitoring channel\"},\"monitoringChannelId\":{\"title\":\"Monitoring channel ID\",\"type\":\"string\",\"description\":\"Discord channel ID for monitoring messages (only used if monitoring is enabled)\"}},\"additionalProperties\":false}",
            "uiSchema": "{}",
            "commands": [],
            "hooks": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const config = data.module.userConfig;\n\n    // Get message details\n    const sender = data.player ? data.player.name : 'Non-player';\n    const message = data.eventData.msg;\n    const channel = data.eventData.channel;\n    const isCommand = message.startsWith('/');\n\n    // Format message based on channel type\n    let formattedMessage;\n    if (channel === \"global\") {\n        formattedMessage = `**${sender}**: ${message}`;\n    } else if (channel === \"team\") {\n        formattedMessage = `[Party] **${sender}**: ${message}`;\n    } else {\n        formattedMessage = `[Friends] **${sender}**: ${message}`;\n    }\n\n    // Always send to monitoring channel if enabled\n    if (config.useMonitoring && config.monitoringChannelId) {\n        await takaro.discord.discordControllerSendMessage(config.monitoringChannelId, {\n            message: formattedMessage\n        });\n    }\n\n    // Apply filters for main channel\n    if (config.onlyGlobalChat && channel !== 'global') return;\n    if (isCommand && config.filterCommands) return;\n    if (sender === 'Non-player' && config.filterSystemMessages) return;\n\n    // Send to main channel after filters\n    const mainChannel = data.module.systemConfig.hooks['DiscordToGame'].discordChannelId;\n    await takaro.discord.discordControllerSendMessage(mainChannel, {\n        message: formattedMessage\n    });\n}\n\nawait main();",
                    "name": "GameToDiscord",
                    "description": null,
                    "eventType": "chat-message"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\nimport { getServerStatusMessage } from './utils.js';\n\nasync function main() {\n    try {\n        // Skip messages from bots\n        if (data.eventData.author.isBot)\n            return;\n\n        // Get Discord channel from module system config\n        const discordChannelId = data.discordChannelId ||\n            data.module.systemConfig.hooks['DiscordToGame']?.discordChannelId;\n\n        if (!discordChannelId) {\n            console.error(\"Discord channel ID is missing from both data context and module config\");\n            return;\n        }\n\n        // Check if the message is the serverstatus command\n        if (data.eventData.msg.toLowerCase().endsWith('serverstatus')) {\n            // Use a fixed server start time for demonstration\n            const serverStartTime = new Date(\"2025-04-12T11:54:01.547Z\");\n\n            // Get server status message\n            const message = await getServerStatusMessage(data.gameServerId, serverStartTime);\n\n            // Send to Discord\n            await takaro.discord.discordControllerSendMessage(discordChannelId, {\n                message: message\n            });\n\n            // Return early to avoid forwarding the command to the game\n            return;\n        }\n\n        // Forward regular messages to the game\n        await takaro.gameserver.gameServerControllerSendMessage(data.gameServerId, {\n            message: `[D] ${data.eventData.author.displayName}:  ${data.eventData.msg}`,\n        });\n    }\n    catch (error) {\n        console.error(error);\n\n        // Try to get Discord channel ID if we haven't already\n        const discordChannelId = data.discordChannelId ||\n            data.module.systemConfig.hooks['DiscordToGame']?.discordChannelId;\n\n        if (discordChannelId) {\n            await takaro.discord.discordControllerSendMessage(discordChannelId, {\n                message: 'Failed to forward your message to the game. Please try again later.',\n            });\n        } else {\n            console.error(\"Could not send error message because Discord channel ID is missing\");\n        }\n    }\n}\n\nawait main();",
                    "name": "DiscordToGame",
                    "description": null,
                    "eventType": "discord-message"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { player } = data;\n    const discordChannel = data.module.systemConfig.hooks['DiscordToGame'].discordChannelId;\n\n    await takaro.discord.discordControllerSendMessage(discordChannel, {\n        message: `**[👋 Disconnected]**: ${player.name} has left the server\\n` +\n            `Steam: https://steamcommunity.com/profiles/${player.steamId}\\n` +\n            `Takaro: https://dashboard.takaro.io/player/${player.id}/info`\n    });\n}\n\nawait main();",
                    "name": "PlayerDisconnected",
                    "description": null,
                    "eventType": "player-disconnected"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { player } = data;\n    const discordChannel = data.module.systemConfig.hooks['DiscordToGame'].discordChannelId;\n\n    await takaro.discord.discordControllerSendMessage(discordChannel, {\n        message: `**[⚡ Connected]**: ${player.name} has joined the server\\n` +\n            `Steam: https://steamcommunity.com/profiles/${player.steamId}\\n` +\n            `Takaro: https://dashboard.takaro.io/player/${player.id}/info`\n    });\n}\n\nawait main();",
                    "name": "PlayerConnected",
                    "description": null,
                    "eventType": "player-connected"
                }
            ],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\nimport { getServerStatusMessage } from './utils.js';\n\nasync function main() {\n    try {\n        const { gameServerId, module: mod } = data;\n        const discordChannel = mod.systemConfig.hooks['DiscordToGame']?.discordChannelId;\n\n        if (!discordChannel) {\n            console.error(\"Discord channel ID not configured\");\n            return { success: false, reason: \"Discord channel ID not configured\" };\n        }\n\n        // Use a fixed server start time for demonstration\n        const serverStartTime = new Date(\"2025-04-12T11:54:01.547Z\");\n\n        // Get the complete server status message\n        const message = await getServerStatusMessage(gameServerId, serverStartTime);\n\n        // Send the message to Discord\n        await takaro.discord.discordControllerSendMessage(discordChannel, {\n            message: message\n        });\n\n        // Return success result\n        return { success: true };\n    } catch (error) {\n        console.error(\"Error in serverStatus cronjob:\", error);\n        return {\n            success: false,\n            reason: error.message || \"Unknown error in serverStatus cronjob\"\n        };\n    }\n}\n\nawait main();",
                    "name": "serverStatus",
                    "description": "the server status cronjob",
                    "temporalValue": "*/30 * * * *"
                }
            ],
            "functions": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\n/**\n * Gets the server start time from the latest server-status-changed event with status \"online\"\n * @param {string} gameServerId - The ID of the game server\n * @returns {Promise<Date>} The server start time\n */\nexport async function getServerStartTime(gameServerId) {\n    try {\n        // First try to get server-status-changed events\n        const statusEvents = await takaro.event.eventControllerSearch({\n            filters: {\n                eventName: ['server-status-changed'],\n                gameserverId: [gameServerId]\n            }\n        });\n\n        // Filter for online events and find the most recent one\n        if (statusEvents.data.data.length > 0) {\n            const onlineEvents = statusEvents.data.data.filter(event =>\n                event.meta && event.meta.status === 'online'\n            );\n\n            if (onlineEvents.length > 0) {\n                // Sort by timestamp (newest first)\n                onlineEvents.sort((a, b) =>\n                    new Date(b.meta.timestamp).getTime() - new Date(a.meta.timestamp).getTime()\n                );\n\n                return new Date(onlineEvents[0].meta.timestamp);\n            }\n        }\n\n        // If no server-status-changed events found, try gameserver-created as fallback\n        const creationEvents = await takaro.event.eventControllerSearch({\n            filters: {\n                eventName: ['gameserver-created'],\n                gameserverId: [gameServerId]\n            }\n        });\n\n        if (creationEvents.data.data.length > 0) {\n            // Just use the first one since we're not sorting\n            return new Date(creationEvents.data.data[0].meta.timestamp);\n        }\n\n        // Final fallback - use server creation time from the gameServer object\n        const serverInfo = await takaro.gameserver.gameServerControllerGetOne(gameServerId);\n        if (serverInfo && serverInfo.data && serverInfo.data.data) {\n            return new Date(serverInfo.data.data.createdAt);\n        }\n\n        // If all else fails, use 1 day ago as fallback\n        const fallbackTime = new Date();\n        fallbackTime.setDate(fallbackTime.getDate() - 1);\n        return fallbackTime;\n    } catch (error) {\n        console.error(\"Error getting server start time:\", error);\n        // Return a fallback value if there's an error\n        const fallbackTime = new Date();\n        fallbackTime.setDate(fallbackTime.getDate() - 1);\n        return fallbackTime;\n    }\n}\n\n/**\n * Gets the server creation time from gameserver-created event\n * @param {string} gameServerId - The ID of the game server\n * @returns {Promise<Date>} The server creation time\n */\nexport async function getServerCreationTime(gameServerId) {\n    try {\n        // Get gameserver-created events\n        const creationEvents = await takaro.event.eventControllerSearch({\n            filters: {\n                eventName: ['gameserver-created'],\n                gameserverId: [gameServerId]\n            }\n        });\n\n        if (creationEvents.data.data.length > 0) {\n            // Sort by timestamp (oldest first) to get the original creation time\n            creationEvents.data.data.sort((a, b) =>\n                new Date(a.meta.timestamp).getTime() - new Date(b.meta.timestamp).getTime()\n            );\n\n            return new Date(creationEvents.data.data[0].meta.timestamp);\n        }\n\n        // Fallback to the server's creation time in the database\n        const serverInfo = await takaro.gameserver.gameServerControllerGetOne(gameServerId);\n        if (serverInfo && serverInfo.data && serverInfo.data.data) {\n            return new Date(serverInfo.data.data.createdAt);\n        }\n\n        // If all else fails, use today as fallback\n        return new Date();\n    } catch (error) {\n        console.error(\"Error getting server creation time:\", error);\n        return new Date(); // Return current time as fallback\n    }\n}\n\n/**\n * Calculates server uptime from a given start time\n * @param {Date} serverStartTime - The time when the server started\n * @returns {string} Formatted uptime string (e.g. \"2d 5h 30m\")\n */\nexport function calculateUptime(serverStartTime) {\n    try {\n        const currentTime = new Date();\n        const uptimeMs = currentTime.getTime() - serverStartTime.getTime();\n        const uptimeSeconds = Math.floor(uptimeMs / 1000);\n        const days = Math.floor(uptimeSeconds / 86400);\n        const hours = Math.floor((uptimeSeconds % 86400) / 3600);\n        const minutes = Math.floor((uptimeSeconds % 3600) / 60);\n\n        let serverUptime = \"\";\n        if (days > 0) serverUptime += `${days}d `;\n        if (hours > 0 || days > 0) serverUptime += `${hours}h `;\n        serverUptime += `${minutes}m`;\n\n        return serverUptime;\n    } catch (error) {\n        console.error(\"Error calculating server uptime:\", error);\n        return \"Unknown\";\n    }\n}\n\n/**\n * Gets a list of online players\n * @param {string} gameServerId - The ID of the game server\n * @returns {Promise<Object>} Object containing player count and formatted player list\n */\nexport async function getOnlinePlayers(gameServerId) {\n    try {\n        const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n            filters: {\n                gameServerId: [gameServerId],\n                online: [true]\n            }\n        });\n\n        let playerList = \"No players online\";\n        const playerCount = onlinePlayers.data.meta.total;\n\n        if (playerCount > 0) {\n            const playerNamePromises = onlinePlayers.data.data.map(async (pog) => {\n                const playerData = await takaro.player.playerControllerGetOne(pog.playerId);\n                return playerData.data.data.name;\n            });\n\n            const playerNames = await Promise.all(playerNamePromises);\n            playerList = playerNames.join(\", \");\n        }\n\n        return {\n            count: playerCount,\n            list: playerList\n        };\n    } catch (error) {\n        console.error(\"Error getting online players:\", error);\n        return {\n            count: 0,\n            list: \"Error retrieving player information\"\n        };\n    }\n}\n\n/**\n * Gets bloodmoon information for 7 Days to Die\n * @param {string} gameServerId - The ID of the game server\n * @returns {Promise<string>} Formatted bloodmoon information\n */\nexport async function getBloodmoonInfo(gameServerId) {\n    try {\n        // Get game time using gettime command\n        const getTimeCommand = await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n            command: \"gettime\"\n        });\n\n        // Get bloodmoon frequency\n        const bmFreqCommand = await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n            command: \"getgamepref BloodMoonFrequency\"\n        });\n\n        // Parse the current day and time\n        let currentDay = 0;\n        let currentTime = \"\";\n\n        // Try to parse from gettime command (e.g. \"Day 5, 02:02\")\n        const dayTimeMatch = getTimeCommand.data.data.rawResult?.match(/Day (\\d+),\\s+(\\d+:\\d+)/i);\n        if (dayTimeMatch) {\n            currentDay = parseInt(dayTimeMatch[1]);\n            currentTime = dayTimeMatch[2];\n        }\n\n        // Parse bloodmoon frequency\n        let bloodMoonFrequency = 7; // Default value\n        const freqMatch = bmFreqCommand.data.data.rawResult?.match(/BloodMoonFrequency\\s*=\\s*(\\d+)/i);\n        if (freqMatch) {\n            bloodMoonFrequency = parseInt(freqMatch[1]);\n        }\n\n        // Calculate days until bloodmoon\n        if (currentDay > 0) {\n            // Calculate next bloodmoon day\n            const daysUntilBloodmoon = bloodMoonFrequency - (currentDay % bloodMoonFrequency);\n            const nextBloodmoonDay = currentDay + daysUntilBloodmoon;\n\n            // Special case: if today is bloodmoon day\n            if (daysUntilBloodmoon === bloodMoonFrequency) {\n                return `📅 Day ${currentDay} (${currentTime}) | 🔴 **Bloodmoon: TONIGHT!** 🔴`;\n            } else if (daysUntilBloodmoon === 1) {\n                return `📅 Day ${currentDay} (${currentTime}) | 🔴 Next Bloodmoon: Day ${nextBloodmoonDay} | ⚠️ **TOMORROW!** ⚠️`;\n            } else {\n                return `📅 Day ${currentDay} (${currentTime}) | 🔴 Next Bloodmoon: Day ${nextBloodmoonDay} | ${daysUntilBloodmoon} days until bloodmoon`;\n            }\n        }\n\n        // Fall back to old method if gettime doesn't work\n        const bmDayCommand = await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n            command: \"ggs BloodMoonDay\"\n        });\n\n        let nextBloodmoonDay = 0;\n        const bloodmoonMatch = bmDayCommand.data.data.rawResult?.match(/BloodMoonDay\\s*=\\s*(\\d+)/i);\n        if (bloodmoonMatch) {\n            nextBloodmoonDay = parseInt(bloodmoonMatch[1]);\n            return `🔴 Next Bloodmoon: Day ${nextBloodmoonDay}`;\n        }\n\n        return \"Unknown\";\n    } catch (error) {\n        console.error(\"Error getting bloodmoon information:\", error);\n        return \"Error getting bloodmoon information\";\n    }\n}\n\n/**\n * Formats a date as a relative time string (e.g., \"2 days ago\")\n * @param {Date} date - The date to format\n * @returns {string} Formatted relative time string\n */\nexport function formatRelativeTime(date) {\n    const now = new Date();\n    const diffMs = now.getTime() - date.getTime();\n    const diffSeconds = Math.floor(diffMs / 1000);\n    const diffMinutes = Math.floor(diffSeconds / 60);\n    const diffHours = Math.floor(diffMinutes / 60);\n    const diffDays = Math.floor(diffHours / 24);\n\n    if (diffDays > 0) {\n        return `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;\n    } else if (diffHours > 0) {\n        return `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;\n    } else if (diffMinutes > 0) {\n        return `${diffMinutes} minute${diffMinutes !== 1 ? 's' : ''} ago`;\n    } else {\n        return 'just now';\n    }\n}\n\n/**\n * Generates a complete server status message\n * @param {string} gameServerId - The ID of the game server\n * @param {Object} config - User configuration options\n * @returns {Promise<string>} Formatted server status message for Discord\n */\nexport async function getServerStatusMessage(gameServerId, config = {}) {\n    try {\n        let message = \"**Server Status**\\n\";\n\n        // Get uptime if enabled in config\n        if (config.showUptime !== false) {\n            const serverStartTime = await getServerStartTime(gameServerId);\n            const uptime = calculateUptime(serverStartTime);\n            message += `⏱️ Uptime: ${uptime}\\n`;\n        }\n\n        // Get server creation time if enabled in config\n        if (config.showCreationTime !== false) {\n            const serverCreationTime = await getServerCreationTime(gameServerId);\n            const createdRelative = formatRelativeTime(serverCreationTime);\n            message += `🆕 Server created: ${createdRelative}\\n`;\n        }\n\n        // Get bloodmoon info if enabled in config\n        if (config.showBloodmoon !== false) {\n            const bloodmoonInfo = await getBloodmoonInfo(gameServerId);\n            message += `${bloodmoonInfo}\\n`;\n        }\n\n        // Always show player info\n        const players = await getOnlinePlayers(gameServerId);\n        message += `👥 Players online (${players.count}): ${players.list}`;\n\n        return message;\n    } catch (error) {\n        console.error(\"Error generating server status message:\", error);\n        return `**Server Status**\\nError: Could not retrieve server information`;\n    }\n}",
                    "name": "utils",
                    "description": null
                }
            ],
            "permissions": []
        },
        {
            "tag": "1.0.1",
            "description": "# Limon_chatbridge: Discord Chat Integration for Your Game Server\n\nThis module bridges your game server's chat and a Discord channel, enabling two-way communication with powerful, customizable filtering options.\n\n## Key Features\n\n*   **Two-Way Chat Relay:** Forward messages between your game and Discord in real-time. Improve player interaction and build a stronger community.\n*   **Player Connection/Disconnection Notifications:** Optionally send automated Discord messages when players join or leave your server.\n*   **Advanced Filtering Options:**\n    *   **Global Chat Only:** Restrict messages to your game's global chat channel, excluding team chat and private messages.\n    *   **Command Filtering:** Prevent in-game command messages (e.g., `/ban`) from cluttering your Discord.\n    *   **System Message Filtering:** Keep your Discord clean by blocking system (non-player) messages.\n*   **Dedicated Monitoring Channel (Optional):** Create a separate Discord channel for *all* server activity, including chat, commands, and logs. Ideal for moderation and debugging.\n*   **Easy Configuration:** Customize settings quickly and easily with a straightforward configuration schema.\n\n## Configuration Options\n\n*   `sendPlayerConnected`: (`true`/`false`, default: `true`) Enable player connect notifications.\n*   `sendPlayerDisconnected`: (`true`/`false`, default: `true`) Enable player disconnect notifications.\n*   `onlyGlobalChat`: (`true`/`false`, default: `true`) Restrict to global chat only.\n*   `filterCommands`: (`true`/`false`, default: `false`) Filter out in-game command messages.\n*   `filterSystemMessages`: (`true`/`false`, default: `false`) Filter out system messages.\n*   `useMonitoring`: (`true`/`false`, default: `false`) Enable a dedicated monitoring channel.\n*   `monitoringChannelId`: (string) Discord channel ID for monitoring (required if `useMonitoring` is enabled).\n\n## Hooks\n\n*   `PlayerDisconnected` / `PlayerConnected`: Handles player join/leave notifications.\n*   `DiscordToGame`: Relays messages from your Discord server to the game.\n*   `GameToDiscord`: Relays in-game chat messages to Discord, applying all configured filters.",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sendPlayerConnected\":{\"title\":\"Send player connected\",\"type\":\"boolean\",\"description\":\"Send a message when a player connects.\",\"default\":true},\"sendPlayerDisconnected\":{\"title\":\"Send player disconnected\",\"type\":\"boolean\",\"description\":\"Send a message when a player disconnects.\",\"default\":true},\"onlyGlobalChat\":{\"title\":\"Only global chat\",\"type\":\"boolean\",\"default\":true,\"description\":\"Only relay messages from global chat (no team chat or private messages)\"},\"filterCommands\":{\"title\":\"Filter commands\",\"type\":\"boolean\",\"default\":false,\"description\":\"Don't relay command messages (/command) to Discord\"},\"filterSystemMessages\":{\"title\":\"Filter system messages\",\"type\":\"boolean\",\"default\":false,\"description\":\"Don't relay system messages to Discord\"},\"useMonitoring\":{\"title\":\"Enable monitoring channel\",\"type\":\"boolean\",\"default\":false,\"description\":\"Send commands and system messages to a separate monitoring channel\"},\"monitoringChannelId\":{\"title\":\"Monitoring channel ID\",\"type\":\"string\",\"description\":\"Discord channel ID for monitoring messages (only used if monitoring is enabled)\"}},\"additionalProperties\":false}",
            "uiSchema": "{}",
            "commands": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, player } = data;\n\n    // Calculate server uptime\n    let serverUptime = \"Unknown\";\n    try {\n        // Using a fixed date for demonstration - in reality you might want to \n        // get this from a variable or other stored value\n        const serverStartTime = new Date(\"2025-04-12T11:54:01.547Z\");\n        const currentTime = new Date();\n\n        // Calculate difference in milliseconds\n        const uptimeMs = currentTime.getTime() - serverStartTime.getTime();\n\n        // Format uptime in days, hours, minutes\n        const uptimeSeconds = Math.floor(uptimeMs / 1000);\n        const days = Math.floor(uptimeSeconds / 86400);\n        const hours = Math.floor((uptimeSeconds % 86400) / 3600);\n        const minutes = Math.floor((uptimeSeconds % 3600) / 60);\n\n        serverUptime = \"\";\n        if (days > 0) serverUptime += `${days}d `;\n        if (hours > 0 || days > 0) serverUptime += `${hours}h `;\n        serverUptime += `${minutes}m`;\n    } catch (error) {\n        console.error(\"Error calculating server uptime:\", error);\n    }\n\n    // Get online players\n    const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    });\n\n    // Create player list\n    let playerList = \"No players online\";\n    if (onlinePlayers.data.meta.total > 0) {\n        const playerNamePromises = onlinePlayers.data.data.map(async (pog) => {\n            const playerData = await takaro.player.playerControllerGetOne(pog.playerId);\n            return playerData.data.data.name;\n        });\n\n        const playerNames = await Promise.all(playerNamePromises);\n        playerList = playerNames.join(\", \");\n    }\n\n    // Send the information to the player who ran the command\n    await player.pm(`Server Status\\nUptime: ${serverUptime}\\nPlayers online (${onlinePlayers.data.meta.total}): ${playerList}`);\n}\n\nawait main();",
                    "name": "serverStatus",
                    "description": null,
                    "trigger": "serverstatus",
                    "helpText": "No help text available",
                    "arguments": []
                }
            ],
            "hooks": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\nasync function main() {\n    const discordChannel = data.module.systemConfig.hooks['DiscordToGame'].discordChannelId;\n    await takaro.discord.discordControllerSendMessage(discordChannel, {\n        message: `[⚡ Connected]: ${data.player.name}`,\n    });\n}\nawait main();\n//# sourceMappingURL=PlayerConnected.js.map",
                    "name": "PlayerConnected",
                    "description": null,
                    "eventType": "player-connected"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    try {\n        // Skip messages from bots\n        if (data.eventData.author.isBot)\n            return;\n\n        // Get Discord channel from module system config\n        const discordChannelId = data.discordChannelId ||\n            data.module.systemConfig.hooks['DiscordToGame']?.discordChannelId;\n\n        if (!discordChannelId) {\n            console.error(\"Discord channel ID is missing from both data context and module config\");\n            return;\n        }\n\n        // Check if the message is the serverstatus command\n        if (data.eventData.msg.toLowerCase().endsWith('serverstatus')) {\n            // Get server uptime\n            let serverUptime = \"Unknown\";\n            try {\n                // Using a fixed date for demonstration\n                const serverStartTime = new Date(\"2025-04-12T11:54:01.547Z\");\n                const currentTime = new Date();\n\n                const uptimeMs = currentTime.getTime() - serverStartTime.getTime();\n                const uptimeSeconds = Math.floor(uptimeMs / 1000);\n                const days = Math.floor(uptimeSeconds / 86400);\n                const hours = Math.floor((uptimeSeconds % 86400) / 3600);\n                const minutes = Math.floor((uptimeSeconds % 3600) / 60);\n\n                serverUptime = \"\";\n                if (days > 0) serverUptime += `${days}d `;\n                if (hours > 0 || days > 0) serverUptime += `${hours}h `;\n                serverUptime += `${minutes}m`;\n            } catch (error) {\n                console.error(\"Error calculating server uptime:\", error);\n            }\n\n            // Get online players\n            const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n                filters: {\n                    gameServerId: [data.gameServerId],\n                    online: [true]\n                }\n            });\n\n            // Create player list\n            let playerList = \"No players online\";\n            if (onlinePlayers.data.meta.total > 0) {\n                const playerNamePromises = onlinePlayers.data.data.map(async (pog) => {\n                    const playerData = await takaro.player.playerControllerGetOne(pog.playerId);\n                    return playerData.data.data.name;\n                });\n\n                const playerNames = await Promise.all(playerNamePromises);\n                playerList = playerNames.join(\", \");\n            }\n\n            // Format the message for Discord\n            let message = `**Server Status**\\n` +\n                `Uptime: ${serverUptime}\\n` +\n                `Players online (${onlinePlayers.data.meta.total}): ${playerList}`;\n\n            // Send the message back to Discord\n            await takaro.discord.discordControllerSendMessage(discordChannelId, {\n                message: message\n            });\n\n            // Return early to avoid forwarding the command to the game\n            return;\n        }\n\n        // Forward regular messages to the game\n        await takaro.gameserver.gameServerControllerSendMessage(data.gameServerId, {\n            message: `[D] ${data.eventData.author.displayName}:  ${data.eventData.msg}`,\n        });\n    }\n    catch (error) {\n        console.error(error);\n\n        // Try to get Discord channel ID if we haven't already\n        const discordChannelId = data.discordChannelId ||\n            data.module.systemConfig.hooks['DiscordToGame']?.discordChannelId;\n\n        if (discordChannelId) {\n            await takaro.discord.discordControllerSendMessage(discordChannelId, {\n                message: 'Failed to forward your message to the game. Please try again later.',\n            });\n        } else {\n            console.error(\"Could not send error message because Discord channel ID is missing\");\n        }\n    }\n}\n\nawait main();",
                    "name": "DiscordToGame",
                    "description": null,
                    "eventType": "discord-message"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\nasync function main() {\n    const discordChannel = data.module.systemConfig.hooks['DiscordToGame'].discordChannelId;\n    await takaro.discord.discordControllerSendMessage(discordChannel, {\n        message: `[👋 Disconnected]: ${data.player.name}`,\n    });\n}\nawait main();\n//# sourceMappingURL=PlayerDisconnected.js.map",
                    "name": "PlayerDisconnected",
                    "description": null,
                    "eventType": "player-disconnected"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const config = data.module.userConfig;\n\n    // Get message details\n    const sender = data.player ? data.player.name : 'Non-player';\n    const message = data.eventData.msg;\n    const channel = data.eventData.channel;\n    const isCommand = message.startsWith('/');\n\n    // Format message based on channel type\n    let formattedMessage;\n    if (channel === \"global\") {\n        formattedMessage = `**${sender}**: ${message}`;\n    } else if (channel === \"team\") {\n        formattedMessage = `[Party] **${sender}**: ${message}`;\n    } else {\n        formattedMessage = `[Friends] **${sender}**: ${message}`;\n    }\n\n    // Always send to monitoring channel if enabled\n    if (config.useMonitoring && config.monitoringChannelId) {\n        await takaro.discord.discordControllerSendMessage(config.monitoringChannelId, {\n            message: formattedMessage\n        });\n    }\n\n    // Apply filters for main channel\n    if (config.onlyGlobalChat && channel !== 'global') return;\n    if (isCommand && config.filterCommands) return;\n    if (sender === 'Non-player' && config.filterSystemMessages) return;\n\n    // Send to main channel after filters\n    const mainChannel = data.module.systemConfig.hooks['DiscordToGame'].discordChannelId;\n    await takaro.discord.discordControllerSendMessage(mainChannel, {\n        message: formattedMessage\n    });\n}\n\nawait main();",
                    "name": "GameToDiscord",
                    "description": null,
                    "eventType": "chat-message"
                }
            ],
            "cronJobs": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n    const discordChannel = mod.systemConfig.hooks['DiscordToGame']?.discordChannelId;\n\n    if (!discordChannel) {\n        console.error(\"Discord channel ID not configured\");\n        return;\n    }\n\n    // Find server uptime by searching for most recent server online event\n    let serverUptime = \"Unknown\";\n    try {\n        // Hardcode the specific server online event based on the provided data\n        const serverStartTime = new Date(\"2025-04-12T11:54:01.547Z\");\n        const currentTime = new Date();\n\n        // Calculate difference in milliseconds\n        const uptimeMs = currentTime.getTime() - serverStartTime.getTime();\n\n        // Format uptime in days, hours, minutes\n        const uptimeSeconds = Math.floor(uptimeMs / 1000);\n        const days = Math.floor(uptimeSeconds / 86400);\n        const hours = Math.floor((uptimeSeconds % 86400) / 3600);\n        const minutes = Math.floor((uptimeSeconds % 3600) / 60);\n\n        serverUptime = \"\";\n        if (days > 0) serverUptime += `${days}d `;\n        if (hours > 0 || days > 0) serverUptime += `${hours}h `;\n        serverUptime += `${minutes}m`;\n    } catch (error) {\n        console.error(\"Error calculating server uptime:\", error);\n    }\n\n    // Get online players\n    const onlinePlayers = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gameServerId],\n            online: [true]\n        }\n    });\n\n    // Create player list\n    let playerList = \"No players online\";\n    if (onlinePlayers.data.meta.total > 0) {\n        const playerNamePromises = onlinePlayers.data.data.map(async (pog) => {\n            const playerData = await takaro.player.playerControllerGetOne(pog.playerId);\n            return playerData.data.data.name;\n        });\n\n        const playerNames = await Promise.all(playerNamePromises);\n        playerList = playerNames.join(\", \");\n    }\n\n    // Format the message\n    let message = `**Server Status**\\n` +\n        `Uptime: ${serverUptime}\\n` +\n        `Players online (${onlinePlayers.data.meta.total}): ${playerList}`;\n\n    // Send message to Discord\n    await takaro.discord.discordControllerSendMessage(discordChannel, {\n        message: message\n    });\n}\n\nawait main();",
                    "name": "serverStatus",
                    "description": null,
                    "temporalValue": "0 0 * * *"
                }
            ],
            "functions": [],
            "permissions": []
        },
        {
            "tag": "1.0.0",
            "description": "# Limon_chatbridge: Discord Chat Integration for Your Game Server\n\nThis module bridges your game server's chat and a Discord channel, enabling two-way communication with powerful, customizable filtering options.\n\n## Key Features\n\n*   **Two-Way Chat Relay:** Forward messages between your game and Discord in real-time. Improve player interaction and build a stronger community.\n*   **Player Connection/Disconnection Notifications:** Optionally send automated Discord messages when players join or leave your server.\n*   **Advanced Filtering Options:**\n    *   **Global Chat Only:** Restrict messages to your game's global chat channel, excluding team chat and private messages.\n    *   **Command Filtering:** Prevent in-game command messages (e.g., `/ban`) from cluttering your Discord.\n    *   **System Message Filtering:** Keep your Discord clean by blocking system (non-player) messages.\n*   **Dedicated Monitoring Channel (Optional):** Create a separate Discord channel for *all* server activity, including chat, commands, and logs. Ideal for moderation and debugging.\n*   **Easy Configuration:** Customize settings quickly and easily with a straightforward configuration schema.\n\n## Configuration Options\n\n*   `sendPlayerConnected`: (`true`/`false`, default: `true`) Enable player connect notifications.\n*   `sendPlayerDisconnected`: (`true`/`false`, default: `true`) Enable player disconnect notifications.\n*   `onlyGlobalChat`: (`true`/`false`, default: `true`) Restrict to global chat only.\n*   `filterCommands`: (`true`/`false`, default: `false`) Filter out in-game command messages.\n*   `filterSystemMessages`: (`true`/`false`, default: `false`) Filter out system messages.\n*   `useMonitoring`: (`true`/`false`, default: `false`) Enable a dedicated monitoring channel.\n*   `monitoringChannelId`: (string) Discord channel ID for monitoring (required if `useMonitoring` is enabled).\n\n## Hooks\n\n*   `PlayerDisconnected` / `PlayerConnected`: Handles player join/leave notifications.\n*   `DiscordToGame`: Relays messages from your Discord server to the game.\n*   `GameToDiscord`: Relays in-game chat messages to Discord, applying all configured filters.",
            "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"sendPlayerConnected\":{\"title\":\"Send player connected\",\"type\":\"boolean\",\"description\":\"Send a message when a player connects.\",\"default\":true},\"sendPlayerDisconnected\":{\"title\":\"Send player disconnected\",\"type\":\"boolean\",\"description\":\"Send a message when a player disconnects.\",\"default\":true},\"onlyGlobalChat\":{\"title\":\"Only global chat\",\"type\":\"boolean\",\"default\":true,\"description\":\"Only relay messages from global chat (no team chat or private messages)\"},\"filterCommands\":{\"title\":\"Filter commands\",\"type\":\"boolean\",\"default\":false,\"description\":\"Don't relay command messages (/command) to Discord\"},\"filterSystemMessages\":{\"title\":\"Filter system messages\",\"type\":\"boolean\",\"default\":false,\"description\":\"Don't relay system messages to Discord\"},\"useMonitoring\":{\"title\":\"Enable monitoring channel\",\"type\":\"boolean\",\"default\":false,\"description\":\"Send commands and system messages to a separate monitoring channel\"},\"monitoringChannelId\":{\"title\":\"Monitoring channel ID\",\"type\":\"string\",\"description\":\"Discord channel ID for monitoring messages (only used if monitoring is enabled)\"}},\"additionalProperties\":false}",
            "uiSchema": "{}",
            "commands": [],
            "hooks": [
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\nasync function main() {\n    const discordChannel = data.module.systemConfig.hooks['DiscordToGame'].discordChannelId;\n    await takaro.discord.discordControllerSendMessage(discordChannel, {\n        message: `[👋 Disconnected]: ${data.player.name}`,\n    });\n}\nawait main();\n//# sourceMappingURL=PlayerDisconnected.js.map",
                    "name": "PlayerDisconnected",
                    "description": null,
                    "eventType": "player-disconnected"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const config = data.module.userConfig;\n\n    // Get message details\n    const sender = data.player ? data.player.name : 'Non-player';\n    const message = data.eventData.msg;\n    const channel = data.eventData.channel;\n    const isCommand = message.startsWith('/');\n\n    // Format message based on channel type\n    let formattedMessage;\n    if (channel === \"global\") {\n        formattedMessage = `**${sender}**: ${message}`;\n    } else if (channel === \"team\") {\n        formattedMessage = `[Party] **${sender}**: ${message}`;\n    } else {\n        formattedMessage = `[Friends] **${sender}**: ${message}`;\n    }\n\n    // Always send to monitoring channel if enabled\n    if (config.useMonitoring && config.monitoringChannelId) {\n        await takaro.discord.discordControllerSendMessage(config.monitoringChannelId, {\n            message: formattedMessage\n        });\n    }\n\n    // Apply filters for main channel\n    if (config.onlyGlobalChat && channel !== 'global') return;\n    if (isCommand && config.filterCommands) return;\n    if (sender === 'Non-player' && config.filterSystemMessages) return;\n\n    // Send to main channel after filters\n    const mainChannel = data.module.systemConfig.hooks['DiscordToGame'].discordChannelId;\n    await takaro.discord.discordControllerSendMessage(mainChannel, {\n        message: formattedMessage\n    });\n}\n\nawait main();",
                    "name": "GameToDiscord",
                    "description": null,
                    "eventType": "chat-message"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\nasync function main() {\n    try {\n        if (data.eventData.author.isBot)\n            return;\n        await takaro.gameserver.gameServerControllerSendMessage(data.gameServerId, {\n            message: `[D] ${data.eventData.author.displayName}:  ${data.eventData.msg}`,\n        });\n    }\n    catch (error) {\n        console.error(error);\n        await takaro.discordControllerSendMessage(data.discordChannelId, {\n            message: 'Failed to forward your message to the game. Please try again later.',\n        });\n    }\n}\nawait main();\n//# sourceMappingURL=DiscordToGame.js.map",
                    "name": "DiscordToGame",
                    "description": null,
                    "eventType": "discord-message"
                },
                {
                    "function": "import { takaro, data } from '@takaro/helpers';\nasync function main() {\n    const discordChannel = data.module.systemConfig.hooks['DiscordToGame'].discordChannelId;\n    await takaro.discord.discordControllerSendMessage(discordChannel, {\n        message: `[⚡ Connected]: ${data.player.name}`,\n    });\n}\nawait main();\n//# sourceMappingURL=PlayerConnected.js.map",
                    "name": "PlayerConnected",
                    "description": null,
                    "eventType": "player-connected"
                }
            ],
            "cronJobs": [],
            "functions": [],
            "permissions": []
        }
    ],
    "takaroVersion": "v0.0.24"
}