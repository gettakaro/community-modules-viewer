{
  "name": "PvP Air Drops",
  "author": "Mad",
  "supportedGames": ["all"],
  "versions": [
    {
      "tag": "2.1.3",
      "description": "Make your Air Drop a PvP area. ",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[\"pvpMessage\",\"pvpRange\",\"deleteCronjob\"],\"additionalProperties\":false,\"properties\":{\"pvpMessage\":{\"title\":\"pvpMessage\",\"description\":\"Message to the server about airdrops being PvP. Use {x} and {z} to announce the location of the air drop.\",\"default\":\"[FE0288]An airdrop has been dropped at [DECEA3]{x} [70FE02]{z}[-]. This area is now a [FF0001]PvP[-] zone!\",\"type\":\"string\"},\"pvpRange\":{\"title\":\"pvpRange\",\"description\":\"The range of PvP area. The Area will be double this number.\",\"default\":100,\"type\":\"number\"},\"enterPvPMessage\":{\"title\":\"enterPvPMessage\",\"description\":\"Entering the PvP area message\",\"default\":\"[FE0288]You are in the [D64C4C]PvP[-] area! You can kill people![-]\",\"type\":\"string\"},\"exitPvPMessage\":{\"title\":\"exitPvPMessage\",\"description\":\"Exiting the PvP area Message\",\"default\":\"[ADDFB3]You left the [D64C4C]PvP[-] area. People in the [D64C4C]PvP[-] area can still kill you\",\"type\":\"string\"},\"deleteCronjob\":{\"title\":\"deleteCronjob\",\"description\":\"Set the minutes you want the PvP area to be live\",\"default\":30,\"type\":\"number\"}}}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Making sure 'module' is available for module.userConfig and module.versionId\n    const { gameServerId, eventData, module } = data;\n\n    const messageToSend = module.userConfig.pvpMessage;\n    const pvpRangeString = module.userConfig.pvpRange;\n    const enterMessage = module.userConfig.enterPvPMessage;\n    const exitMessage = module.userConfig.exitPvPMessage;\n\n    const range = parseInt(pvpRangeString, 10);\n\n    const logLine = eventData?.msg || eventData?.raw || eventData?.message || (typeof eventData === 'string' ? eventData : null);\n\n    console.log(`AirdropTracker: Raw log line being processed: \"${logLine}\"`);\n\n    const coordRegex = /\\((-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*)\\)/;\n    const matches = logLine.match(coordRegex);\n\n    if (!matches) {\n        console.log(`AirdropTracker: Could not find coordinate pattern in logLine: \"${logLine}\"`);\n        return;\n    }\n\n    const extractedX = parseFloat(matches[1]);\n    const extractedZ = parseFloat(matches[3]);\n\n    if (isNaN(extractedX) || isNaN(extractedZ)) {\n        console.log(`AirdropTracker: Extracted coordinates are not valid numbers. X: ${matches[1]}, Z: ${matches[3]}`);\n        return;\n    }\n\n    const roundedX = Math.ceil(extractedX);\n    const roundedZ = Math.ceil(extractedZ);\n\n    let formattedDisplayX;\n    if (roundedX >= 0) {\n        formattedDisplayX = `${roundedX} East`;\n    } else {\n        formattedDisplayX = `${Math.abs(roundedX)} West`;\n    }\n\n    let formattedDisplayZ;\n    if (roundedZ >= 0) {\n        formattedDisplayZ = `${roundedZ} North`;\n    } else {\n        formattedDisplayZ = `${Math.abs(roundedZ)} South`;\n    }\n\n    const formattedMessage = messageToSend\n        .replace('{x}', formattedDisplayX)\n        .replace('{z}', formattedDisplayZ);\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: formattedMessage,\n    });\n\n    console.log(`AirdropTracker: Detected on server ${gameServerId}. Original X: ${extractedX.toFixed(1)}, Original Z: ${extractedZ.toFixed(1)}. Rounded Up X: ${roundedX}, Rounded Up Z: ${roundedZ}`);\n\n    const xPlusRange = roundedX + range;\n    const zPlusRange = roundedZ + range;\n    const xMinusRange = roundedX - range;\n    const zMinusRange = roundedZ - range;\n\n    console.log(`AirdropTracker: Calculated (X+${range}, Z+${range}): X = ${xPlusRange}, Z = ${zPlusRange} | (X-${range}, Z-${range}): X = ${xMinusRange}, Z = ${zMinusRange}`);\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add pvpFightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} -1 \"notify:${enterMessage}:${exitMessage}\"`,\n    });\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add FightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} -1 \"notify::\"`,\n    });\n}\n\nawait main();",
          "name": "PvP Air Drop",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        }
      ],
      "cronJobs": [],
      "functions": [],
      "permissions": []
    },
    {
      "tag": "2.0.2",
      "description": "Make your Air Drop a PvP area. ",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[\"pvpMessage\",\"pvpRange\",\"deleteCronjob\"],\"additionalProperties\":false,\"properties\":{\"pvpMessage\":{\"title\":\"pvpMessage\",\"description\":\"Message to the server about airdrops being PvP. Use {x} and {z} to announce the location of the air drop.\",\"default\":\"[FE0288]An airdrop has been dropped at [DECEA3]{x} [70FE02]{z}[-]. This area is now a [FF0001]PvP[-] zone!\",\"type\":\"string\"},\"pvpRange\":{\"title\":\"pvpRange\",\"description\":\"The range of PvP area. The Area will be double this number.\",\"default\":100,\"type\":\"number\"},\"enterPvPMessage\":{\"title\":\"enterPvPMessage\",\"description\":\"Entering the PvP area message\",\"default\":\"[FE0288]You are in the [D64C4C]PvP[-] area! You can kill people![-]\",\"type\":\"string\"},\"exitPvPMessage\":{\"title\":\"exitPvPMessage\",\"description\":\"Exiting the PvP area Message\",\"default\":\"[ADDFB3]You left the [D64C4C]PvP[-] area. People in the [D64C4C]PvP[-] area can still kill you\",\"type\":\"string\"},\"deleteCronjob\":{\"title\":\"deleteCronjob\",\"description\":\"Set the minutes you want the PvP area to be live\",\"default\":30,\"type\":\"number\"}}}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Making sure 'module' is available for module.userConfig and module.versionId\n    const { gameServerId, eventData, eventType, module } = data;\n\n    const messageToSend = module.userConfig.pvpMessage;\n    const pvpRangeString = module.userConfig.pvpRange;\n    const enterMessage = module.userConfig.enterPvPMessage;\n    const exitMessage = module.userConfig.exitPvPMessage;\n    const deleteCronjobDelayMinutes = module.userConfig.deleteCronjob;\n\n    const range = parseInt(pvpRangeString, 10);\n\n    const logLine = eventData?.msg || eventData?.raw || eventData?.message || (typeof eventData === 'string' ? eventData : null);\n\n    console.log(`AirdropTracker: Raw log line being processed: \"${logLine}\"`);\n\n    const coordRegex = /\\((-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*)\\)/;\n    const matches = logLine.match(coordRegex);\n\n    if (!matches) {\n        console.log(`AirdropTracker: Could not find coordinate pattern in logLine: \"${logLine}\"`);\n        return;\n    }\n\n    const extractedX = parseFloat(matches[1]);\n    const extractedZ = parseFloat(matches[3]);\n\n    if (isNaN(extractedX) || isNaN(extractedZ)) {\n        console.log(`AirdropTracker: Extracted coordinates are not valid numbers. X: ${matches[1]}, Z: ${matches[3]}`);\n        return;\n    }\n\n    const roundedX = Math.ceil(extractedX);\n    const roundedZ = Math.ceil(extractedZ);\n\n    let formattedDisplayX;\n    if (roundedX >= 0) {\n        formattedDisplayX = `${roundedX} East`;\n    } else {\n        formattedDisplayX = `${Math.abs(roundedX)} West`;\n    }\n\n    let formattedDisplayZ;\n    if (roundedZ >= 0) {\n        formattedDisplayZ = `${roundedZ} North`;\n    } else {\n        formattedDisplayZ = `${Math.abs(roundedZ)} South`;\n    }\n\n    const formattedMessage = messageToSend\n        .replace('{x}', formattedDisplayX)\n        .replace('{z}', formattedDisplayZ);\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: formattedMessage,\n    });\n\n    console.log(`AirdropTracker: Detected on server ${gameServerId}. Original X: ${extractedX.toFixed(1)}, Original Z: ${extractedZ.toFixed(1)}. Rounded Up X: ${roundedX}, Rounded Up Z: ${roundedZ}`);\n\n    const xPlusRange = roundedX + range;\n    const zPlusRange = roundedZ + range;\n    const xMinusRange = roundedX - range;\n    const zMinusRange = roundedZ - range;\n\n    console.log(`AirdropTracker: Calculated (X+${range}, Z+${range}): X = ${xPlusRange}, Z = ${zPlusRange} | (X-${range}, Z-${range}): X = ${xMinusRange}, Z = ${zMinusRange}`);\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add pvpFightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} 1 \"notify:${enterMessage}:${exitMessage}\"`,\n    });\n\n    const delayMinutes = parseInt(deleteCronjobDelayMinutes, 10);\n\n    if (!isNaN(delayMinutes) && delayMinutes > 0) {\n        const now = new Date();\n        const executionTime = new Date(now.getTime() + delayMinutes * 60000); // This is in UTC\n\n        const cronMinute = executionTime.getMinutes(); // Gets minute in UTC\n        const cronHour = executionTime.getHours(); // Gets hour in UTC\n        const cronDayOfMonth = executionTime.getDate(); // Gets day in UTC\n        const cronMonth = executionTime.getMonth() + 1; // Gets month in UTC (0-indexed, so +1)\n\n        const temporalValue = `${cronMinute} ${cronHour} ${cronDayOfMonth} ${cronMonth} *`;\n\n        let cronJobName = `pvp-cleanup-${Date.now()}`;\n        if (cronJobName.length > 50) {\n            cronJobName = cronJobName.substring(0, 50);\n        }\n\n        const cleanupFunction = `\nimport { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Log the entire data object to see its structure\n    console.log('Cleanup Cron Data Object: ' + JSON.stringify(data, null, 2));\n\n    const cronGameServerId = data.gameServerId; \n    // The ID of the currently executing cronjob is in data.itemId\n    const executingCronJobId = data.itemId; \n    // The name is not directly available in 'data', so we'll use a placeholder or the ID for logging.\n    const executingCronJobName = 'pvp-cleanup-dynamic'; // Placeholder name for logs\n\n    try {\n        console.log('Executing PvP area cleanup cron job: ' + executingCronJobName + ' (ID: ' + executingCronJobId + ') for game server: ' + cronGameServerId);\n        \n        if (!cronGameServerId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): cronGameServerId is missing from data. Cannot execute commands.');\n            return; \n        }\n        if (!executingCronJobId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) is missing. Cannot self-delete.');\n            // Still attempt to run game commands\n        }\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove pvpFightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove pvpFightingArena\" for ' + cronGameServerId);\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove FightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove FightingArena\" for ' + cronGameServerId);\n        \n        // Use data.itemId for self-deletion\n        if (executingCronJobId) {\n            try {\n                await takaro.cronjob.cronJobControllerRemove(executingCronJobId);\n                console.log('PvP Cleanup (' + executingCronJobName + '): Cron job ID ' + executingCronJobId + ' self-deleted successfully.');\n            } catch (deleteError) {\n                let errorMsg = String(deleteError.message || deleteError);\n                if (deleteError.response && deleteError.response.data) {\n                    errorMsg += ' - API Error Details: ' + JSON.stringify(deleteError.response.data);\n                }\n                console.error('PvP Cleanup (' + executingCronJobName + '): Failed to self-delete cron job ID ' + executingCronJobId + '. Error: ' + errorMsg);\n            }\n        } else {\n            console.log('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) was not available, cannot self-delete by ID.');\n        }\n    } catch (error) {\n        let errorMsg = String(error.message || error);\n        if (error.response && error.response.data) {\n            errorMsg += ' - API Error Details: ' + JSON.stringify(error.response.data);\n        }\n        console.error('PvP Cleanup (' + executingCronJobName + ' - ID: ' + (executingCronJobId || 'undefined_id') + '): Error during execution. Error: ' + errorMsg);\n    }\n}\nawait main();\n`; // End of cleanupFunction string\n\n        try {\n            await takaro.cronjob.cronJobControllerCreate({\n                name: cronJobName,\n                temporalValue: temporalValue, // This cron schedule is based on UTC server time\n                versionId: module.versionId,\n                function: cleanupFunction.trim(),\n            });\n\n            // For logging in CDT (UTC-5)\n            // Create a new Date object adjusted by -5 hours for display purposes\n            const displayTime = new Date(executionTime.getTime() - (5 * 60 * 60 * 1000));\n\n            console.log(`AirdropTracker: Scheduled PvP area cleanup cron job \"${cronJobName}\" to run at approximately ${displayTime.toLocaleString()} (CDT) (Cron: ${temporalValue} UTC)`);\n\n        } catch (error) {\n            console.log(`AirdropTracker: Failed to create cleanup cron job \"${cronJobName}\". Error: ${error.message}`);\n            if (error.response && error.response.data) {\n                console.log(`AirdropTracker: API Error details: ${JSON.stringify(error.response.data, null, 2)}`);\n            } else if (error.request) {\n                console.log(`AirdropTracker: No response received for cron job creation. Request details (may be large): ${error.request}`);\n            } else {\n                console.log('AirdropTracker: Error setting up cron job creation request:', error.message);\n            }\n        }\n    } else {\n        console.log(`AirdropTracker: 'deleteCronjob' minutes (\"${deleteCronjobDelayMinutes}\") is not configured, is zero, or invalid. Cleanup cron job will not be created.`);\n    }\n}\n\nawait main();\n",
          "name": "PvP Air Drop",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        }
      ],
      "cronJobs": [],
      "functions": [],
      "permissions": []
    },
    {
      "tag": "1.0.3",
      "description": "Make your Air Drop a PvP area. ",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[\"pvpMessage\",\"pvpRange\"],\"additionalProperties\":false,\"properties\":{\"pvpMessage\":{\"title\":\"pvpMessage\",\"description\":\"Message to the server about airdrops being PvP. Use {x} and {z} to announce the location of the air drop.\",\"default\":\"[FE0288]An airdrop has been dropped at [DECEA3]{x} [70FE02]{z}[-]. This area is now a [FF0001]PvP[-] zone!\",\"type\":\"string\"},\"pvpRange\":{\"title\":\"pvpRange\",\"description\":\"The range of PvP area. The Area will be double this number.\",\"default\":100,\"type\":\"number\"},\"enterPvPMessage\":{\"title\":\"enterPvPMessage\",\"description\":\"Entering the PvP area message\",\"default\":\"[FE0288]You are in the [D64C4C]PvP[-] area! You can kill people![-]\",\"type\":\"string\"},\"exitPvPMessage\":{\"title\":\"exitPvPMessage\",\"description\":\"Exiting the PvP area Message\",\"default\":\"[ADDFB3]You left the [D64C4C]PvP[-] area. People in the [D64C4C]PvP[-] area can still kill you\",\"type\":\"string\"}}}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [
        {
          "function": "import { data, takaro } from '@takaro/helpers';\nasync function main() {\n    const gameServerId = data.gameServerId\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc remove pvpFightingArena`,\n    });\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc remove FightingArena`,\n    });\n}\nawait main();",
          "name": "Remove Pvp",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        },
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, eventData, eventType, module } = data;\n\n    const messageToSend = module.userConfig.pvpMessage;\n    const pvpRangeString = module.userConfig.pvpRange;\n    const enterMessage = module.userConfig.enterPvPMessage;\n    const exitMessage = module.userConfig.exitPvPMessage;\n\n    const range = parseInt(pvpRangeString, 10);\n\n    const logLine = eventData?.msg || eventData?.raw || eventData?.message || (typeof eventData === 'string' ? eventData : null);\n\n    console.log(`AirdropTracker: Raw log line being processed: \"${logLine}\"`);\n\n    const coordRegex = /\\((-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*)\\)/;\n    const matches = logLine.match(coordRegex);\n\n    const extractedX = parseFloat(matches[1]);\n    const extractedZ = parseFloat(matches[3]);\n\n    if (isNaN(extractedX) || isNaN(extractedZ)) {\n        return;\n    }\n\n    const roundedX = Math.ceil(extractedX);\n    const roundedZ = Math.ceil(extractedZ);\n\n    let formattedDisplayX;\n    if (roundedX >= 0) {\n        formattedDisplayX = `${roundedX} East`;\n    } else {\n        formattedDisplayX = `${Math.abs(roundedX)} West`;\n    }\n\n    let formattedDisplayZ;\n    if (roundedZ >= 0) {\n        formattedDisplayZ = `${roundedZ} North`;\n    } else {\n        formattedDisplayZ = `${Math.abs(roundedZ)} South`;\n    }\n\n    const formattedMessage = messageToSend\n        .replace('{x}', formattedDisplayX)\n        .replace('{z}', formattedDisplayZ);\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: formattedMessage,\n    });\n\n    console.log(`AirdropTracker: Detected on server ${gameServerId}. Original X: ${extractedX.toFixed(1)}, Original Z: ${extractedZ.toFixed(1)}. Rounded Up X: ${roundedX}, Rounded Up Z: ${roundedZ}`);\n\n    const xPlusRange = roundedX + range;\n    const zPlusRange = roundedZ + range;\n    const xMinusRange = roundedX - range;\n    const zMinusRange = roundedZ - range;\n\n    console.log(`AirdropTracker: Calculated (X+${range}, Z+${range}): X = ${xPlusRange}, Z = ${zPlusRange} | (X-${range}, Z-${range}): X = ${xMinusRange}, Z = ${zMinusRange}`);\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add pvpFightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} 1 \"notify:${enterMessage}:${exitMessage}\"`,\n    });\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add FightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} 1 \"notify::\"`,\n    });\n}\n\nawait main();\n",
          "name": "PvP Air Drop",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        }
      ],
      "cronJobs": [],
      "functions": [],
      "permissions": []
    },
    {
      "tag": "0.0.1",
      "description": "Make your Air Drop a PvP area",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[],\"additionalProperties\":false}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, eventData, eventType } = data;\n\n    // Optional: Keep these for debugging if issues arise with eventData structure or logLine extraction.\n    // console.log(`AirdropTracker DIAGNOSTIC: Full eventData received: ${JSON.stringify(eventData)}`);\n    // console.log(`AirdropTracker DIAGNOSTIC: Event type: ${eventType}`);\n\n    const logLine = eventData?.msg || eventData?.raw || eventData?.message || (typeof eventData === 'string' ? eventData : null);\n    // console.log(`AirdropTracker DIAGNOSTIC: Extracted logLine: \"${logLine}\"`); // Useful for debugging extraction\n\n    if (!logLine || typeof logLine !== 'string') {\n        // console.log('AirdropTracker: logLine is empty or not a string. Exiting.'); // Log if needed for debugging\n        return;\n    }\n\n    // Regex to extract coordinates, handles optional negative sign and decimals.\n    // Assumes logLine is the correct airdrop message due to hook filtering.\n    // Example: AIAirDrop: Spawned supply crate at (-962.6, 255.0, -660.2), plane is at (...)\n    const coordRegex = /\\((-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*)\\)/;\n    const matches = logLine.match(coordRegex);\n\n    // We are interested in the first set of coordinates (supply crate location).\n    if (matches && matches.length >= 4) { // Ensure X, Y, Z coordinates are captured\n        const extractedX = parseFloat(matches[1]); // First captured group: X\n        const extractedZ = parseFloat(matches[3]); // Third captured group: Z\n\n        if (isNaN(extractedX) || isNaN(extractedZ)) {\n            console.log(`AirdropTracker: Failed to parse coordinates from \"${logLine}\". Extracted: X='${matches[1]}', Z='${matches[3]}'`);\n            return;\n        }\n\n        const roundedX = Math.ceil(extractedX);\n        const roundedZ = Math.ceil(extractedZ);\n\n        console.log(`AirdropTracker: Detected on server ${gameServerId}. Original X: ${extractedX.toFixed(1)}, Original Z: ${extractedZ.toFixed(1)}. Rounded Up X: ${roundedX}, Rounded Up Z: ${roundedZ}`);\n\n    } else {\n        // This logs if coordinates couldn't be extracted.\n        // Useful if the hook trigger is too broad or log format changes unexpectedly.\n        console.log(`AirdropTracker: Could not extract coordinates from logLine: \"${logLine}\".`);\n    }\n}\n\nawait main();",
          "name": "PvP Air Drop",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        }
      ],
      "cronJobs": [],
      "functions": [],
      "permissions": []
    },
    {
      "tag": "0.0.2",
      "description": "Make your Air Drop a PvP area",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[\"pvpMessage\"],\"additionalProperties\":false,\"properties\":{\"pvpMessage\":{\"title\":\"pvpMessage\",\"description\":\"Message to the server about airdrops being PvP\",\"type\":\"string\"}}}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, eventData, eventType } = data;\n    const messageToSend = data.module.userConfig.pvpMessage\n\n    const logLine = eventData?.msg || eventData?.raw || eventData?.message || (typeof eventData === 'string' ? eventData : null);\n\n    // New console log to print the raw logLine\n    console.log(`AirdropTracker: Raw log line being processed: \"${logLine}\"`);\n\n    // console.log(`AirdropTracker DIAGNOSTIC: Extracted logLine: \"${logLine}\"`); // This is duplicative of the one above now.\n\n    if (!logLine || typeof logLine !== 'string') {\n        // console.log('AirdropTracker: logLine is empty or not a string. Exiting.'); // Log if needed for debugging\n        return;\n    }\n\n    // Regex to extract coordinates, handles optional negative sign and decimals.\n    // Assumes logLine is the correct airdrop message due to hook filtering.\n    // Example: AIAirDrop: Spawned supply crate at (-962.6, 255.0, -660.2), plane is at (...)\n    const coordRegex = /\\((-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*)\\)/;\n    const matches = logLine.match(coordRegex);\n\n    // We are interested in the first set of coordinates (supply crate location).\n    if (matches && matches.length >= 4) { // Ensure X, Y, Z coordinates are captured\n        const extractedX = parseFloat(matches[1]); // First captured group: X\n        const extractedZ = parseFloat(matches[3]); // Third captured group: Z\n\n        if (isNaN(extractedX) || isNaN(extractedZ)) {\n            console.log(`AirdropTracker: Failed to parse coordinates from \"${logLine}\". Extracted: X='${matches[1]}', Z='${matches[3]}'`);\n            return;\n        }\n\n        const roundedX = Math.ceil(extractedX);\n        const roundedZ = Math.ceil(extractedZ);\n\n        const formattedMessage = messageToSend\n            .replace('{x}', roundedX)\n            .replace('{z}', roundedZ);\n\n        await takaro.gameserver.gameServerControllerSendMessage(data.gameServerId, {\n            message: formattedMessage,\n        });\n\n        console.log(`AirdropTracker: Detected on server ${gameServerId}. Original X: ${extractedX.toFixed(1)}, Original Z: ${extractedZ.toFixed(1)}. Rounded Up X: ${roundedX}, Rounded Up Z: ${roundedZ}`);\n\n        // Define constants for calculated coordinates\n        const xPlus50 = roundedX + 100;\n        const zPlus50 = roundedZ + 100;\n        const xMinus50 = roundedX - 100;\n        const zMinus50 = roundedZ - 100;\n\n        // Use constants in console log\n        console.log(`AirdropTracker: Calculated (X+50, Z+50): X = ${xPlus50}, Z = ${zPlus50}`);\n\n        // Use constants in console log\n        console.log(`AirdropTracker: Calculated (X-50, Z-50): X = ${xMinus50}, Z = ${zMinus50}`);\n\n        //ccc add <claimid/steamid> <w_boundary> <e_boundary> <n_boundary> <s_boundary> <accessLevel> \"notify:<enterMsgWithColorSupport>:<exitMsgWithColorSupport>\"\n        await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n            command: `ccc add pvpFightingArena ${xMinus50} ${xPlus50} ${zPlus50} ${zMinus50} 1 \"notify:[FE0288]You are in the [D64C4C]PvP[-] area! You can kill people![-]:[ADDFB3]You left the [D64C4C]PvP[-] area. People in the [D64C4C]PvP[-] area can still kill you.\"`,\n        });\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n            command: `ccc add FightingArena ${xMinus50} ${xPlus50} ${zPlus50} ${zMinus50} 1 \"notify::\"`,\n        });\n\n    } else {\n        // This logs if coordinates couldn't be extracted.\n        console.log(`AirdropTracker: Could not extract coordinates from logLine: \"${logLine}\".`);\n    }\n}\n\nawait main();\n",
          "name": "PvP Air Drop",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        },
        {
          "function": "import { data, takaro } from '@takaro/helpers';\nasync function main() {\n    const gameServerId = data.gameServerId\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc remove pvpFightingArena`,\n    });\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc remove FightingArena`,\n    });\n}\nawait main();",
          "name": "Remove Pvp",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        }
      ],
      "cronJobs": [],
      "functions": [],
      "permissions": []
    },
    {
      "tag": "2.1.5",
      "description": "Make your Air Drop a PvP area. ",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[\"pvpMessage\",\"pvpRange\",\"deleteCronjob\"],\"additionalProperties\":false,\"properties\":{\"pvpMessage\":{\"title\":\"pvpMessage\",\"description\":\"Message to the server about airdrops being PvP. Use {x} and {z} to announce the location of the air drop.\",\"default\":\"[FE0288]An airdrop has been dropped at [DECEA3]{x} [70FE02]{z}[-]. This area is now a [FF0001]PvP[-] zone!\",\"type\":\"string\"},\"pvpRange\":{\"title\":\"pvpRange\",\"description\":\"The range of PvP area. The Area will be double this number.\",\"default\":100,\"type\":\"number\"},\"enterPvPMessage\":{\"title\":\"enterPvPMessage\",\"description\":\"Entering the PvP area message\",\"default\":\"[FE0288]You are in the [D64C4C]PvP[-] area! You can kill people![-]\",\"type\":\"string\"},\"exitPvPMessage\":{\"title\":\"exitPvPMessage\",\"description\":\"Exiting the PvP area Message\",\"default\":\"[ADDFB3]You left the [D64C4C]PvP[-] area. People in the [D64C4C]PvP[-] area can still kill you\",\"type\":\"string\"},\"deleteCronjob\":{\"title\":\"deleteCronjob\",\"description\":\"Set the minutes you want the PvP area to be live\",\"default\":30,\"type\":\"number\"}}}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, eventData, module } = data;\n\n    // Check if the noPvP variable is present\n    const noPvpVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['noPvP'],\n            gameServerId: [gameServerId]\n            // Remove moduleId filter to find variable from any module\n        }\n    });\n\n    // If the variable exists, stop the function\n    if (noPvpVar.data.data.length > 0) {\n        console.log('AirdropTracker: noPvP variable is present, skipping execution.');\n        return;\n    }\n\n    const messageToSend = module.userConfig.pvpMessage;\n    const pvpRangeString = module.userConfig.pvpRange;\n    const enterMessage = module.userConfig.enterPvPMessage;\n    const exitMessage = module.userConfig.exitPvPMessage;\n\n    const range = parseInt(pvpRangeString, 10);\n\n    const logLine = eventData?.msg || eventData?.raw || eventData?.message || (typeof eventData === 'string' ? eventData : null);\n\n    console.log(`AirdropTracker: Raw log line being processed: \"${logLine}\"`);\n\n    const coordRegex = /\\((-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*)\\)/;\n    const matches = logLine.match(coordRegex);\n\n    if (!matches) {\n        console.log(`AirdropTracker: Could not find coordinate pattern in logLine: \"${logLine}\"`);\n        return;\n    }\n\n    const extractedX = parseFloat(matches[1]);\n    const extractedZ = parseFloat(matches[3]);\n\n    if (isNaN(extractedX) || isNaN(extractedZ)) {\n        console.log(`AirdropTracker: Extracted coordinates are not valid numbers. X: ${matches[1]}, Z: ${matches[3]}`);\n        return;\n    }\n\n    const roundedX = Math.ceil(extractedX);\n    const roundedZ = Math.ceil(extractedZ);\n\n    let formattedDisplayX;\n    if (roundedX >= 0) {\n        formattedDisplayX = `${roundedX} East`;\n    } else {\n        formattedDisplayX = `${Math.abs(roundedX)} West`;\n    }\n\n    let formattedDisplayZ;\n    if (roundedZ >= 0) {\n        formattedDisplayZ = `${roundedZ} North`;\n    } else {\n        formattedDisplayZ = `${Math.abs(roundedZ)} South`;\n    }\n\n    const formattedMessage = messageToSend\n        .replace('{x}', formattedDisplayX)\n        .replace('{z}', formattedDisplayZ);\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: formattedMessage,\n    });\n\n    console.log(`AirdropTracker: Detected on server ${gameServerId}. Original X: ${extractedX.toFixed(1)}, Original Z: ${extractedZ.toFixed(1)}. Rounded Up X: ${roundedX}, Rounded Up Z: ${roundedZ}`);\n\n    const xPlusRange = roundedX + range;\n    const zPlusRange = roundedZ + range;\n    const xMinusRange = roundedX - range;\n    const zMinusRange = roundedZ - range;\n\n    console.log(`AirdropTracker: Calculated (X+${range}, Z+${range}): X = ${xPlusRange}, Z = ${zPlusRange} | (X-${range}, Z-${range}): X = ${xMinusRange}, Z = ${zMinusRange}`);\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add pvpFightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} -1 \"notify:${enterMessage}:${exitMessage}\"`,\n    });\n}\n\nawait main();",
          "name": "PvP Air Drop",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        }
      ],
      "cronJobs": [
        {
          "function": "import { data, takaro } from '@takaro/helpers';\nasync function main() {\n    const { gameServerId, module } = data;\n\n    // Check if the noPvP variable is present\n    const noPvpVar = await takaro.variable.variableControllerSearch({\n        filters: {\n            key: ['noPvP'],\n            gameServerId: [gameServerId]\n            // Remove moduleId filter to find variable from any module\n        }\n    });\n\n    // If the variable exists, stop the function\n    if (noPvpVar.data.data.length > 0) {\n        console.log('AirdropTracker: noPvP variable is present, skipping execution.');\n        return;\n    }\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `spawnairdrop`,\n    });\n}\nawait main();",
          "name": "spawn air drops",
          "description": null,
          "temporalValue": "0 * * * *"
        },
        {
          "function": "import { data, takaro } from '@takaro/helpers';\nasync function main() {\n    const { gameServerId, module } = data;\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc remove pvpFightingArena`,\n    });\n\n}\nawait main();",
          "name": "Clean up air drops",
          "description": null,
          "temporalValue": "30 * * * *"
        }
      ],
      "functions": [],
      "permissions": []
    },
    {
      "tag": "2.1.0",
      "description": "Make your Air Drop a PvP area. ",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[\"pvpMessage\",\"pvpRange\",\"deleteCronjob\"],\"additionalProperties\":false,\"properties\":{\"pvpMessage\":{\"title\":\"pvpMessage\",\"description\":\"Message to the server about airdrops being PvP. Use {x} and {z} to announce the location of the air drop.\",\"default\":\"[FE0288]An airdrop has been dropped at [DECEA3]{x} [70FE02]{z}[-]. This area is now a [FF0001]PvP[-] zone!\",\"type\":\"string\"},\"pvpRange\":{\"title\":\"pvpRange\",\"description\":\"The range of PvP area. The Area will be double this number.\",\"default\":100,\"type\":\"number\"},\"enterPvPMessage\":{\"title\":\"enterPvPMessage\",\"description\":\"Entering the PvP area message\",\"default\":\"[FE0288]You are in the [D64C4C]PvP[-] area! You can kill people![-]\",\"type\":\"string\"},\"exitPvPMessage\":{\"title\":\"exitPvPMessage\",\"description\":\"Exiting the PvP area Message\",\"default\":\"[ADDFB3]You left the [D64C4C]PvP[-] area. People in the [D64C4C]PvP[-] area can still kill you\",\"type\":\"string\"},\"deleteCronjob\":{\"title\":\"deleteCronjob\",\"description\":\"Set the minutes you want the PvP area to be live\",\"default\":30,\"type\":\"number\"}}}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Making sure 'module' is available for module.userConfig and module.versionId\n    const { gameServerId, eventData, eventType, module } = data;\n\n    const messageToSend = module.userConfig.pvpMessage;\n    const pvpRangeString = module.userConfig.pvpRange;\n    const enterMessage = module.userConfig.enterPvPMessage;\n    const exitMessage = module.userConfig.exitPvPMessage;\n    const deleteCronjobDelayMinutes = module.userConfig.deleteCronjob;\n\n    const range = parseInt(pvpRangeString, 10);\n\n    const logLine = eventData?.msg || eventData?.raw || eventData?.message || (typeof eventData === 'string' ? eventData : null);\n\n    console.log(`AirdropTracker: Raw log line being processed: \"${logLine}\"`);\n\n    const coordRegex = /\\((-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*)\\)/;\n    const matches = logLine.match(coordRegex);\n\n    if (!matches) {\n        console.log(`AirdropTracker: Could not find coordinate pattern in logLine: \"${logLine}\"`);\n        return;\n    }\n\n    const extractedX = parseFloat(matches[1]);\n    const extractedZ = parseFloat(matches[3]);\n\n    if (isNaN(extractedX) || isNaN(extractedZ)) {\n        console.log(`AirdropTracker: Extracted coordinates are not valid numbers. X: ${matches[1]}, Z: ${matches[3]}`);\n        return;\n    }\n\n    const roundedX = Math.ceil(extractedX);\n    const roundedZ = Math.ceil(extractedZ);\n\n    let formattedDisplayX;\n    if (roundedX >= 0) {\n        formattedDisplayX = `${roundedX} East`;\n    } else {\n        formattedDisplayX = `${Math.abs(roundedX)} West`;\n    }\n\n    let formattedDisplayZ;\n    if (roundedZ >= 0) {\n        formattedDisplayZ = `${roundedZ} North`;\n    } else {\n        formattedDisplayZ = `${Math.abs(roundedZ)} South`;\n    }\n\n    const formattedMessage = messageToSend\n        .replace('{x}', formattedDisplayX)\n        .replace('{z}', formattedDisplayZ);\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: formattedMessage,\n    });\n\n    console.log(`AirdropTracker: Detected on server ${gameServerId}. Original X: ${extractedX.toFixed(1)}, Original Z: ${extractedZ.toFixed(1)}. Rounded Up X: ${roundedX}, Rounded Up Z: ${roundedZ}`);\n\n    const xPlusRange = roundedX + range;\n    const zPlusRange = roundedZ + range;\n    const xMinusRange = roundedX - range;\n    const zMinusRange = roundedZ - range;\n\n    console.log(`AirdropTracker: Calculated (X+${range}, Z+${range}): X = ${xPlusRange}, Z = ${zPlusRange} | (X-${range}, Z-${range}): X = ${xMinusRange}, Z = ${zMinusRange}`);\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add pvpFightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} 1 \"notify:${enterMessage}:${exitMessage}\"`,\n    });\n\n    const delayMinutes = parseInt(deleteCronjobDelayMinutes, 10);\n\n    if (!isNaN(delayMinutes) && delayMinutes > 0) {\n        const now = new Date();\n        const executionTime = new Date(now.getTime() + delayMinutes * 60000); // This is in UTC\n\n        const cronMinute = executionTime.getMinutes(); // Gets minute in UTC\n        const cronHour = executionTime.getHours(); // Gets hour in UTC\n        const cronDayOfMonth = executionTime.getDate(); // Gets day in UTC\n        const cronMonth = executionTime.getMonth() + 1; // Gets month in UTC (0-indexed, so +1)\n\n        const temporalValue = `${cronMinute} ${cronHour} ${cronDayOfMonth} ${cronMonth} *`;\n\n        let cronJobName = `pvp-cleanup-${Date.now()}`;\n        if (cronJobName.length > 50) {\n            cronJobName = cronJobName.substring(0, 50);\n        }\n\n        const cleanupFunction = `\nimport { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Log the entire data object to see its structure\n    console.log('Cleanup Cron Data Object: ' + JSON.stringify(data, null, 2));\n\n    const cronGameServerId = data.gameServerId; \n    // The ID of the currently executing cronjob is in data.itemId\n    const executingCronJobId = data.itemId; \n    // The name is not directly available in 'data', so we'll use a placeholder or the ID for logging.\n    const executingCronJobName = 'pvp-cleanup-dynamic'; // Placeholder name for logs\n\n    try {\n        console.log('Executing PvP area cleanup cron job: ' + executingCronJobName + ' (ID: ' + executingCronJobId + ') for game server: ' + cronGameServerId);\n        \n        if (!cronGameServerId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): cronGameServerId is missing from data. Cannot execute commands.');\n            return; \n        }\n        if (!executingCronJobId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) is missing. Cannot self-delete.');\n            // Still attempt to run game commands\n        }\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove pvpFightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove pvpFightingArena\" for ' + cronGameServerId);\n        \n        // Use data.itemId for self-deletion\n        if (executingCronJobId) {\n            try {\n                await takaro.cronjob.cronJobControllerRemove(executingCronJobId);\n                console.log('PvP Cleanup (' + executingCronJobName + '): Cron job ID ' + executingCronJobId + ' self-deleted successfully.');\n            } catch (deleteError) {\n                let errorMsg = String(deleteError.message || deleteError);\n                if (deleteError.response && deleteError.response.data) {\n                    errorMsg += ' - API Error Details: ' + JSON.stringify(deleteError.response.data);\n                }\n                console.error('PvP Cleanup (' + executingCronJobName + '): Failed to self-delete cron job ID ' + executingCronJobId + '. Error: ' + errorMsg);\n            }\n        } else {\n            console.log('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) was not available, cannot self-delete by ID.');\n        }\n    } catch (error) {\n        let errorMsg = String(error.message || error);\n        if (error.response && error.response.data) {\n            errorMsg += ' - API Error Details: ' + JSON.stringify(error.response.data);\n        }\n        console.error('PvP Cleanup (' + executingCronJobName + ' - ID: ' + (executingCronJobId || 'undefined_id') + '): Error during execution. Error: ' + errorMsg);\n    }\n}\nawait main();\n`; // End of cleanupFunction string\n\n        try {\n            await takaro.cronjob.cronJobControllerCreate({\n                name: cronJobName,\n                temporalValue: temporalValue, // This cron schedule is based on UTC server time\n                versionId: module.versionId,\n                function: cleanupFunction.trim(),\n            });\n\n            // For logging in CDT (UTC-5)\n            // Create a new Date object adjusted by -5 hours for display purposes\n            const displayTime = new Date(executionTime.getTime() - (5 * 60 * 60 * 1000));\n\n            console.log(`AirdropTracker: Scheduled PvP area cleanup cron job \"${cronJobName}\" to run at approximately ${displayTime.toLocaleString()} (CDT) (Cron: ${temporalValue} UTC)`);\n\n        } catch (error) {\n            console.log(`AirdropTracker: Failed to create cleanup cron job \"${cronJobName}\". Error: ${error.message}`);\n            if (error.response && error.response.data) {\n                console.log(`AirdropTracker: API Error details: ${JSON.stringify(error.response.data, null, 2)}`);\n            } else if (error.request) {\n                console.log(`AirdropTracker: No response received for cron job creation. Request details (may be large): ${error.request}`);\n            } else {\n                console.log('AirdropTracker: Error setting up cron job creation request:', error.message);\n            }\n        }\n    } else {\n        console.log(`AirdropTracker: 'deleteCronjob' minutes (\"${deleteCronjobDelayMinutes}\") is not configured, is zero, or invalid. Cleanup cron job will not be created.`);\n    }\n}\n\nawait main();\n",
          "name": "PvP Air Drop",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        }
      ],
      "cronJobs": [],
      "functions": [],
      "permissions": []
    },
    {
      "tag": "1.0.4",
      "description": "Make your Air Drop a PvP area. ",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[\"pvpMessage\",\"pvpRange\",\"deleteCronjob\"],\"additionalProperties\":false,\"properties\":{\"pvpMessage\":{\"title\":\"pvpMessage\",\"description\":\"Message to the server about airdrops being PvP. Use {x} and {z} to announce the location of the air drop.\",\"default\":\"[FE0288]An airdrop has been dropped at [DECEA3]{x} [70FE02]{z}[-]. This area is now a [FF0001]PvP[-] zone!\",\"type\":\"string\"},\"pvpRange\":{\"title\":\"pvpRange\",\"description\":\"The range of PvP area. The Area will be double this number.\",\"default\":100,\"type\":\"number\"},\"enterPvPMessage\":{\"title\":\"enterPvPMessage\",\"description\":\"Entering the PvP area message\",\"default\":\"[FE0288]You are in the [D64C4C]PvP[-] area! You can kill people![-]\",\"type\":\"string\"},\"exitPvPMessage\":{\"title\":\"exitPvPMessage\",\"description\":\"Exiting the PvP area Message\",\"default\":\"[ADDFB3]You left the [D64C4C]PvP[-] area. People in the [D64C4C]PvP[-] area can still kill you\",\"type\":\"string\"},\"deleteCronjob\":{\"title\":\"deleteCronjob\",\"description\":\"Set the minutes you want the PvP area to be live\",\"default\":30,\"type\":\"number\"}}}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [
        {
          "function": "import { data, takaro } from '@takaro/helpers';\nasync function main() {\n    const gameServerId = data.gameServerId\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc remove pvpFightingArena`,\n    });\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc remove FightingArena`,\n    });\n}\nawait main();",
          "name": "Remove Pvp",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        },
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Making sure 'module' is available for module.versionId and module.userConfig\n    const { gameServerId, eventData, eventType, module } = data;\n\n    const messageToSend = module.userConfig.pvpMessage;\n    const pvpRangeString = module.userConfig.pvpRange;\n    const enterMessage = module.userConfig.enterPvPMessage;\n    const exitMessage = module.userConfig.exitPvPMessage;\n    const deleteCronjobDelayMinutes = module.userConfig.deleteCronjob;\n\n    const range = parseInt(pvpRangeString, 10);\n\n    const logLine = eventData?.msg || eventData?.raw || eventData?.message || (typeof eventData === 'string' ? eventData : null);\n\n    console.log(`AirdropTracker: Raw log line being processed: \"${logLine}\"`);\n\n    const coordRegex = /\\((-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*)\\)/;\n    const matches = logLine.match(coordRegex);\n\n    if (!matches) {\n        console.log(`AirdropTracker: Could not find coordinate pattern in logLine: \"${logLine}\"`);\n        return;\n    }\n\n    const extractedX = parseFloat(matches[1]);\n    const extractedZ = parseFloat(matches[3]);\n\n    if (isNaN(extractedX) || isNaN(extractedZ)) {\n        return;\n    }\n\n    const roundedX = Math.ceil(extractedX);\n    const roundedZ = Math.ceil(extractedZ);\n\n    let formattedDisplayX;\n    if (roundedX >= 0) {\n        formattedDisplayX = `${roundedX} East`;\n    } else {\n        formattedDisplayX = `${Math.abs(roundedX)} West`;\n    }\n\n    let formattedDisplayZ;\n    if (roundedZ >= 0) {\n        formattedDisplayZ = `${roundedZ} North`;\n    } else {\n        formattedDisplayZ = `${Math.abs(roundedZ)} South`;\n    }\n\n    const formattedMessage = messageToSend\n        .replace('{x}', formattedDisplayX)\n        .replace('{z}', formattedDisplayZ);\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: formattedMessage,\n    });\n\n    console.log(`AirdropTracker: Detected on server ${gameServerId}. Original X: ${extractedX.toFixed(1)}, Original Z: ${extractedZ.toFixed(1)}. Rounded Up X: ${roundedX}, Rounded Up Z: ${roundedZ}`);\n\n    const xPlusRange = roundedX + range;\n    const zPlusRange = roundedZ + range;\n    const xMinusRange = roundedX - range;\n    const zMinusRange = roundedZ - range;\n\n    console.log(`AirdropTracker: Calculated (X+${range}, Z+${range}): X = ${xPlusRange}, Z = ${zPlusRange} | (X-${range}, Z-${range}): X = ${xMinusRange}, Z = ${zMinusRange}`);\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add pvpFightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} 1 \"notify:${enterMessage}:${exitMessage}\"`,\n    });\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add FightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} 1 \"notify::\"`,\n    });\n\n    const delayMinutes = parseInt(deleteCronjobDelayMinutes, 10);\n\n    if (!isNaN(delayMinutes) && delayMinutes > 0) {\n        const now = new Date();\n        const executionTime = new Date(now.getTime() + delayMinutes * 60000);\n\n        const cronMinute = executionTime.getMinutes();\n        const cronHour = executionTime.getHours();\n        const cronDayOfMonth = executionTime.getDate();\n        const cronMonth = executionTime.getMonth() + 1;\n\n        const temporalValue = `${cronMinute} ${cronHour} ${cronDayOfMonth} ${cronMonth} *`;\n\n        // MODIFIED: Shorten cronJobName to ensure it's <= 50 characters\n        // Removed gameServerId from the name for brevity. Date.now() should provide uniqueness.\n        let cronJobName = `pvp-cleanup-${Date.now()}`;\n        if (cronJobName.length > 50) {\n            cronJobName = cronJobName.substring(0, 50);\n        }\n\n        const cleanupFunction = 'import { takaro, data } from \\'@takaro/helpers\\';\\n\\nasync function main() {\\n    const { gameServerId: cronGameServerId, cronJob } = data;\\n\\n    try {\\n        console.log(\\'Executing PvP area cleanup cron job: \\' + cronJob?.name + \\' (ID: \\' + cronJob?.id + \\') for game server: \\' + cronGameServerId);\\n        \\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\\n            command: \\'ccc remove pvpFightingArena\\',\\n        });\\n        console.log(\\'PvP Cleanup (\\' + cronJob?.name + \\'): Executed \"ccc remove pvpFightingArena\" for \\' + cronGameServerId);\\n\\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\\n            command: \\'ccc remove FightingArena\\',\\n        });\\n        console.log(\\'PvP Cleanup (\\' + cronJob?.name + \\'): Executed \"ccc remove FightingArena\" for \\' + cronGameServerId);\\n        \\n        if (cronJob && cronJob.id) {\\n            try {\\n                await takaro.cronjob.cronJobControllerRemove(cronJob.id);\\n                console.log(\\'PvP Cleanup (\\' + cronJob?.name + \\'): Cron job ID \\' + cronJob.id + \\' self-deleted successfully.\\');\\n            } catch (deleteError) {\\n                console.error(\\'PvP Cleanup (\\' + cronJob?.name + \\'): Failed to self-delete cron job ID \\' + cronJob.id + \\'. Error: \\', deleteError);\\n            }\\n        } else {\\n            console.log(\\'PvP Cleanup (\\' + cronJob?.name + \\'): cronJob.id not available in data, cannot self-delete by ID.\\');\\n        }\\n    } catch (error) {\\n        console.error(\\'PvP Cleanup (\\' + cronJob?.name + \\'): Error during execution. Error: \\', error);\\n    }\\n}\\nawait main();\\n';\n\n        try {\n            await takaro.cronjob.cronJobControllerCreate({\n                name: cronJobName, // MODIFIED: Name is now shorter\n                temporalValue: temporalValue,\n                // moduleId: module.moduleId, // REMOVED: This field should not exist here\n                versionId: module.versionId, // ADDED: This field is required and must be a UUID\n                function: cleanupFunction.trim(),\n            });\n            console.log(`AirdropTracker: Scheduled PvP area cleanup cron job \"${cronJobName}\" to run at approximately ${executionTime.toLocaleString()} (Cron: ${temporalValue})`);\n        } catch (error) {\n            console.log(`AirdropTracker: Failed to create cleanup cron job \"${cronJobName}\". Error: ${error.message}`);\n            if (error.response && error.response.data) {\n                console.log(`AirdropTracker: API Error details: ${JSON.stringify(error.response.data, null, 2)}`);\n            } else if (error.request) {\n                console.log(`AirdropTracker: No response received for cron job creation. Request details (may be large): ${error.request}`);\n            } else {\n                console.log('AirdropTracker: Error setting up cron job creation request:', error.message);\n            }\n        }\n    } else {\n        console.log(`AirdropTracker: 'deleteCronjob' minutes (\"${deleteCronjobDelayMinutes}\") is not configured, is zero, or invalid. Cleanup cron job will not be created.`);\n    }\n}\n\nawait main();",
          "name": "PvP Air Drop",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        }
      ],
      "cronJobs": [],
      "functions": [],
      "permissions": []
    },
    {
      "tag": "1.0.0",
      "description": "Make your Air Drop a PvP area. Use {x} and {z} to announce the location of the air drop.",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[\"pvpMessage\"],\"additionalProperties\":false,\"properties\":{\"pvpMessage\":{\"title\":\"pvpMessage\",\"description\":\"Message to the server about airdrops being PvP\",\"type\":\"string\"},\"pvpRange\":{\"title\":\"pvpRange\",\"description\":\"The range of PvP area. The Area will be double this number.\",\"type\":\"string\"}}}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, eventData, eventType } = data;\n    const messageToSend = data.module.userConfig.pvpMessage\n    const range = data.module.userConfig.pvpRange\n\n    const logLine = eventData?.msg || eventData?.raw || eventData?.message || (typeof eventData === 'string' ? eventData : null);\n\n    // New console log to print the raw logLine\n    console.log(`AirdropTracker: Raw log line being processed: \"${logLine}\"`);\n\n    // console.log(`AirdropTracker DIAGNOSTIC: Extracted logLine: \"${logLine}\"`); // This is duplicative of the one above now.\n\n    if (!logLine || typeof logLine !== 'string') {\n        // console.log('AirdropTracker: logLine is empty or not a string. Exiting.'); // Log if needed for debugging\n        return;\n    }\n\n    // Regex to extract coordinates, handles optional negative sign and decimals.\n    // Assumes logLine is the correct airdrop message due to hook filtering.\n    // Example: AIAirDrop: Spawned supply crate at (-962.6, 255.0, -660.2), plane is at (...)\n    const coordRegex = /\\((-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*)\\)/;\n    const matches = logLine.match(coordRegex);\n\n    // We are interested in the first set of coordinates (supply crate location).\n    if (matches && matches.length >= 4) { // Ensure X, Y, Z coordinates are captured\n        const extractedX = parseFloat(matches[1]); // First captured group: X\n        const extractedZ = parseFloat(matches[3]); // Third captured group: Z\n\n        if (isNaN(extractedX) || isNaN(extractedZ)) {\n            console.log(`AirdropTracker: Failed to parse coordinates from \"${logLine}\". Extracted: X='${matches[1]}', Z='${matches[3]}'`);\n            return;\n        }\n\n        const roundedX = Math.ceil(extractedX);\n        const roundedZ = Math.ceil(extractedZ);\n\n        const formattedMessage = messageToSend\n            .replace('{x}', roundedX)\n            .replace('{z}', roundedZ);\n\n        await takaro.gameserver.gameServerControllerSendMessage(data.gameServerId, {\n            message: formattedMessage,\n        });\n\n        console.log(`AirdropTracker: Detected on server ${gameServerId}. Original X: ${extractedX.toFixed(1)}, Original Z: ${extractedZ.toFixed(1)}. Rounded Up X: ${roundedX}, Rounded Up Z: ${roundedZ}`);\n\n        // Define constants for calculated coordinates\n        const xPlus50 = roundedX + range;\n        const zPlus50 = roundedZ + range;\n        const xMinus50 = roundedX - range;\n        const zMinus50 = roundedZ - range;\n\n        // Use constants in console log\n        console.log(`AirdropTracker: Calculated (X+${range}, Z+${range}): X = ${xPlus50}, Z = ${zPlus50}`);\n\n        // Use constants in console log\n        console.log(`AirdropTracker: Calculated (X-${range}, Z-${range}): X = ${xMinus50}, Z = ${zMinus50}`);\n\n        //ccc add <claimid/steamid> <w_boundary> <e_boundary> <n_boundary> <s_boundary> <accessLevel> \"notify:<enterMsgWithColorSupport>:<exitMsgWithColorSupport>\"\n        await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n            command: `ccc add pvpFightingArena ${xMinus50} ${xPlus50} ${zPlus50} ${zMinus50} 1 \"notify:[FE0288]You are in the [D64C4C]PvP[-] area! You can kill people![-]:[ADDFB3]You left the [D64C4C]PvP[-] area. People in the [D64C4C]PvP[-] area can still kill you.\"`,\n        });\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n            command: `ccc add FightingArena ${xMinus50} ${xPlus50} ${zPlus50} ${zMinus50} 1 \"notify::\"`,\n        });\n\n    } else {\n        // This logs if coordinates couldn't be extracted.\n        console.log(`AirdropTracker: Could not extract coordinates from logLine: \"${logLine}\".`);\n    }\n}\n\nawait main();\n",
          "name": "PvP Air Drop",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        },
        {
          "function": "import { data, takaro } from '@takaro/helpers';\nasync function main() {\n    const gameServerId = data.gameServerId\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc remove pvpFightingArena`,\n    });\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc remove FightingArena`,\n    });\n}\nawait main();",
          "name": "Remove Pvp",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        }
      ],
      "cronJobs": [],
      "functions": [],
      "permissions": []
    },
    {
      "tag": "2.0.0",
      "description": "Make your Air Drop a PvP area. ",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[\"pvpMessage\",\"pvpRange\",\"deleteCronjob\"],\"additionalProperties\":false,\"properties\":{\"pvpMessage\":{\"title\":\"pvpMessage\",\"description\":\"Message to the server about airdrops being PvP. Use {x} and {z} to announce the location of the air drop.\",\"default\":\"[FE0288]An airdrop has been dropped at [DECEA3]{x} [70FE02]{z}[-]. This area is now a [FF0001]PvP[-] zone!\",\"type\":\"string\"},\"pvpRange\":{\"title\":\"pvpRange\",\"description\":\"The range of PvP area. The Area will be double this number.\",\"default\":100,\"type\":\"number\"},\"enterPvPMessage\":{\"title\":\"enterPvPMessage\",\"description\":\"Entering the PvP area message\",\"default\":\"[FE0288]You are in the [D64C4C]PvP[-] area! You can kill people![-]\",\"type\":\"string\"},\"exitPvPMessage\":{\"title\":\"exitPvPMessage\",\"description\":\"Exiting the PvP area Message\",\"default\":\"[ADDFB3]You left the [D64C4C]PvP[-] area. People in the [D64C4C]PvP[-] area can still kill you\",\"type\":\"string\"},\"deleteCronjob\":{\"title\":\"deleteCronjob\",\"description\":\"Set the minutes you want the PvP area to be live\",\"default\":30,\"type\":\"number\"}}}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Making sure 'module' is available for module.userConfig and module.versionId\n    const { gameServerId, eventData, eventType, module } = data;\n\n    const messageToSend = module.userConfig.pvpMessage;\n    const pvpRangeString = module.userConfig.pvpRange;\n    const enterMessage = module.userConfig.enterPvPMessage;\n    const exitMessage = module.userConfig.exitPvPMessage;\n    const deleteCronjobDelayMinutes = module.userConfig.deleteCronjob;\n\n    const range = parseInt(pvpRangeString, 10);\n\n    const logLine = eventData?.msg || eventData?.raw || eventData?.message || (typeof eventData === 'string' ? eventData : null);\n\n    console.log(`AirdropTracker: Raw log line being processed: \"${logLine}\"`);\n\n    const coordRegex = /\\((-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*)\\)/;\n    const matches = logLine.match(coordRegex);\n\n    if (!matches) {\n        console.log(`AirdropTracker: Could not find coordinate pattern in logLine: \"${logLine}\"`);\n        return;\n    }\n\n    const extractedX = parseFloat(matches[1]);\n    const extractedZ = parseFloat(matches[3]);\n\n    if (isNaN(extractedX) || isNaN(extractedZ)) {\n        console.log(`AirdropTracker: Extracted coordinates are not valid numbers. X: ${matches[1]}, Z: ${matches[3]}`);\n        return;\n    }\n\n    const roundedX = Math.ceil(extractedX);\n    const roundedZ = Math.ceil(extractedZ);\n\n    let formattedDisplayX;\n    if (roundedX >= 0) {\n        formattedDisplayX = `${roundedX} East`;\n    } else {\n        formattedDisplayX = `${Math.abs(roundedX)} West`;\n    }\n\n    let formattedDisplayZ;\n    if (roundedZ >= 0) {\n        formattedDisplayZ = `${roundedZ} North`;\n    } else {\n        formattedDisplayZ = `${Math.abs(roundedZ)} South`;\n    }\n\n    const formattedMessage = messageToSend\n        .replace('{x}', formattedDisplayX)\n        .replace('{z}', formattedDisplayZ);\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: formattedMessage,\n    });\n\n    console.log(`AirdropTracker: Detected on server ${gameServerId}. Original X: ${extractedX.toFixed(1)}, Original Z: ${extractedZ.toFixed(1)}. Rounded Up X: ${roundedX}, Rounded Up Z: ${roundedZ}`);\n\n    const xPlusRange = roundedX + range;\n    const zPlusRange = roundedZ + range;\n    const xMinusRange = roundedX - range;\n    const zMinusRange = roundedZ - range;\n\n    console.log(`AirdropTracker: Calculated (X+${range}, Z+${range}): X = ${xPlusRange}, Z = ${zPlusRange} | (X-${range}, Z-${range}): X = ${xMinusRange}, Z = ${zMinusRange}`);\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add pvpFightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} 1 \"notify:${enterMessage}:${exitMessage}\"`,\n    });\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add FightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} 1 \"notify::\"`,\n    });\n\n    const delayMinutes = parseInt(deleteCronjobDelayMinutes, 10);\n\n    if (!isNaN(delayMinutes) && delayMinutes > 0) {\n        const now = new Date();\n        const executionTime = new Date(now.getTime() + delayMinutes * 60000); // This is in UTC\n\n        const cronMinute = executionTime.getMinutes(); // Gets minute in UTC\n        const cronHour = executionTime.getHours(); // Gets hour in UTC\n        const cronDayOfMonth = executionTime.getDate(); // Gets day in UTC\n        const cronMonth = executionTime.getMonth() + 1; // Gets month in UTC (0-indexed, so +1)\n\n        const temporalValue = `${cronMinute} ${cronHour} ${cronDayOfMonth} ${cronMonth} *`;\n\n        let cronJobName = `pvp-cleanup-${Date.now()}`;\n        if (cronJobName.length > 50) {\n            cronJobName = cronJobName.substring(0, 50);\n        }\n\n        const cleanupFunction = `\nimport { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Log the entire data object to see its structure\n    console.log('Cleanup Cron Data Object: ' + JSON.stringify(data, null, 2));\n\n    const cronGameServerId = data.gameServerId; \n    // The ID of the currently executing cronjob is in data.itemId\n    const executingCronJobId = data.itemId; \n    // The name is not directly available in 'data', so we'll use a placeholder or the ID for logging.\n    const executingCronJobName = 'pvp-cleanup-dynamic'; // Placeholder name for logs\n\n    try {\n        console.log('Executing PvP area cleanup cron job: ' + executingCronJobName + ' (ID: ' + executingCronJobId + ') for game server: ' + cronGameServerId);\n        \n        if (!cronGameServerId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): cronGameServerId is missing from data. Cannot execute commands.');\n            return; \n        }\n        if (!executingCronJobId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) is missing. Cannot self-delete.');\n            // Still attempt to run game commands\n        }\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove pvpFightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove pvpFightingArena\" for ' + cronGameServerId);\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove FightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove FightingArena\" for ' + cronGameServerId);\n        \n        // Use data.itemId for self-deletion\n        if (executingCronJobId) {\n            try {\n                await takaro.cronjob.cronJobControllerRemove(executingCronJobId);\n                console.log('PvP Cleanup (' + executingCronJobName + '): Cron job ID ' + executingCronJobId + ' self-deleted successfully.');\n            } catch (deleteError) {\n                let errorMsg = String(deleteError.message || deleteError);\n                if (deleteError.response && deleteError.response.data) {\n                    errorMsg += ' - API Error Details: ' + JSON.stringify(deleteError.response.data);\n                }\n                console.error('PvP Cleanup (' + executingCronJobName + '): Failed to self-delete cron job ID ' + executingCronJobId + '. Error: ' + errorMsg);\n            }\n        } else {\n            console.log('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) was not available, cannot self-delete by ID.');\n        }\n    } catch (error) {\n        let errorMsg = String(error.message || error);\n        if (error.response && error.response.data) {\n            errorMsg += ' - API Error Details: ' + JSON.stringify(error.response.data);\n        }\n        console.error('PvP Cleanup (' + executingCronJobName + ' - ID: ' + (executingCronJobId || 'undefined_id') + '): Error during execution. Error: ' + errorMsg);\n    }\n}\nawait main();\n`; // End of cleanupFunction string\n\n        try {\n            await takaro.cronjob.cronJobControllerCreate({\n                name: cronJobName,\n                temporalValue: temporalValue, // This cron schedule is based on UTC server time\n                versionId: module.versionId,\n                function: cleanupFunction.trim(),\n            });\n\n            // For logging in CDT (UTC-5)\n            // Create a new Date object adjusted by -5 hours for display purposes\n            const displayTime = new Date(executionTime.getTime() - (5 * 60 * 60 * 1000));\n\n            console.log(`AirdropTracker: Scheduled PvP area cleanup cron job \"${cronJobName}\" to run at approximately ${displayTime.toLocaleString()} (CDT) (Cron: ${temporalValue} UTC)`);\n\n        } catch (error) {\n            console.log(`AirdropTracker: Failed to create cleanup cron job \"${cronJobName}\". Error: ${error.message}`);\n            if (error.response && error.response.data) {\n                console.log(`AirdropTracker: API Error details: ${JSON.stringify(error.response.data, null, 2)}`);\n            } else if (error.request) {\n                console.log(`AirdropTracker: No response received for cron job creation. Request details (may be large): ${error.request}`);\n            } else {\n                console.log('AirdropTracker: Error setting up cron job creation request:', error.message);\n            }\n        }\n    } else {\n        console.log(`AirdropTracker: 'deleteCronjob' minutes (\"${deleteCronjobDelayMinutes}\") is not configured, is zero, or invalid. Cleanup cron job will not be created.`);\n    }\n}\n\nawait main();\n",
          "name": "PvP Air Drop",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        }
      ],
      "cronJobs": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Log the entire data object to see its structure\n    console.log('Cleanup Cron Data Object: ' + JSON.stringify(data, null, 2));\n\n    const cronGameServerId = data.gameServerId; \n    // The ID of the currently executing cronjob is in data.itemId\n    const executingCronJobId = data.itemId; \n    // The name is not directly available in 'data', so we'll use a placeholder or the ID for logging.\n    const executingCronJobName = 'pvp-cleanup-dynamic'; // Placeholder name for logs\n\n    try {\n        console.log('Executing PvP area cleanup cron job: ' + executingCronJobName + ' (ID: ' + executingCronJobId + ') for game server: ' + cronGameServerId);\n        \n        if (!cronGameServerId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): cronGameServerId is missing from data. Cannot execute commands.');\n            return; \n        }\n        if (!executingCronJobId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) is missing. Cannot self-delete.');\n            // Still attempt to run game commands\n        }\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove pvpFightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove pvpFightingArena\" for ' + cronGameServerId);\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove FightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove FightingArena\" for ' + cronGameServerId);\n        \n        // Use data.itemId for self-deletion\n        if (executingCronJobId) {\n            try {\n                await takaro.cronjob.cronJobControllerRemove(executingCronJobId);\n                console.log('PvP Cleanup (' + executingCronJobName + '): Cron job ID ' + executingCronJobId + ' self-deleted successfully.');\n            } catch (deleteError) {\n                let errorMsg = String(deleteError.message || deleteError);\n                if (deleteError.response && deleteError.response.data) {\n                    errorMsg += ' - API Error Details: ' + JSON.stringify(deleteError.response.data);\n                }\n                console.error('PvP Cleanup (' + executingCronJobName + '): Failed to self-delete cron job ID ' + executingCronJobId + '. Error: ' + errorMsg);\n            }\n        } else {\n            console.log('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) was not available, cannot self-delete by ID.');\n        }\n    } catch (error) {\n        let errorMsg = String(error.message || error);\n        if (error.response && error.response.data) {\n            errorMsg += ' - API Error Details: ' + JSON.stringify(error.response.data);\n        }\n        console.error('PvP Cleanup (' + executingCronJobName + ' - ID: ' + (executingCronJobId || 'undefined_id') + '): Error during execution. Error: ' + errorMsg);\n    }\n}\nawait main();",
          "name": "pvp-cleanup-1746900789157",
          "description": null,
          "temporalValue": "43 18 10 5 *"
        }
      ],
      "functions": [],
      "permissions": []
    },
    {
      "tag": "1.0.2",
      "description": "Make your Air Drop a PvP area. ",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[\"pvpMessage\",\"pvpRange\"],\"additionalProperties\":false,\"properties\":{\"pvpMessage\":{\"title\":\"pvpMessage\",\"description\":\"Message to the server about airdrops being PvP. Use {x} and {z} to announce the location of the air drop.\",\"default\":\"[FE0288]An airdrop has been dropped at [DECEA3]{x} [70FE02]{z}[-]. This area is now a [FF0001]PvP[-] zone!\",\"type\":\"string\"},\"pvpRange\":{\"title\":\"pvpRange\",\"description\":\"The range of PvP area. The Area will be double this number.\",\"default\":100,\"type\":\"number\"},\"enterPvPMessage\":{\"title\":\"enterPvPMessage\",\"description\":\"Entering the PvP area message\",\"default\":\"[FE0288]You are in the [D64C4C]PvP[-] area! You can kill people![-]\",\"type\":\"string\"},\"exitPvPMessage\":{\"title\":\"exitPvPMessage\",\"description\":\"Exiting the PvP area Message\",\"default\":\"[ADDFB3]You left the [D64C4C]PvP[-] area. People in the [D64C4C]PvP[-] area can still kill you\",\"type\":\"string\"}}}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Destructure gameServerId, eventData, eventType, and module from data\n    const { gameServerId, eventData, module } = data;\n\n    // Destructure userConfig properties directly from module.userConfig\n    // Renaming pvpRange to pvpRangeString to hold the original string value from config,\n    // and pvpMessage, enterPvPMessage, exitPvPMessage to their existing variable names.\n    const {\n        pvpMessage: messageToSend,\n        pvpRange: pvpRangeString, // This is the string value from config\n        enterPvPMessage: enterMessage,\n        exitPvPMessage: exitMessage\n    } = module.userConfig;\n\n    // Ensure 'range' is treated as a number by parsing the string version\n    const range = parseInt(pvpRangeString, 10); // Convert string (e.g., \"100\") to number (e.g., 100)\n\n    // Validate that range is a number after parsing\n    if (isNaN(range)) {\n        console.error(`AirdropTracker: pvpRange \"${pvpRangeString}\" from config is not a valid number. Please check module configuration.`);\n        return; // Stop execution if range is not a valid number\n    }\n\n    const logLine = eventData?.msg || eventData?.raw || eventData?.message || (typeof eventData === 'string' ? eventData : null);\n\n    console.log(`AirdropTracker: Raw log line being processed: \"${logLine}\"`);\n\n    if (!logLine || typeof logLine !== 'string') {\n        console.log('AirdropTracker: logLine is empty or not a string.');\n        return;\n    }\n\n    // Regex to extract coordinates, handles optional negative sign and decimals.\n    const coordRegex = /\\((-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*)\\)/;\n    const matches = logLine.match(coordRegex);\n\n    if (matches && matches.length >= 4) { // Ensure X, Y, Z coordinates are captured\n        const extractedX = parseFloat(matches[1]); // First captured group: X\n        const extractedZ = parseFloat(matches[3]); // Third captured group: Z\n\n        if (isNaN(extractedX) || isNaN(extractedZ)) {\n            console.log(`AirdropTracker: Failed to parse coordinates from \"${logLine}\". Extracted: X='${matches[1]}', Z='${matches[3]}'`);\n            return;\n        }\n\n        const roundedX = Math.ceil(extractedX);\n        const roundedZ = Math.ceil(extractedZ);\n\n        // Format roundedX with East/West direction based on its own sign\n        let formattedDisplayX;\n        if (roundedX >= 0) { // If roundedX is positive or zero\n            formattedDisplayX = `${roundedX} East`;\n        } else { // If roundedX is negative\n            formattedDisplayX = `${Math.abs(roundedX)} West`;\n        }\n\n        // Format roundedZ with North/South direction based on its own sign\n        let formattedDisplayZ;\n        if (roundedZ >= 0) { // If roundedZ is positive or zero\n            formattedDisplayZ = `${roundedZ} North`;\n        } else { // If roundedZ is negative\n            formattedDisplayZ = `${Math.abs(roundedZ)} South`;\n        }\n\n        // Prepare and send the PvP announcement message using the new formatted coordinates\n        const formattedMessage = messageToSend\n            .replace('{x}', formattedDisplayX)\n            .replace('{z}', formattedDisplayZ);\n\n        try {\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, { // gameServerId is now directly available\n                message: formattedMessage,\n            });\n        } catch (error) {\n            console.error(`AirdropTracker: Failed to send PvP announcement message. Error: ${error}`);\n        }\n\n        console.log(`AirdropTracker: Detected on server ${gameServerId}. Original X: ${extractedX.toFixed(1)}, Original Z: ${extractedZ.toFixed(1)}. Rounded Up X: ${roundedX}, Rounded Up Z: ${roundedZ}`);\n\n        // Define constants for calculated coordinates using the numeric 'range'\n        const xPlusRange = roundedX + range;\n        const zPlusRange = roundedZ + range;\n        const xMinusRange = roundedX - range;\n        const zMinusRange = roundedZ - range;\n\n        console.log(`AirdropTracker: Calculated (X+${range}, Z+${range}): X = ${xPlusRange}, Z = ${zPlusRange}`);\n        console.log(`AirdropTracker: Calculated (X-${range}, Z-${range}): X = ${xMinusRange}, Z = ${zMinusRange}`);\n\n        // Execute game commands to create the PvP zones\n        try {\n            await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n                command: `ccc add pvpFightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} 1 \"notify:${enterMessage}:${exitMessage}\"`,\n            });\n            console.log(\"AirdropTracker: 'ccc add pvpFightingArena' command executed.\");\n\n            await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n                command: `ccc add FightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} 1 \"notify::\"`,\n            });\n            console.log(\"AirdropTracker: 'ccc add FightingArena' command executed.\");\n\n        } catch (error) {\n            console.error(`AirdropTracker: Failed to execute 'ccc add' commands. Error: ${error}`);\n        }\n\n    } else {\n        console.log(`AirdropTracker: Could not extract coordinates from logLine: \"${logLine}\".`);\n    }\n}\n\nawait main();\n",
          "name": "PvP Air Drop",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        },
        {
          "function": "import { data, takaro } from '@takaro/helpers';\nasync function main() {\n    const gameServerId = data.gameServerId\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc remove pvpFightingArena`,\n    });\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc remove FightingArena`,\n    });\n}\nawait main();",
          "name": "Remove Pvp",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        }
      ],
      "cronJobs": [],
      "functions": [],
      "permissions": []
    },
    {
      "tag": "2.1.1",
      "description": "Make your Air Drop a PvP area. ",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[\"pvpMessage\",\"pvpRange\",\"deleteCronjob\"],\"additionalProperties\":false,\"properties\":{\"pvpMessage\":{\"title\":\"pvpMessage\",\"description\":\"Message to the server about airdrops being PvP. Use {x} and {z} to announce the location of the air drop.\",\"default\":\"[FE0288]An airdrop has been dropped at [DECEA3]{x} [70FE02]{z}[-]. This area is now a [FF0001]PvP[-] zone!\",\"type\":\"string\"},\"pvpRange\":{\"title\":\"pvpRange\",\"description\":\"The range of PvP area. The Area will be double this number.\",\"default\":100,\"type\":\"number\"},\"enterPvPMessage\":{\"title\":\"enterPvPMessage\",\"description\":\"Entering the PvP area message\",\"default\":\"[FE0288]You are in the [D64C4C]PvP[-] area! You can kill people![-]\",\"type\":\"string\"},\"exitPvPMessage\":{\"title\":\"exitPvPMessage\",\"description\":\"Exiting the PvP area Message\",\"default\":\"[ADDFB3]You left the [D64C4C]PvP[-] area. People in the [D64C4C]PvP[-] area can still kill you\",\"type\":\"string\"},\"deleteCronjob\":{\"title\":\"deleteCronjob\",\"description\":\"Set the minutes you want the PvP area to be live\",\"default\":30,\"type\":\"number\"}}}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Making sure 'module' is available for module.userConfig and module.versionId\n    const { gameServerId, eventData, eventType, module } = data;\n\n    const messageToSend = module.userConfig.pvpMessage;\n    const pvpRangeString = module.userConfig.pvpRange;\n    const enterMessage = module.userConfig.enterPvPMessage;\n    const exitMessage = module.userConfig.exitPvPMessage;\n    const deleteCronjobDelayMinutes = module.userConfig.deleteCronjob;\n\n    const range = parseInt(pvpRangeString, 10);\n\n    const logLine = eventData?.msg || eventData?.raw || eventData?.message || (typeof eventData === 'string' ? eventData : null);\n\n    console.log(`AirdropTracker: Raw log line being processed: \"${logLine}\"`);\n\n    const coordRegex = /\\((-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*)\\)/;\n    const matches = logLine.match(coordRegex);\n\n    if (!matches) {\n        console.log(`AirdropTracker: Could not find coordinate pattern in logLine: \"${logLine}\"`);\n        return;\n    }\n\n    const extractedX = parseFloat(matches[1]);\n    const extractedZ = parseFloat(matches[3]);\n\n    if (isNaN(extractedX) || isNaN(extractedZ)) {\n        console.log(`AirdropTracker: Extracted coordinates are not valid numbers. X: ${matches[1]}, Z: ${matches[3]}`);\n        return;\n    }\n\n    const roundedX = Math.ceil(extractedX);\n    const roundedZ = Math.ceil(extractedZ);\n\n    let formattedDisplayX;\n    if (roundedX >= 0) {\n        formattedDisplayX = `${roundedX} East`;\n    } else {\n        formattedDisplayX = `${Math.abs(roundedX)} West`;\n    }\n\n    let formattedDisplayZ;\n    if (roundedZ >= 0) {\n        formattedDisplayZ = `${roundedZ} North`;\n    } else {\n        formattedDisplayZ = `${Math.abs(roundedZ)} South`;\n    }\n\n    const formattedMessage = messageToSend\n        .replace('{x}', formattedDisplayX)\n        .replace('{z}', formattedDisplayZ);\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: formattedMessage,\n    });\n\n    console.log(`AirdropTracker: Detected on server ${gameServerId}. Original X: ${extractedX.toFixed(1)}, Original Z: ${extractedZ.toFixed(1)}. Rounded Up X: ${roundedX}, Rounded Up Z: ${roundedZ}`);\n\n    const xPlusRange = roundedX + range;\n    const zPlusRange = roundedZ + range;\n    const xMinusRange = roundedX - range;\n    const zMinusRange = roundedZ - range;\n\n    console.log(`AirdropTracker: Calculated (X+${range}, Z+${range}): X = ${xPlusRange}, Z = ${zPlusRange} | (X-${range}, Z-${range}): X = ${xMinusRange}, Z = ${zMinusRange}`);\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add pvpFightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} 1 \"notify:${enterMessage}:${exitMessage}\"`,\n    });\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add FightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} 1 \"notify::\"`,\n    });\n\n    const delayMinutes = parseInt(deleteCronjobDelayMinutes, 10);\n\n    if (!isNaN(delayMinutes) && delayMinutes > 0) {\n        const now = new Date();\n        const executionTime = new Date(now.getTime() + delayMinutes * 60000); // This is in UTC\n\n        const cronMinute = executionTime.getMinutes(); // Gets minute in UTC\n        const cronHour = executionTime.getHours(); // Gets hour in UTC\n        const cronDayOfMonth = executionTime.getDate(); // Gets day in UTC\n        const cronMonth = executionTime.getMonth() + 1; // Gets month in UTC (0-indexed, so +1)\n\n        const temporalValue = `${cronMinute} ${cronHour} ${cronDayOfMonth} ${cronMonth} *`;\n\n        let cronJobName = `pvp-cleanup-${Date.now()}`;\n        if (cronJobName.length > 50) {\n            cronJobName = cronJobName.substring(0, 50);\n        }\n\n        const cleanupFunction = `import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Log the entire data object to see its structure\n    console.log('Cleanup Cron Data Object: ' + JSON.stringify(data, null, 2));\n\n    const cronGameServerId = data.gameServerId; \n    // The ID of the currently executing cronjob is in data.itemId\n    const executingCronJobId = data.itemId; \n    // The name is not directly available in 'data', so we'll use a placeholder or the ID for logging.\n    const executingCronJobName = 'pvp-cleanup-dynamic'; // Placeholder name for logs\n\n    try {\n        console.log('Executing PvP area cleanup cron job: ' + executingCronJobName + ' (ID: ' + executingCronJobId + ') for game server: ' + cronGameServerId);\n        \n        if (!cronGameServerId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): cronGameServerId is missing from data. Cannot execute commands.');\n            return; \n        }\n        if (!executingCronJobId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) is missing. Cannot self-delete.');\n            // Still attempt to run game commands\n        }\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove pvpFightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove pvpFightingArena\" for ' + cronGameServerId);\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove FightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove FightingArena\" for ' + cronGameServerId);\n        \n        // Use data.itemId for self-deletion\n        if (executingCronJobId) {\n            try {\n                await takaro.cronjob.cronJobControllerRemove(executingCronJobId);\n                console.log('PvP Cleanup (' + executingCronJobName + '): Cron job ID ' + executingCronJobId + ' self-deleted successfully.');\n            } catch (deleteError) {\n                let errorMsg = String(deleteError.message || deleteError);\n                if (deleteError.response && deleteError.response.data) {\n                    errorMsg += ' - API Error Details: ' + JSON.stringify(deleteError.response.data);\n                }\n                console.error('PvP Cleanup (' + executingCronJobName + '): Failed to self-delete cron job ID ' + executingCronJobId + '. Error: ' + errorMsg);\n            }\n        } else {\n            console.log('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) was not available, cannot self-delete by ID.');\n        }\n    } catch (error) {\n        let errorMsg = String(error.message || error);\n        if (error.response && error.response.data) {\n            errorMsg += ' - API Error Details: ' + JSON.stringify(error.response.data);\n        }\n        console.error('PvP Cleanup (' + executingCronJobName + ' - ID: ' + (executingCronJobId || 'undefined_id') + '): Error during execution. Error: ' + errorMsg);\n    }\n}\nawait main();\n`; // End of cleanupFunction string\n\n        try {\n            await takaro.cronjob.cronJobControllerCreate({\n                name: cronJobName,\n                temporalValue: temporalValue, // This cron schedule is based on UTC server time\n                versionId: module.versionId,\n                function: cleanupFunction.trim(),\n            });\n\n            // For logging in CDT (UTC-5)\n            // Create a new Date object adjusted by -5 hours for display purposes\n            const displayTime = new Date(executionTime.getTime() - (5 * 60 * 60 * 1000));\n\n            console.log(`AirdropTracker: Scheduled PvP area cleanup cron job \"${cronJobName}\" to run at approximately ${displayTime.toLocaleString()} (CDT) (Cron: ${temporalValue} UTC)`);\n\n        } catch (error) {\n            console.log(`AirdropTracker: Failed to create cleanup cron job \"${cronJobName}\". Error: ${error.message}`);\n            if (error.response && error.response.data) {\n                console.log(`AirdropTracker: API Error details: ${JSON.stringify(error.response.data, null, 2)}`);\n            } else if (error.request) {\n                console.log(`AirdropTracker: No response received for cron job creation. Request details (may be large): ${error.request}`);\n            } else {\n                console.log('AirdropTracker: Error setting up cron job creation request:', error.message);\n            }\n        }\n    } else {\n        console.log(`AirdropTracker: 'deleteCronjob' minutes (\"${deleteCronjobDelayMinutes}\") is not configured, is zero, or invalid. Cleanup cron job will not be created.`);\n    }\n}\n\nawait main();\n",
          "name": "PvP Air Drop",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        }
      ],
      "cronJobs": [],
      "functions": [],
      "permissions": []
    },
    {
      "tag": "2.1.4",
      "description": "Make your Air Drop a PvP area. ",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[\"pvpMessage\",\"pvpRange\",\"deleteCronjob\"],\"additionalProperties\":false,\"properties\":{\"pvpMessage\":{\"title\":\"pvpMessage\",\"description\":\"Message to the server about airdrops being PvP. Use {x} and {z} to announce the location of the air drop.\",\"default\":\"[FE0288]An airdrop has been dropped at [DECEA3]{x} [70FE02]{z}[-]. This area is now a [FF0001]PvP[-] zone!\",\"type\":\"string\"},\"pvpRange\":{\"title\":\"pvpRange\",\"description\":\"The range of PvP area. The Area will be double this number.\",\"default\":100,\"type\":\"number\"},\"enterPvPMessage\":{\"title\":\"enterPvPMessage\",\"description\":\"Entering the PvP area message\",\"default\":\"[FE0288]You are in the [D64C4C]PvP[-] area! You can kill people![-]\",\"type\":\"string\"},\"exitPvPMessage\":{\"title\":\"exitPvPMessage\",\"description\":\"Exiting the PvP area Message\",\"default\":\"[ADDFB3]You left the [D64C4C]PvP[-] area. People in the [D64C4C]PvP[-] area can still kill you\",\"type\":\"string\"},\"deleteCronjob\":{\"title\":\"deleteCronjob\",\"description\":\"Set the minutes you want the PvP area to be live\",\"default\":30,\"type\":\"number\"}}}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Making sure 'module' is available for module.userConfig and module.versionId\n    const { gameServerId, eventData, module } = data;\n\n    const messageToSend = module.userConfig.pvpMessage;\n    const pvpRangeString = module.userConfig.pvpRange;\n    const enterMessage = module.userConfig.enterPvPMessage;\n    const exitMessage = module.userConfig.exitPvPMessage;\n\n    const range = parseInt(pvpRangeString, 10);\n\n    const logLine = eventData?.msg || eventData?.raw || eventData?.message || (typeof eventData === 'string' ? eventData : null);\n\n    console.log(`AirdropTracker: Raw log line being processed: \"${logLine}\"`);\n\n    const coordRegex = /\\((-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*)\\)/;\n    const matches = logLine.match(coordRegex);\n\n    if (!matches) {\n        console.log(`AirdropTracker: Could not find coordinate pattern in logLine: \"${logLine}\"`);\n        return;\n    }\n\n    const extractedX = parseFloat(matches[1]);\n    const extractedZ = parseFloat(matches[3]);\n\n    if (isNaN(extractedX) || isNaN(extractedZ)) {\n        console.log(`AirdropTracker: Extracted coordinates are not valid numbers. X: ${matches[1]}, Z: ${matches[3]}`);\n        return;\n    }\n\n    const roundedX = Math.ceil(extractedX);\n    const roundedZ = Math.ceil(extractedZ);\n\n    let formattedDisplayX;\n    if (roundedX >= 0) {\n        formattedDisplayX = `${roundedX} East`;\n    } else {\n        formattedDisplayX = `${Math.abs(roundedX)} West`;\n    }\n\n    let formattedDisplayZ;\n    if (roundedZ >= 0) {\n        formattedDisplayZ = `${roundedZ} North`;\n    } else {\n        formattedDisplayZ = `${Math.abs(roundedZ)} South`;\n    }\n\n    const formattedMessage = messageToSend\n        .replace('{x}', formattedDisplayX)\n        .replace('{z}', formattedDisplayZ);\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: formattedMessage,\n    });\n\n    console.log(`AirdropTracker: Detected on server ${gameServerId}. Original X: ${extractedX.toFixed(1)}, Original Z: ${extractedZ.toFixed(1)}. Rounded Up X: ${roundedX}, Rounded Up Z: ${roundedZ}`);\n\n    const xPlusRange = roundedX + range;\n    const zPlusRange = roundedZ + range;\n    const xMinusRange = roundedX - range;\n    const zMinusRange = roundedZ - range;\n\n    console.log(`AirdropTracker: Calculated (X+${range}, Z+${range}): X = ${xPlusRange}, Z = ${zPlusRange} | (X-${range}, Z-${range}): X = ${xMinusRange}, Z = ${zMinusRange}`);\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add pvpFightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} -1 \"notify:${enterMessage}:${exitMessage}\"`,\n    });\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add FightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} -1 \"notify::\"`,\n    });\n}\n\nawait main();",
          "name": "PvP Air Drop",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        }
      ],
      "cronJobs": [],
      "functions": [],
      "permissions": []
    },
    {
      "tag": "latest",
      "description": "Make your Air Drop a PvP area. ",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[\"pvpMessage\",\"pvpRange\",\"deleteCronjob\"],\"additionalProperties\":false,\"properties\":{\"pvpMessage\":{\"title\":\"pvpMessage\",\"description\":\"Message to the server about airdrops being PvP. Use {x} and {z} to announce the location of the air drop.\",\"default\":\"[FE0288]An airdrop has been dropped at [DECEA3]{x} [70FE02]{z}[-]. This area is now a [FF0001]PvP[-] zone!\",\"type\":\"string\"},\"pvpRange\":{\"title\":\"pvpRange\",\"description\":\"The range of PvP area. The Area will be double this number.\",\"default\":100,\"type\":\"number\"},\"enterPvPMessage\":{\"title\":\"enterPvPMessage\",\"description\":\"Entering the PvP area message\",\"default\":\"[FE0288]You are in the [D64C4C]PvP[-] area! You can kill people![-]\",\"type\":\"string\"},\"exitPvPMessage\":{\"title\":\"exitPvPMessage\",\"description\":\"Exiting the PvP area Message\",\"default\":\"[ADDFB3]You left the [D64C4C]PvP[-] area. People in the [D64C4C]PvP[-] area can still kill you\",\"type\":\"string\"},\"deleteCronjob\":{\"title\":\"deleteCronjob\",\"description\":\"Set the minutes you want the PvP area to be live\",\"default\":30,\"type\":\"number\"}}}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, eventData, module } = data;\n\n    // Check if blood moon is active using the isbloodmoon command\n    const bloodMoonCheck = await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: 'isbloodmoon',\n    });\n\n    // If blood moon is active (returns true), skip execution\n    if (bloodMoonCheck.data.data.rawResult && bloodMoonCheck.data.data.rawResult.toLowerCase().includes('true')) {\n        console.log('AirdropTracker: Blood moon is active, skipping airdrop PvP zone creation.');\n        return;\n    }\n\n    const messageToSend = module.userConfig.pvpMessage;\n    const pvpRangeString = module.userConfig.pvpRange;\n    const enterMessage = module.userConfig.enterPvPMessage;\n    const exitMessage = module.userConfig.exitPvPMessage;\n\n    const range = parseInt(pvpRangeString, 10);\n\n    const logLine = eventData?.msg || eventData?.raw || eventData?.message || (typeof eventData === 'string' ? eventData : null);\n\n    console.log(`AirdropTracker: Raw log line being processed: \"${logLine}\"`);\n\n    const coordRegex = /\\((-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*)\\)/;\n    const matches = logLine.match(coordRegex);\n\n    if (!matches) {\n        console.log(`AirdropTracker: Could not find coordinate pattern in logLine: \"${logLine}\"`);\n        return;\n    }\n\n    const extractedX = parseFloat(matches[1]);\n    const extractedZ = parseFloat(matches[3]);\n\n    if (isNaN(extractedX) || isNaN(extractedZ)) {\n        console.log(`AirdropTracker: Extracted coordinates are not valid numbers. X: ${matches[1]}, Z: ${matches[3]}`);\n        return;\n    }\n\n    const roundedX = Math.ceil(extractedX);\n    const roundedZ = Math.ceil(extractedZ);\n\n    let formattedDisplayX;\n    if (roundedX >= 0) {\n        formattedDisplayX = `${roundedX} East`;\n    } else {\n        formattedDisplayX = `${Math.abs(roundedX)} West`;\n    }\n\n    let formattedDisplayZ;\n    if (roundedZ >= 0) {\n        formattedDisplayZ = `${roundedZ} North`;\n    } else {\n        formattedDisplayZ = `${Math.abs(roundedZ)} South`;\n    }\n\n    const formattedMessage = messageToSend\n        .replace('{x}', formattedDisplayX)\n        .replace('{z}', formattedDisplayZ);\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: formattedMessage,\n    });\n\n    console.log(`AirdropTracker: Detected on server ${gameServerId}. Original X: ${extractedX.toFixed(1)}, Original Z: ${extractedZ.toFixed(1)}. Rounded Up X: ${roundedX}, Rounded Up Z: ${roundedZ}`);\n\n    const xPlusRange = roundedX + range;\n    const zPlusRange = roundedZ + range;\n    const xMinusRange = roundedX - range;\n    const zMinusRange = roundedZ - range;\n\n    console.log(`AirdropTracker: Calculated (X+${range}, Z+${range}): X = ${xPlusRange}, Z = ${zPlusRange} | (X-${range}, Z-${range}): X = ${xMinusRange}, Z = ${zMinusRange}`);\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add pvpFightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} -1 \"notify:${enterMessage}:${exitMessage}\"`,\n    });\n}\n\nawait main();",
          "name": "PvP Air Drop",
          "description": "Why",
          "eventType": "log",
          "regex": "Spawned supply crate"
        }
      ],
      "cronJobs": [
        {
          "function": "import { data, takaro } from '@takaro/helpers';\nasync function main() {\n    const { gameServerId, module } = data;\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc remove pvpFightingArena`,\n    });\n\n}\nawait main();",
          "name": "Clean up air drops",
          "description": "Airdrop",
          "temporalValue": "30 * * * *"
        },
        {
          "function": "import { data, takaro } from '@takaro/helpers';\nasync function main() {\n    const { gameServerId, module } = data;\n\n    // Check if blood moon is active using the isbloodmoon command\n    const bloodMoonCheck = await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: 'isbloodmoon',\n    });\n\n    // If blood moon is active (returns true), skip execution\n    if (bloodMoonCheck.data.data.rawResult && bloodMoonCheck.data.data.rawResult.toLowerCase().includes('true')) {\n        console.log('AirdropTracker: Blood moon is active, skipping airdrop spawn.');\n        return;\n    }\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `spawnairdrop`,\n    });\n}\nawait main();",
          "name": "spawn air drops",
          "description": "Airdrop",
          "temporalValue": "0 * * * *"
        }
      ],
      "functions": [],
      "permissions": []
    },
    {
      "tag": "2.1.2",
      "description": "Make your Air Drop a PvP area. ",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[\"pvpMessage\",\"pvpRange\",\"deleteCronjob\"],\"additionalProperties\":false,\"properties\":{\"pvpMessage\":{\"title\":\"pvpMessage\",\"description\":\"Message to the server about airdrops being PvP. Use {x} and {z} to announce the location of the air drop.\",\"default\":\"[FE0288]An airdrop has been dropped at [DECEA3]{x} [70FE02]{z}[-]. This area is now a [FF0001]PvP[-] zone!\",\"type\":\"string\"},\"pvpRange\":{\"title\":\"pvpRange\",\"description\":\"The range of PvP area. The Area will be double this number.\",\"default\":100,\"type\":\"number\"},\"enterPvPMessage\":{\"title\":\"enterPvPMessage\",\"description\":\"Entering the PvP area message\",\"default\":\"[FE0288]You are in the [D64C4C]PvP[-] area! You can kill people![-]\",\"type\":\"string\"},\"exitPvPMessage\":{\"title\":\"exitPvPMessage\",\"description\":\"Exiting the PvP area Message\",\"default\":\"[ADDFB3]You left the [D64C4C]PvP[-] area. People in the [D64C4C]PvP[-] area can still kill you\",\"type\":\"string\"},\"deleteCronjob\":{\"title\":\"deleteCronjob\",\"description\":\"Set the minutes you want the PvP area to be live\",\"default\":30,\"type\":\"number\"}}}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Making sure 'module' is available for module.userConfig and module.versionId\n    const { gameServerId, eventData, eventType, module } = data;\n\n    const messageToSend = module.userConfig.pvpMessage;\n    const pvpRangeString = module.userConfig.pvpRange;\n    const enterMessage = module.userConfig.enterPvPMessage;\n    const exitMessage = module.userConfig.exitPvPMessage;\n    const deleteCronjobDelayMinutes = module.userConfig.deleteCronjob;\n\n    const range = parseInt(pvpRangeString, 10);\n\n    const logLine = eventData?.msg || eventData?.raw || eventData?.message || (typeof eventData === 'string' ? eventData : null);\n\n    console.log(`AirdropTracker: Raw log line being processed: \"${logLine}\"`);\n\n    const coordRegex = /\\((-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*)\\)/;\n    const matches = logLine.match(coordRegex);\n\n    if (!matches) {\n        console.log(`AirdropTracker: Could not find coordinate pattern in logLine: \"${logLine}\"`);\n        return;\n    }\n\n    const extractedX = parseFloat(matches[1]);\n    const extractedZ = parseFloat(matches[3]);\n\n    if (isNaN(extractedX) || isNaN(extractedZ)) {\n        console.log(`AirdropTracker: Extracted coordinates are not valid numbers. X: ${matches[1]}, Z: ${matches[3]}`);\n        return;\n    }\n\n    const roundedX = Math.ceil(extractedX);\n    const roundedZ = Math.ceil(extractedZ);\n\n    let formattedDisplayX;\n    if (roundedX >= 0) {\n        formattedDisplayX = `${roundedX} East`;\n    } else {\n        formattedDisplayX = `${Math.abs(roundedX)} West`;\n    }\n\n    let formattedDisplayZ;\n    if (roundedZ >= 0) {\n        formattedDisplayZ = `${roundedZ} North`;\n    } else {\n        formattedDisplayZ = `${Math.abs(roundedZ)} South`;\n    }\n\n    const formattedMessage = messageToSend\n        .replace('{x}', formattedDisplayX)\n        .replace('{z}', formattedDisplayZ);\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: formattedMessage,\n    });\n\n    console.log(`AirdropTracker: Detected on server ${gameServerId}. Original X: ${extractedX.toFixed(1)}, Original Z: ${extractedZ.toFixed(1)}. Rounded Up X: ${roundedX}, Rounded Up Z: ${roundedZ}`);\n\n    const xPlusRange = roundedX + range;\n    const zPlusRange = roundedZ + range;\n    const xMinusRange = roundedX - range;\n    const zMinusRange = roundedZ - range;\n\n    console.log(`AirdropTracker: Calculated (X+${range}, Z+${range}): X = ${xPlusRange}, Z = ${zPlusRange} | (X-${range}, Z-${range}): X = ${xMinusRange}, Z = ${zMinusRange}`);\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add pvpFightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} -1 \"notify:${enterMessage}:${exitMessage}\"`,\n    });\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add FightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} -1 \"notify::\"`,\n    });\n\n    const delayMinutes = parseInt(deleteCronjobDelayMinutes, 10);\n\n    if (!isNaN(delayMinutes) && delayMinutes > 0) {\n        const now = new Date();\n        const executionTime = new Date(now.getTime() + delayMinutes * 60000); // This is in UTC\n\n        const cronMinute = executionTime.getMinutes(); // Gets minute in UTC\n        const cronHour = executionTime.getHours(); // Gets hour in UTC\n        const cronDayOfMonth = executionTime.getDate(); // Gets day in UTC\n        const cronMonth = executionTime.getMonth() + 1; // Gets month in UTC (0-indexed, so +1)\n\n        const temporalValue = `${cronMinute} ${cronHour} ${cronDayOfMonth} ${cronMonth} *`;\n\n        let cronJobName = `pvp-cleanup-${Date.now()}`;\n        if (cronJobName.length > 50) {\n            cronJobName = cronJobName.substring(0, 50);\n        }\n\n        const cleanupFunction = `import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Log the entire data object to see its structure\n    console.log('Cleanup Cron Data Object: ' + JSON.stringify(data, null, 2));\n\n    const cronGameServerId = data.gameServerId; \n    // The ID of the currently executing cronjob is in data.itemId\n    const executingCronJobId = data.itemId; \n    // The name is not directly available in 'data', so we'll use a placeholder or the ID for logging.\n    const executingCronJobName = 'pvp-cleanup-dynamic'; // Placeholder name for logs\n\n    try {\n        console.log('Executing PvP area cleanup cron job: ' + executingCronJobName + ' (ID: ' + executingCronJobId + ') for game server: ' + cronGameServerId);\n        \n        if (!cronGameServerId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): cronGameServerId is missing from data. Cannot execute commands.');\n            return; \n        }\n        if (!executingCronJobId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) is missing. Cannot self-delete.');\n            // Still attempt to run game commands\n        }\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove pvpFightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove pvpFightingArena\" for ' + cronGameServerId);\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove FightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove FightingArena\" for ' + cronGameServerId);\n        \n        // Use data.itemId for self-deletion\n        if (executingCronJobId) {\n            try {\n                await takaro.cronjob.cronJobControllerRemove(executingCronJobId);\n                console.log('PvP Cleanup (' + executingCronJobName + '): Cron job ID ' + executingCronJobId + ' self-deleted successfully.');\n            } catch (deleteError) {\n                let errorMsg = String(deleteError.message || deleteError);\n                if (deleteError.response && deleteError.response.data) {\n                    errorMsg += ' - API Error Details: ' + JSON.stringify(deleteError.response.data);\n                }\n                console.error('PvP Cleanup (' + executingCronJobName + '): Failed to self-delete cron job ID ' + executingCronJobId + '. Error: ' + errorMsg);\n            }\n        } else {\n            console.log('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) was not available, cannot self-delete by ID.');\n        }\n    } catch (error) {\n        let errorMsg = String(error.message || error);\n        if (error.response && error.response.data) {\n            errorMsg += ' - API Error Details: ' + JSON.stringify(error.response.data);\n        }\n        console.error('PvP Cleanup (' + executingCronJobName + ' - ID: ' + (executingCronJobId || 'undefined_id') + '): Error during execution. Error: ' + errorMsg);\n    }\n}\nawait main();\n`; // End of cleanupFunction string\n\n        try {\n            await takaro.cronjob.cronJobControllerCreate({\n                name: cronJobName,\n                temporalValue: temporalValue, // This cron schedule is based on UTC server time\n                versionId: module.versionId,\n                function: cleanupFunction.trim(),\n            });\n\n            // For logging in CDT (UTC-5)\n            // Create a new Date object adjusted by -5 hours for display purposes\n            const displayTime = new Date(executionTime.getTime() - (5 * 60 * 60 * 1000));\n\n            console.log(`AirdropTracker: Scheduled PvP area cleanup cron job \"${cronJobName}\" to run at approximately ${displayTime.toLocaleString()} (CDT) (Cron: ${temporalValue} UTC)`);\n\n        } catch (error) {\n            console.log(`AirdropTracker: Failed to create cleanup cron job \"${cronJobName}\". Error: ${error.message}`);\n            if (error.response && error.response.data) {\n                console.log(`AirdropTracker: API Error details: ${JSON.stringify(error.response.data, null, 2)}`);\n            } else if (error.request) {\n                console.log(`AirdropTracker: No response received for cron job creation. Request details (may be large): ${error.request}`);\n            } else {\n                console.log('AirdropTracker: Error setting up cron job creation request:', error.message);\n            }\n        }\n    } else {\n        console.log(`AirdropTracker: 'deleteCronjob' minutes (\"${deleteCronjobDelayMinutes}\") is not configured, is zero, or invalid. Cleanup cron job will not be created.`);\n    }\n}\n\nawait main();\n",
          "name": "PvP Air Drop",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        }
      ],
      "cronJobs": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Log the entire data object to see its structure\n    console.log('Cleanup Cron Data Object: ' + JSON.stringify(data, null, 2));\n\n    const cronGameServerId = data.gameServerId; \n    // The ID of the currently executing cronjob is in data.itemId\n    const executingCronJobId = data.itemId; \n    // The name is not directly available in 'data', so we'll use a placeholder or the ID for logging.\n    const executingCronJobName = 'pvp-cleanup-dynamic'; // Placeholder name for logs\n\n    try {\n        console.log('Executing PvP area cleanup cron job: ' + executingCronJobName + ' (ID: ' + executingCronJobId + ') for game server: ' + cronGameServerId);\n        \n        if (!cronGameServerId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): cronGameServerId is missing from data. Cannot execute commands.');\n            return; \n        }\n        if (!executingCronJobId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) is missing. Cannot self-delete.');\n            // Still attempt to run game commands\n        }\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove pvpFightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove pvpFightingArena\" for ' + cronGameServerId);\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove FightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove FightingArena\" for ' + cronGameServerId);\n        \n        // Use data.itemId for self-deletion\n        if (executingCronJobId) {\n            try {\n                await takaro.cronjob.cronJobControllerRemove(executingCronJobId);\n                console.log('PvP Cleanup (' + executingCronJobName + '): Cron job ID ' + executingCronJobId + ' self-deleted successfully.');\n            } catch (deleteError) {\n                let errorMsg = String(deleteError.message || deleteError);\n                if (deleteError.response && deleteError.response.data) {\n                    errorMsg += ' - API Error Details: ' + JSON.stringify(deleteError.response.data);\n                }\n                console.error('PvP Cleanup (' + executingCronJobName + '): Failed to self-delete cron job ID ' + executingCronJobId + '. Error: ' + errorMsg);\n            }\n        } else {\n            console.log('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) was not available, cannot self-delete by ID.');\n        }\n    } catch (error) {\n        let errorMsg = String(error.message || error);\n        if (error.response && error.response.data) {\n            errorMsg += ' - API Error Details: ' + JSON.stringify(error.response.data);\n        }\n        console.error('PvP Cleanup (' + executingCronJobName + ' - ID: ' + (executingCronJobId || 'undefined_id') + '): Error during execution. Error: ' + errorMsg);\n    }\n}\nawait main();",
          "name": "pvp-cleanup-1749222955763",
          "description": null,
          "temporalValue": "45 15 6 6 *"
        },
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Log the entire data object to see its structure\n    console.log('Cleanup Cron Data Object: ' + JSON.stringify(data, null, 2));\n\n    const cronGameServerId = data.gameServerId; \n    // The ID of the currently executing cronjob is in data.itemId\n    const executingCronJobId = data.itemId; \n    // The name is not directly available in 'data', so we'll use a placeholder or the ID for logging.\n    const executingCronJobName = 'pvp-cleanup-dynamic'; // Placeholder name for logs\n\n    try {\n        console.log('Executing PvP area cleanup cron job: ' + executingCronJobName + ' (ID: ' + executingCronJobId + ') for game server: ' + cronGameServerId);\n        \n        if (!cronGameServerId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): cronGameServerId is missing from data. Cannot execute commands.');\n            return; \n        }\n        if (!executingCronJobId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) is missing. Cannot self-delete.');\n            // Still attempt to run game commands\n        }\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove pvpFightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove pvpFightingArena\" for ' + cronGameServerId);\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove FightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove FightingArena\" for ' + cronGameServerId);\n        \n        // Use data.itemId for self-deletion\n        if (executingCronJobId) {\n            try {\n                await takaro.cronjob.cronJobControllerRemove(executingCronJobId);\n                console.log('PvP Cleanup (' + executingCronJobName + '): Cron job ID ' + executingCronJobId + ' self-deleted successfully.');\n            } catch (deleteError) {\n                let errorMsg = String(deleteError.message || deleteError);\n                if (deleteError.response && deleteError.response.data) {\n                    errorMsg += ' - API Error Details: ' + JSON.stringify(deleteError.response.data);\n                }\n                console.error('PvP Cleanup (' + executingCronJobName + '): Failed to self-delete cron job ID ' + executingCronJobId + '. Error: ' + errorMsg);\n            }\n        } else {\n            console.log('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) was not available, cannot self-delete by ID.');\n        }\n    } catch (error) {\n        let errorMsg = String(error.message || error);\n        if (error.response && error.response.data) {\n            errorMsg += ' - API Error Details: ' + JSON.stringify(error.response.data);\n        }\n        console.error('PvP Cleanup (' + executingCronJobName + ' - ID: ' + (executingCronJobId || 'undefined_id') + '): Error during execution. Error: ' + errorMsg);\n    }\n}\nawait main();",
          "name": "pvp-cleanup-1747666061610",
          "description": null,
          "temporalValue": "17 15 19 5 *"
        },
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Log the entire data object to see its structure\n    console.log('Cleanup Cron Data Object: ' + JSON.stringify(data, null, 2));\n\n    const cronGameServerId = data.gameServerId; \n    // The ID of the currently executing cronjob is in data.itemId\n    const executingCronJobId = data.itemId; \n    // The name is not directly available in 'data', so we'll use a placeholder or the ID for logging.\n    const executingCronJobName = 'pvp-cleanup-dynamic'; // Placeholder name for logs\n\n    try {\n        console.log('Executing PvP area cleanup cron job: ' + executingCronJobName + ' (ID: ' + executingCronJobId + ') for game server: ' + cronGameServerId);\n        \n        if (!cronGameServerId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): cronGameServerId is missing from data. Cannot execute commands.');\n            return; \n        }\n        if (!executingCronJobId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) is missing. Cannot self-delete.');\n            // Still attempt to run game commands\n        }\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove pvpFightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove pvpFightingArena\" for ' + cronGameServerId);\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove FightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove FightingArena\" for ' + cronGameServerId);\n        \n        // Use data.itemId for self-deletion\n        if (executingCronJobId) {\n            try {\n                await takaro.cronjob.cronJobControllerRemove(executingCronJobId);\n                console.log('PvP Cleanup (' + executingCronJobName + '): Cron job ID ' + executingCronJobId + ' self-deleted successfully.');\n            } catch (deleteError) {\n                let errorMsg = String(deleteError.message || deleteError);\n                if (deleteError.response && deleteError.response.data) {\n                    errorMsg += ' - API Error Details: ' + JSON.stringify(deleteError.response.data);\n                }\n                console.error('PvP Cleanup (' + executingCronJobName + '): Failed to self-delete cron job ID ' + executingCronJobId + '. Error: ' + errorMsg);\n            }\n        } else {\n            console.log('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) was not available, cannot self-delete by ID.');\n        }\n    } catch (error) {\n        let errorMsg = String(error.message || error);\n        if (error.response && error.response.data) {\n            errorMsg += ' - API Error Details: ' + JSON.stringify(error.response.data);\n        }\n        console.error('PvP Cleanup (' + executingCronJobName + ' - ID: ' + (executingCronJobId || 'undefined_id') + '): Error during execution. Error: ' + errorMsg);\n    }\n}\nawait main();",
          "name": "pvp-cleanup-1747666699981",
          "description": null,
          "temporalValue": "28 15 19 5 *"
        },
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Log the entire data object to see its structure\n    console.log('Cleanup Cron Data Object: ' + JSON.stringify(data, null, 2));\n\n    const cronGameServerId = data.gameServerId; \n    // The ID of the currently executing cronjob is in data.itemId\n    const executingCronJobId = data.itemId; \n    // The name is not directly available in 'data', so we'll use a placeholder or the ID for logging.\n    const executingCronJobName = 'pvp-cleanup-dynamic'; // Placeholder name for logs\n\n    try {\n        console.log('Executing PvP area cleanup cron job: ' + executingCronJobName + ' (ID: ' + executingCronJobId + ') for game server: ' + cronGameServerId);\n        \n        if (!cronGameServerId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): cronGameServerId is missing from data. Cannot execute commands.');\n            return; \n        }\n        if (!executingCronJobId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) is missing. Cannot self-delete.');\n            // Still attempt to run game commands\n        }\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove pvpFightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove pvpFightingArena\" for ' + cronGameServerId);\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove FightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove FightingArena\" for ' + cronGameServerId);\n        \n        // Use data.itemId for self-deletion\n        if (executingCronJobId) {\n            try {\n                await takaro.cronjob.cronJobControllerRemove(executingCronJobId);\n                console.log('PvP Cleanup (' + executingCronJobName + '): Cron job ID ' + executingCronJobId + ' self-deleted successfully.');\n            } catch (deleteError) {\n                let errorMsg = String(deleteError.message || deleteError);\n                if (deleteError.response && deleteError.response.data) {\n                    errorMsg += ' - API Error Details: ' + JSON.stringify(deleteError.response.data);\n                }\n                console.error('PvP Cleanup (' + executingCronJobName + '): Failed to self-delete cron job ID ' + executingCronJobId + '. Error: ' + errorMsg);\n            }\n        } else {\n            console.log('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) was not available, cannot self-delete by ID.');\n        }\n    } catch (error) {\n        let errorMsg = String(error.message || error);\n        if (error.response && error.response.data) {\n            errorMsg += ' - API Error Details: ' + JSON.stringify(error.response.data);\n        }\n        console.error('PvP Cleanup (' + executingCronJobName + ' - ID: ' + (executingCronJobId || 'undefined_id') + '): Error during execution. Error: ' + errorMsg);\n    }\n}\nawait main();",
          "name": "pvp-cleanup-1749205866031",
          "description": null,
          "temporalValue": "1 11 6 6 *"
        }
      ],
      "functions": [],
      "permissions": []
    },
    {
      "tag": "1.0.1",
      "description": "Make your Air Drop a PvP area. ",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[\"pvpMessage\",\"pvpRange\"],\"additionalProperties\":false,\"properties\":{\"pvpMessage\":{\"title\":\"pvpMessage\",\"description\":\"Message to the server about airdrops being PvP. Use {x} and {z} to announce the location of the air drop.\",\"default\":\"[FE0288]An airdrop has been dropped at [DECEA3]{x} {z}[-]. This area is now a [FF0001]PvP[-] zone!\",\"type\":\"string\"},\"pvpRange\":{\"title\":\"pvpRange\",\"description\":\"The range of PvP area. The Area will be double this number.\",\"default\":100,\"type\":\"number\"},\"enterPvPMessage\":{\"title\":\"enterPvPMessage\",\"description\":\"Entering the PvP area message\",\"default\":\"[FE0288]You are in the [D64C4C]PvP[-] area! You can kill people![-]\",\"type\":\"string\"},\"exitPvPMessage\":{\"title\":\"exitPvPMessage\",\"description\":\"Exiting the PvP area Message\",\"default\":\"[ADDFB3]You left the [D64C4C]PvP[-] area. People in the [D64C4C]PvP[-] area can still kill you\",\"type\":\"string\"}}}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Destructure gameServerId, eventData, eventType, and module from data\n    const { gameServerId, eventData, module } = data;\n\n    // Destructure userConfig properties directly from module.userConfig\n    // Renaming pvpRange to pvpRangeString to hold the original string value from config,\n    // and pvpMessage, enterPvPMessage, exitPvPMessage to their existing variable names.\n    const {\n        pvpMessage: messageToSend,\n        pvpRange: pvpRangeString, // This is the string value from config\n        enterPvPMessage: enterMessage,\n        exitPvPMessage: exitMessage\n    } = module.userConfig;\n\n    // Ensure 'range' is treated as a number by parsing the string version\n    const range = parseInt(pvpRangeString, 10); // Convert string (e.g., \"100\") to number (e.g., 100)\n\n    // Validate that range is a number after parsing\n    if (isNaN(range)) {\n        console.error(`AirdropTracker: pvpRange \"${pvpRangeString}\" from config is not a valid number. Please check module configuration.`);\n        return; // Stop execution if range is not a valid number\n    }\n\n    const logLine = eventData?.msg || eventData?.raw || eventData?.message || (typeof eventData === 'string' ? eventData : null);\n\n    console.log(`AirdropTracker: Raw log line being processed: \"${logLine}\"`);\n\n    if (!logLine || typeof logLine !== 'string') {\n        console.log('AirdropTracker: logLine is empty or not a string.');\n        return;\n    }\n\n    // Regex to extract coordinates, handles optional negative sign and decimals.\n    const coordRegex = /\\((-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*)\\)/;\n    const matches = logLine.match(coordRegex);\n\n    if (matches && matches.length >= 4) { // Ensure X, Y, Z coordinates are captured\n        const extractedX = parseFloat(matches[1]); // First captured group: X\n        const extractedZ = parseFloat(matches[3]); // Third captured group: Z\n\n        if (isNaN(extractedX) || isNaN(extractedZ)) {\n            console.log(`AirdropTracker: Failed to parse coordinates from \"${logLine}\". Extracted: X='${matches[1]}', Z='${matches[3]}'`);\n            return;\n        }\n\n        const roundedX = Math.ceil(extractedX);\n        const roundedZ = Math.ceil(extractedZ);\n\n        // Format roundedX with East/West direction based on its own sign\n        let formattedDisplayX;\n        if (roundedX >= 0) { // If roundedX is positive or zero\n            formattedDisplayX = `${roundedX} East`;\n        } else { // If roundedX is negative\n            formattedDisplayX = `${Math.abs(roundedX)} West`;\n        }\n\n        // Format roundedZ with North/South direction based on its own sign\n        let formattedDisplayZ;\n        if (roundedZ >= 0) { // If roundedZ is positive or zero\n            formattedDisplayZ = `${roundedZ} North`;\n        } else { // If roundedZ is negative\n            formattedDisplayZ = `${Math.abs(roundedZ)} South`;\n        }\n\n        // Prepare and send the PvP announcement message using the new formatted coordinates\n        const formattedMessage = messageToSend\n            .replace('{x}', formattedDisplayX)\n            .replace('{z}', formattedDisplayZ);\n\n        try {\n            await takaro.gameserver.gameServerControllerSendMessage(gameServerId, { // gameServerId is now directly available\n                message: formattedMessage,\n            });\n        } catch (error) {\n            console.error(`AirdropTracker: Failed to send PvP announcement message. Error: ${error}`);\n        }\n\n        console.log(`AirdropTracker: Detected on server ${gameServerId}. Original X: ${extractedX.toFixed(1)}, Original Z: ${extractedZ.toFixed(1)}. Rounded Up X: ${roundedX}, Rounded Up Z: ${roundedZ}`);\n\n        // Define constants for calculated coordinates using the numeric 'range'\n        const xPlusRange = roundedX + range;\n        const zPlusRange = roundedZ + range;\n        const xMinusRange = roundedX - range;\n        const zMinusRange = roundedZ - range;\n\n        console.log(`AirdropTracker: Calculated (X+${range}, Z+${range}): X = ${xPlusRange}, Z = ${zPlusRange}`);\n        console.log(`AirdropTracker: Calculated (X-${range}, Z-${range}): X = ${xMinusRange}, Z = ${zMinusRange}`);\n\n        // Execute game commands to create the PvP zones\n        try {\n            await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n                command: `ccc add pvpFightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} 1 \"notify:${enterMessage}:${exitMessage}\"`,\n            });\n            console.log(\"AirdropTracker: 'ccc add pvpFightingArena' command executed.\");\n\n            await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n                command: `ccc add FightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} 1 \"notify::\"`,\n            });\n            console.log(\"AirdropTracker: 'ccc add FightingArena' command executed.\");\n\n        } catch (error) {\n            console.error(`AirdropTracker: Failed to execute 'ccc add' commands. Error: ${error}`);\n        }\n\n    } else {\n        console.log(`AirdropTracker: Could not extract coordinates from logLine: \"${logLine}\".`);\n    }\n}\n\nawait main();\n",
          "name": "PvP Air Drop",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        },
        {
          "function": "import { data, takaro } from '@takaro/helpers';\nasync function main() {\n    const gameServerId = data.gameServerId\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc remove pvpFightingArena`,\n    });\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc remove FightingArena`,\n    });\n}\nawait main();",
          "name": "Remove Pvp",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        }
      ],
      "cronJobs": [],
      "functions": [],
      "permissions": []
    },
    {
      "tag": "1.0.5",
      "description": "Make your Air Drop a PvP area. ",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[\"pvpMessage\",\"pvpRange\",\"deleteCronjob\"],\"additionalProperties\":false,\"properties\":{\"pvpMessage\":{\"title\":\"pvpMessage\",\"description\":\"Message to the server about airdrops being PvP. Use {x} and {z} to announce the location of the air drop.\",\"default\":\"[FE0288]An airdrop has been dropped at [DECEA3]{x} [70FE02]{z}[-]. This area is now a [FF0001]PvP[-] zone!\",\"type\":\"string\"},\"pvpRange\":{\"title\":\"pvpRange\",\"description\":\"The range of PvP area. The Area will be double this number.\",\"default\":100,\"type\":\"number\"},\"enterPvPMessage\":{\"title\":\"enterPvPMessage\",\"description\":\"Entering the PvP area message\",\"default\":\"[FE0288]You are in the [D64C4C]PvP[-] area! You can kill people![-]\",\"type\":\"string\"},\"exitPvPMessage\":{\"title\":\"exitPvPMessage\",\"description\":\"Exiting the PvP area Message\",\"default\":\"[ADDFB3]You left the [D64C4C]PvP[-] area. People in the [D64C4C]PvP[-] area can still kill you\",\"type\":\"string\"},\"deleteCronjob\":{\"title\":\"deleteCronjob\",\"description\":\"Set the minutes you want the PvP area to be live\",\"default\":30,\"type\":\"number\"}}}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [
        {
          "function": "import { data, takaro } from '@takaro/helpers';\nasync function main() {\n    const gameServerId = data.gameServerId\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc remove pvpFightingArena`,\n    });\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc remove FightingArena`,\n    });\n}\nawait main();",
          "name": "Remove Pvp",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        },
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Making sure 'module' is available for module.userConfig and module.versionId\n    const { gameServerId, eventData, eventType, module } = data;\n\n    const messageToSend = module.userConfig.pvpMessage;\n    const pvpRangeString = module.userConfig.pvpRange;\n    const enterMessage = module.userConfig.enterPvPMessage;\n    const exitMessage = module.userConfig.exitPvPMessage;\n    const deleteCronjobDelayMinutes = module.userConfig.deleteCronjob;\n\n    const range = parseInt(pvpRangeString, 10);\n\n    const logLine = eventData?.msg || eventData?.raw || eventData?.message || (typeof eventData === 'string' ? eventData : null);\n\n    console.log(`AirdropTracker: Raw log line being processed: \"${logLine}\"`);\n\n    const coordRegex = /\\((-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*)\\)/;\n    const matches = logLine.match(coordRegex);\n\n    if (!matches) {\n        console.log(`AirdropTracker: Could not find coordinate pattern in logLine: \"${logLine}\"`);\n        return;\n    }\n\n    const extractedX = parseFloat(matches[1]);\n    const extractedZ = parseFloat(matches[3]);\n\n    if (isNaN(extractedX) || isNaN(extractedZ)) {\n        console.log(`AirdropTracker: Extracted coordinates are not valid numbers. X: ${matches[1]}, Z: ${matches[3]}`);\n        return;\n    }\n\n    const roundedX = Math.ceil(extractedX);\n    const roundedZ = Math.ceil(extractedZ);\n\n    let formattedDisplayX;\n    if (roundedX >= 0) {\n        formattedDisplayX = `${roundedX} East`;\n    } else {\n        formattedDisplayX = `${Math.abs(roundedX)} West`;\n    }\n\n    let formattedDisplayZ;\n    if (roundedZ >= 0) {\n        formattedDisplayZ = `${roundedZ} North`;\n    } else {\n        formattedDisplayZ = `${Math.abs(roundedZ)} South`;\n    }\n\n    const formattedMessage = messageToSend\n        .replace('{x}', formattedDisplayX)\n        .replace('{z}', formattedDisplayZ);\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: formattedMessage,\n    });\n\n    console.log(`AirdropTracker: Detected on server ${gameServerId}. Original X: ${extractedX.toFixed(1)}, Original Z: ${extractedZ.toFixed(1)}. Rounded Up X: ${roundedX}, Rounded Up Z: ${roundedZ}`);\n\n    const xPlusRange = roundedX + range;\n    const zPlusRange = roundedZ + range;\n    const xMinusRange = roundedX - range;\n    const zMinusRange = roundedZ - range;\n\n    console.log(`AirdropTracker: Calculated (X+${range}, Z+${range}): X = ${xPlusRange}, Z = ${zPlusRange} | (X-${range}, Z-${range}): X = ${xMinusRange}, Z = ${zMinusRange}`);\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add pvpFightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} 1 \"notify:${enterMessage}:${exitMessage}\"`,\n    });\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add FightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} 1 \"notify::\"`,\n    });\n\n    const delayMinutes = parseInt(deleteCronjobDelayMinutes, 10);\n\n    if (!isNaN(delayMinutes) && delayMinutes > 0) {\n        const now = new Date();\n        const executionTime = new Date(now.getTime() + delayMinutes * 60000); // This is in UTC\n\n        const cronMinute = executionTime.getMinutes(); // Gets minute in UTC\n        const cronHour = executionTime.getHours(); // Gets hour in UTC\n        const cronDayOfMonth = executionTime.getDate(); // Gets day in UTC\n        const cronMonth = executionTime.getMonth() + 1; // Gets month in UTC (0-indexed, so +1)\n\n        const temporalValue = `${cronMinute} ${cronHour} ${cronDayOfMonth} ${cronMonth} *`;\n\n        let cronJobName = `pvp-cleanup-${Date.now()}`;\n        if (cronJobName.length > 50) {\n            cronJobName = cronJobName.substring(0, 50);\n        }\n\n        const cleanupFunction = `\nimport { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Log the entire data object to see its structure\n    console.log('Cleanup Cron Data Object: ' + JSON.stringify(data, null, 2));\n\n    const cronGameServerId = data.gameServerId; \n    // The ID of the currently executing cronjob is in data.itemId\n    const executingCronJobId = data.itemId; \n    // The name is not directly available in 'data', so we'll use a placeholder or the ID for logging.\n    const executingCronJobName = 'pvp-cleanup-dynamic'; // Placeholder name for logs\n\n    try {\n        console.log('Executing PvP area cleanup cron job: ' + executingCronJobName + ' (ID: ' + executingCronJobId + ') for game server: ' + cronGameServerId);\n        \n        if (!cronGameServerId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): cronGameServerId is missing from data. Cannot execute commands.');\n            return; \n        }\n        if (!executingCronJobId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) is missing. Cannot self-delete.');\n            // Still attempt to run game commands\n        }\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove pvpFightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove pvpFightingArena\" for ' + cronGameServerId);\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove FightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove FightingArena\" for ' + cronGameServerId);\n        \n        // Use data.itemId for self-deletion\n        if (executingCronJobId) {\n            try {\n                await takaro.cronjob.cronJobControllerRemove(executingCronJobId);\n                console.log('PvP Cleanup (' + executingCronJobName + '): Cron job ID ' + executingCronJobId + ' self-deleted successfully.');\n            } catch (deleteError) {\n                let errorMsg = String(deleteError.message || deleteError);\n                if (deleteError.response && deleteError.response.data) {\n                    errorMsg += ' - API Error Details: ' + JSON.stringify(deleteError.response.data);\n                }\n                console.error('PvP Cleanup (' + executingCronJobName + '): Failed to self-delete cron job ID ' + executingCronJobId + '. Error: ' + errorMsg);\n            }\n        } else {\n            console.log('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) was not available, cannot self-delete by ID.');\n        }\n    } catch (error) {\n        let errorMsg = String(error.message || error);\n        if (error.response && error.response.data) {\n            errorMsg += ' - API Error Details: ' + JSON.stringify(error.response.data);\n        }\n        console.error('PvP Cleanup (' + executingCronJobName + ' - ID: ' + (executingCronJobId || 'undefined_id') + '): Error during execution. Error: ' + errorMsg);\n    }\n}\nawait main();\n`; // End of cleanupFunction string\n\n        try {\n            await takaro.cronjob.cronJobControllerCreate({\n                name: cronJobName,\n                temporalValue: temporalValue, // This cron schedule is based on UTC server time\n                versionId: module.versionId,\n                function: cleanupFunction.trim(),\n            });\n\n            // For logging in CDT (UTC-5)\n            // Create a new Date object adjusted by -5 hours for display purposes\n            const displayTime = new Date(executionTime.getTime() - (5 * 60 * 60 * 1000));\n\n            console.log(`AirdropTracker: Scheduled PvP area cleanup cron job \"${cronJobName}\" to run at approximately ${displayTime.toLocaleString()} (CDT) (Cron: ${temporalValue} UTC)`);\n\n        } catch (error) {\n            console.log(`AirdropTracker: Failed to create cleanup cron job \"${cronJobName}\". Error: ${error.message}`);\n            if (error.response && error.response.data) {\n                console.log(`AirdropTracker: API Error details: ${JSON.stringify(error.response.data, null, 2)}`);\n            } else if (error.request) {\n                console.log(`AirdropTracker: No response received for cron job creation. Request details (may be large): ${error.request}`);\n            } else {\n                console.log('AirdropTracker: Error setting up cron job creation request:', error.message);\n            }\n        }\n    } else {\n        console.log(`AirdropTracker: 'deleteCronjob' minutes (\"${deleteCronjobDelayMinutes}\") is not configured, is zero, or invalid. Cleanup cron job will not be created.`);\n    }\n}\n\nawait main();\n",
          "name": "PvP Air Drop",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        }
      ],
      "cronJobs": [],
      "functions": [],
      "permissions": []
    },
    {
      "tag": "2.0.1",
      "description": "Make your Air Drop a PvP area. ",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"required\":[\"pvpMessage\",\"pvpRange\",\"deleteCronjob\"],\"additionalProperties\":false,\"properties\":{\"pvpMessage\":{\"title\":\"pvpMessage\",\"description\":\"Message to the server about airdrops being PvP. Use {x} and {z} to announce the location of the air drop.\",\"default\":\"[FE0288]An airdrop has been dropped at [DECEA3]{x} [70FE02]{z}[-]. This area is now a [FF0001]PvP[-] zone!\",\"type\":\"string\"},\"pvpRange\":{\"title\":\"pvpRange\",\"description\":\"The range of PvP area. The Area will be double this number.\",\"default\":100,\"type\":\"number\"},\"enterPvPMessage\":{\"title\":\"enterPvPMessage\",\"description\":\"Entering the PvP area message\",\"default\":\"[FE0288]You are in the [D64C4C]PvP[-] area! You can kill people![-]\",\"type\":\"string\"},\"exitPvPMessage\":{\"title\":\"exitPvPMessage\",\"description\":\"Exiting the PvP area Message\",\"default\":\"[ADDFB3]You left the [D64C4C]PvP[-] area. People in the [D64C4C]PvP[-] area can still kill you\",\"type\":\"string\"},\"deleteCronjob\":{\"title\":\"deleteCronjob\",\"description\":\"Set the minutes you want the PvP area to be live\",\"default\":30,\"type\":\"number\"}}}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Making sure 'module' is available for module.userConfig and module.versionId\n    const { gameServerId, eventData, eventType, module } = data;\n\n    const messageToSend = module.userConfig.pvpMessage;\n    const pvpRangeString = module.userConfig.pvpRange;\n    const enterMessage = module.userConfig.enterPvPMessage;\n    const exitMessage = module.userConfig.exitPvPMessage;\n    const deleteCronjobDelayMinutes = module.userConfig.deleteCronjob;\n\n    const range = parseInt(pvpRangeString, 10);\n\n    const logLine = eventData?.msg || eventData?.raw || eventData?.message || (typeof eventData === 'string' ? eventData : null);\n\n    console.log(`AirdropTracker: Raw log line being processed: \"${logLine}\"`);\n\n    const coordRegex = /\\((-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*),\\s*(-?\\d+\\.?\\d*)\\)/;\n    const matches = logLine.match(coordRegex);\n\n    if (!matches) {\n        console.log(`AirdropTracker: Could not find coordinate pattern in logLine: \"${logLine}\"`);\n        return;\n    }\n\n    const extractedX = parseFloat(matches[1]);\n    const extractedZ = parseFloat(matches[3]);\n\n    if (isNaN(extractedX) || isNaN(extractedZ)) {\n        console.log(`AirdropTracker: Extracted coordinates are not valid numbers. X: ${matches[1]}, Z: ${matches[3]}`);\n        return;\n    }\n\n    const roundedX = Math.ceil(extractedX);\n    const roundedZ = Math.ceil(extractedZ);\n\n    let formattedDisplayX;\n    if (roundedX >= 0) {\n        formattedDisplayX = `${roundedX} East`;\n    } else {\n        formattedDisplayX = `${Math.abs(roundedX)} West`;\n    }\n\n    let formattedDisplayZ;\n    if (roundedZ >= 0) {\n        formattedDisplayZ = `${roundedZ} North`;\n    } else {\n        formattedDisplayZ = `${Math.abs(roundedZ)} South`;\n    }\n\n    const formattedMessage = messageToSend\n        .replace('{x}', formattedDisplayX)\n        .replace('{z}', formattedDisplayZ);\n\n    await takaro.gameserver.gameServerControllerSendMessage(gameServerId, {\n        message: formattedMessage,\n    });\n\n    console.log(`AirdropTracker: Detected on server ${gameServerId}. Original X: ${extractedX.toFixed(1)}, Original Z: ${extractedZ.toFixed(1)}. Rounded Up X: ${roundedX}, Rounded Up Z: ${roundedZ}`);\n\n    const xPlusRange = roundedX + range;\n    const zPlusRange = roundedZ + range;\n    const xMinusRange = roundedX - range;\n    const zMinusRange = roundedZ - range;\n\n    console.log(`AirdropTracker: Calculated (X+${range}, Z+${range}): X = ${xPlusRange}, Z = ${zPlusRange} | (X-${range}, Z-${range}): X = ${xMinusRange}, Z = ${zMinusRange}`);\n\n    await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, {\n        command: `ccc add pvpFightingArena ${xMinusRange} ${xPlusRange} ${zPlusRange} ${zMinusRange} 1 \"notify:${enterMessage}:${exitMessage}\"`,\n    });\n\n    const delayMinutes = parseInt(deleteCronjobDelayMinutes, 10);\n\n    if (!isNaN(delayMinutes) && delayMinutes > 0) {\n        const now = new Date();\n        const executionTime = new Date(now.getTime() + delayMinutes * 60000); // This is in UTC\n\n        const cronMinute = executionTime.getMinutes(); // Gets minute in UTC\n        const cronHour = executionTime.getHours(); // Gets hour in UTC\n        const cronDayOfMonth = executionTime.getDate(); // Gets day in UTC\n        const cronMonth = executionTime.getMonth() + 1; // Gets month in UTC (0-indexed, so +1)\n\n        const temporalValue = `${cronMinute} ${cronHour} ${cronDayOfMonth} ${cronMonth} *`;\n\n        let cronJobName = `pvp-cleanup-${Date.now()}`;\n        if (cronJobName.length > 50) {\n            cronJobName = cronJobName.substring(0, 50);\n        }\n\n        const cleanupFunction = `\nimport { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    // Log the entire data object to see its structure\n    console.log('Cleanup Cron Data Object: ' + JSON.stringify(data, null, 2));\n\n    const cronGameServerId = data.gameServerId; \n    // The ID of the currently executing cronjob is in data.itemId\n    const executingCronJobId = data.itemId; \n    // The name is not directly available in 'data', so we'll use a placeholder or the ID for logging.\n    const executingCronJobName = 'pvp-cleanup-dynamic'; // Placeholder name for logs\n\n    try {\n        console.log('Executing PvP area cleanup cron job: ' + executingCronJobName + ' (ID: ' + executingCronJobId + ') for game server: ' + cronGameServerId);\n        \n        if (!cronGameServerId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): cronGameServerId is missing from data. Cannot execute commands.');\n            return; \n        }\n        if (!executingCronJobId) {\n            console.error('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) is missing. Cannot self-delete.');\n            // Still attempt to run game commands\n        }\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove pvpFightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove pvpFightingArena\" for ' + cronGameServerId);\n\n        await takaro.gameserver.gameServerControllerExecuteCommand(cronGameServerId, {\n            command: 'ccc remove FightingArena',\n        });\n        console.log('PvP Cleanup (' + executingCronJobName + ' - ID: ' + executingCronJobId + '): Executed \"ccc remove FightingArena\" for ' + cronGameServerId);\n        \n        // Use data.itemId for self-deletion\n        if (executingCronJobId) {\n            try {\n                await takaro.cronjob.cronJobControllerRemove(executingCronJobId);\n                console.log('PvP Cleanup (' + executingCronJobName + '): Cron job ID ' + executingCronJobId + ' self-deleted successfully.');\n            } catch (deleteError) {\n                let errorMsg = String(deleteError.message || deleteError);\n                if (deleteError.response && deleteError.response.data) {\n                    errorMsg += ' - API Error Details: ' + JSON.stringify(deleteError.response.data);\n                }\n                console.error('PvP Cleanup (' + executingCronJobName + '): Failed to self-delete cron job ID ' + executingCronJobId + '. Error: ' + errorMsg);\n            }\n        } else {\n            console.log('PvP Cleanup (' + executingCronJobName + '): executingCronJobId (data.itemId) was not available, cannot self-delete by ID.');\n        }\n    } catch (error) {\n        let errorMsg = String(error.message || error);\n        if (error.response && error.response.data) {\n            errorMsg += ' - API Error Details: ' + JSON.stringify(error.response.data);\n        }\n        console.error('PvP Cleanup (' + executingCronJobName + ' - ID: ' + (executingCronJobId || 'undefined_id') + '): Error during execution. Error: ' + errorMsg);\n    }\n}\nawait main();\n`; // End of cleanupFunction string\n\n        try {\n            await takaro.cronjob.cronJobControllerCreate({\n                name: cronJobName,\n                temporalValue: temporalValue, // This cron schedule is based on UTC server time\n                versionId: module.versionId,\n                function: cleanupFunction.trim(),\n            });\n\n            // For logging in CDT (UTC-5)\n            // Create a new Date object adjusted by -5 hours for display purposes\n            const displayTime = new Date(executionTime.getTime() - (5 * 60 * 60 * 1000));\n\n            console.log(`AirdropTracker: Scheduled PvP area cleanup cron job \"${cronJobName}\" to run at approximately ${displayTime.toLocaleString()} (CDT) (Cron: ${temporalValue} UTC)`);\n\n        } catch (error) {\n            console.log(`AirdropTracker: Failed to create cleanup cron job \"${cronJobName}\". Error: ${error.message}`);\n            if (error.response && error.response.data) {\n                console.log(`AirdropTracker: API Error details: ${JSON.stringify(error.response.data, null, 2)}`);\n            } else if (error.request) {\n                console.log(`AirdropTracker: No response received for cron job creation. Request details (may be large): ${error.request}`);\n            } else {\n                console.log('AirdropTracker: Error setting up cron job creation request:', error.message);\n            }\n        }\n    } else {\n        console.log(`AirdropTracker: 'deleteCronjob' minutes (\"${deleteCronjobDelayMinutes}\") is not configured, is zero, or invalid. Cleanup cron job will not be created.`);\n    }\n}\n\nawait main();\n",
          "name": "PvP Air Drop",
          "description": null,
          "eventType": "log",
          "regex": "Spawned supply crate"
        }
      ],
      "cronJobs": [],
      "functions": [],
      "permissions": []
    }
  ],
  "takaroVersion": "v0.4.9"
}
