{
  "name": "dynamicCommands",
  "author": "Limon",
  "supportedGames": ["7 Days to Die"],
  "versions": [
    {
      "tag": "latest",
      "description": "Create game server commands dynamically from configuration. Define triggers, arguments, and permissions - commands sync automatically every 15 minutes.\n\n## How It Works\n\n1. Add commands to the **Dynamic Commands** list in the config form\n2. The cronjob syncs your configuration every 15 minutes\n3. Commands are created, updated, or removed to match your config\n4. Permissions are auto-created when referenced\n\n## Argument Types\n\n| Type | Description |\n|------|-------------|\n| `string` | Free text input (item names, messages) |\n| `number` | Numeric values (coordinates, amounts) |\n| `player` | Player selector, validates against online players |\n| `self` | Auto-filled with the executing player (not prompted) |\n\n## Example: Teleport to Player\n\n| Field | Value |\n|-------|-------|\n| Name | teleportto |\n| Trigger | teleportto |\n| Game Command | teleportplayer |\n| Argument 1 | me (type: `self`) - auto-fills with your name |\n| Argument 2 | target (type: `player`) - who to teleport to |\n\n**Result:** Player types `/teleportto Steve` → executes `teleportplayer YourName Steve`\n\n## Example: Give Item\n\n| Field | Value |\n|-------|-------|\n| Name | giveitem |\n| Trigger | give |\n| Game Command | giveself |\n| Argument 1 | item (type: `string`) |\n| Argument 2 | amount (type: `number`, default: 1) |\n\n**Result:** Player types `/give gunPistol 5` → executes `giveself gunPistol 5`\n\n## Example: Admin Command with Permission\n\n| Field | Value |\n|-------|-------|\n| Name | admintp |\n| Trigger | atp |\n| Game Command | teleportplayer |\n| Permission | `ADMIN_TP` (only players with this permission can use it) |\n| Arguments | target (`player`), x (`number`), y (`number`), z (`number`) |\n\n## Placeholders\n\nArguments are appended automatically in order to the game command. For player-type arguments, you can access `.gameId`, `.name`, or `.steamId`. Self-type arguments auto-fill with the executing player's data.",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"additionalProperties\":false,\"properties\":{\"validateOnlinePlayers\":{\"type\":\"boolean\",\"default\":true,\"description\":\"Global setting: When enabled, validates player-type arguments against online players before executing. Can be overridden per-command.\"},\"commands\":{\"type\":\"array\",\"title\":\"Dynamic Commands\",\"description\":\"List of commands to create dynamically\",\"default\":[],\"items\":{\"type\":\"object\",\"additionalProperties\":false,\"properties\":{\"name\":{\"type\":\"string\",\"description\":\"Command identifier (used internally)\"},\"trigger\":{\"type\":\"string\",\"description\":\"What players type (without prefix)\"},\"gameCommand\":{\"type\":\"string\",\"description\":\"Raw game console command. Use placeholders like {{player.gameId}}, {{args.target.gameId}}\"},\"validateOnlinePlayers\":{\"type\":\"boolean\",\"default\":true,\"description\":\"Validates player-type arguments against online players\"},\"description\":{\"type\":\"string\",\"description\":\"Help text shown to players\"},\"permission\":{\"oneOf\":[{\"type\":\"string\",\"title\":\"Simple permission ID\",\"description\":\"Just the permission ID - friendly name auto-generated from ID\"},{\"type\":\"object\",\"title\":\"Custom permission with friendly name\",\"properties\":{\"id\":{\"type\":\"string\",\"description\":\"Permission identifier\"},\"friendlyName\":{\"type\":\"string\",\"description\":\"Human-readable name shown in role management\"},\"description\":{\"type\":\"string\",\"description\":\"Description of what this permission allows\"}},\"required\":[\"id\"],\"additionalProperties\":false}],\"description\":\"Permission required to use this command\"},\"arguments\":{\"type\":\"array\",\"description\":\"Command arguments\",\"items\":{\"type\":\"object\",\"additionalProperties\":false,\"properties\":{\"name\":{\"type\":\"string\",\"description\":\"Argument name\"},\"type\":{\"type\":\"string\",\"enum\":[\"string\",\"number\",\"player\",\"self\"],\"description\":\"Argument type. Use 'self' for auto-filled executing player (not prompted to user)\"},\"required\":{\"type\":\"boolean\",\"default\":true},\"default\":{\"type\":\"string\"},\"helpText\":{\"type\":\"string\"}},\"required\":[\"name\",\"type\"]}}},\"required\":[\"name\",\"trigger\",\"gameCommand\"]}}}}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [],
      "cronJobs": [
        {
          "function": "import { data, takaro } from '@takaro/helpers';\n\nasync function main() {\n  const { gameServerId, module: mod } = data;\n  const commands = mod.userConfig.commands || [];\n  const moduleId = mod.moduleId;\n  const versionId = mod.versionId;\n\n  console.log(`Processing ${commands.length} commands for server ${gameServerId}`);\n  console.log(`Module version: ${versionId}`);\n\n  // Step 1: Store each command config as a variable (PER-SERVER)\n  for (const cmdConfig of commands) {\n    const varKey = `dc-config-${cmdConfig.trigger}`;\n    \n    // Normalize permission and store friendlyName for error messages\n    const permId = typeof cmdConfig.permission === 'object'\n      ? cmdConfig.permission.id\n      : cmdConfig.permission;\n    const permFriendlyName = typeof cmdConfig.permission === 'object'\n      ? cmdConfig.permission.friendlyName\n      : null;\n    \n    const configToStore = {\n      ...cmdConfig,\n      _permissionId: permId || null,\n      _permissionFriendlyName: permFriendlyName\n    };\n    \n    const configValue = JSON.stringify(configToStore);\n\n    const existing = await takaro.variable.variableControllerSearch({\n      filters: { key: [varKey], gameServerId: [gameServerId], moduleId: [moduleId] }\n    });\n\n    if (existing.data.data.length > 0) {\n      await takaro.variable.variableControllerUpdate(existing.data.data[0].id, { value: configValue });\n      console.log(`Updated config for ${cmdConfig.trigger}`);\n    } else {\n      await takaro.variable.variableControllerCreate({\n        key: varKey,\n        value: configValue,\n        gameServerId: gameServerId,\n        moduleId: moduleId\n      });\n      console.log(`Created config for ${cmdConfig.trigger}`);\n    }\n  }\n\n  // Step 1.5: Ensure all referenced permissions exist at module level\n  const referencedPermissions = new Map();\n  for (const cmdConfig of commands) {\n    if (cmdConfig.permission) {\n      if (typeof cmdConfig.permission === 'object') {\n        referencedPermissions.set(cmdConfig.permission.id, {\n          friendlyName: cmdConfig.permission.friendlyName,\n          description: cmdConfig.permission.description\n        });\n      } else {\n        referencedPermissions.set(cmdConfig.permission, null);\n      }\n    }\n  }\n\n  if (referencedPermissions.size > 0) {\n    console.log(`Checking ${referencedPermissions.size} referenced permissions`);\n    \n    const moduleData = (await takaro.module.moduleControllerGetOne(moduleId)).data.data;\n    const existingPermsRaw = moduleData.latestVersion.permissions || [];\n    const existingPermNames = new Set(existingPermsRaw.map(p => p.permission));\n    \n    console.log(`Existing permissions: ${[...existingPermNames].join(', ') || 'none'}`);\n\n    const missingPerms = [];\n    for (const [permId, customConfig] of referencedPermissions) {\n      if (!existingPermNames.has(permId)) {\n        missingPerms.push({\n          permission: permId,\n          friendlyName: customConfig?.friendlyName\n            || permId.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase()),\n          description: customConfig?.description\n            || `Permission for dynamic command using ${permId}`,\n          canHaveCount: false\n        });\n      }\n    }\n\n    if (missingPerms.length > 0) {\n      console.log(`Creating ${missingPerms.length} missing permissions: ${missingPerms.map(p => p.permission).join(', ')}`);\n      \n      // Clean existing permissions - only keep allowed properties\n      const cleanedExisting = existingPermsRaw.map(p => ({\n        permission: p.permission,\n        friendlyName: p.friendlyName,\n        description: p.description,\n        canHaveCount: p.canHaveCount || false\n      }));\n      \n      await takaro.module.moduleControllerUpdate(moduleId, {\n        latestVersion: {\n          permissions: [...cleanedExisting, ...missingPerms]\n        }\n      });\n      console.log(`Created permissions successfully`);\n    }\n  }\n\n  // Step 2: Get all existing dc- commands for this module version\n  const existingCommands = (await takaro.command.commandControllerSearch({\n    filters: { moduleId: [moduleId] }\n  })).data.data;\n\n  const dcCommands = existingCommands.filter(cmd => \n    cmd.name.startsWith('dc-') && cmd.versionId === versionId\n  );\n  \n  console.log(`Found ${dcCommands.length} dc- commands in latest version`);\n\n  // Track which triggers we want to keep\n  const wantedTriggers = new Set(commands.map(c => c.trigger));\n\n  // Step 3: Create/update commands from config\n  for (let i = 0; i < commands.length; i++) {\n    const cmdConfig = commands[i];\n    const commandName = `dc-${i + 1}-${cmdConfig.name}`;\n    const trigger = cmdConfig.trigger;\n    \n    const permId = typeof cmdConfig.permission === 'object'\n      ? cmdConfig.permission.id\n      : cmdConfig.permission;\n\n    const functionCode = `import { data, takaro, checkPermission, TakaroUserError } from '@takaro/helpers';\n\nasync function main() {\n  const { gameServerId, player, pog, arguments: args, module: mod } = data;\n  const TRIGGER = '${trigger}';\n\n  const configVars = await takaro.variable.variableControllerSearch({\n    filters: {\n      key: [\\`dc-config-\\${TRIGGER}\\`],\n      gameServerId: [gameServerId],\n      moduleId: [mod.moduleId]\n    }\n  });\n\n  if (configVars.data.data.length === 0) {\n    throw new TakaroUserError(\\`Command '\\${TRIGGER}' not configured for this server.\\`);\n  }\n\n  const config = JSON.parse(configVars.data.data[0].value);\n\n  const permId = config._permissionId;\n  if (permId && !checkPermission(pog, permId)) {\n    const permName = config._permissionFriendlyName || permId;\n    throw new TakaroUserError(\\`You need the '\\${permName}' permission to use /\\${TRIGGER}.\\`);\n  }\n\n  const validateOnline = config.validateOnlinePlayers !== false;\n  let onlinePlayers = [];\n\n  const resolvedArgs = {};\n  \n  // First, handle \"self\" type arguments - auto-fill with executing player's data\n  for (const argConfig of config.arguments || []) {\n    if (argConfig.type === 'self') {\n      resolvedArgs[argConfig.name] = {\n        name: player.name,\n        gameId: pog.gameId,\n        steamId: player.steamId || ''\n      };\n      console.log(\\`Auto-filled self argument '\\${argConfig.name}' with player '\\${player.name}'\\`);\n    }\n  }\n  \n  // Then process user-provided arguments\n  for (const [key, value] of Object.entries(args)) {\n    const argConfig = (config.arguments || []).find(a => a.name === key);\n    \n    if (argConfig && argConfig.type === 'player') {\n      if (typeof value === 'object' && value !== null) {\n        const playerName = value.player?.name || value.name || 'Unknown';\n        const playerGameId = value.gameId || value.player?.gameId || '';\n        const playerSteamId = value.player?.steamId || value.steamId || '';\n        \n        resolvedArgs[key] = { name: playerName, gameId: playerGameId, steamId: playerSteamId };\n        console.log(\\`Using pre-resolved player '\\${playerName}' (gameId: \\${playerGameId})\\`);\n      } else if (validateOnline) {\n        if (onlinePlayers.length === 0) {\n          onlinePlayers = (await takaro.gameserver.gameServerControllerGetPlayers(gameServerId)).data.data;\n        }\n        \n        const searchValue = String(value).toLowerCase();\n        let target = onlinePlayers.find(p => p.name.toLowerCase() === searchValue);\n        if (!target) target = onlinePlayers.find(p => p.name.toLowerCase().includes(searchValue));\n        \n        if (!target) {\n          const names = onlinePlayers.map(p => p.name).join(', ');\n          throw new TakaroUserError(names ? \\`Player '\\${value}' not found. Online: \\${names}\\` : 'No players are currently online.');\n        }\n        \n        resolvedArgs[key] = { name: target.name, gameId: target.gameId, steamId: target.steamId || '' };\n        console.log(\\`Resolved player '\\${value}' to '\\${target.name}' (gameId: \\${target.gameId})\\`);\n      } else {\n        resolvedArgs[key] = value;\n      }\n    } else {\n      resolvedArgs[key] = value;\n    }\n  }\n\n  let command = config.gameCommand;\n  \n  // Backward compatibility: if targetsSelf is true and no \"self\" type argument exists, append at end\n  const hasSelfArg = (config.arguments || []).some(a => a.type === 'self');\n  if (config.targetsSelf && !hasSelfArg && !command.includes('{{player.')) {\n    command += ' \"{{player.name}}\"';\n  }\n  \n  // Append arguments in order (including \"self\" type args at their defined position)\n  for (const arg of config.arguments || []) {\n    if (!command.includes('{{args.' + arg.name)) {\n      command += ' {{args.' + arg.name + '}}';\n    }\n  }\n\n  command = command.replace(/{{player\\\\.gameId}}/g, pog.gameId || '');\n  command = command.replace(/{{player\\\\.name}}/g, player.name || '');\n  command = command.replace(/{{player\\\\.steamId}}/g, player.steamId || '');\n  command = command.replace(/{{player\\\\.epicOnlineServicesId}}/g, player.epicOnlineServicesId || '');\n\n  for (const [key, value] of Object.entries(resolvedArgs)) {\n    if (typeof value === 'object' && value !== null && value.gameId !== undefined) {\n      command = command.replace(new RegExp('{{args\\\\\\\\.' + key + '\\\\\\\\.gameId}}', 'g'), value.gameId);\n      command = command.replace(new RegExp('{{args\\\\\\\\.' + key + '\\\\\\\\.steamId}}', 'g'), value.steamId || '');\n      const safeName = /\\\\s/.test(value.name) ? '\"' + value.name + '\"' : value.name;\n      command = command.replace(new RegExp('{{args\\\\\\\\.' + key + '\\\\\\\\.name}}', 'g'), safeName);\n      command = command.replace(new RegExp('{{args\\\\\\\\.' + key + '}}', 'g'), safeName);\n    } else {\n      const safeValue = /\\\\s/.test(String(value)) ? '\"' + value + '\"' : String(value);\n      command = command.replace(new RegExp('{{args\\\\\\\\.' + key + '}}', 'g'), safeValue);\n    }\n  }\n\n  console.log('Executing command:', command);\n\n  const response = await takaro.gameserver.gameServerControllerExecuteCommand(gameServerId, { command });\n  const result = response.data.data.rawResult || '';\n  console.log('Command result:', result);\n\n  if (result.includes('not a valid entity id') || result.includes('Player not found')) {\n    throw new TakaroUserError('Player not found or invalid.');\n  }\n\n  await player.pm('Command executed successfully.');\n}\n\nawait main();`;\n\n    const existing = dcCommands.find(c => c.trigger === trigger);\n\n    // Filter out \"self\" type arguments - they are auto-filled, not user-provided\n    const commandArgs = (cmdConfig.arguments || [])\n      .filter(arg => arg.type !== 'self')\n      .map((arg, idx) => ({\n        name: arg.name,\n        type: arg.type,\n        position: idx,\n        helpText: arg.helpText || '',\n        defaultValue: arg.default || undefined\n      }));\n\n    try {\n      if (!existing) {\n        console.log(`Creating command: ${commandName} (trigger: ${trigger})`);\n        await takaro.command.commandControllerCreate({\n          name: commandName,\n          trigger: trigger,\n          helpText: cmdConfig.description || '',\n          function: functionCode,\n          versionId: versionId,\n          arguments: commandArgs,\n          requiredPermissions: permId ? [permId] : []\n        });\n        console.log(`Created command: ${trigger}`);\n      } else {\n        console.log(`Updating command: ${trigger} (id: ${existing.id})`);\n        await takaro.command.commandControllerUpdate(existing.id, {\n          function: functionCode,\n          helpText: cmdConfig.description || '',\n          requiredPermissions: permId ? [permId] : [],\n          arguments: commandArgs\n        });\n        console.log(`Updated command: ${trigger}`);\n      }\n    } catch (err) {\n      console.log(`Error processing command ${trigger}: ${err.message}`);\n    }\n  }\n\n  // Step 4: Delete orphaned commands (dc- commands not in config)\n  for (const cmd of dcCommands) {\n    if (!wantedTriggers.has(cmd.trigger)) {\n      try {\n        await takaro.command.commandControllerRemove(cmd.id);\n        console.log(`Removed orphaned command: ${cmd.trigger} (id: ${cmd.id})`);\n      } catch (err) {\n        console.log(`Error removing command ${cmd.trigger}: ${err.message}`);\n      }\n    }\n  }\n\n  // Step 5: Clean up orphaned variables for this server\n  const allVars = await takaro.variable.variableControllerSearch({\n    filters: { gameServerId: [gameServerId], moduleId: [moduleId] },\n    search: { key: ['dc-config-'] }\n  });\n\n  const configuredTriggers = new Set(commands.map(c => `dc-config-${c.trigger}`));\n  for (const v of allVars.data.data) {\n    if (v.key.startsWith('dc-config-') && !configuredTriggers.has(v.key)) {\n      await takaro.variable.variableControllerDelete(v.id);\n      console.log(`Removed orphaned config: ${v.key}`);\n    }\n  }\n\n  // Step 6: Clean up orphaned permissions\n  // Re-fetch dc- commands after cleanup to see what's left\n  const remainingDcCommands = (await takaro.command.commandControllerSearch({\n    filters: { moduleId: [moduleId] }\n  })).data.data.filter(cmd => cmd.name.startsWith('dc-') && cmd.versionId === versionId);\n\n  // Collect permissions still in use by remaining dc- commands\n  const usedPermissions = new Set();\n  for (const cmd of remainingDcCommands) {\n    for (const perm of cmd.requiredPermissions || []) {\n      usedPermissions.add(perm);\n    }\n  }\n\n  // Get current module permissions\n  const moduleData = (await takaro.module.moduleControllerGetOne(moduleId)).data.data;\n  const modulePerms = moduleData.latestVersion.permissions || [];\n\n  // Find orphaned permissions (any permission not used by remaining dc- commands)\n  const orphanedPerms = modulePerms.filter(p => !usedPermissions.has(p.permission));\n\n  if (orphanedPerms.length > 0) {\n    console.log(`Removing ${orphanedPerms.length} orphaned permissions: ${orphanedPerms.map(p => p.permission).join(', ')}`);\n\n    const keptPerms = modulePerms.filter(p => !orphanedPerms.some(op => op.permission === p.permission));\n\n    // Clean for API (remove createdAt, updatedAt, id, moduleVersionId)\n    const cleanedPerms = keptPerms.map(p => ({\n      permission: p.permission,\n      friendlyName: p.friendlyName,\n      description: p.description,\n      canHaveCount: p.canHaveCount || false\n    }));\n\n    await takaro.module.moduleControllerUpdate(moduleId, {\n      latestVersion: { permissions: cleanedPerms }\n    });\n    console.log(`Removed orphaned permissions successfully`);\n  }\n\n  console.log('Done');\n}\n\nawait main();",
          "name": "commandGenerator",
          "description": "Generates Takaro commands from userConfig.commands. Runs every 15 minutes to sync configuration with actual commands. Uses hash-based change detection to skip unnecessary updates.",
          "temporalValue": "*/15 * * * *"
        }
      ],
      "functions": [],
      "permissions": []
    }
  ],
  "takaroVersion": "main"
}
