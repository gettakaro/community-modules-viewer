{
  "name": "DynamicServerMessages",
  "author": "Limon",
  "supportedGames": ["all"],
  "versions": [
    {
      "tag": "latest",
      "description": "# Dynamic CronJob Manager: Automated Game Server Command Scheduler\n\n---\nüé• **SETUP TUTORIAL**  \n**[‚ñ∫ Watch the Complete Guide](https://youtu.be/NlmRnMvPSLg?si=Y-bKwt4St_Wjn51L)**  \n*Learn how to set up and configure dynamic cronjobs*\n---\n\nCreate and manage dynamic cronjobs for executing game server commands based on flexible schedules. Define commands and their cron expressions to automate tasks.  \n\n  -   **Dynamic Updates:** The module's `cronJobGenerator` cronjob automatically checks for and adapts to changes in the user configuration. This ensures that any modifications to commands or schedules are applied dynamically.\n  -   **Cron Syntax Validation:** The module validates the syntax of cron expressions. If an invalid expression is provided, that specific cronjob will be skipped, preventing errors and ensuring only valid schedules are applied.  For assistance with cron syntax, you can use a tool like [crontab.guru](https://crontab.guru/).\n  -   **Command Sequencing:** You can define multiple commands within a single cronjob entry, separated by semicolons. These commands will be executed sequentially according to the defined schedule.\n  -   **Game Server Specificity:** It is crucial to install the latest version of this module and create a **separate copy for each game server**. This ensures that cronjobs are executed on the intended server and avoids unintended cross-server execution.\n  -   **Automated Management:** The module handles the creation, updating, and cleanup of cronjobs. It removes any cronjobs that are no longer present in the configuration, maintaining a clean and accurate schedule.\n  -   **Internal Synchronization:** To ensure proper synchronization of cron schedules, the module may perform internal operations to update its configuration. This process is automated and does not require manual intervention from the user.",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"cronjobs\":{\"type\":\"array\",\"title\":\"Cronjobs\",\"description\":\"List of cronjobs and their schedules\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\",\"description\":\"Optional name for the cronjob\",\"minLength\":1},\"command\":{\"type\":\"string\",\"description\":\"Command to execute\",\"minLength\":1},\"temporalValue\":{\"type\":\"string\",\"description\":\"Cron expression for execution schedule\",\"minLength\":1}},\"required\":[\"command\",\"temporalValue\"]}}},\"additionalProperties\":false}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [],
      "cronJobs": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n    const { gameServerId, module: mod } = data;\n    const cronjobs = mod.userConfig.cronjobs || [];\n\n    console.log('üîÑ Dynamic Server Messages Generator starting...');\n\n    // Server short ID for namespacing (first 8 chars of gameServerId)\n    const serverShortId = gameServerId.substring(0, 8);\n    const serverPrefix = `sm-${serverShortId}-`;\n\n    console.log(`üìç Server: ${serverShortId} (${gameServerId})`);\n\n    // State management keys\n    const configHashKey = 'sm_config_hash';\n    const lastProcessedKey = 'sm_last_processed';\n    const backupConfigKey = 'sm_backup_config';\n\n    try {\n        // Create configuration hash for change detection\n        const currentConfigHash = JSON.stringify(cronjobs).split('').reduce((a, b) => {\n            a = ((a << 5) - a) + b.charCodeAt(0);\n            return a & a;\n        }, 0).toString();\n\n        // Get stored state\n        let storedHash = null;\n        let lastProcessed = null;\n        try {\n            const hashVar = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: [configHashKey],\n                    moduleId: [mod.moduleId],\n                    gameServerId: [gameServerId]\n                }\n            });\n            if (hashVar.data.data.length > 0) {\n                storedHash = hashVar.data.data[0].value;\n            }\n\n            const processedVar = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: [lastProcessedKey],\n                    moduleId: [mod.moduleId],\n                    gameServerId: [gameServerId]\n                }\n            });\n            if (processedVar.data.data.length > 0) {\n                lastProcessed = new Date(processedVar.data.data[0].value);\n            }\n        } catch (error) {\n            console.log('üìù No previous state found, treating as first run');\n        }\n\n        // Check if configuration changed (5 minute cooldown)\n        if (storedHash === currentConfigHash && lastProcessed && (Date.now() - lastProcessed.getTime()) < 300000) {\n            console.log('‚úÖ No configuration changes detected, skipping update');\n            return;\n        }\n\n        // Backup current configuration\n        try {\n            await takaro.variable.variableControllerCreate({\n                key: backupConfigKey,\n                value: JSON.stringify({\n                    userConfig: mod.userConfig,\n                    timestamp: new Date().toISOString(),\n                    hash: currentConfigHash\n                }),\n                gameServerId,\n                moduleId: mod.moduleId\n            });\n            console.log('üíæ Configuration backup created');\n        } catch (backupError) {\n            const existingBackup = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: [backupConfigKey],\n                    moduleId: [mod.moduleId],\n                    gameServerId: [gameServerId]\n                }\n            });\n            if (existingBackup.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(existingBackup.data.data[0].id, {\n                    value: JSON.stringify({\n                        userConfig: mod.userConfig,\n                        timestamp: new Date().toISOString(),\n                        hash: currentConfigHash\n                    })\n                });\n                console.log('üíæ Configuration backup updated');\n            }\n        }\n\n        // Get existing cronjobs for this module version\n        const existingCronjobs = (await takaro.cronjob.cronJobControllerSearch({\n            filters: { versionId: [mod.versionId] }\n        })).data.data;\n\n        // Legacy cleanup (old format without server ID)\n        let legacyCleanupCount = 0;\n        for (const existingJob of existingCronjobs) {\n            if (/^sm-\\d+(-|$)/.test(existingJob.name)) {\n                const afterSm = existingJob.name.substring(3);\n                if (!/^[a-f0-9]{8}-/i.test(afterSm)) {\n                    try {\n                        await takaro.cronjob.cronJobControllerRemove(existingJob.id);\n                        legacyCleanupCount++;\n                        console.log(`üßπ Removed legacy cronjob: ${existingJob.name}`);\n                    } catch (error) {\n                        console.log(`‚ö†Ô∏è Could not remove legacy cronjob \"${existingJob.name}\": ${error.message}`);\n                    }\n                }\n            }\n        }\n        if (legacyCleanupCount > 0) {\n            console.log(`üßπ Cleaned up ${legacyCleanupCount} legacy cronjob(s)`);\n        }\n\n        const processedJobs = new Set();\n        let createdCount = 0;\n        let updatedCount = 0;\n        let errorCount = 0;\n\n        for (let i = 0; i < cronjobs.length; i++) {\n            const job = cronjobs[i];\n            const jobNameSuffix = job.name ? `-${job.name}` : '';\n            const jobName = `${serverPrefix}${i + 1}${jobNameSuffix}`;\n\n            processedJobs.add(jobName);\n\n            const existingJob = existingCronjobs.find(j => j.name === jobName);\n\n            const jobFunction = `\nimport { takaro, data } from '@takaro/helpers';\nasync function main() {\n    // Server guard - silently exit if wrong server\n    if (data.gameServerId !== '${gameServerId}') return;\n\n    const { gameServerId: gsId } = data;\n\n    const currentPlayers = (await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: {\n            gameServerId: [gsId],\n            online: [true]\n        }\n    })).data.meta;\n\n    if (currentPlayers.total === 0) return;\n\n    await takaro.gameserver.gameServerControllerSendMessage(gsId, {\n        message: \\`${job.command}\\`,\n    });\n}\nawait main();\n`.trim();\n\n            try {\n                if (existingJob) {\n                    if (existingJob.temporalValue !== job.temporalValue || existingJob.function !== jobFunction) {\n                        await takaro.cronjob.cronJobControllerUpdate(existingJob.id, {\n                            name: jobName,\n                            temporalValue: job.temporalValue,\n                            function: jobFunction\n                        });\n                        updatedCount++;\n                        console.log(`üìù Updated: ${jobName}`);\n                    }\n                } else {\n                    try {\n                        await takaro.cronjob.cronJobControllerCreate({\n                            name: jobName,\n                            temporalValue: job.temporalValue,\n                            versionId: mod.versionId,\n                            function: jobFunction\n                        });\n                        createdCount++;\n                        console.log(`‚ûï Created: ${jobName}`);\n                    } catch (createError) {\n                        if (createError.response?.status === 409) {\n                            const conflictJobSearch = await takaro.cronjob.cronJobControllerSearch({\n                                filters: { name: [jobName] }\n                            });\n                            if (conflictJobSearch.data.data.length > 0) {\n                                await takaro.cronjob.cronJobControllerUpdate(\n                                    conflictJobSearch.data.data[0].id,\n                                    { name: jobName, temporalValue: job.temporalValue, function: jobFunction }\n                                );\n                                updatedCount++;\n                                console.log(`üìù Resolved conflict: ${jobName}`);\n                            } else {\n                                throw createError;\n                            }\n                        } else {\n                            throw createError;\n                        }\n                    }\n                }\n            } catch (error) {\n                console.log(`‚ùå Error with \"${jobName}\": ${error.message || \"Unknown error\"}`);\n                errorCount++;\n            }\n        }\n\n        // Server-scoped cleanup (only THIS server's orphans)\n        let cleanupCount = 0;\n        for (const existingJob of existingCronjobs) {\n            if (existingJob.name.startsWith(serverPrefix) && !processedJobs.has(existingJob.name)) {\n                try {\n                    await takaro.cronjob.cronJobControllerRemove(existingJob.id);\n                    cleanupCount++;\n                    console.log(`üóëÔ∏è Removed orphan: ${existingJob.name}`);\n                } catch (error) {\n                    console.log(`‚ùå Error removing \"${existingJob.name}\": ${error.message}`);\n                    errorCount++;\n                }\n            }\n        }\n\n        // Update state variables\n        try {\n            const hashVarSearch = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: [configHashKey],\n                    moduleId: [mod.moduleId],\n                    gameServerId: [gameServerId]\n                }\n            });\n\n            if (hashVarSearch.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(hashVarSearch.data.data[0].id, {\n                    value: currentConfigHash\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: configHashKey,\n                    value: currentConfigHash,\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n\n            const processedVarSearch = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: [lastProcessedKey],\n                    moduleId: [mod.moduleId],\n                    gameServerId: [gameServerId]\n                }\n            });\n\n            if (processedVarSearch.data.data.length > 0) {\n                await takaro.variable.variableControllerUpdate(processedVarSearch.data.data[0].id, {\n                    value: new Date().toISOString()\n                });\n            } else {\n                await takaro.variable.variableControllerCreate({\n                    key: lastProcessedKey,\n                    value: new Date().toISOString(),\n                    gameServerId,\n                    moduleId: mod.moduleId\n                });\n            }\n        } catch (stateError) {\n            console.log(`‚ö†Ô∏è Could not update state: ${stateError.message}`);\n        }\n\n        // Summary\n        console.log(`‚úÖ Completed for server ${serverShortId}:`);\n        if (createdCount > 0) console.log(`   ‚ûï ${createdCount} created`);\n        if (updatedCount > 0) console.log(`   üìù ${updatedCount} updated`);\n        if (cleanupCount > 0) console.log(`   üóëÔ∏è ${cleanupCount} orphans removed`);\n        if (errorCount > 0) console.log(`   ‚ùå ${errorCount} errors`);\n        if (createdCount === 0 && updatedCount === 0 && cleanupCount === 0) {\n            console.log(`   ‚úì No changes needed`);\n        }\n\n    } catch (error) {\n        console.log(`üí• Critical error: ${error.message}`);\n\n        try {\n            const backupSearch = await takaro.variable.variableControllerSearch({\n                filters: {\n                    key: [backupConfigKey],\n                    moduleId: [mod.moduleId],\n                    gameServerId: [gameServerId]\n                }\n            });\n\n            if (backupSearch.data.data.length > 0) {\n                const backup = JSON.parse(backupSearch.data.data[0].value);\n                console.log(`üîÑ Backup available from ${backup.timestamp}`);\n            }\n        } catch (backupError) {\n            console.log('‚ö†Ô∏è No backup available');\n        }\n\n        throw error;\n    }\n}\n\nawait main();",
          "name": "ServerMessagesGenerator",
          "description": null,
          "temporalValue": "5 4 * * *"
        }
      ],
      "functions": [],
      "permissions": []
    }
  ],
  "takaroVersion": "main"
}
