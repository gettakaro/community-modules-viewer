{
  "name": "Inactive Player Cleanup",
  "author": "Mad",
  "supportedGames": ["all"],
  "versions": [
    {
      "tag": "latest",
      "description": "Automatically removes players who haven't connected in a specified number of days. Processes players in batches and logs all activities to Discord.",
      "configSchema": "{\"type\":\"object\",\"properties\":{\"discordChannelId\":{\"type\":\"string\",\"title\":\"Discord Channel ID\",\"description\":\"The Discord channel ID where cleanup logs will be sent\"},\"inactivityDays\":{\"type\":\"number\",\"title\":\"Inactivity Days\",\"description\":\"Number of days of inactivity before a player is considered for deletion\",\"default\":90,\"minimum\":1},\"batchSize\":{\"type\":\"number\",\"title\":\"Batch Size\",\"description\":\"Number of players to process per cronjob execution\",\"default\":10,\"minimum\":1,\"maximum\":100},\"enabled\":{\"type\":\"boolean\",\"title\":\"Enable Cleanup\",\"description\":\"Master switch to enable/disable the cleanup process\",\"default\":false}},\"required\":[\"discordChannelId\"]}",
      "uiSchema": "{\"discordChannelId\":{\"ui:help\":\"Get this from Discord by right-clicking a channel and copying the ID\"}}",
      "commands": [],
      "hooks": [],
      "cronJobs": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n  const { gameServerId, module, cronjob } = data;\n  const moduleId = module.moduleId;\n  const discordChannelId = module.userConfig?.discordChannelId;\n  const inactivityDays = module.userConfig?.inactivityDays || 90;\n\n  await takaro.log.info('üöÄ Inactive Player Cleanup starting...');\n\n  async function getVar(key) {\n    try {\n      const varsRes = await takaro.variable.variableControllerSearch({\n        filters: {\n          key: [key],\n          moduleId: [moduleId],\n          gameServerId: [gameServerId]\n        }\n      });\n      return varsRes.data.data.length > 0 ? varsRes.data.data[0] : null;\n    } catch (error) {\n      await takaro.log.error(`Error getting variable ${key}: ${error.message}`);\n      return null;\n    }\n  }\n\n  async function updateVar(key, value) {\n    try {\n      const existing = await getVar(key);\n      if (existing) {\n        await takaro.variable.variableControllerUpdate(existing.id, { value: String(value) });\n      } else {\n        await takaro.variable.variableControllerCreate({\n          key,\n          value: String(value),\n          gameServerId,\n          moduleId\n        });\n      }\n    } catch (error) {\n      await takaro.log.error(`Error updating variable ${key}: ${error.message}`);\n    }\n  }\n\n  async function deleteAllVariables() {\n    try {\n      const varsRes = await takaro.variable.variableControllerSearch({\n        filters: {\n          moduleId: [moduleId],\n          gameServerId: [gameServerId]\n        }\n      });\n      \n      for (const variable of varsRes.data.data) {\n        await takaro.variable.variableControllerDelete(variable.id);\n      }\n      \n      await takaro.log.info(`üóëÔ∏è Deleted ${varsRes.data.data.length} cleanup variables`);\n    } catch (error) {\n      await takaro.log.error(`Error deleting variables: ${error.message}`);\n    }\n  }\n\n  const vars = {\n    phase: await getVar('cleanup_phase'),\n    playerIds: await getVar('inactive_player_ids'),\n    currentIndex: await getVar('current_processing_index'),\n    currentPage: await getVar('current_collection_page'),\n    mainCronjobId: await getVar('mainCronjobId'),\n    totalDeleted: await getVar('totalDeleted'),\n    totalProcessed: await getVar('totalProcessed'),\n    totalPlayers: await getVar('totalPlayers'),\n    startTime: await getVar('startTime')\n  };\n\n  const phase = vars.phase?.value || 'start';\n\n  let mainCronjobId = cronjob?.id;\n  if (!mainCronjobId) {\n    try {\n      const cronjobSearch = await takaro.cronjob.cronJobControllerSearch({\n        filters: { versionId: [module.versionId] }\n      });\n      const mainCronjob = cronjobSearch.data.data.find(cj => cj.name === 'Monthly Inactive Player Cleanup');\n      if (mainCronjob) {\n        mainCronjobId = mainCronjob.id;\n      }\n    } catch (e) {\n      await takaro.log.error(`Failed to find main cronjob: ${e.message}`);\n    }\n  }\n\n  if (mainCronjobId) {\n    await updateVar('mainCronjobId', mainCronjobId);\n  } else {\n    await takaro.log.error('Could not determine main cronjob ID');\n  }\n\n  if (phase === 'start') {\n    await takaro.log.info('üìã Phase 0: Initializing cleanup process');\n\n    const watchdogFunction = `\nimport { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n  const { gameServerId, module } = data;\n  const moduleId = module.moduleId;\n  const discordChannelId = module.userConfig?.discordChannelId;\n  \n  async function getVar(key) {\n    try {\n      const varsRes = await takaro.variable.variableControllerSearch({\n        filters: {\n          key: [key],\n          moduleId: [moduleId],\n          gameServerId: [gameServerId]\n        }\n      });\n      return varsRes.data.data.length > 0 ? varsRes.data.data[0] : null;\n    } catch (error) {\n      return null;\n    }\n  }\n  \n  const vars = {\n    phase: await getVar('cleanup_phase'),\n    lastUpdate: await getVar('cleanup_last_update'),\n    mainCronjobId: await getVar('mainCronjobId')\n  };\n  \n  const phase = vars.phase?.value;\n  const lastUpdateStr = vars.lastUpdate?.value;\n  const mainCronjobId = vars.mainCronjobId?.value;\n  \n  if (!phase || phase === 'complete' || !lastUpdateStr) {\n    await takaro.log.info('‚úÖ Watchdog: No active cleanup or already complete');\n    return;\n  }\n  \n  const lastUpdate = new Date(lastUpdateStr);\n  const now = new Date();\n  const minutesSinceUpdate = (now - lastUpdate) / (1000 * 60);\n  \n  if (minutesSinceUpdate > 10) {\n    await takaro.log.warn(\\\\\\`‚ö†Ô∏è Watchdog detected stalled cleanup (Phase: \\\\\\${phase}, Last update: \\\\\\${minutesSinceUpdate.toFixed(1)} minutes ago)\\\\\\`);\n    \n    if (!mainCronjobId) {\n      await takaro.log.error('‚ùå Watchdog Error: Cannot restart cleanup (missing cronjob ID)');\n      return;\n    }\n    \n    await takaro.log.info('üîÑ Watchdog restarting cleanup...');\n    \n    if (discordChannelId) {\n      try {\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n          message: \\\\\\`üîÑ Watchdog: Restarting Cleanup\\\\\\\\nThe cleanup process was restarted by the watchdog\\\\\\\\nReason: Stalled for \\\\\\${minutesSinceUpdate.toFixed(1)} minutes\\\\\\`\n        });\n      } catch (e) {\n        await takaro.log.error(\\\\\\`Discord notification failed: \\\\\\${e.message}\\\\\\`);\n      }\n    }\n    \n    await takaro.cronjob.cronJobControllerTrigger({\n      cronjobId: mainCronjobId,\n      gameServerId: gameServerId,\n      moduleId: moduleId\n    });\n  } else {\n    await takaro.log.info(\\\\\\`‚úÖ Watchdog: Cleanup progressing normally (Phase: \\\\\\${phase}, \\\\\\${minutesSinceUpdate.toFixed(1)} min ago)\\\\\\`);\n  }\n}\n\nawait main();\n    `.trim();\n\n    let watchdogCreated = false;\n    try {\n      const existingWatchdogSearch = await takaro.cronjob.cronJobControllerSearch({\n        filters: { name: ['Cleanup Watchdog'] }\n      });\n\n      if (existingWatchdogSearch.data.data.length > 0) {\n        const existingWatchdog = existingWatchdogSearch.data.data[0];\n        \n        if (existingWatchdog.versionId !== module.versionId) {\n          await takaro.log.info('üóëÔ∏è Removing old watchdog from previous version');\n          try {\n            await takaro.cronjob.cronJobControllerRemove(existingWatchdog.id);\n          } catch (deleteError) {\n            await takaro.log.warn(`Warning: Could not delete old watchdog: ${deleteError.message}`);\n            if (discordChannelId) {\n              try {\n                await takaro.discord.discordControllerSendMessage(discordChannelId, {\n                  message: `‚ö†Ô∏è Warning: Could not delete old watchdog`\n                });\n              } catch (e) {}\n            }\n          }\n          \n          await takaro.cronjob.cronJobControllerCreate({\n            name: 'Cleanup Watchdog',\n            temporalValue: '*/5 * * * *',\n            versionId: module.versionId,\n            function: watchdogFunction\n          });\n          await takaro.log.info('‚úÖ Watchdog created');\n          watchdogCreated = true;\n        } else {\n          try {\n            await takaro.cronjob.cronJobControllerUpdate(existingWatchdog.id, {\n              name: 'Cleanup Watchdog',\n              temporalValue: '*/5 * * * *',\n              function: watchdogFunction\n            });\n            await takaro.log.info('‚úÖ Watchdog updated');\n            watchdogCreated = true;\n          } catch (updateError) {\n            if (updateError.message?.includes('tagged version')) {\n              await takaro.log.warn('‚ö†Ô∏è Cannot update watchdog from tagged version, will use existing');\n              watchdogCreated = true;\n            } else {\n              throw updateError;\n            }\n          }\n        }\n      } else {\n        await takaro.cronjob.cronJobControllerCreate({\n          name: 'Cleanup Watchdog',\n          temporalValue: '*/5 * * * *',\n          versionId: module.versionId,\n          function: watchdogFunction\n        });\n        await takaro.log.info('‚úÖ Watchdog created');\n        watchdogCreated = true;\n      }\n    } catch (watchdogError) {\n      await takaro.log.warn(`Warning: Watchdog creation failed: ${watchdogError.message}`);\n      if (discordChannelId) {\n        try {\n          await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: `‚ö†Ô∏è Warning: Watchdog creation failed - cleanup will continue without watchdog protection`\n          });\n        } catch (e) {}\n      }\n    }\n\n    if (discordChannelId) {\n      try {\n        const watchdogStatus = watchdogCreated ? '‚úÖ Created' : '‚ö†Ô∏è Failed';\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n          message: `üßπ Inactive Player Cleanup Started\\nStarting cleanup of players inactive for more than ${inactivityDays} days\\nWatchdog: ${watchdogStatus}`\n        });\n      } catch (e) {\n        await takaro.log.error(`Discord message failed: ${e.message}`);\n      }\n    }\n\n    await updateVar('cleanup_phase', 'collecting');\n    await updateVar('inactive_player_ids', '[]');\n    await updateVar('current_collection_page', '0');\n    await updateVar('current_processing_index', '0');\n    await updateVar('totalDeleted', '0');\n    await updateVar('totalProcessed', '0');\n    await updateVar('totalPlayers', '0');\n    await updateVar('startTime', new Date().toISOString());\n    await updateVar('cleanup_last_update', new Date().toISOString());\n\n    await takaro.log.info('‚úÖ Initialization complete, starting collection phase...');\n\n    if (mainCronjobId) {\n      await takaro.cronjob.cronJobControllerTrigger({\n        cronjobId: mainCronjobId,\n        gameServerId: gameServerId,\n        moduleId: moduleId\n      });\n    } else {\n      await takaro.log.error('‚ùå Cannot trigger collecting phase: mainCronjobId not found');\n    }\n    return;\n  }\n\n  if (phase === 'collecting') {\n    const currentPage = parseInt(vars.currentPage?.value || '0', 10);\n    const collectedIdsStr = vars.playerIds?.value || '[]';\n    let collectedIds = JSON.parse(collectedIdsStr);\n    let totalPlayers = parseInt(vars.totalPlayers?.value || '0', 10);\n\n    await takaro.log.info(`üìä Phase 1: Collecting inactive player IDs (Page ${currentPage})`);\n\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - inactivityDays);\n\n    const mainCronjobId = vars.mainCronjobId?.value;\n\n    try {\n      const playersRes = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: { gameServerId: [gameServerId] },\n        sortBy: 'lastSeen',\n        sortDirection: 'asc',\n        limit: 100,\n        page: currentPage,\n        greaterThan: {},\n        lessThan: { lastSeen: cutoffDate.toISOString() }\n      });\n\n      const players = playersRes.data.data;\n      const newIds = players.map(p => p.playerId);\n      collectedIds = collectedIds.concat(newIds);\n\n      // Get total player count on first page\n      if (currentPage === 0) {\n        const totalPlayersRes = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n          filters: { gameServerId: [gameServerId] },\n          limit: 1\n        });\n        totalPlayers = totalPlayersRes.data.meta.total;\n        await updateVar('totalPlayers', String(totalPlayers));\n        await takaro.log.info(`üìä Total players on server: ${totalPlayers}`);\n      }\n\n      await takaro.log.info(`Found ${newIds.length} inactive players on page ${currentPage} (Total: ${collectedIds.length})`);\n\n      await updateVar('inactive_player_ids', JSON.stringify(collectedIds));\n      await updateVar('cleanup_last_update', new Date().toISOString());\n\n      if (players.length === 100) {\n        await updateVar('current_collection_page', String(currentPage + 1));\n        await takaro.log.info('üìÑ More pages to collect, triggering next collection...');\n\n        if (mainCronjobId) {\n          await takaro.cronjob.cronJobControllerTrigger({\n            cronjobId: mainCronjobId,\n            gameServerId: gameServerId,\n            moduleId: moduleId\n          });\n        }\n      } else {\n        await takaro.log.info(`‚úÖ Collection complete! Found ${collectedIds.length} total inactive players out of ${totalPlayers} total players`);\n        await updateVar('cleanup_phase', 'processing');\n        await updateVar('current_processing_index', '0');\n\n        if (mainCronjobId) {\n          await takaro.cronjob.cronJobControllerTrigger({\n            cronjobId: mainCronjobId,\n            gameServerId: gameServerId,\n            moduleId: moduleId\n          });\n        }\n      }\n    } catch (error) {\n      await takaro.log.error(`Error during collection: ${error.message}`);\n      throw error;\n    }\n\n    return;\n  }\n\n  if (phase === 'processing') {\n    const currentIndex = parseInt(vars.currentIndex?.value || '0', 10);\n    const collectedIdsStr = vars.playerIds?.value || '[]';\n    const collectedIds = JSON.parse(collectedIdsStr);\n    let totalDeleted = parseInt(vars.totalDeleted?.value || '0', 10);\n    let totalProcessed = parseInt(vars.totalProcessed?.value || '0', 10);\n    const totalPlayers = parseInt(vars.totalPlayers?.value || '0', 10);\n    const startTime = vars.startTime?.value;\n\n    if (collectedIds.length === 0) {\n      await takaro.log.info('‚úÖ No inactive players to process');\n      \n      const totalTime = startTime ? Math.floor((new Date() - new Date(startTime)) / 1000) : 0;\n      const minutes = Math.floor(totalTime / 60);\n      const seconds = totalTime % 60;\n      \n      try {\n        const watchdogSearch = await takaro.cronjob.cronJobControllerSearch({\n          filters: { \n            name: ['Cleanup Watchdog'],\n            versionId: [module.versionId]\n          }\n        });\n        if (watchdogSearch.data.data.length > 0) {\n          await takaro.cronjob.cronJobControllerRemove(watchdogSearch.data.data[0].id);\n          await takaro.log.info('üóëÔ∏è Watchdog deleted');\n        }\n      } catch (e) {\n        await takaro.log.warn(`Could not delete watchdog: ${e.message}`);\n      }\n      \n      if (discordChannelId) {\n        try {\n          await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: `‚úÖ Inactive Player Cleanup Complete\\n\\nTotal Players Scanned: ${totalPlayers}\\nInactive Players Found: 0\\nPlayers Deleted: 0\\nTotal Time: ${minutes}m ${seconds}s\\nWatchdog: üóëÔ∏è Removed`\n          });\n        } catch (e) {\n          await takaro.log.error(`Discord message failed: ${e.message}`);\n        }\n      }\n      \n      // Delete all variables to reset for next run\n      await deleteAllVariables();\n      \n      return;\n    }\n\n    await takaro.log.info(`üóëÔ∏è Phase 2: Processing inactive players (${currentIndex}/${collectedIds.length})`);\n\n    const batchSize = 5;\n    const endIndex = Math.min(currentIndex + batchSize, collectedIds.length);\n    const batch = collectedIds.slice(currentIndex, endIndex);\n\n    const deletedPlayers = [];\n    let successCount = 0;\n    let errorCount = 0;\n\n    for (const playerId of batch) {\n      try {\n        const playerRes = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, playerId);\n        const player = playerRes.data.data;\n        \n        await takaro.playerOnGameserver.playerOnGameServerControllerDelete(gameServerId, playerId);\n        \n        const lastSeen = new Date(player.lastSeen);\n        const now = new Date();\n        const daysInactive = Math.floor((now - lastSeen) / (1000 * 60 * 60 * 24));\n        \n        const playerName = player.player?.name || 'Unknown';\n        \n        deletedPlayers.push({\n          name: playerName,\n          daysInactive: daysInactive\n        });\n        \n        successCount++;\n        totalDeleted++;\n      } catch (error) {\n        await takaro.log.error(`Failed to remove player ${playerId}: ${error.message}`);\n        errorCount++\n      }\n      totalProcessed++;\n    }\n\n    await takaro.log.info(`‚úÖ Batch complete: ${successCount} removed, ${errorCount} errors`);\n    await updateVar('current_processing_index', String(endIndex));\n    await updateVar('totalDeleted', String(totalDeleted));\n    await updateVar('totalProcessed', String(totalProcessed));\n    await updateVar('cleanup_last_update', new Date().toISOString());\n\n    if (discordChannelId && deletedPlayers.length > 0) {\n      try {\n        let message = `Deleted Players (${deletedPlayers.length}):\\n`;\n        deletedPlayers.forEach(p => {\n          message += `‚Ä¢ ${p.name} - ${p.daysInactive} days inactive\\n`;\n        });\n        message += `\\nProgress: ${totalProcessed} of ${collectedIds.length} inactive players processed, ${totalDeleted} deleted`;\n        \n        await takaro.discord.discordControllerSendMessage(discordChannelId, { message });\n      } catch (discordError) {\n        await takaro.log.error(`Discord notification failed: ${discordError.message}`);\n      }\n    }\n\n    const mainCronjobId = vars.mainCronjobId?.value;\n\n    if (endIndex < collectedIds.length) {\n      await takaro.log.info(`üìä Progress: ${endIndex}/${collectedIds.length} (${((endIndex / collectedIds.length) * 100).toFixed(1)}%)`);\n\n      if (mainCronjobId) {\n        await takaro.cronjob.cronJobControllerTrigger({\n          cronjobId: mainCronjobId,\n          gameServerId: gameServerId,\n          moduleId: moduleId\n        });\n      }\n    } else {\n      await takaro.log.info(`üéâ Cleanup complete! Processed ${collectedIds.length} inactive players out of ${totalPlayers} total players`);\n      \n      const startTime = vars.startTime?.value;\n      const totalTime = startTime ? Math.floor((new Date() - new Date(startTime)) / 1000) : 0;\n      const minutes = Math.floor(totalTime / 60);\n      const seconds = totalTime % 60;\n      \n      try {\n        const watchdogSearch = await takaro.cronjob.cronJobControllerSearch({\n          filters: { \n            name: ['Cleanup Watchdog'],\n            versionId: [module.versionId]\n          }\n        });\n        if (watchdogSearch.data.data.length > 0) {\n          await takaro.cronjob.cronJobControllerRemove(watchdogSearch.data.data[0].id);\n          await takaro.log.info('üóëÔ∏è Watchdog deleted');\n        }\n      } catch (e) {\n        await takaro.log.warn(`Could not delete watchdog: ${e.message}`);\n      }\n      \n      if (discordChannelId) {\n        try {\n          await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: `‚úÖ Inactive Player Cleanup Complete\\n\\nTotal Players Scanned: ${totalPlayers}\\nInactive Players Found: ${collectedIds.length}\\nPlayers Deleted: ${totalDeleted}\\nTotal Time: ${minutes}m ${seconds}s\\nWatchdog: üóëÔ∏è Removed`\n          });\n        } catch (e) {\n          await takaro.log.error(`Discord message failed: ${e.message}`);\n        }\n      }\n      \n      // Delete all variables to reset for next run\n      await deleteAllVariables();\n    }\n\n    return;\n  }\n\n  if (phase === 'complete') {\n    await takaro.log.info('‚úÖ Cleanup already complete - resetting for next run');\n    \n    // Clean up any leftover watchdog\n    try {\n      const watchdogSearch = await takaro.cronjob.cronJobControllerSearch({\n        filters: { \n          name: ['Cleanup Watchdog'],\n          versionId: [module.versionId]\n        }\n      });\n      if (watchdogSearch.data.data.length > 0) {\n        await takaro.cronjob.cronJobControllerRemove(watchdogSearch.data.data[0].id);\n        await takaro.log.info('üóëÔ∏è Watchdog deleted (cleanup)');\n      }\n    } catch (e) {\n      await takaro.log.warn(`Could not delete watchdog: ${e.message}`);\n    }\n    \n    // Send notification that we're resetting\n    if (discordChannelId) {\n      try {\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n          message: `‚ÑπÔ∏è Inactive Player Cleanup\\n\\nCleanup was already complete. Resetting state for next run.\\nThe next scheduled cleanup will run normally.`\n        });\n      } catch (e) {\n        await takaro.log.error(`Discord message failed: ${e.message}`);\n      }\n    }\n    \n    // Delete all variables to reset for next run\n    await deleteAllVariables();\n    \n    return;\n  }\n\n  await takaro.log.error(`Unknown phase: ${phase}`);\n}\n\nawait main();",
          "name": "Monthly Inactive Player Cleanup",
          "description": "Runs monthly to clean up inactive players. Processes in batches of 10 and self-triggers until all players are checked.",
          "temporalValue": "0 0 1 * *"
        },
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n  const { gameServerId, module } = data;\n  const moduleId = module.moduleId;\n  const discordChannelId = module.userConfig?.discordChannelId;\n  \n  async function getVar(key) {\n    try {\n      const varsRes = await takaro.variable.variableControllerSearch({\n        filters: {\n          key: [key],\n          moduleId: [moduleId],\n          gameServerId: [gameServerId]\n        }\n      });\n      return varsRes.data.data.length > 0 ? varsRes.data.data[0] : null;\n    } catch (error) {\n      return null;\n    }\n  }\n  \n  const vars = {\n    phase: await getVar('cleanup_phase'),\n    lastUpdate: await getVar('cleanup_last_update'),\n    mainCronjobId: await getVar('mainCronjobId')\n  };\n  \n  const phase = vars.phase?.value;\n  const lastUpdateStr = vars.lastUpdate?.value;\n  const mainCronjobId = vars.mainCronjobId?.value;\n  \n  if (!phase || phase === 'complete' || !lastUpdateStr) {\n    await takaro.log.info('‚úÖ Watchdog: No active cleanup or already complete');\n    return;\n  }\n  \n  const lastUpdate = new Date(lastUpdateStr);\n  const now = new Date();\n  const minutesSinceUpdate = (now - lastUpdate) / (1000 * 60);\n  \n  if (minutesSinceUpdate > 10) {\n    await takaro.log.warn(\\`‚ö†Ô∏è Watchdog detected stalled cleanup (Phase: \\${phase}, Last update: \\${minutesSinceUpdate.toFixed(1)} minutes ago)\\`);\n    \n    if (!mainCronjobId) {\n      await takaro.log.error('‚ùå Watchdog Error: Cannot restart cleanup (missing cronjob ID)');\n      return;\n    }\n    \n    await takaro.log.info('üîÑ Watchdog restarting cleanup...');\n    \n    if (discordChannelId) {\n      try {\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n          message: \\`üîÑ Watchdog: Restarting Cleanup\\\\nThe cleanup process was restarted by the watchdog\\\\nReason: Stalled for \\${minutesSinceUpdate.toFixed(1)} minutes\\`\n        });\n      } catch (e) {\n        await takaro.log.error(\\`Discord notification failed: \\${e.message}\\`);\n      }\n    }\n    \n    await takaro.cronjob.cronJobControllerTrigger({\n      cronjobId: mainCronjobId,\n      gameServerId: gameServerId,\n      moduleId: moduleId\n    });\n  } else {\n    await takaro.log.info(\\`‚úÖ Watchdog: Cleanup progressing normally (Phase: \\${phase}, \\${minutesSinceUpdate.toFixed(1)} min ago)\\`);\n  }\n}\n\nawait main();",
          "name": "Cleanup Watchdog",
          "description": null,
          "temporalValue": "*/5 * * * *"
        }
      ],
      "functions": [
        {
          "function": "import { data, takaro } from '@takaro/helpers';\n\nasync function main() {\n  const { gameServerId, module } = data;\n  const moduleId = module.moduleId;\n  const discordChannelId = module.userConfig.discordChannelId;\n  \n  // Get cleanup state variables\n  const varsRes = await takaro.variable.variableControllerSearch({\n    filters: { moduleId: [moduleId], gameServerId: [gameServerId] }\n  });\n  \n  const vars = {};\n  varsRes.data.data.forEach(v => {\n    vars[v.key] = v;\n  });\n  \n  const inProgress = vars.cleanupInProgress?.value === 'true';\n  \n  if (!inProgress) {\n    // Cleanup is not running, watchdog no longer needed\n    await takaro.log.info('Cleanup not in progress, watchdog will be removed by main cleanup');\n    return;\n  }\n  \n  const lastExecutionTime = vars.lastExecutionTime?.value;\n  \n  if (!lastExecutionTime) {\n    // First run, no last execution time yet\n    await takaro.log.info('No lastExecutionTime found, skipping watchdog check');\n    return;\n  }\n  \n  const lastExecution = new Date(lastExecutionTime);\n  const now = new Date();\n  const minutesSinceLastRun = (now.getTime() - lastExecution.getTime()) / 1000 / 60;\n  \n  await takaro.log.info(`Minutes since last cleanup execution: ${minutesSinceLastRun.toFixed(2)}`);\n  \n  if (minutesSinceLastRun > 2) {\n    // Cleanup is stalled, restart it\n    await takaro.log.info('Cleanup appears stalled, triggering restart');\n    \n    try {\n      await takaro.discord.discordControllerSendMessage(discordChannelId, {\n        message: `üîÑ Watchdog: Restarting Cleanup\\nThe cleanup process was restarted by the watchdog\\nReason: Stalled for ${minutesSinceLastRun.toFixed(1)} minutes`\n      });\n    } catch (e) {\n      await takaro.log.error(`Discord notification failed: ${e.message}`);\n    }\n    \n    // Get the main cronjob ID from variables\n    const mainCronjobId = vars.mainCronjobId?.value;\n    \n    if (!mainCronjobId) {\n      await takaro.log.error('mainCronjobId not found in variables, cannot restart cleanup');\n      await takaro.discord.discordControllerSendMessage(discordChannelId, {\n        message: '‚ùå Watchdog Error: Cannot restart cleanup (missing cronjob ID)'\n      });\n      return;\n    }\n    \n    // Trigger the main cleanup cronjob using dynamic ID\n    await takaro.cronjob.cronJobControllerTrigger({\n      cronjobId: mainCronjobId,\n      gameServerId: gameServerId,\n      moduleId: moduleId\n    });\n    \n    await takaro.log.info('Cleanup restarted by watchdog');\n  } else {\n    await takaro.log.info('Cleanup is running normally');\n  }\n}\n\nawait main();",
          "name": "watchdog",
          "description": null
        }
      ],
      "permissions": []
    },
    {
      "tag": "1.0.15",
      "description": "Automatically removes players who haven't connected in a specified number of days. Processes players in batches and logs all activities to Discord.",
      "configSchema": "{\"type\":\"object\",\"properties\":{\"discordChannelId\":{\"type\":\"string\",\"title\":\"Discord Channel ID\",\"description\":\"The Discord channel ID where cleanup logs will be sent\"},\"inactivityDays\":{\"type\":\"number\",\"title\":\"Inactivity Days\",\"description\":\"Number of days of inactivity before a player is considered for deletion\",\"default\":90,\"minimum\":1},\"batchSize\":{\"type\":\"number\",\"title\":\"Batch Size\",\"description\":\"Number of players to process per cronjob execution\",\"default\":10,\"minimum\":1,\"maximum\":100},\"enabled\":{\"type\":\"boolean\",\"title\":\"Enable Cleanup\",\"description\":\"Master switch to enable/disable the cleanup process\",\"default\":false}},\"required\":[\"discordChannelId\"]}",
      "uiSchema": "{\"discordChannelId\":{\"ui:help\":\"Get this from Discord by right-clicking a channel and copying the ID\"}}",
      "commands": [],
      "hooks": [],
      "cronJobs": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n  const { gameServerId, module, cronjob } = data;\n  const moduleId = module.moduleId;\n  const discordChannelId = module.userConfig?.discordChannelId;\n  const inactivityDays = module.userConfig?.inactivityDays || 90;\n\n  await takaro.log.info('üöÄ Inactive Player Cleanup starting...');\n\n  async function getVar(key) {\n    try {\n      const varsRes = await takaro.variable.variableControllerSearch({\n        filters: {\n          key: [key],\n          moduleId: [moduleId],\n          gameServerId: [gameServerId]\n        }\n      });\n      return varsRes.data.data.length > 0 ? varsRes.data.data[0] : null;\n    } catch (error) {\n      await takaro.log.error(`Error getting variable ${key}: ${error.message}`);\n      return null;\n    }\n  }\n\n  async function updateVar(key, value) {\n    try {\n      const existing = await getVar(key);\n      if (existing) {\n        await takaro.variable.variableControllerUpdate(existing.id, { value: String(value) });\n      } else {\n        await takaro.variable.variableControllerCreate({\n          key,\n          value: String(value),\n          gameServerId,\n          moduleId\n        });\n      }\n    } catch (error) {\n      await takaro.log.error(`Error updating variable ${key}: ${error.message}`);\n    }\n  }\n\n  async function deleteAllVariables() {\n    try {\n      const varsRes = await takaro.variable.variableControllerSearch({\n        filters: {\n          moduleId: [moduleId],\n          gameServerId: [gameServerId]\n        }\n      });\n      \n      for (const variable of varsRes.data.data) {\n        await takaro.variable.variableControllerDelete(variable.id);\n      }\n      \n      await takaro.log.info(`üóëÔ∏è Deleted ${varsRes.data.data.length} cleanup variables`);\n    } catch (error) {\n      await takaro.log.error(`Error deleting variables: ${error.message}`);\n    }\n  }\n\n  const vars = {\n    phase: await getVar('cleanup_phase'),\n    playerIds: await getVar('inactive_player_ids'),\n    currentIndex: await getVar('current_processing_index'),\n    currentPage: await getVar('current_collection_page'),\n    mainCronjobId: await getVar('mainCronjobId'),\n    totalDeleted: await getVar('totalDeleted'),\n    totalProcessed: await getVar('totalProcessed'),\n    totalPlayers: await getVar('totalPlayers'),\n    startTime: await getVar('startTime')\n  };\n\n  const phase = vars.phase?.value || 'start';\n\n  let mainCronjobId = cronjob?.id;\n  if (!mainCronjobId) {\n    try {\n      const cronjobSearch = await takaro.cronjob.cronJobControllerSearch({\n        filters: { versionId: [module.versionId] }\n      });\n      const mainCronjob = cronjobSearch.data.data.find(cj => cj.name === 'Monthly Inactive Player Cleanup');\n      if (mainCronjob) {\n        mainCronjobId = mainCronjob.id;\n      }\n    } catch (e) {\n      await takaro.log.error(`Failed to find main cronjob: ${e.message}`);\n    }\n  }\n\n  if (mainCronjobId) {\n    await updateVar('mainCronjobId', mainCronjobId);\n  } else {\n    await takaro.log.error('Could not determine main cronjob ID');\n  }\n\n  if (phase === 'start') {\n    await takaro.log.info('üìã Phase 0: Initializing cleanup process');\n\n    const watchdogFunction = `\nimport { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n  const { gameServerId, module } = data;\n  const moduleId = module.moduleId;\n  const discordChannelId = module.userConfig?.discordChannelId;\n  \n  async function getVar(key) {\n    try {\n      const varsRes = await takaro.variable.variableControllerSearch({\n        filters: {\n          key: [key],\n          moduleId: [moduleId],\n          gameServerId: [gameServerId]\n        }\n      });\n      return varsRes.data.data.length > 0 ? varsRes.data.data[0] : null;\n    } catch (error) {\n      return null;\n    }\n  }\n  \n  const vars = {\n    phase: await getVar('cleanup_phase'),\n    lastUpdate: await getVar('cleanup_last_update'),\n    mainCronjobId: await getVar('mainCronjobId')\n  };\n  \n  const phase = vars.phase?.value;\n  const lastUpdateStr = vars.lastUpdate?.value;\n  const mainCronjobId = vars.mainCronjobId?.value;\n  \n  if (!phase || phase === 'complete' || !lastUpdateStr) {\n    await takaro.log.info('‚úÖ Watchdog: No active cleanup or already complete');\n    return;\n  }\n  \n  const lastUpdate = new Date(lastUpdateStr);\n  const now = new Date();\n  const minutesSinceUpdate = (now - lastUpdate) / (1000 * 60);\n  \n  if (minutesSinceUpdate > 10) {\n    await takaro.log.warn(\\\\\\`‚ö†Ô∏è Watchdog detected stalled cleanup (Phase: \\\\\\${phase}, Last update: \\\\\\${minutesSinceUpdate.toFixed(1)} minutes ago)\\\\\\`);\n    \n    if (!mainCronjobId) {\n      await takaro.log.error('‚ùå Watchdog Error: Cannot restart cleanup (missing cronjob ID)');\n      return;\n    }\n    \n    await takaro.log.info('üîÑ Watchdog restarting cleanup...');\n    \n    if (discordChannelId) {\n      try {\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n          message: \\\\\\`üîÑ Watchdog: Restarting Cleanup\\\\\\\\nThe cleanup process was restarted by the watchdog\\\\\\\\nReason: Stalled for \\\\\\${minutesSinceUpdate.toFixed(1)} minutes\\\\\\`\n        });\n      } catch (e) {\n        await takaro.log.error(\\\\\\`Discord notification failed: \\\\\\${e.message}\\\\\\`);\n      }\n    }\n    \n    await takaro.cronjob.cronJobControllerTrigger({\n      cronjobId: mainCronjobId,\n      gameServerId: gameServerId,\n      moduleId: moduleId\n    });\n  } else {\n    await takaro.log.info(\\\\\\`‚úÖ Watchdog: Cleanup progressing normally (Phase: \\\\\\${phase}, \\\\\\${minutesSinceUpdate.toFixed(1)} min ago)\\\\\\`);\n  }\n}\n\nawait main();\n    `.trim();\n\n    let watchdogCreated = false;\n    try {\n      const existingWatchdogSearch = await takaro.cronjob.cronJobControllerSearch({\n        filters: { name: ['Cleanup Watchdog'] }\n      });\n\n      if (existingWatchdogSearch.data.data.length > 0) {\n        const existingWatchdog = existingWatchdogSearch.data.data[0];\n        \n        if (existingWatchdog.versionId !== module.versionId) {\n          await takaro.log.info('üóëÔ∏è Removing old watchdog from previous version');\n          try {\n            await takaro.cronjob.cronJobControllerRemove(existingWatchdog.id);\n          } catch (deleteError) {\n            await takaro.log.warn(`Warning: Could not delete old watchdog: ${deleteError.message}`);\n            if (discordChannelId) {\n              try {\n                await takaro.discord.discordControllerSendMessage(discordChannelId, {\n                  message: `‚ö†Ô∏è Warning: Could not delete old watchdog`\n                });\n              } catch (e) {}\n            }\n          }\n          \n          await takaro.cronjob.cronJobControllerCreate({\n            name: 'Cleanup Watchdog',\n            temporalValue: '*/5 * * * *',\n            versionId: module.versionId,\n            function: watchdogFunction\n          });\n          await takaro.log.info('‚úÖ Watchdog created');\n          watchdogCreated = true;\n        } else {\n          try {\n            await takaro.cronjob.cronJobControllerUpdate(existingWatchdog.id, {\n              name: 'Cleanup Watchdog',\n              temporalValue: '*/5 * * * *',\n              function: watchdogFunction\n            });\n            await takaro.log.info('‚úÖ Watchdog updated');\n            watchdogCreated = true;\n          } catch (updateError) {\n            if (updateError.message?.includes('tagged version')) {\n              await takaro.log.warn('‚ö†Ô∏è Cannot update watchdog from tagged version, will use existing');\n              watchdogCreated = true;\n            } else {\n              throw updateError;\n            }\n          }\n        }\n      } else {\n        await takaro.cronjob.cronJobControllerCreate({\n          name: 'Cleanup Watchdog',\n          temporalValue: '*/5 * * * *',\n          versionId: module.versionId,\n          function: watchdogFunction\n        });\n        await takaro.log.info('‚úÖ Watchdog created');\n        watchdogCreated = true;\n      }\n    } catch (watchdogError) {\n      await takaro.log.warn(`Warning: Watchdog creation failed: ${watchdogError.message}`);\n      if (discordChannelId) {\n        try {\n          await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: `‚ö†Ô∏è Warning: Watchdog creation failed - cleanup will continue without watchdog protection`\n          });\n        } catch (e) {}\n      }\n    }\n\n    if (discordChannelId) {\n      try {\n        const watchdogStatus = watchdogCreated ? '‚úÖ Created' : '‚ö†Ô∏è Failed';\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n          message: `üßπ Inactive Player Cleanup Started\\nStarting cleanup of players inactive for more than ${inactivityDays} days\\nWatchdog: ${watchdogStatus}`\n        });\n      } catch (e) {\n        await takaro.log.error(`Discord message failed: ${e.message}`);\n      }\n    }\n\n    await updateVar('cleanup_phase', 'collecting');\n    await updateVar('inactive_player_ids', '[]');\n    await updateVar('current_collection_page', '0');\n    await updateVar('current_processing_index', '0');\n    await updateVar('totalDeleted', '0');\n    await updateVar('totalProcessed', '0');\n    await updateVar('totalPlayers', '0');\n    await updateVar('startTime', new Date().toISOString());\n    await updateVar('cleanup_last_update', new Date().toISOString());\n\n    await takaro.log.info('‚úÖ Initialization complete, starting collection phase...');\n\n    if (mainCronjobId) {\n      await takaro.cronjob.cronJobControllerTrigger({\n        cronjobId: mainCronjobId,\n        gameServerId: gameServerId,\n        moduleId: moduleId\n      });\n    } else {\n      await takaro.log.error('‚ùå Cannot trigger collecting phase: mainCronjobId not found');\n    }\n    return;\n  }\n\n  if (phase === 'collecting') {\n    const currentPage = parseInt(vars.currentPage?.value || '0', 10);\n    const collectedIdsStr = vars.playerIds?.value || '[]';\n    let collectedIds = JSON.parse(collectedIdsStr);\n    let totalPlayers = parseInt(vars.totalPlayers?.value || '0', 10);\n\n    await takaro.log.info(`üìä Phase 1: Collecting inactive player IDs (Page ${currentPage})`);\n\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - inactivityDays);\n\n    const mainCronjobId = vars.mainCronjobId?.value;\n\n    try {\n      const playersRes = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n        filters: { gameServerId: [gameServerId] },\n        sortBy: 'lastSeen',\n        sortDirection: 'asc',\n        limit: 100,\n        page: currentPage,\n        greaterThan: {},\n        lessThan: { lastSeen: cutoffDate.toISOString() }\n      });\n\n      const players = playersRes.data.data;\n      const newIds = players.map(p => p.playerId);\n      collectedIds = collectedIds.concat(newIds);\n\n      // Get total player count on first page\n      if (currentPage === 0) {\n        const totalPlayersRes = await takaro.playerOnGameserver.playerOnGameServerControllerSearch({\n          filters: { gameServerId: [gameServerId] },\n          limit: 1\n        });\n        totalPlayers = totalPlayersRes.data.meta.total;\n        await updateVar('totalPlayers', String(totalPlayers));\n        await takaro.log.info(`üìä Total players on server: ${totalPlayers}`);\n      }\n\n      await takaro.log.info(`Found ${newIds.length} inactive players on page ${currentPage} (Total: ${collectedIds.length})`);\n\n      await updateVar('inactive_player_ids', JSON.stringify(collectedIds));\n      await updateVar('cleanup_last_update', new Date().toISOString());\n\n      if (players.length === 100) {\n        await updateVar('current_collection_page', String(currentPage + 1));\n        await takaro.log.info('üìÑ More pages to collect, triggering next collection...');\n\n        if (mainCronjobId) {\n          await takaro.cronjob.cronJobControllerTrigger({\n            cronjobId: mainCronjobId,\n            gameServerId: gameServerId,\n            moduleId: moduleId\n          });\n        }\n      } else {\n        await takaro.log.info(`‚úÖ Collection complete! Found ${collectedIds.length} total inactive players out of ${totalPlayers} total players`);\n        await updateVar('cleanup_phase', 'processing');\n        await updateVar('current_processing_index', '0');\n\n        if (mainCronjobId) {\n          await takaro.cronjob.cronJobControllerTrigger({\n            cronjobId: mainCronjobId,\n            gameServerId: gameServerId,\n            moduleId: moduleId\n          });\n        }\n      }\n    } catch (error) {\n      await takaro.log.error(`Error during collection: ${error.message}`);\n      throw error;\n    }\n\n    return;\n  }\n\n  if (phase === 'processing') {\n    const currentIndex = parseInt(vars.currentIndex?.value || '0', 10);\n    const collectedIdsStr = vars.playerIds?.value || '[]';\n    const collectedIds = JSON.parse(collectedIdsStr);\n    let totalDeleted = parseInt(vars.totalDeleted?.value || '0', 10);\n    let totalProcessed = parseInt(vars.totalProcessed?.value || '0', 10);\n    const totalPlayers = parseInt(vars.totalPlayers?.value || '0', 10);\n    const startTime = vars.startTime?.value;\n\n    if (collectedIds.length === 0) {\n      await takaro.log.info('‚úÖ No inactive players to process');\n      \n      const totalTime = startTime ? Math.floor((new Date() - new Date(startTime)) / 1000) : 0;\n      const minutes = Math.floor(totalTime / 60);\n      const seconds = totalTime % 60;\n      \n      try {\n        const watchdogSearch = await takaro.cronjob.cronJobControllerSearch({\n          filters: { \n            name: ['Cleanup Watchdog'],\n            versionId: [module.versionId]\n          }\n        });\n        if (watchdogSearch.data.data.length > 0) {\n          await takaro.cronjob.cronJobControllerRemove(watchdogSearch.data.data[0].id);\n          await takaro.log.info('üóëÔ∏è Watchdog deleted');\n        }\n      } catch (e) {\n        await takaro.log.warn(`Could not delete watchdog: ${e.message}`);\n      }\n      \n      if (discordChannelId) {\n        try {\n          await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: `‚úÖ Inactive Player Cleanup Complete\\n\\nTotal Players Scanned: ${totalPlayers}\\nInactive Players Found: 0\\nPlayers Deleted: 0\\nTotal Time: ${minutes}m ${seconds}s\\nWatchdog: üóëÔ∏è Removed`\n          });\n        } catch (e) {\n          await takaro.log.error(`Discord message failed: ${e.message}`);\n        }\n      }\n      \n      // Delete all variables to reset for next run\n      await deleteAllVariables();\n      \n      return;\n    }\n\n    await takaro.log.info(`üóëÔ∏è Phase 2: Processing inactive players (${currentIndex}/${collectedIds.length})`);\n\n    const batchSize = 5;\n    const endIndex = Math.min(currentIndex + batchSize, collectedIds.length);\n    const batch = collectedIds.slice(currentIndex, endIndex);\n\n    const deletedPlayers = [];\n    let successCount = 0;\n    let errorCount = 0;\n\n    for (const playerId of batch) {\n      try {\n        const playerRes = await takaro.playerOnGameserver.playerOnGameServerControllerGetOne(gameServerId, playerId);\n        const player = playerRes.data.data;\n        \n        await takaro.playerOnGameserver.playerOnGameServerControllerDelete(gameServerId, playerId);\n        \n        const lastSeen = new Date(player.lastSeen);\n        const now = new Date();\n        const daysInactive = Math.floor((now - lastSeen) / (1000 * 60 * 60 * 24));\n        \n        const playerName = player.player?.name || 'Unknown';\n        \n        deletedPlayers.push({\n          name: playerName,\n          daysInactive: daysInactive\n        });\n        \n        successCount++;\n        totalDeleted++;\n      } catch (error) {\n        await takaro.log.error(`Failed to remove player ${playerId}: ${error.message}`);\n        errorCount++\n      }\n      totalProcessed++;\n    }\n\n    await takaro.log.info(`‚úÖ Batch complete: ${successCount} removed, ${errorCount} errors`);\n    await updateVar('current_processing_index', String(endIndex));\n    await updateVar('totalDeleted', String(totalDeleted));\n    await updateVar('totalProcessed', String(totalProcessed));\n    await updateVar('cleanup_last_update', new Date().toISOString());\n\n    if (discordChannelId && deletedPlayers.length > 0) {\n      try {\n        let message = `Deleted Players (${deletedPlayers.length}):\\n`;\n        deletedPlayers.forEach(p => {\n          message += `‚Ä¢ ${p.name} - ${p.daysInactive} days inactive\\n`;\n        });\n        message += `\\nProgress: ${totalProcessed} of ${collectedIds.length} inactive players processed, ${totalDeleted} deleted`;\n        \n        await takaro.discord.discordControllerSendMessage(discordChannelId, { message });\n      } catch (discordError) {\n        await takaro.log.error(`Discord notification failed: ${discordError.message}`);\n      }\n    }\n\n    const mainCronjobId = vars.mainCronjobId?.value;\n\n    if (endIndex < collectedIds.length) {\n      await takaro.log.info(`üìä Progress: ${endIndex}/${collectedIds.length} (${((endIndex / collectedIds.length) * 100).toFixed(1)}%)`);\n\n      if (mainCronjobId) {\n        await takaro.cronjob.cronJobControllerTrigger({\n          cronjobId: mainCronjobId,\n          gameServerId: gameServerId,\n          moduleId: moduleId\n        });\n      }\n    } else {\n      await takaro.log.info(`üéâ Cleanup complete! Processed ${collectedIds.length} inactive players out of ${totalPlayers} total players`);\n      \n      const startTime = vars.startTime?.value;\n      const totalTime = startTime ? Math.floor((new Date() - new Date(startTime)) / 1000) : 0;\n      const minutes = Math.floor(totalTime / 60);\n      const seconds = totalTime % 60;\n      \n      try {\n        const watchdogSearch = await takaro.cronjob.cronJobControllerSearch({\n          filters: { \n            name: ['Cleanup Watchdog'],\n            versionId: [module.versionId]\n          }\n        });\n        if (watchdogSearch.data.data.length > 0) {\n          await takaro.cronjob.cronJobControllerRemove(watchdogSearch.data.data[0].id);\n          await takaro.log.info('üóëÔ∏è Watchdog deleted');\n        }\n      } catch (e) {\n        await takaro.log.warn(`Could not delete watchdog: ${e.message}`);\n      }\n      \n      if (discordChannelId) {\n        try {\n          await takaro.discord.discordControllerSendMessage(discordChannelId, {\n            message: `‚úÖ Inactive Player Cleanup Complete\\n\\nTotal Players Scanned: ${totalPlayers}\\nInactive Players Found: ${collectedIds.length}\\nPlayers Deleted: ${totalDeleted}\\nTotal Time: ${minutes}m ${seconds}s\\nWatchdog: üóëÔ∏è Removed`\n          });\n        } catch (e) {\n          await takaro.log.error(`Discord message failed: ${e.message}`);\n        }\n      }\n      \n      // Delete all variables to reset for next run\n      await deleteAllVariables();\n    }\n\n    return;\n  }\n\n  if (phase === 'complete') {\n    await takaro.log.info('‚úÖ Cleanup already complete - resetting for next run');\n    \n    // Clean up any leftover watchdog\n    try {\n      const watchdogSearch = await takaro.cronjob.cronJobControllerSearch({\n        filters: { \n          name: ['Cleanup Watchdog'],\n          versionId: [module.versionId]\n        }\n      });\n      if (watchdogSearch.data.data.length > 0) {\n        await takaro.cronjob.cronJobControllerRemove(watchdogSearch.data.data[0].id);\n        await takaro.log.info('üóëÔ∏è Watchdog deleted (cleanup)');\n      }\n    } catch (e) {\n      await takaro.log.warn(`Could not delete watchdog: ${e.message}`);\n    }\n    \n    // Send notification that we're resetting\n    if (discordChannelId) {\n      try {\n        await takaro.discord.discordControllerSendMessage(discordChannelId, {\n          message: `‚ÑπÔ∏è Inactive Player Cleanup\\n\\nCleanup was already complete. Resetting state for next run.\\nThe next scheduled cleanup will run normally.`\n        });\n      } catch (e) {\n        await takaro.log.error(`Discord message failed: ${e.message}`);\n      }\n    }\n    \n    // Delete all variables to reset for next run\n    await deleteAllVariables();\n    \n    return;\n  }\n\n  await takaro.log.error(`Unknown phase: ${phase}`);\n}\n\nawait main();",
          "name": "Monthly Inactive Player Cleanup",
          "description": null,
          "temporalValue": "0 0 1 * *"
        }
      ],
      "functions": [
        {
          "function": "import { data, takaro } from '@takaro/helpers';\n\nasync function main() {\n  const { gameServerId, module } = data;\n  const moduleId = module.moduleId;\n  const discordChannelId = module.userConfig.discordChannelId;\n  \n  // Get cleanup state variables\n  const varsRes = await takaro.variable.variableControllerSearch({\n    filters: { moduleId: [moduleId], gameServerId: [gameServerId] }\n  });\n  \n  const vars = {};\n  varsRes.data.data.forEach(v => {\n    vars[v.key] = v;\n  });\n  \n  const inProgress = vars.cleanupInProgress?.value === 'true';\n  \n  if (!inProgress) {\n    // Cleanup is not running, watchdog no longer needed\n    await takaro.log.info('Cleanup not in progress, watchdog will be removed by main cleanup');\n    return;\n  }\n  \n  const lastExecutionTime = vars.lastExecutionTime?.value;\n  \n  if (!lastExecutionTime) {\n    // First run, no last execution time yet\n    await takaro.log.info('No lastExecutionTime found, skipping watchdog check');\n    return;\n  }\n  \n  const lastExecution = new Date(lastExecutionTime);\n  const now = new Date();\n  const minutesSinceLastRun = (now.getTime() - lastExecution.getTime()) / 1000 / 60;\n  \n  await takaro.log.info(`Minutes since last cleanup execution: ${minutesSinceLastRun.toFixed(2)}`);\n  \n  if (minutesSinceLastRun > 2) {\n    // Cleanup is stalled, restart it\n    await takaro.log.info('Cleanup appears stalled, triggering restart');\n    \n    try {\n      await takaro.discord.discordControllerSendMessage(discordChannelId, {\n        message: `üîÑ Watchdog: Restarting Cleanup\\nThe cleanup process was restarted by the watchdog\\nReason: Stalled for ${minutesSinceLastRun.toFixed(1)} minutes`\n      });\n    } catch (e) {\n      await takaro.log.error(`Discord notification failed: ${e.message}`);\n    }\n    \n    // Get the main cronjob ID from variables\n    const mainCronjobId = vars.mainCronjobId?.value;\n    \n    if (!mainCronjobId) {\n      await takaro.log.error('mainCronjobId not found in variables, cannot restart cleanup');\n      await takaro.discord.discordControllerSendMessage(discordChannelId, {\n        message: '‚ùå Watchdog Error: Cannot restart cleanup (missing cronjob ID)'\n      });\n      return;\n    }\n    \n    // Trigger the main cleanup cronjob using dynamic ID\n    await takaro.cronjob.cronJobControllerTrigger({\n      cronjobId: mainCronjobId,\n      gameServerId: gameServerId,\n      moduleId: moduleId\n    });\n    \n    await takaro.log.info('Cleanup restarted by watchdog');\n  } else {\n    await takaro.log.info('Cleanup is running normally');\n  }\n}\n\nawait main();",
          "name": "watchdog",
          "description": null
        }
      ],
      "permissions": []
    }
  ],
  "takaroVersion": "v0.4.9"
}
