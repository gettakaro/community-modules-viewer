{
  "name": "DynamicCronjobs",
  "author": "Limon",
  "supportedGames": ["all"],
  "versions": [
    {
      "tag": "latest",
      "description": "# Dynamic CronJob Manager: Automated Game Server Command Scheduler\n\n---\nüé• **SETUP TUTORIAL**  \n**[‚ñ∫ Watch the Complete Guide](https://youtu.be/OwxbBxYFZk8?si=7Fu3XVB972in6IvS)**  \n*Learn how to set up and configure dynamic cronjobs*\n---\n\nCreate and manage dynamic cronjobs for executing game server commands based on flexible schedules. Define commands and their cron expressions to automate tasks.  \n\n  -   **Dynamic Updates:** The module's `cronJobGenerator` cronjob automatically checks for and adapts to changes in the user configuration. This ensures that any modifications to commands or schedules are applied dynamically.\n  -   **Cron Syntax Validation:** The module validates the syntax of cron expressions. If an invalid expression is provided, that specific cronjob will be skipped, preventing errors and ensuring only valid schedules are applied.  For assistance with cron syntax, you can use a tool like [crontab.guru](https://crontab.guru/).\n  -   **Command Sequencing:** You can define multiple commands within a single cronjob entry, separated by semicolons. These commands will be executed sequentially according to the defined schedule.\n  -   **Game Server Specificity:** It is crucial to install the latest version of this module and create a **separate copy for each game server**. This ensures that cronjobs are executed on the intended server and avoids unintended cross-server execution.\n  -   **Automated Management:** The module handles the creation, updating, and cleanup of cronjobs. It removes any cronjobs that are no longer present in the configuration, maintaining a clean and accurate schedule.\n  -   **Internal Synchronization:** To ensure proper synchronization of cron schedules, the module may perform internal operations to update its configuration. This process is automated and does not require manual intervention from the user.",
      "configSchema": "{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"type\":\"object\",\"properties\":{\"cronjobs\":{\"type\":\"array\",\"title\":\"Cronjobs\",\"description\":\"List of cronjobs and their schedules\",\"items\":{\"type\":\"object\",\"properties\":{\"name\":{\"type\":\"string\",\"description\":\"Optional name for the cronjob\",\"minLength\":1},\"command\":{\"type\":\"string\",\"description\":\"You can enter multiple commands separated by semicolons (;) to create a sequence of scheduled tasks for the same cron expression. \",\"minLength\":1},\"temporalValue\":{\"type\":\"string\",\"description\":\"Cron expression for execution schedule\",\"minLength\":1}},\"required\":[\"command\",\"temporalValue\"]}}},\"additionalProperties\":false}",
      "uiSchema": "{}",
      "commands": [],
      "hooks": [],
      "cronJobs": [
        {
          "function": "import { takaro, data } from '@takaro/helpers';\n\nasync function main() {\n  const { gameServerId, module: mod } = data;\n  const cronjobs = mod.userConfig.cronjobs || [];\n\n  console.log('üîÑ Dynamic Cronjob Generator starting...');\n\n  // Server short ID for namespacing (first 8 chars of gameServerId)\n  const serverShortId = gameServerId.substring(0, 8);\n  const serverPrefix = `cr-${serverShortId}-`;\n\n  console.log(`üìç Server: ${serverShortId} (${gameServerId})`);\n\n  // State management keys\n  const configHashKey = 'config_hash';\n  const lastProcessedKey = 'last_processed';\n  const backupConfigKey = 'backup_config';\n\n  // Track updated cronjobs for systemConfig sync\n  const updatedCronJobs = {}; // { cronjobName: temporalValue }\n\n  try {\n    // Create configuration hash for change detection\n    const currentConfigHash = JSON.stringify(cronjobs).split('').reduce((a, b) => {\n      a = ((a << 5) - a) + b.charCodeAt(0);\n      return a & a;\n    }, 0).toString();\n\n    // Get stored state\n    let storedHash = null;\n    let lastProcessed = null;\n    try {\n      const hashVar = await takaro.variable.variableControllerSearch({\n        filters: {\n          key: [configHashKey],\n          moduleId: [mod.moduleId],\n          gameServerId: [gameServerId]\n        }\n      });\n      if (hashVar.data.data.length > 0) {\n        storedHash = hashVar.data.data[0].value;\n      }\n\n      const processedVar = await takaro.variable.variableControllerSearch({\n        filters: {\n          key: [lastProcessedKey],\n          moduleId: [mod.moduleId],\n          gameServerId: [gameServerId]\n        }\n      });\n      if (processedVar.data.data.length > 0) {\n        lastProcessed = new Date(processedVar.data.data[0].value);\n      }\n    } catch (error) {\n      console.log('üìù No previous state found, treating as first run');\n    }\n\n    // Check if configuration changed (5 minute cooldown)\n    if (storedHash === currentConfigHash && lastProcessed && (Date.now() - lastProcessed.getTime()) < 300000) {\n      console.log('‚úÖ No configuration changes detected, skipping update');\n      return;\n    }\n\n    // Backup current configuration\n    try {\n      await takaro.variable.variableControllerCreate({\n        key: backupConfigKey,\n        value: JSON.stringify({\n          userConfig: mod.userConfig,\n          timestamp: new Date().toISOString(),\n          hash: currentConfigHash\n        }),\n        gameServerId,\n        moduleId: mod.moduleId\n      });\n      console.log('üíæ Configuration backup created');\n    } catch (backupError) {\n      const existingBackup = await takaro.variable.variableControllerSearch({\n        filters: {\n          key: [backupConfigKey],\n          moduleId: [mod.moduleId],\n          gameServerId: [gameServerId]\n        }\n      });\n      if (existingBackup.data.data.length > 0) {\n        await takaro.variable.variableControllerUpdate(existingBackup.data.data[0].id, {\n          value: JSON.stringify({\n            userConfig: mod.userConfig,\n            timestamp: new Date().toISOString(),\n            hash: currentConfigHash\n          })\n        });\n        console.log('üíæ Configuration backup updated');\n      }\n    }\n\n    // Cron syntax validation\n    function isValidCronSyntax(cronExpression) {\n      try {\n        cronExpression = cronExpression.trim();\n\n        if (/^@(yearly|annually|monthly|weekly|daily|hourly|reboot)$/.test(cronExpression)) {\n          return true;\n        }\n\n        const parts = cronExpression.split(/\\s+/);\n        if (parts.length !== 5) return false;\n\n        const validPatterns = [\n          /^[0-9,\\-*\\/]+$/,       // Minutes\n          /^[0-9,\\-*\\/]+$/,       // Hours  \n          /^[0-9,\\-*\\/?]+$/,      // Day of month\n          /^[0-9,\\-*\\/]+$/,       // Month\n          /^[0-9,\\-*\\/?a-zA-Z]+$/ // Day of week\n        ];\n\n        for (let i = 0; i < 5; i++) {\n          if (!validPatterns[i].test(parts[i])) return false;\n        }\n\n        const minutes = parts[0].split(/[,\\-\\/]/).filter(m => m !== '*' && /^\\d+$/.test(m));\n        if (minutes.some(m => parseInt(m) > 59)) return false;\n\n        const hours = parts[1].split(/[,\\-\\/]/).filter(h => h !== '*' && /^\\d+$/.test(h));\n        if (hours.some(h => parseInt(h) > 23)) return false;\n\n        const dom = parts[2].split(/[,\\-\\/]/).filter(d => d !== '*' && d !== '?' && /^\\d+$/.test(d));\n        if (dom.some(d => parseInt(d) < 1 || parseInt(d) > 31)) return false;\n\n        const months = parts[3].split(/[,\\-\\/]/).filter(m => m !== '*' && /^\\d+$/.test(m));\n        if (months.some(m => parseInt(m) < 1 || parseInt(m) > 12)) return false;\n\n        return true;\n      } catch (err) {\n        return false;\n      }\n    }\n\n    // Validate cronjobs\n    const validatedCronjobs = [];\n    const invalidJobs = [];\n\n    for (let i = 0; i < cronjobs.length; i++) {\n      const job = cronjobs[i];\n      if (!isValidCronSyntax(job.temporalValue)) {\n        console.log(`‚ùå Invalid cron syntax in job ${job.name || i + 1}: \"${job.temporalValue}\"`);\n        invalidJobs.push(job);\n        continue;\n      }\n      validatedCronjobs.push(job);\n    }\n\n    if (invalidJobs.length > 0) {\n      console.log(`‚ö†Ô∏è  Skipped ${invalidJobs.length} invalid cronjob(s)`);\n    }\n\n    // Get existing cronjobs for this module version\n    const existingCronjobs = (await takaro.cronjob.cronJobControllerSearch({\n      filters: {\n        versionId: [mod.versionId]\n      }\n    })).data.data;\n\n    // Clean up legacy cronjobs (old format without server ID)\n    let legacyCleanupCount = 0;\n    for (const existingJob of existingCronjobs) {\n      // Match old format: cr-{number} or cr-{number}-{name}\n      // But NOT new format: cr-{8hexchars}-{number}\n      if (/^cr-\\d+(-|$)/.test(existingJob.name)) {\n        const afterCr = existingJob.name.substring(3);\n        // If it doesn't start with 8 hex chars followed by dash, it's legacy\n        if (!/^[a-f0-9]{8}-/i.test(afterCr)) {\n          try {\n            await takaro.cronjob.cronJobControllerRemove(existingJob.id);\n            legacyCleanupCount++;\n            console.log(`üßπ Removed legacy cronjob: ${existingJob.name}`);\n          } catch (error) {\n            console.log(`‚ö†Ô∏è  Could not remove legacy cronjob \"${existingJob.name}\": ${error.message}`);\n          }\n        }\n      }\n    }\n\n    if (legacyCleanupCount > 0) {\n      console.log(`üßπ Cleaned up ${legacyCleanupCount} legacy cronjob(s)`);\n    }\n\n    // Process validated cronjobs\n    const processedJobs = new Set();\n    let jobCounter = 1;\n    let createdCount = 0;\n    let updatedCount = 0;\n    let errorCount = 0;\n\n    for (let i = 0; i < validatedCronjobs.length; i++) {\n      const job = validatedCronjobs[i];\n      const commands = job.command.split(';').map(cmd => cmd.trim()).filter(cmd => cmd);\n\n      for (let cmdIndex = 0; cmdIndex < commands.length; cmdIndex++) {\n        const command = commands[cmdIndex];\n        const seqSuffix = commands.length > 1 ? `-seq${cmdIndex + 1}` : '';\n        const jobNameSuffix = job.name ? `-${job.name}${seqSuffix}` : seqSuffix;\n        const jobName = `${serverPrefix}${jobCounter}${jobNameSuffix}`;\n        jobCounter++;\n\n        processedJobs.add(jobName);\n\n        // Generated function with silent server guard\n        const jobFunction = `import { takaro, data } from '@takaro/helpers';\nasync function main() {\n  if (data.gameServerId !== '${gameServerId}') return;\n  await takaro.gameserver.gameServerControllerExecuteCommand(data.gameServerId, {\n    command: \\`${command}\\`,\n  });\n}\nawait main();`;\n\n        try {\n          const existingJob = existingCronjobs.find(j => j.name === jobName);\n\n          if (existingJob) {\n            // Only update if something changed\n            if (existingJob.temporalValue !== job.temporalValue || existingJob.function !== jobFunction) {\n              await takaro.cronjob.cronJobControllerUpdate(existingJob.id, {\n                name: jobName,\n                temporalValue: job.temporalValue,\n                function: jobFunction\n              });\n              updatedCount++;\n              console.log(`üìù Updated: ${jobName}`);\n              \n              // Track for systemConfig sync\n              updatedCronJobs[jobName] = job.temporalValue;\n            }\n          } else {\n            try {\n              await takaro.cronjob.cronJobControllerCreate({\n                name: jobName,\n                temporalValue: job.temporalValue,\n                versionId: mod.versionId,\n                function: jobFunction\n              });\n              createdCount++;\n              console.log(`‚ûï Created: ${jobName}`);\n              \n              // Track newly created jobs for systemConfig sync\n              updatedCronJobs[jobName] = job.temporalValue;\n            } catch (createError) {\n              if (createError.response?.status === 409) {\n                const conflictJobSearch = await takaro.cronjob.cronJobControllerSearch({\n                  filters: { name: [jobName] }\n                });\n\n                if (conflictJobSearch.data.data.length > 0) {\n                  const conflictJob = conflictJobSearch.data.data[0];\n                  await takaro.cronjob.cronJobControllerUpdate(conflictJob.id, {\n                    name: jobName,\n                    temporalValue: job.temporalValue,\n                    function: jobFunction\n                  });\n                  updatedCount++;\n                  console.log(`üìù Resolved conflict: ${jobName}`);\n                  \n                  // Track for systemConfig sync\n                  updatedCronJobs[jobName] = job.temporalValue;\n                } else {\n                  throw createError;\n                }\n              } else {\n                throw createError;\n              }\n            }\n          }\n        } catch (error) {\n          console.log(`‚ùå Error with \"${jobName}\": ${error.message || \"Unknown error\"}`);\n          errorCount++;\n        }\n      }\n    }\n\n    // Clean up orphaned cronjobs (SERVER-SCOPED only)\n    let cleanupCount = 0;\n    for (const existingJob of existingCronjobs) {\n      if (existingJob.name.startsWith(serverPrefix) && !processedJobs.has(existingJob.name)) {\n        try {\n          await takaro.cronjob.cronJobControllerRemove(existingJob.id);\n          cleanupCount++;\n          console.log(`üóëÔ∏è  Removed orphan: ${existingJob.name}`);\n        } catch (error) {\n          console.log(`‚ùå Error removing \"${existingJob.name}\": ${error.message}`);\n          errorCount++;\n        }\n      }\n    }\n\n    // Update state variables\n    try {\n      const hashVarSearch = await takaro.variable.variableControllerSearch({\n        filters: {\n          key: [configHashKey],\n          moduleId: [mod.moduleId],\n          gameServerId: [gameServerId]\n        }\n      });\n\n      if (hashVarSearch.data.data.length > 0) {\n        await takaro.variable.variableControllerUpdate(hashVarSearch.data.data[0].id, {\n          value: currentConfigHash\n        });\n      } else {\n        await takaro.variable.variableControllerCreate({\n          key: configHashKey,\n          value: currentConfigHash,\n          gameServerId,\n          moduleId: mod.moduleId\n        });\n      }\n\n      const processedVarSearch = await takaro.variable.variableControllerSearch({\n        filters: {\n          key: [lastProcessedKey],\n          moduleId: [mod.moduleId],\n          gameServerId: [gameServerId]\n        }\n      });\n\n      if (processedVarSearch.data.data.length > 0) {\n        await takaro.variable.variableControllerUpdate(processedVarSearch.data.data[0].id, {\n          value: new Date().toISOString()\n        });\n      } else {\n        await takaro.variable.variableControllerCreate({\n          key: lastProcessedKey,\n          value: new Date().toISOString(),\n          gameServerId,\n          moduleId: mod.moduleId\n        });\n      }\n    } catch (stateError) {\n      console.log(`‚ö†Ô∏è  Could not update state: ${stateError.message}`);\n    }\n\n    // Sync systemConfig if cronjobs were updated/created\n    if (Object.keys(updatedCronJobs).length > 0) {\n      console.log('üîÑ Syncing systemConfig with updated cronjob temporalValues...');\n      \n      try {\n        // Get current installation (using takaro.module, not takaro.moduleInstallations)\n        const installation = await takaro.module.moduleInstallationsControllerGetModuleInstallation(\n          mod.moduleId,\n          gameServerId\n        );\n        \n        const currentSystemConfig = installation.data.data.systemConfig || {};\n        const currentUserConfig = installation.data.data.userConfig || {};\n        const versionId = installation.data.data.versionId;\n        \n        // Build new systemConfig with updated temporalValues\n        const newSystemConfig = JSON.parse(JSON.stringify(currentSystemConfig)); // Deep clone\n        \n        if (!newSystemConfig.cronJobs) {\n          newSystemConfig.cronJobs = {};\n        }\n        \n        let hasChanges = false;\n        for (const [jobName, temporalValue] of Object.entries(updatedCronJobs)) {\n          if (newSystemConfig.cronJobs[jobName]) {\n            if (newSystemConfig.cronJobs[jobName].temporalValue !== temporalValue) {\n              newSystemConfig.cronJobs[jobName].temporalValue = temporalValue;\n              hasChanges = true;\n              console.log(`   üìù systemConfig.cronJobs.${jobName}.temporalValue = \"${temporalValue}\"`);\n            }\n          }\n        }\n        \n        if (hasChanges) {\n          // Uninstall module\n          await takaro.module.moduleInstallationsControllerUninstallModule(\n            mod.moduleId,\n            gameServerId\n          );\n          console.log('   üîß Module uninstalled for reinstall');\n          \n          // Reinstall with updated systemConfig\n          await takaro.module.moduleInstallationsControllerInstallModule({\n            versionId: versionId,\n            gameServerId: gameServerId,\n            userConfig: JSON.stringify(currentUserConfig),\n            systemConfig: JSON.stringify(newSystemConfig)\n          });\n          console.log('   ‚úÖ Module reinstalled with updated systemConfig');\n        } else {\n          console.log('   ‚úì systemConfig already in sync');\n        }\n      } catch (syncError) {\n        console.log(`‚ö†Ô∏è  Could not sync systemConfig: ${syncError.message}`);\n        // Don't throw - cronjobs are already updated, this is just a sync issue\n      }\n    }\n\n    // Summary\n    console.log(`‚úÖ Completed for server ${serverShortId}:`);\n    if (createdCount > 0) console.log(`   ‚ûï ${createdCount} created`);\n    if (updatedCount > 0) console.log(`   üìù ${updatedCount} updated`);\n    if (cleanupCount > 0) console.log(`   üóëÔ∏è  ${cleanupCount} orphans removed`);\n    if (errorCount > 0) console.log(`   ‚ùå ${errorCount} errors`);\n    if (createdCount === 0 && updatedCount === 0 && cleanupCount === 0) {\n      console.log(`   ‚úì No changes needed`);\n    }\n\n  } catch (error) {\n    console.log(`üí• Critical error: ${error.message}`);\n\n    try {\n      const backupSearch = await takaro.variable.variableControllerSearch({\n        filters: {\n          key: [backupConfigKey],\n          moduleId: [mod.moduleId],\n          gameServerId: [gameServerId]\n        }\n      });\n\n      if (backupSearch.data.data.length > 0) {\n        const backup = JSON.parse(backupSearch.data.data[0].value);\n        console.log(`üîÑ Backup available from ${backup.timestamp}`);\n      }\n    } catch (backupError) {\n      console.log('‚ö†Ô∏è  No backup available');\n    }\n\n    throw error;\n  }\n}\n\nawait main();",
          "name": "cronJobGenerator",
          "description": "Check changes in the user config and adapts (optimized: runs every 15 minutes with smart change detection)",
          "temporalValue": "*/15 * * * *"
        },
        {
          "function": "import { takaro, data } from '@takaro/helpers';\nasync function main() {\n  if (data.gameServerId !== '2a2b1d73-50ea-4f28-a2d4-3b02aef3041f') return;\n  await takaro.gameserver.gameServerControllerExecuteCommand(data.gameServerId, {\n    command: `testservera1`,\n  });\n}\nawait main();",
          "name": "cr-2a2b1d73-1-testservera1",
          "description": null,
          "temporalValue": "5 4 * * *"
        },
        {
          "function": "import { takaro, data } from '@takaro/helpers';\nasync function main() {\n  if (data.gameServerId !== '1a46b457-84ae-434d-83fc-484a8c3c1743') return;\n  await takaro.gameserver.gameServerControllerExecuteCommand(data.gameServerId, {\n    command: `testserverb1`,\n  });\n}\nawait main();",
          "name": "cr-1a46b457-1-testserverb1",
          "description": null,
          "temporalValue": "1 2 * * *"
        },
        {
          "function": "import { takaro, data } from '@takaro/helpers';\nasync function main() {\n  if (data.gameServerId !== '1a46b457-84ae-434d-83fc-484a8c3c1743') return;\n  await takaro.gameserver.gameServerControllerExecuteCommand(data.gameServerId, {\n    command: `testserverb2`,\n  });\n}\nawait main();",
          "name": "cr-1a46b457-2-testserverb2",
          "description": null,
          "temporalValue": "2 2 * * *"
        },
        {
          "function": "import { takaro, data } from '@takaro/helpers';\nasync function main() {\n  if (data.gameServerId !== '3251bb7f-9290-4163-a4d1-43247e90faf6') return;\n  await takaro.gameserver.gameServerControllerExecuteCommand(data.gameServerId, {\n    command: `status`,\n  });\n}\nawait main();",
          "name": "cr-3251bb7f-1-mocktest2",
          "description": null,
          "temporalValue": "1 * * * *"
        }
      ],
      "functions": [],
      "permissions": []
    }
  ],
  "takaroVersion": "main"
}
